<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>相机成像原理之sensor篇</title>
    <url>/2020/03/28/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8Bsensor%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="（一）sensor的硬件结构"><a href="#（一）sensor的硬件结构" class="headerlink" title="（一）sensor的硬件结构"></a>（一）sensor的硬件结构</h2><h3 id="1-每个像素的结构"><a href="#1-每个像素的结构" class="headerlink" title="1. 每个像素的结构"></a>1. 每个像素的结构</h3><p>每个像素点的最上方有个微透镜，增加透光量。有镜头就有CRA的问题，超出一定角度的光线无法被收集，需要和镜头进行匹配。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200325171710.png"  alt="像素的结构"></p>
<h3 id="2-sensor的纵向结构"><a href="#2-sensor的纵向结构" class="headerlink" title="2. sensor的纵向结构"></a>2. sensor的纵向结构</h3><p>光透过电路会发生反射，造成每个像素点之间的干扰。背照式的结构（感光层在电路的上方）不会受到电路的影响。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200325171743.png"  alt="sensor的纵向结构 "></p>
<h3 id="3-CFA-color-filter-array"><a href="#3-CFA-color-filter-array" class="headerlink" title="3. CFA(color filter array)"></a>3. CFA(color filter array)</h3><p>每个像素点上覆盖有一种颜色的滤光片，从而去感知每种颜色的亮度。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200325171811.png"  alt="滤光片CFA"></p>
<p>Bayer格式：绿色分量为总像素数的一半，红色蓝色为总像素的四分之一。</p>
<h4 id="3-1-MONO-sensor"><a href="#3-1-MONO-sensor" class="headerlink" title="3.1 MONO sensor"></a>3.1 MONO sensor</h4><p>由于滤光会带来亮度上的损失，有种MONO sensor，没有滤光片的处理，亮度会大大提高（有文章说可以提高四倍），但是这就感知不到颜色了，所以又叫黑白sensor。</p>
<h4 id="3-2-光谱响应曲线"><a href="#3-2-光谱响应曲线" class="headerlink" title="3.2 光谱响应曲线"></a>3.2 光谱响应曲线</h4><p>下图是IMX290每个红绿蓝滤光片的光谱响应曲线。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200325171849.png"  alt="IMX290光谱响应曲线"></p>
<p>这是人眼视锥细胞对光谱的响应曲线</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200325171930.png"  alt="人眼视锥细胞对光谱的响应曲线"></p>
<p>由于人眼和sensor对光谱的感应曲线不同，同一个物体感知到的颜色不同。因此颜色需要一个转换关系。ISP中的CCM（色彩校正矩阵）就此诞生，利用一个3x3的矩阵，将sensor感知到的RGB颜色，校准成我们看到的RGB颜色。</p>
<h4 id="3-3-红绿灯变色问题"><a href="#3-3-红绿灯变色问题" class="headerlink" title="3.3 红绿灯变色问题"></a>3.3 红绿灯变色问题</h4><p>这里穿插一个监控摄像头常遇到的问题，拍红灯的时候，经常会拍成黄灯和白灯，这是为什么呢？</p>
<p>因为红灯的光谱在780~620nm之间，从光谱响应曲线中可以看到，红像素最敏感，然后是绿像素，最后是蓝色像素。</p>
<p>当感光度比较小的时候，红色像素的亮度远远大于绿色和蓝色，肯定是呈现出红色。感光度比较大时，绿色像素也能有很高的亮度，而红色像素早已经饱和了，不在增加，这个时候呈现的颜色就是红色+绿色=黄色。感光度很大的时候，RGB都饱和了，红绿蓝加在一起就是白色。</p>
<h4 id="3-4-去马赛克"><a href="#3-4-去马赛克" class="headerlink" title="3.4 去马赛克"></a>3.4 去马赛克</h4><p>由于sensor每个像素点只能感知到一种颜色，因此想要得到每个像素点的RGB值，需要进行插值，这个过程就是去马赛克(Demosiac)。<br><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200327202901.png"  alt="demosiac"></p>
<h3 id="4-IR-CUT"><a href="#4-IR-CUT" class="headerlink" title="4. IR-CUT"></a>4. IR-CUT</h3><p>大家都知道，摄像头有个IR-CUT，那为什么要加IR-CUT filter 呢？IR-CUT是红外滤光片，可以滤除红外光。</p>
<p>从IMX290的光谱敏感性曲线可以看到sensor到了1000的波长还能进行光电转换，而人眼只能到700nm，也就是可以说sensor 的“可见光”和人眼的不一样，而且范围远远比人眼的要大。</p>
<p>那么就会导致什么问题呢，最大的问题就是颜色不一样，因为人眼是感受到的是在可见光在可见光范围内的响应，而sensor感受到的却是在400-1000范围内的响应。因此我们需要加上一个IR-cut 使sensor感受的波段和人眼一样。</p>
<h4 id="4-1-拓展：RGB-IR-sensor"><a href="#4-1-拓展：RGB-IR-sensor" class="headerlink" title="4.1 拓展：RGB-IR sensor"></a>4.1 拓展：RGB-IR sensor</h4><p>补充一种sensor，这种sensor不用IR-CUT，除了有RGB三种CFA，还增加了一种专门只通过红外光的CFA。由光谱图我们可以知道，普通sensor中的绿像素不仅仅能感知绿色，还能感知到红外波段的光，实际上是绿色+IR（红外光）。RGB-IR的sensor有个IR像素只感知红外光，两者相减就可以得到可见光的绿色。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200328184305.png"  alt="RGB-IR format"></p>
<p>这样就用数字滤光代替了IR-CUT。我觉得更有应用场景的地方在于，夜间场景下开红外灯，不仅可以感知到红外，还能感知到颜色，是一种待开发的黑光技术。</p>
<h3 id="5-黑电平"><a href="#5-黑电平" class="headerlink" title="5. 黑电平"></a>5. 黑电平</h3><p>黑电平（Black Level Correction）也就是黑色的最低点，以8bit数据来说，指在经过一定校准的显示装置上，没有一行光亮输出的视频信号电平。定义图像数据为0时对应的信号电平。</p>
<p>黑电平产生的原因：</p>
<ol>
<li>CMOS传感器采集的信息经过一系列转换生成原始RAW格式数据。以8bit数据为例，单个pixel的有效值是0-255，但是实际AD芯片（模数转换芯片）的精度可能无法将电压值很小的一部分转换出来，因此，sensor厂家一般会在AD的输入之前加上一个固定的偏移量，使输出的pixel       value在5（非固定）-255之间，目的是为了让暗部的细节完全保留，当然同时也会损失一些亮部细节，由于对于图像来说，我们的关注度更倾向于暗部区域，ISP后面会有很多增益模块（LSC、AWB、Gamma等），因此亮区的一点点损失是可以接受的。</li>
<li>sensor的电路本身会存在暗电流，导致在没有光线照射的时候，像素单位也有一定的输出电压，暗电流这个东西跟曝光时间和gain都有关系，不同的位置也是不一样的。因此在gain增大的时候，电路的增益增大，暗电流也会增强，因此很多ISP会选择在不同gain下减去不同的黑电平的值。</li>
</ol>
<p>ISP pipeline中的黑电平校正（Black Level Correction） ：</p>
<p>拍几张不同增益下的全黑图像，算出每个增益下对应的黑电平值。isp会在raw图之后减去这个黑电平值。这一般是ISP的第一步。</p>
<h3 id="6-坏点"><a href="#6-坏点" class="headerlink" title="6. 坏点"></a>6. 坏点</h3><p>传感器芯片由于工艺的原因产生一些有缺陷的像素点，这些像素点可能比邻近的像素点更暗或者更亮。</p>
<p>  ISP pipeline中的的坏点校正：</p>
<p>  在判定某像素为坏点后，会根据邻近像素点的值计算得到一个值以替代该坏点。</p>
<h2 id="（二）sensor的曝光"><a href="#（二）sensor的曝光" class="headerlink" title="（二）sensor的曝光"></a>（二）sensor的曝光</h2><p>sensor的曝光时间和快门时间是一个概念，都是sensor的感光时间。曝光（快门）时间越长，图像就越亮。</p>
<p>当控制快门时间，仍然达不到期望的亮度，就需要调节sensor的感光度（ISO）。CMOS sensor的感光度就是它的增益。增益是用模拟或数字的方法进行放大，不可避免的会放大噪声，因此拍摄时一般快门优先。</p>
<p>当拍摄高速运动的物体或者手抖的时候，容易产生运动模糊，就需要降低快门时间。</p>
<p>sensor的曝光方式有两种，卷帘曝光和全局曝光。</p>
<h3 id="1-卷帘曝光（rolling-shutter）"><a href="#1-卷帘曝光（rolling-shutter）" class="headerlink" title="1. 卷帘曝光（rolling shutter）"></a>1. 卷帘曝光（rolling shutter）</h3><ol>
<li><p>sensor曝光是每一行依次开始曝光的，所以图像中每一行的起始曝光时间是不一致的，目前大部分sensor属于这种。下图是卷帘曝光拍摄高速运动的物体的现象。</p>
<p><img src="/" class="lazyload" data-src="/2020/03/28/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8Bsensor%E7%AF%87/20200325172907.png"  alt="卷帘曝光失真"></p>
</li>
<li><p>这是IMX290的sensor曝光与输出示意图<br> <img src="/" class="lazyload" data-src="/2020/03/28/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8Bsensor%E7%AF%87/20200325172932.png"  alt="IMX290 曝光序列"></p>
<p> 黄色区域是sensor处于感光的时间，蓝色区域是sensor每一行数据的输出时间，红色是曝光开始的时间。XHS是进行每个操作的最小时间单位。</p>
<p> 从时间先后来看，一幅图像是从第一行开始曝光，一个XHS之后，再从第二行开始曝光，依次类推。图像的第一行曝光结束后，进行输出，输出数据的时间是一个XHS，依此类推。</p>
</li>
<li><p>卷帘曝光带来的问题</p>
<ol>
<li><p>日光灯下有横条纹</p>
<p>日光灯属于频闪灯，跟当地的供电频率有关，如果当地的供电是50Hz的正弦波（国内），日光灯就会以100Hz的频率闪烁。sensor每行的起始曝光时间是不同的，这就导致了每一行曝光时的亮度不同。因此会出现横条纹</p>
<p> <strong>解决方法：</strong></p>
<ul>
<li>控制曝光时间是1/100的整数倍，这样每行的曝光时间都是一个周期的整数倍，亮度就保持一致了。</li>
<li>控制帧率为25/50帧，不能解决横条纹的问题，但是可以让每帧图像中的横条纹固定在相同的位置。1/25是1/100的整数倍，可以使不同图像中每一行曝光的开始时间都相差四个周期。保证了每张图像中同一行的亮度是一致的。</li>
</ul>
</li>
<li><p>拍摄快速运动的物体会有失真</p>
<p>  因为每一行曝光开始的时间不同，当物体快速运动时，每行抓拍下来的物体位置都不同，造成了物体的变形。</p>
<p>  <strong>解决方法：</strong></p>
<ul>
<li>加大图像输出的速度（提高帧率也可行，本质上改变的就是输出速度）</li>
<li>调整抓拍的时间和角度，比如远处的车辆每帧移动的像素点较少，可以去抓拍稍远处的车辆</li>
<li>使用全局曝光的sensor</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="2-全局曝光（global-shutter）"><a href="#2-全局曝光（global-shutter）" class="headerlink" title="2. 全局曝光（global shutter）"></a>2. 全局曝光（global shutter）</h3><p>每一行的起始曝光和终止曝光的时间一致，目前只有电警设备上用到，价格昂贵。因为电警设备有爆闪灯，爆闪灯亮的时间很短。如果使用卷帘曝光的sensor，一幅图像才曝光几行灯就熄灭了，所以必须要用全局曝光的传感器。</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>ISP</tag>
      </tags>
  </entry>
  <entry>
    <title>人卡微卡调试注意事项总结</title>
    <url>/2020/03/20/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-%E4%BA%BA%E5%8D%A1%E5%BE%AE%E5%8D%A1%E8%B0%83%E8%AF%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="微卡"><a href="#微卡" class="headerlink" title="微卡"></a>微卡</h2><h3 id="一．相机安装"><a href="#一．相机安装" class="headerlink" title="一．相机安装"></a>一．相机安装</h3><p>1.垂直角度在13正负3度<br>2.为保障车牌识别的准确性，监控区域画面近端，保持两个车道7m。<br>3.画面中心在保持在需要监控道路的中心。<br>4.相机安装水平不倾斜。</p>
<h3 id="二．相机标定"><a href="#二．相机标定" class="headerlink" title="二．相机标定"></a>二．相机标定</h3><p>根据远近处的车牌大小进行标定，具体如下图：<br><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200329000918.png"  alt="车牌标定"></p>
<h3 id="三．图像参数"><a href="#三．图像参数" class="headerlink" title="三．图像参数"></a>三．图像参数</h3><ol>
<li><p>快门：默认先用1/240，能覆盖大多数情况</p>
</li>
<li><p>增益：增益上限默认到50，</p>
</li>
<li><p>对比度：降低对比度调成20，有助于在比较暗环境下提高暗区亮度。</p>
</li>
<li><p>补光灯：智能配置->补光灯配置那里，根据环境中是否有外置补光灯，无外置灯的，默认模式设置为自动，阈值35，内置补光灯2 强度设置20， 有外置补光灯的默认关闭内置补光灯。</p>
</li>
<li><p>为保障车牌识别的准确性，监控区域画面近端，保持两个车道7m;<br><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200329001136.png"  alt="微卡车道拍摄"></p>
</li>
</ol>
<h3 id="四-微调"><a href="#四-微调" class="headerlink" title="四. 微调"></a>四. 微调</h3><ol>
<li>若聚焦已经调整到中下部，车速太快，早上或者傍晚抓拍到大量运动模糊的车牌，降低快门下限至1/300.</li>
<li>这样配置后还是车牌过曝，优先降低一点内置补光灯强度，若降至0还不行（此时肯定有外置灯直射车牌），可以降低下增益上限，以5为单位降低增益上限。</li>
<li>若夜间车牌比较灰暗，不够亮，可以稍加内置补光灯强度，以5为单位。</li>
<li>若发现不管白天晚上，中下抓拍区域车牌亮度正常，但是整体很糊，可以试着调试聚焦，建议在白天时候 ，调试，聚焦在中下部，聚完焦后再设置镜头锁定。（保证下一半清晰）</li>
</ol>
<h2 id="人卡"><a href="#人卡" class="headerlink" title="人卡"></a>人卡</h2><h3 id="一-相机安装"><a href="#一-相机安装" class="headerlink" title="一. 相机安装"></a>一. 相机安装</h3><p>1.垂直角度在13正负3度<br>2.为保障车牌识别的准确性，监控区域纵向在2人高以内，横向5米以内。<br>3.画面中心在保持在需要监控区域的中心。<br>4.相机安装水平不倾斜。</p>
<h3 id="二-相机标定"><a href="#二-相机标定" class="headerlink" title="二. 相机标定"></a>二. 相机标定</h3><p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200329001629.png"  alt="人卡相机标定"></p>
<h3 id="三-图像参数"><a href="#三-图像参数" class="headerlink" title="三. 图像参数"></a>三. 图像参数</h3><ol>
<li><p>快门：根据实际场景中人员状态，若行人居多，默认快门上限1/100; 若电瓶车或者小三轮居多，快门往下降1/150,或1/200。</p>
</li>
<li><p>聚焦：聚焦在画面中下部，白天调完聚焦后，保存在配置->摄像机->图像->聚焦中，若晚上切换到夜模式后出现中下部比中上明显偏糊，需要再调整下聚焦保存在夜模式中，后面自动切换日夜的时候就会自动调用两个位置。</p>
</li>
<li><p>若架设场景是全天大多数时间都是背光的室内对着大门的场景，开启智能配置->参数配置->智能曝光，其他正常场景关闭该功能。</p>
</li>
</ol>
<h3 id="四-夜间注意事项"><a href="#四-夜间注意事项" class="headerlink" title="四. 夜间注意事项"></a>四. 夜间注意事项</h3><ol>
<li><p>建议在环境光比较好的场景，在配置->摄像机->图像->日夜转换的模式设置为白天。</p>
</li>
<li><p>若进行日夜切换，开启红外灯的设备，根据抓取的人脸亮度，先用默认参数，若过曝或者较暗，调整红外强度手动模式，并且修改强度。</p>
</li>
<li><p>若聚焦以及亮度都调整完后，还是觉得有点糊，可以尝试减小2D降噪，但是会引入更多噪声，谨慎调试。</p>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像效果调试</category>
      </categories>
      <tags>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：红外回调不生效</title>
    <url>/2020/03/12/%E5%B7%A5%E4%BD%9C-BUG-BUG-%E7%BA%A2%E5%A4%96%E5%9B%9E%E8%B0%83%E4%B8%8D%E7%94%9F%E6%95%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><ol>
<li>同一个版本，业务获取不到回调值，但是我们能获取到。同一个设备，有时能回调，有时没有回调。</li>
<li>关采集的时候没有给回调值</li>
<li>自动模式下，开红外之后关采集，再打开的时候，画面正常切到白天，但是回调给的状态是开红外</li>
</ol>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li><input checked disabled type="checkbox"> 在同一个设备中进行打印，观察何时能回调，何时没有回调</li>
</ul>
<p>关闭采集的时候没有给回调值，有两种可能性： </p>
<ul>
<li><input checked disabled type="checkbox"> 红外开关是在ROM中设置，可能关闭采集的时候，isp组件先关闭了，再去关红外灯的，就没法去执行业务的回调</li>
<li><input checked disabled type="checkbox"> 在关闭采集的时候，没有对property进行设置，isp组件中也就没有获取到当前的红外状态</li>
</ul>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li>同一台设备中打印，有的时候有回调，有的是否没有回调，后来发现和root权限有关。没有root过就没有回调，root过就有回调。这个现象在之前创建fd的时候也遇到过，SElinux对创建fd等操作进行了权限管理。</li>
<li>整理红外回调的思路：ROM中设置红外开关的时候都会设置对应的property值。在isp组件中创建一个线程，对property的值轮询，如果发生了改变，就执行业务的回调。</li>
<li>由于isp组件可能在红外灯关闭之前就被kill掉了，而不管是手动还是自动模式，关闭采集的时候都需要关闭红外，所以直接在isp组件退出的时候，回调红外关闭的状态。</li>
<li>isp组件需要保存上一次的值，否则很可能在关闭采集的时候，回调两次红外关闭的状态（isp组件检测到红外关闭回调一次，isp组件退出的时候回调一次）。回调红外关闭的状态，从isp组件退出的地方，修改到轮询property线程结束的地方，这样可以利用static保存上一次的值。</li>
<li>关闭采集的时候，发现ROM那边仅仅是把红外灯设置成关闭状态，没有更新property值，所以需要增加一句设置property的代码</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li>SElinux权限，需要找负责ROM的人开</li>
<li>isp组件：在更新红外状态的线程结束时，把红外状态设置成关，回调给业务</li>
<li>rom: 在camera关闭的状态下，也要注意更新property的值</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>不仅仅fd的创建与读写，property的读写也是由SElinux管理的，以后代码提交的时候，需要在非root的情况下也验证一下，防止出现此类问题</li>
<li>这种更新状态的问题，需要考虑到开关机，线程中途退出等等问题，必须要考虑全面</li>
<li>线程结束的时候，多思考一下，需要释放哪些资源，需要重置哪些状态等等</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>BUG</tag>
        <tag>高通camera</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：畸变校正算法不生效</title>
    <url>/2020/03/11/%E5%B7%A5%E4%BD%9C-BUG-BUG-%E7%95%B8%E5%8F%98%E6%A0%A1%E6%AD%A3%E4%B8%8D%E7%94%9F%E6%95%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>设备从老版本R2B1切到了R2B3流，畸变校正算法不生效</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><ul>
<li><input checked disabled type="checkbox"> 代码解决编译问题</li>
<li><input checked disabled type="checkbox"> 2241设备已经切到R2B3了，把动态库放到设备里面看一下是否生效 ——测试：葛志海</li>
<li><input checked disabled type="checkbox"> 把动态库库放到2431中是否生效，确认一下用的媒控库是新的还是老的 —— 测试：王海龙</li>
<li><input checked disabled type="checkbox"> 如果生效了，检查路径。如果不生效，IMGVideoAlgOpen函数返回1，在其中加打印，看一下传入结构体里的值对不对</li>
<li><input checked disabled type="checkbox"> 如果不生效，查看媒控的调用情况，主要注意库名和函数名</li>
<li><input checked disabled type="checkbox"> 2241把新库放进去看一下是否生效，如果生效了，就是库的版本不对，如果不生效的话，还需要和媒控查看代码</li>
</ul>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li><p>编译 到<code>jni</code>目录下，运行<code>ndk_build.cmd</code></p>
</li>
<li><p>2241设备IP：<code>10.67.36.191</code></p>
</li>
<li><p>启动ssh登陆后，登陆17230端口，<code>openssh</code>。然后打开10023端口，输入网口转usb指令：<code>setprop service.adb.tcp.port 5555 && stop adbd && start adbd</code>，然后root：<code>setprop service.ipc.root 1</code>，最后用adb连上</p>
</li>
<li><p>防止换的库被覆盖，<code>mv /etc/update.bz2 /etc/update.bz2.bak</code>，换库路径<code>/storage/sdcard0/bin/lib</code></p>
</li>
<li><p>发现2241开关没有明显作用，联系葛志海测试多台设备发现，R2B3的每日流有效果，封闭流没效果。</p>
</li>
<li><p>又找了一台设备<code>10.67.36.194</code>发现花屏</p>
<p><img src="/" class="lazyload" data-src="/2020/03/11/%E5%B7%A5%E4%BD%9C-BUG-BUG-%E7%95%B8%E5%8F%98%E6%A0%A1%E6%AD%A3%E4%B8%8D%E7%94%9F%E6%95%88/f0c18288-1de3-4c2f-8811-3a8354be5218_1d808b11-dc95-4acf-81fe-05e86b38e90b@kedacom.com.png"  alt></p>
</li>
<li><p>换到中试R2B1版本，有点效果</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line"># IPC</span><br><span class="line">setcapratio <span class="number">1920</span> <span class="number">1080</span> # 上面这一条是切分辨率的，<span class="number">2241</span>是<span class="number">200</span>万的，但是没有用</span><br><span class="line">mcsetldc <span class="number">1500</span> <span class="number">100</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>换上我的库后在界面上开关没有反应，但是输入命令mcsetldc就生效了 。由于mcsetldc命令是媒控封装的，是否能证明是业务的问题？</p>
</li>
<li><p>在2241上的R2B3测试：原有的库输入命令就会花屏，换上最新的算法库，在web界面上调没有反应，但是输入指令就正常了</p>
</li>
<li><p>在2431上换上最新的算法库也会报错，先搞定2431的问题 </p>
</li>
<li><p>查看媒控代码，发现老版本的媒控使用的库名和函数名都不对，用的是老的算法库，需要替换成新的</p>
</li>
<li><p>当媒控修改库之后，配上最新的算法库就正常了，联系CMO取库，发现一套代码编出了两个版本，一个放在8056目录，一个放在了660目录。2431是8056的老设备，用8056目录下的库即可</p>
</li>
<li><p>2241更新代码后，换上最新的算法库，发现一切正常。说明还是算法库用的是老的，但是CMO放的路径确实没有问题。查看业务的编译脚本，发现它把两个版本的算法库都拷贝了进来，但是用老的算法库覆盖了新库，导致最后用的还是老库</p>
</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><p>CMO分两种，第一种是专门编译代码的，第二种是专门把编译出的代码放在一个地方让业务去取的。然后业务写编译脚本，把库包含进来。</p>
</li>
<li><p>媒控有两个版本，老设备用的是alpha，新设备和双摄用的是beta版，需要关注他们的版本。</p>
</li>
<li><p>版本信息的打印很重要，只不过这个是很久不维护的，如何添加版本信息，可以参考我之前的文章。</p>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>BUG</tag>
        <tag>高通camera</tag>
        <tag>版本信息</tag>
      </tags>
  </entry>
  <entry>
    <title>相机成像模型</title>
    <url>/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>此文转载自<a href="https://zhuanlan.zhihu.com/p/23090593" target="_blank" rel="noopener">知乎</a></p>
</blockquote>
<p>相机在计算机视觉应用中起着重要作用，作为图像数据来源，影响着后续各个处理步骤。成像模型就是用数学公式刻画整个成像过程，即被拍摄物体空间点到照片成像点之间的几何变换关系。</p>
<p>总体上，相机成像可以分为四个步骤：刚体变换、透视投影、畸变校正和数字化图像。</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/v2-6d70200c60c2fb80595bd931a2167c89_1440w.png"  alt></p>
<h2 id="1、刚体变换"><a href="#1、刚体变换" class="headerlink" title="1、刚体变换"></a>1、刚体变换</h2><p>刚体变换只改变物体的空间位置(平移)和朝向(旋转)，而不改变其形状，可用两个变量来描述：旋转矩阵R和平移向量t</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/v2-0dc276d40437a5f17ed0ec039b18953f_1440w.png"  alt></p>
<p>其次坐标下可写为：<br><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/v2-47be6823de88962d67c5dbe13567d460_1440w.png"  alt></p>
<p>旋转矩阵R是正交矩阵，可通过罗德里格斯（Rodrigues）变换转换为只有三个独立变量的旋转向量：</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/v2-bfa1bff196934d0d6e19da2b404067aa_1440w.png"  alt></p>
<p>因此，刚体变换可用6个参数来描述，这6个参数就称为相机的外参(Extrinsic)，相机外参决定了空间点从世界坐标系转换到相机坐标系的变换，也可以说外参描述了相机在世界坐标系中的位置和朝向。</p>
<p><strong>我的理解：</strong></p>
<p><strong>相机的旋转就是改变了旋转矩阵R，旋转图像就是修改这个R</strong></p>
<p><strong>如果放在GPU中运行，其实其他过程都是一样的，只是要修改这个R，其他都是同一个流程，是不是简化很多算法</strong></p>
<h2 id="2、透视投影"><a href="#2、透视投影" class="headerlink" title="2、透视投影"></a>2、透视投影</h2><p>我们可以将透镜的成像简单地抽象成下图所示：</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/v2-860767727cf42fb84c60d435e41a83e4_1440w.png"  alt></p>
<p>设 f=OB 表示透镜的焦距，m=OC 为像距，n=AO 为物距，有：</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/v2-084365a995c90a05793383d030edad4c_1440w.png"  alt></p>
<p>一般地，由于物距远大于焦距，即 n>>f，所以 m≈f，此时可以用小孔模型代替透镜成像：</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/v2-e94f94883bb903f9fa8ad52581bc9033_1440w.png"  alt></p>
<p>可得：</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/v2-4adc27fdfd0e1028ab3e1d2aaabc2d49_1440w.png"  alt></p>
<p>齐次坐标下有：</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/v2-c0dcd00c16c8315216125077d4b8ad06_1440w.png"  alt></p>
<p>如果将成像平面移到相机光心与物体之间，则有中心透视模型：</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/v2-a76d8f55905611284570f06f0d77676a_1440w.png"  alt></p>
<p>可得：</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/v2-9d87d744835b0044a20f3d6559d24d31_1440w.png"  alt></p>
<p>齐次坐标下有：</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/v2-619b0d27a64e6fa74641670610ade0b0_1440w.png"  alt></p>
<p>总体上看，透视投影将相机坐标系中的点投影到理想图像坐标系，其变换过程只与相机焦距 f 有关。</p>
<h2 id="3、畸变校正"><a href="#3、畸变校正" class="headerlink" title="3、畸变校正"></a>3、畸变校正</h2><p>理想的针孔成像模型确定的坐标变换关系均为线性的，而实际上，现实中使用的相机由于镜头中镜片因为光线的通过产生的不规则的折射，镜头畸变（lens distortion）总是存在的，即根据理想针孔成像模型计算出来的像点坐标与实际坐标存在偏差。畸变的引入使得成像模型中的几何变换关系变为非线性，增加了模型的复杂度，但更接近真实情形。畸变导致的成像失真可分为径向失真和切向失真两类：</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/v2-3f443a32bacc0ed8ec9df0a6b60eadc0_1440w.png"  alt></p>
<p>畸变类型很多，总体上可分为径向畸变和切向畸变两类，径向畸变的形成原因是镜头制造工艺不完美，使得镜头形状存在缺陷，包括枕形畸变和桶形畸变等，可以用如下表达式来描述：</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/v2-4b34d0de42f559659da4ee261b11c98b_1440w.png"  alt></p>
<p>切向畸变又分为薄透镜畸变和离心畸变等，薄透镜畸变则是因为透镜存在一定的细微倾斜造成的；离心畸变的形成原因是镜头是由多个透镜组合而成的，而各个透镜的光轴不在同一条中心线上。切向畸变可以用如下数学表达式来描述：</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/v2-504d609395301742f3c875b3f8023731_1440w.png"  alt></p>
<p>在引入镜头的畸变后，成像点从理想图像坐标系到真实图像坐标系的变换关系可以表示为：</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/v2-8535c6123110df3296799e1a74016612_1440w.png"  alt></p>
<p>实际计算过程中，如果考虑太多高阶的畸变参数，会导致标定求解的不稳定。</p>
<h2 id="4、数字化图像"><a href="#4、数字化图像" class="headerlink" title="4、数字化图像"></a>4、数字化图像</h2><p>光线通过相机镜头后最终成像在感光阵列(CCD或CMOS)上，然后感光阵列将光信号转化为电信号，最后形成完整的图像。我们用dx和dy分别表示感光阵列的每个点在x和y方向上物理尺寸，即一个像素是多少毫米，这两个值一般比较接近，但由于制造工艺的精度问题，会有一定误差，同样的，感光阵列的法向和相机光轴也不是完全重合，即可以看作成像平面与光轴不垂直。</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/v2-1259ab99566c20fb28c30ee2d0e6fcfb_1440w.png"  alt></p>
<p>我们用仿射变换来描述这个过程，如上图，O点是图像中心点，对应图像坐标(u0，v0)，Xd - Yd是真实图像坐标系，U-V是数字化图像坐标系，有：</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/v2-09d962a72f187320ca46e409fd6b364f_1440w.png"  alt></p>
<p>齐次坐标下有：</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/v2-b187fdfd286e725a3a140b003f812e6c_1440w.png"  alt></p>
<p>上式中的变换矩阵即为相机的内参数矩阵 K，其描述了相机坐标系中点到二维图像上点的变换过程。</p>
<p>综上所述，在不考虑镜头畸变的情况下，相机的整个成像过程可表示为：</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/v2-904b09f24a1ea84d64d425760ca8a796_1440w.png"  alt></p>
<p><strong>我的疑问：</strong></p>
<p>一般来说图像的中心并不是（0,0)，而是(w/2,h/2)，也就是说u0=w/2,v0=h/2;<br> 如果说不考虑dx不等于dy的情况，因为大部分像素都是正方形的，那么公式应该变成</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/1583673008090.png"  alt></p>
<p>而这与透视投影的矩阵乘在一起，变成了</p>
<p><img src="/" class="lazyload" data-src="/2020/03/08/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E6%A8%A1%E5%9E%8B/1583673022764.png"  alt></p>
<p>f可以乘做为像素焦距。如果我们需要做畸变校正的话，这两者就不能乘在一起了。</p>
<p>那么最前面的Zc如何计算？</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>camera原理</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-butterfly主题迁移</title>
    <url>/2020/03/01/%E5%AD%A6%E4%B9%A0-%E5%B7%A5%E5%85%B7-hexo-hexo-butterfly%E4%B8%BB%E9%A2%98%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="网站配置"><a href="#网站配置" class="headerlink" title="网站配置"></a>网站配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>参考<a href="https://jerryc.me/posts/21cfbf15/" target="_blank" rel="noopener">《hexo-theme-butterfly安装文档》</a></p>
<h3 id="模板的front-matter"><a href="#模板的front-matter" class="headerlink" title="模板的front matter"></a>模板的front matter</h3><p>将以下front matter设置在/scaffolds/post.md中，就可以在<code>hexo new "title"</code>的时候自动加上这些注释了</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top:</span><br><span class="line">top_img: （除非特定需要，可以不写）</span><br><span class="line">comments： 是否显示评论（除非设置false,可以不写）</span><br><span class="line">cover:  缩略图</span><br><span class="line">toc:  是否显示toc （除非特定文章设置，可以不写）</span><br><span class="line">toc_number: 是否显示toc数字 （除非特定文章设置，可以不写）</span><br><span class="line">copyright: 是否显示版权 （除非特定文章设置，可以不写）</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">hide:</span><br><span class="line">---</span><br></pre></td></tr></tbody></table></figure>

<h3 id="音乐界面"><a href="#音乐界面" class="headerlink" title="音乐界面"></a>音乐界面</h3><p>想增加QQ音乐和网易云音乐的歌单，可以安装插件<a href="https://github.com/MoePlayer/hexo-tag-aplayer" target="_blank" rel="noopener">hexo-tag-aplayer</a>，需要在站点配置文件_config.yml中增加</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">aplayer:</span></span><br><span class="line">  <span class="attr">meting:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>
<p>如何获取歌单的id呢？网易云音乐把歌单分享出来，链接是 <a href="http://music.163.com/playlist?id=472885344&userid=124181546" target="_blank" rel="noopener">http://music.163.com/playlist?id=472885344&userid=124181546</a> ，那么id就是472885344。但是注意QQ音乐，只有网页版的分享链接才会有id号。</p>
<p>只需要在md文件中增加以下代码就可以实现歌单效果了</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">## 我的QQ音乐歌单</span></span><br><span class="line"><span class="string">{%</span> <span class="string">meting</span> <span class="string">"4274201226"</span> <span class="string">"tencent"</span> <span class="string">"playlist"</span> <span class="string">"mutex:true"</span> <span class="string">"listmaxheight:300px"</span> <span class="string">"preload:auto"</span> <span class="string">"theme:#ad7a86"</span><span class="string">%}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 围的网易云歌单</span></span><br><span class="line"><span class="string">{%</span> <span class="string">meting</span> <span class="string">"472885344"</span> <span class="string">"netease"</span> <span class="string">"playlist"</span> <span class="string">"mutex:true"</span> <span class="string">"listmaxheight:300px"</span> <span class="string">"preload:auto"</span> <span class="string">"theme:#ad7a86"</span><span class="string">%}</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="相册"><a href="#相册" class="headerlink" title="相册"></a>相册</h3><p>butterfly的Gallery相册会自动根据图片长度进行排版，书写也更加方便，与markdown格式一样。可根据需要插入到相应的md。</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">{% gallery %}</span><br><span class="line">markdown 图片格式</span><br><span class="line">{% endgallery %}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>站点配置文件_config.yml中，url那一栏填域名，注意只能填顶级域名，不能填二级域名</li>
<li>hexo升级到4.2之后，hexo_asset_image这个插件就出bug了，原来的作者不维护了，有人出了一个修复后的插件，叫hexo_asset_image_fixed。解决方法是：把原来的插件卸载，用命令<code>npm install hexo-asset-image-fixed</code>安装一下即可</li>
<li>网站文件更新后，访问网址并没有进行更新。这是因为cdn缓存了之前的文件，需要刷新cdn缓存，拿七牛举例，需要在cdn的刷新预期->刷新目录即可</li>
<li>想要用PWA的功能，manifest.json一定不能被渲染了，不然浏览器解析不出来。除了手册说的那些操作外，还需要在站点配置文件_config.yml中增加<code>skip_render: 'manifest.json'</code>。还需要注意的是，配置offline属性的时候，要把html去掉，否则他会把html文件缓存在本地，即使文章更新了也看不到。</li>
<li><code>hexo g -d</code>会漏掉service-worker.js，以后尽量用hexo g && hexo d</li>
</ol>
<h2 id="编辑器typora配置"><a href="#编辑器typora配置" class="headerlink" title="编辑器typora配置"></a>编辑器typora配置</h2><h3 id="图片设置"><a href="#图片设置" class="headerlink" title="图片设置"></a>图片设置</h3><p>要让图片复制到当前目录下同名文件夹下，需要修改<strong>偏好设置->图片插入->复制到指定目录./${filename}->对本地和网络图片应用以上规则->勾选优先使用相对路径</strong>。这样编辑器里面的图片，网站也可以正常显示了</p>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p><code>ctrl + K</code> : 将复制的链接，链接到文字上</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>工具</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>镜头畸变的那些事</title>
    <url>/2020/02/29/%E5%8E%9F%E5%88%9B-%E7%95%B8%E5%8F%98%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="镜头畸变的那些事"><a href="#镜头畸变的那些事" class="headerlink" title="镜头畸变的那些事"></a>镜头畸变的那些事</h1><h2 id="畸变"><a href="#畸变" class="headerlink" title="畸变"></a>畸变</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对于理想光学系统，在一对共轭的物像平面上，像的放大率是一个常数。但是对于实际的光学系统，当视场较大或很大时，像的放大率就要随视场而异，这样就会使像相对于物体失去相似性。这种使像变形的成像缺陷称为畸变。</p>
<p><img src="/" class="lazyload" data-src="/2020/02/29/%E5%8E%9F%E5%88%9B-%E7%95%B8%E5%8F%98%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/879a9c2b8b0f4b2da7a09ee7cf1326a6_th-1583470457857.png"  alt></p>
<p>畸变定义为实际像高与理想像高差，而在实际应用中经常将其与理想像高之比的百分数来表示畸变，称为相对畸变，即：</p>
<p><img src="/" class="lazyload" data-src="/2020/02/29/%E5%8E%9F%E5%88%9B-%E7%95%B8%E5%8F%98%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/14695038608OcoPVdc_s.jpg"  alt></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>通常来说镜头的畸变分为径向畸变和切向畸变两类。图像径向畸变是图像像素点以畸变中心为中心点,沿着径向产生的位置偏差,从而导致图像中所成的像发生形变。径向畸变分为桶形畸变和枕形畸变。</p>
<ul>
<li><p>桶形畸变（Barrel Distortion），又称桶形失真，是由镜头中透镜物理性能以及镜片组结构引起的成像画面呈桶形膨胀状的失真现象。我们在使用广角镜头或使用变焦镜头的广角端时，最容易察觉桶形失真现象。</p>
<p>下面是桶形畸变的真实场景，本该是垂直的房屋，却发生了变形。</p>
<p><img src="/" class="lazyload" data-src="https://cdn.pixabay.com/photo/2015/08/11/12/47/bad-camberg-884454__480.jpg"  alt="桶形畸变真实场景"></p>
</li>
<li><p>枕形畸变（Pincushion Distortion），又称枕形失真，它是由镜头引起的画面向中间“收缩”的现象。我们在使用长焦镜头或使用变焦镜头的长焦端时，最容易察觉枕形失真现象。</p>
</li>
</ul>
<p>下图是镜头畸变的对比示意图，第一幅图像是无畸变，第二幅图像是桶形畸变，第三幅图像是枕形畸变。</p>
<p><img src="/" class="lazyload" data-src="/2020/02/29/%E5%8E%9F%E5%88%9B-%E7%95%B8%E5%8F%98%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/20170711145255252.gif"  alt="镜头畸变的对比示意图"></p>
<p>切向畸变是由于透镜本身与相机传感器平面（成像平面）或图像平面不平行而产生的，这种情况多是由于透镜被粘贴到镜头模组上的安装偏差导致。我们一般只考虑径向畸变。</p>
<p>下图是切向畸变的示意图。</p>
<p><img src="/" class="lazyload" data-src="/2020/02/29/%E5%8E%9F%E5%88%9B-%E7%95%B8%E5%8F%98%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/calibration_tangentialdistortion.png"  alt="切向畸变"></p>
<h3 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h3><p>来源于<a href="https://blog.csdn.net/u014652390/article/details/50324347" target="_blank" rel="noopener">博客</a></p>
<p>畸变的常见原因是因为在镜头系统中引入光圈，光圈的位置决定了失真的类别与程度。如下图：</p>
<p><img src="/" class="lazyload" data-src="/2020/02/29/%E5%8E%9F%E5%88%9B-%E7%95%B8%E5%8F%98%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/20170711145319620.png"  alt="畸变原因示意图"> </p>
<p>对于恒定的物体尺寸<em>y</em>，图像尺寸  <em>h</em>有所不同  。</p>
<p>像点的位置由主光线（实线）确定，主光线是穿过光圈中心的光线。当光圈位于透镜上时，也就是中间那幅图像，主光线穿过光学中心，并以与入射角相同的角度离开透镜。这样的系统不会使图像失真，因此没有畸变。</p>
<p>当光圈在透镜前面或后面时，主光线会被折射。当光圈在镜头前面，像的高度减小了，也就是像缩小了，就造成了桶形失真。复杂的镜头，例如后焦距广角镜头，往往就会出现桶形失真，因为前组镜头会充当后组的光圈。</p>
<p>当光圈在镜头后面，像的高度增加了，也就是放大了，就是枕形失真。远焦镜头的后组为负，会导致枕形失真。</p>
<p>下面这幅图片是对应的三维图，更加清晰的看出光圈与镜头的关系。</p>
<p><img src="/" class="lazyload" data-src="/2020/02/29/%E5%8E%9F%E5%88%9B-%E7%95%B8%E5%8F%98%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/bd3d1fbdc57c4ae0be86ef5f7fd2bb6e_th.jpg"  alt="畸变原因三维示意图"></p>
<p>这里可以引申一个问题，投影仪同样也是利用凸透镜，但是畸变就很小，而相机的畸变就相对比较大。因为它可以采用比较接近对称和比较紧凑的结构，镜头就很少有畸变。</p>
<p>简单的说，镜头畸变是由远离光圈的镜片的球面像差造成的。</p>
<p>如果镜头结构关于光圈基本对称，光圈前后的畸变互相抵消，不会有畸变。<br>如果镜头镜片都在光圈很近距离内，也不会有多少畸变。<br>如果远离光圈的镜片校正了球面像差，比如采用非球面镜，也不会产生畸变。<br>如果光圈放在物方焦平面和像方焦平面上，使主光线平行于光轴，也不会产生畸变（<a href="https://baike.baidu.com/item/%E8%BF%9C%E5%BF%83%E9%95%9C%E5%A4%B4/667556?fr=aladdin" target="_blank" rel="noopener">远心镜头</a>）。</p>
<h3 id="畸变矫正的方法"><a href="#畸变矫正的方法" class="headerlink" title="畸变矫正的方法"></a>畸变矫正的方法</h3><p>一般情况下，改善畸变有2种办法：</p>
<ol>
<li><p>一种是通过软件算法把镜头的畸变系数（也就是该镜头在当前距离下拍照时的变形特点）计算出来，一般常用的图像处理平台都包含有标定模块，像OpenCV、Halcon、CCAS等；</p>
<p>软件算法的畸变矫正是通过标定，把像的实际的位置和理想的位置做了一个映射，把图片处理成没有畸变的图片。</p>
<p>缺点是：</p>
<ol>
<li>降低清晰度</li>
<li>由于矫正后边角损失部分像素，会对图像进行裁剪，视场角减小</li>
<li>由于需要一直运行算法，增加功耗</li>
</ol>
<p>优点是：降低硬件成本</p>
</li>
<li><p>另一种就是通过光路设计，从镜头硬件本身消除畸变的影响，如<a href="https://baike.baidu.com/item/%E8%BF%9C%E5%BF%83%E9%95%9C%E5%A4%B4/667556?fr=aladdin" target="_blank" rel="noopener">双远心镜头</a>就是一种非常典型的“零畸变”镜头，利用非球面镜减小畸变等等。</p>
<p>优点是不会损失清晰度。不会裁剪图像，也就不会损失视场角，不需要软件处理，降低功耗。缺点是需要定制，比较昂贵。</p>
</li>
</ol>
<h2 id="畸变计算方法"><a href="#畸变计算方法" class="headerlink" title="畸变计算方法"></a>畸变计算方法</h2><p>这里遇到一个有趣的事情</p>
<p>为什么公安一所测出的畸变值远大于镜头手册的畸变值？答案是计算方法不同。</p>
<h3 id="光学畸变和tv畸变"><a href="#光学畸变和tv畸变" class="headerlink" title="光学畸变和tv畸变"></a>光学畸变和tv畸变</h3><p>先来了解一下光学畸变(也称几何畸变）和tv畸变，他们的计算方法如下图所示。实线是实际成的像，虚线是理想中的像。</p>
<p><img src="/" class="lazyload" data-src="/2020/02/29/%E5%8E%9F%E5%88%9B-%E7%95%B8%E5%8F%98%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/1583426059467.png"  alt="光学畸变和TV畸变示意图"></p>
<p>光学畸变和tv畸变是有换算关系的，以1080P16：9的CMOS为例，tv畸变是光学畸变的0.38倍。</p>
<p>tv畸变有两种计算方法，SMIA TV 畸变和ISO TV畸变：</p>
<p><img src="/" class="lazyload" data-src="/2020/02/29/%E5%8E%9F%E5%88%9B-%E7%95%B8%E5%8F%98%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/1583683566607.png"  alt="tv畸变计算方法"></p>
<p>SMIA TV Distortion = ( A-B )/B ; A = ( A1+A2 )/2</p>
<p>ISO TV Distortion = ( A-B )/(2 * B) ; A = ( A1+A2 )/2</p>
<p>所以，SMIA TV畸变=2*ISO TV畸变，上图的tv畸变指是ISO TV畸变。从公式可以看出，TV畸变是基于图像的高度和参考中心线的高度差异，如果需要计算图像水平方向的畸变，可以导入图像之前，先把图像旋转90°再分析。</p>
<h3 id="公安一所的畸变计算方法"><a href="#公安一所的畸变计算方法" class="headerlink" title="公安一所的畸变计算方法"></a>公安一所的畸变计算方法</h3><p>拍两条横向直线，让他们与图像的上下边相切。两条直线与图像左侧相交，得到两个坐标，计算出纵向像素差A1，同样的方法可以得到右侧的纵向像素差A2。这两条直线的最大距离，也就是中间的纵向像素差是c，畸变值就是(（A1+A2）/2 - B)/B</p>
<p>举例：</p>
<p><img src="/" class="lazyload" data-src="/2020/02/29/%E5%8E%9F%E5%88%9B-%E7%95%B8%E5%8F%98%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/%E4%B8%80%E6%89%80%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%BE%E4%BE%8B.jpg"  alt></p>
<p>用画图工具打开后，可以看到每个点的像素位置，先算出左侧的像素差（881-181=700），右侧的像素差（912-207=705），中间的像素差为1067，就可以计算出畸变值为（（700+705）/2 - 1067）/1067 = -0.3416）</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>同一款镜头，手册上的光学畸变只有21%，理论上的SMIA tv畸变只有16%，但是用一所的方法计算出来却有37%，这是为什么呢？</p>
<p><img src="/" class="lazyload" data-src="/2020/02/29/%E5%8E%9F%E5%88%9B-%E7%95%B8%E5%8F%98%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/1583682669887.png"  alt></p>
<p>如上图所示，红线的方法与tv畸变不同的是，它将上边线延长到了图像左右边框，计算出来的Δh明显比tv畸变大得多。一所测试的时候需要找到两条线与上下边框相切，而不是像tv畸变那种处于中间的一条线，因此一所方法得到的畸变值比红线的方法还要大，这样就能解释为什么一所的方法类似tv畸变，却又比tv畸变大得多。因此我们选择镜头的时候，需要先计算一下是否能够真的符合一所的标准。</p>
<h2 id="畸变矫正算法"><a href="#畸变矫正算法" class="headerlink" title="畸变矫正算法"></a>畸变矫正算法</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h3><p><img src="/" class="lazyload" data-src="/2020/02/29/%E5%8E%9F%E5%88%9B-%E7%95%B8%E5%8F%98%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/1583681970945.png"  alt="径向失真和切向失真对畸变的影响"></p>
<p>径向畸变的形成原因包括枕形畸变和桶形畸变等，可以用如下表达式来描述：</p>
<p><img src="/" class="lazyload" data-src="/2020/02/29/%E5%8E%9F%E5%88%9B-%E7%95%B8%E5%8F%98%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/1583681903257.png"  alt></p>
<p>公式里（x0，y0）是畸变点在成像仪上的原始位置，（x，y）是校正后新的位置。</p>
<p>注意这个公式，（x0，y0）是畸变的原图上像素点的位置；（x，y）是校正后输出图像上像素点的位置。</p>
<p>实现过程是，对输出图的点做遍历——以1080p的图像为例，从点（0,0）到点（1919,1079），一行一行的遍历——依次找到输出点（x, y）对应的原图点（x0, y0）的像素值，再将（x0, y0）的值赋给（x, y）。如果计算出来的对应的原图的点（x0, y0）不是整数，则用二次线性插值计算此点，然后赋值给（x, y）。</p>
<p>切向畸变又分为薄透镜畸变和离心畸变等，薄透镜畸变则是因为透镜存在一定的细微倾斜造成的；离心畸变的形成原因是镜头是由多个透镜组合而成的，而各个透镜的光轴不在同一条中心线上。切向畸变可以用如下数学表达式来描述：</p>
<p><img src="/" class="lazyload" data-src="/2020/02/29/%E5%8E%9F%E5%88%9B-%E7%95%B8%E5%8F%98%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/%E5%88%87%E5%90%91%E7%95%B8%E5%8F%98.png"  alt></p>
<p>在引入镜头的畸变后，成像点从理想图像坐标系到真实图像坐标系的变换关系可以表示为：</p>
<p><img src="/" class="lazyload" data-src="/2020/02/29/%E5%8E%9F%E5%88%9B-%E7%95%B8%E5%8F%98%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/1583499951669.png"  alt></p>
<p>在目前的摄像机标定研究中,对镜头畸变考虑较多的是镜头径向畸变,而忽略了镜头的切向和薄棱镜等其它非线性畸变因素。</p>
<p>实际计算过程中，如果考虑太多高阶的畸变参数，会导致标定求解的不稳定。</p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h4 id="1-图像采集"><a href="#1-图像采集" class="headerlink" title="1. 图像采集"></a>1. 图像采集</h4><p>首先在opencv官网下载<a href="https://docs.opencv.org/2.4/_downloads/pattern.png" target="_blank" rel="noopener">棋盘格图像</a>进行打印。</p>
<h4 id="2-标定"><a href="#2-标定" class="headerlink" title="2. 标定"></a>2. 标定</h4><p>主要过程：用matlab工具箱进行标定，得到畸变矫正参数，并转换成opencv的参数，参考这个<a href="https://blog.csdn.net/youyudexiaoyanjing/article/details/79145898" target="_blank" rel="noopener">博客</a>的步骤</p>
<p>这里主要记录一下，matlab参数与opencv参数的转换：</p>
<ol>
<li><p>在使用opencv中的undistort进行畸变矫正时，需要使用8个参数即fc1, fc2, cc1, cc2, kc1, kc2, kc3, kc4; </p>
</li>
<li><p>MATLAB的参数有三个：</p>
<ul>
<li><p>RadialDistorion中的参数分别是：kc1,kc2,kc5(不常用) </p>
</li>
<li><p>TangentialDistortion中的参数分别是：kc3,kc4 </p>
</li>
<li><p>IntrinsicMatrix中的参数分别是： [[fc1,无用,0],[无用,fc2,0],[cc1,cc2,1]] </p>
</li>
</ul>
</li>
</ol>
<h4 id="3-畸变矫正"><a href="#3-畸变矫正" class="headerlink" title="3. 畸变矫正"></a>3. 畸变矫正</h4><p>利用undistort函数</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_calibration</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="comment"># 设置畸变校正的参数值</span></span><br><span class="line">    fc1 = <span class="number">1.107859597442719e+03</span></span><br><span class="line">    fc2 = <span class="number">1.110705995095509e+03</span></span><br><span class="line">    cc1 = <span class="number">9.701443009307349e+02</span></span><br><span class="line">    cc2 = <span class="number">5.619129804989138e+02</span></span><br><span class="line">    kc1 = <span class="number">-0.321797722411564</span></span><br><span class="line">    kc2 = <span class="number">0.075142421519568</span></span><br><span class="line">    kc3 = <span class="number">0</span></span><br><span class="line">    kc4 = <span class="number">0</span></span><br><span class="line">    cameraMatrix = np.array([</span><br><span class="line">                  [fc1, <span class="number">0</span>  , cc1],</span><br><span class="line">                  [<span class="number">0</span>  , fc2, cc2],</span><br><span class="line">                  [<span class="number">0</span>  , <span class="number">0</span>  , <span class="number">1</span>  ]</span><br><span class="line">    ])</span><br><span class="line">    distCoeffs = np.array([kc1, kc2, kc3, kc4])</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 获取视频中的一帧图像</span></span><br><span class="line">    vidcap = cv2.VideoCapture(video)</span><br><span class="line">    success, frame = vidcap.read() </span><br><span class="line">    imageSize = (frame.shape[<span class="number">1</span>],frame.shape[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># 畸变校正</span></span><br><span class="line">    frameCalibration = cv2.undistort(frame,cameraMatrix,distCoeffs)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 绘图</span></span><br><span class="line">    plt.subplot(<span class="number">211</span>)</span><br><span class="line">    plt.imshow(frame)</span><br><span class="line">    plt.subplot(<span class="number">212</span>)</span><br><span class="line">    plt.imshow(frameCalibration)</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="keyword">return</span> map1,map2</span><br></pre></td></tr></tbody></table></figure>

<h4 id="4-算法加速"><a href="#4-算法加速" class="headerlink" title="4. 算法加速"></a>4. 算法加速</h4><p>可以参考<a href="https://blog.csdn.net/hust_bochu_xuchao/article/details/54585200" target="_blank" rel="noopener">博客</a></p>
<p>主要思路是根据内参和畸变系数，建立了一个查找表（实际位置与理想位置的映射表）</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">test_calibration</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">	# 畸变校正</span><br><span class="line">    #根据内参和畸变系数，建立了一个查找表，map1 map2设置为全局变量，所以这个函数只需要运行一次就好，不需要重复计算查找表。</span><br><span class="line">    newCameraMatrix = cv2.getOptimalNewCameraMatrix(cameraMatrix, distCoeffs, imageSize, <span class="number">1</span>, imageSize, <span class="number">0</span>)</span><br><span class="line">    map1, map2 = cv2.initUndistortRectifyMap(cameraMatrix, distCoeffs, None, newCameraMatrix[<span class="number">0</span>], imageSize, cv2.CV_16SC2);</span><br><span class="line"></span><br><span class="line">    # 此函数根据map1 map2查找表进行畸变矫正，同一个镜头下的视频中map1 map2可以重复使用</span><br><span class="line">    frameCalibration = cv2.remap(frame, map1, map2, cv2.INTER_LINEAR);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> map1,map2</span><br></pre></td></tr></tbody></table></figure>

<h4 id="5-校正效果"><a href="#5-校正效果" class="headerlink" title="5. 校正效果"></a>5. 校正效果</h4><p>下图是没有经过裁剪的畸变校正效果</p>
<p><img src="/" class="lazyload" data-src="/2020/02/29/%E5%8E%9F%E5%88%9B-%E7%95%B8%E5%8F%98%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/1583821547894.png"  alt="没有经过裁剪的畸变校正效果"></p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>镜头</tag>
        <tag>畸变</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：两路摄像头偶尔不能同时切换日夜模式</title>
    <url>/2020/02/29/%E5%B7%A5%E4%BD%9C-BUG-BUG-%E4%B8%A4%E8%B7%AF%E6%91%84%E5%83%8F%E5%A4%B4%E5%81%B6%E5%B0%94%E4%B8%8D%E8%83%BD%E5%90%8C%E6%97%B6%E5%88%87%E6%8D%A2%E6%97%A5%E5%A4%9C%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>两个摄像头对着同一个场景，从夜模式切到日模式，两个摄像头切换的速度不一致，有一个会慢一点，有的时候可以到5-10s</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li><input checked disabled type="checkbox"> 确定是日夜切换判断慢了还是日夜切换执行慢了</li>
<li><input checked disabled type="checkbox"> 如果是执行慢了就好说，如果是判断慢了，需要确定是两路摄像头一起切换才有问题，还是一路摄像头自己切换也会慢</li>
<li><input checked disabled type="checkbox"> 从AE打印上来看两路摄像头的增益有什么区别，尽量保证两个摄像头的增益一致</li>
<li><input checked disabled type="checkbox"> 查看代码逻辑，尤其注意是否因为上锁，进程是否一直被抢占，以及有一路日夜模式判断那么久</li>
</ul>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li>因为执行的过程，手动日夜切换和自动日夜切换是同一个过程，因此可以用手动模式下测试摄像头切换的速度。测试结果是并未出现某一路过慢的问题。</li>
<li>由于逻辑上切5次就会锁住，测试的时候经常锁住，非常不方便，而且影响判断，将锁住的逻辑去掉了</li>
<li>之前发现一个寄存器配置问题，会造成增益小一倍（至今都不知道是不是触发了这颗sensor的隐藏技能，这里记录一下，IMX290的0x3011寄存器手册上写的是应该赋值0x0A，结果弄成了0x20，反而提高了亮度）</li>
<li>把两颗摄像头的ISP参数都设置成一致，让唐佳琪和小范帮忙测试，原以为已经修复，其实并未</li>
<li>两路摄像头基本上是交替进行的，偶尔会有连续两次处理同一个摄像头的情况，不存在进程被抢占的问题</li>
<li>查看日夜模式判断，打开AE打印，找到原因</li>
</ol>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>夜切回日模式的条件是，sensor当前的增益要连续小于日夜切换的阈值五秒。由于日夜切换的阈值默认值很小，接近普通场景下的增益，容易不满足连续小于阈值五秒的条件。虽然两个摄像头对着同一个地方，但是稍微的一点偏差增益就不同，只要大于阈值，就会开始重新计时五秒，因此偶尔会出现有的快有的慢的现象。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>打开web界面的设置，日夜切换那一栏里面的灵敏度和日夜切换阈值都调大些。比如都设置到80，这样可以提高这个阈值，就不会出现这个问题了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><p>一开始主要是一直纠结于两路摄像头切换速度不一致，其实本质是一个摄像头切换时间不固定，第二步的思路没有执行下去，导致后面绕了很多的弯路。定好了思路就该去按照思路去一步一步测试，不然就像无头苍蝇一样乱碰，浪费时间。</p>
</li>
<li><p>对db值不敏感，6db是2倍，12db只有4倍，依次类推。</p>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>BUG</tag>
        <tag>高通camera</tag>
      </tags>
  </entry>
  <entry>
    <title>利用又拍云cdn加速github pages</title>
    <url>/2020/01/21/%E5%AD%A6%E4%B9%A0-%E5%B7%A5%E5%85%B7-hexo-%E5%88%A9%E7%94%A8%E5%8F%88%E6%8B%8D%E4%BA%91cdn%E5%8A%A0%E9%80%9Fgithub-pages/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>作者github上的博客是xiaoqinxing.github.io，如何cdn加速，并用域名<a href="http://www.qinxing.xyz" target="_blank" rel="noopener">www.qinxing.xyz</a> 进行访问呢？</p>
<p>由于国外的cdn流量较贵，因此国外就用github的源站，拥有无限的空间和不错的速度。国内由于网速较慢，需要用cdn进行加速，然后将<a href="http://www.qinxing.xyz" target="_blank" rel="noopener">www.qinxing.xyz</a> 与cdn的加速域名绑定即可。</p>
<p><img src="/" class="lazyload" data-src="/2020/01/21/%E5%AD%A6%E4%B9%A0-%E5%B7%A5%E5%85%B7-hexo-%E5%88%A9%E7%94%A8%E5%8F%88%E6%8B%8D%E4%BA%91cdn%E5%8A%A0%E9%80%9Fgithub-pages/1583892494033.png"  alt></p>
<p>至于为什么不用云存储呢，因为我希望上传一次代码，网站可以直接更新，相比云存储还需要把生成的代码传到云端，少了一步。同时也省了一笔费用。</p>
<h2 id="cdn加速"><a href="#cdn加速" class="headerlink" title="cdn加速"></a>cdn加速</h2><p>作者使用的是又拍云，由于加入又拍云联盟每个月可以有15G免费的HTTPS流量。这是活动的<a href="https://www.upyun.com/league" target="_blank" rel="noopener">网址</a>。</p>
<p>接下来进入正题。</p>
<p>首先，国内云服务商的域名都是需要备案的，我的域名是在阿里云备案的，一两天就通过了，十分的简单。</p>
<p>第二步，在又拍云创建一个cdn服务，源站就设置成xiaoqinxing.github.io，回源协议用https（github强制https)，源站证书校验关闭。使用又拍云的朋友注意了，回源管理中的<strong>回源Host一定要再填一遍源站域名</strong>，被坑了好久，这里还是xiaoqinxing.github.io。</p>
<p>第三步，绑定域名，首先将域名<a href="http://www.qinxing.xyz" target="_blank" rel="noopener">www.qinxing.xyz</a> 绑定在这个cdn上，又拍云会生成一个CNAME名称（我理解中这个是cdn服务器的域名，CNAME就是让一个域名跳转到另外一个域名上）。其次在github.io的设置中设置自定义域名<a href="http://www.qinxing.xyz" target="_blank" rel="noopener">www.qinxing.xyz</a> </p>
<p>第四步，域名解析，这个域名解析是在你的域名服务商那里完成的，比如说就拿阿里云来说，创建两条<a href="http://www.qinxing.xyz" target="_blank" rel="noopener">www.qinxing.xyz</a> 的域名解析记录，记录类型都是CNAME，第一条记录的解析线路是默认，记录值是又拍云cdn的CNAME名称。第二条的解析线路是境外，记录值是源站域名xiaoqinxing.github.io。</p>
<p>第五步，申请证书，开启https服务的时候需要申请SSL证书，这个可以在又拍云里面申请免费的SSL证书。申请好了之后再https配置中，勾选https访问和强制HTTPS访问。</p>
<p><img src="/" class="lazyload" data-src="/2020/01/21/%E5%AD%A6%E4%B9%A0-%E5%B7%A5%E5%85%B7-hexo-%E5%88%A9%E7%94%A8%E5%8F%88%E6%8B%8D%E4%BA%91cdn%E5%8A%A0%E9%80%9Fgithub-pages/1583892988361.png"  alt></p>
<p>第六步，刷新缓存查看是否生效，由于cdn相当于把源站的内容在国内缓存了好多份，想要实时生效，需要刷新cdn缓存。另外浏览器也会把原来的网站缓存一份，浏览器里面直接刷新不出来不代表真的没有生效。拿chrome浏览器举例，刷新的时候要<code>ctrl + F5</code>，才能刷新缓存。</p>
<p>最后，如果有什么问题，可以提交工单，询求技术支持，我的问题就是在他们的帮助下解决的，感谢。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>在GitHub Pages设置自定义域名之后，发现每次hexo d 后都会失效，又要重新设置</p>
<p>回：只要在source 目录添加一个新文件CNAME就好</p>
<p>CNAME –不带任何后缀，这就是全称，里面写的是你的域名</p>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>工具</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>cdn</tag>
      </tags>
  </entry>
  <entry>
    <title>如何安慰人</title>
    <url>/2020/01/17/%E7%94%9F%E6%B4%BB-%E6%80%9D%E8%80%83-%E5%A6%82%E4%BD%95%E5%AE%89%E6%85%B0%E4%BA%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>恰当的安慰一个人，就是去理解对方的理解和需要。恰当的安慰一个人，就是去理解一个人的情绪和感受。相反，不恰当的安慰就是把自己对一个事情的看法和感受，强加到一个痛苦的人身上，然后让对方身心更加痛苦。</p>
</blockquote>
<h2 id="安慰人的关键"><a href="#安慰人的关键" class="headerlink" title="安慰人的关键"></a>安慰人的关键</h2><p>当朋友心情不好时，我们该如何恰当的安慰一个人？</p>
<ul>
<li><strong>理解Ta的感受、承认Ta的痛苦</strong></li>
<li><strong>不“期望”Ta快快好起来</strong></li>
<li><strong>鼓励Ta表达真实的感受</strong></li>
</ul>
<p>通常，我们特别擅于给朋友打些鸡血，说：你看你拥有这些拥有那些，你还有这么多好的东东，不要难过了；说其实这不过是小事一桩，没有什么大不了的，你睡一觉明天就好了。</p>
<p>以前沟通学上老师教过，<strong>倾听这个技能并不像想象中的那么容易。倾听是个体力活。</strong>作为一个男生，这项技能点是残缺的。当他人表述的时候，你得放弃建议的意愿，你得放弃你的价值判断，你得放弃对于倾诉者本身的价值判断，你得带入她的情感而不过分表达，太他妈难了。举个例子，比如闺蜜的男朋友出轨了，找你倾述。你怎么表达算是合适的安慰呢？<br>1.天杀的，不要怕，老娘现在就去剁了他。然后拿起菜刀就出门了。（吓得你闺蜜生拉硬拽把你拉回了家，摸了摸胸口，哦哟，我的小心脏啊。）<br>2.天涯何处无芳草，像你这么优秀的女人大把的男人可以选呢。（闺蜜：选来选去都是渣男。）<br>3.妈的，老娘前前男友也出轨，前男友是个gay，你说人生怎么这么不幸呢？哭的稀里哗啦，（闺蜜反过来安慰你了。）<br>4.那他为什么会出轨呢？（闺蜜：你想说我，不温柔，还长得丑！你：我只是在帮你分析找原因。）<br>5.我早就觉得你男朋友是个人渣了。（闺蜜：你他妈才人渣呢！你：不，我是在帮你出气啊！）<br>6.我带你去吃肉，这事就这么过去了。（闺蜜：你去吧，我不饿。）<br>7.我理解你，你一定很痛苦吧。（闺蜜：你理解个屁，你是在同情我，怜悯我吗？）<br>8.他出轨肯定有他出轨的理由。（闺蜜拿起菜刀把你剁了，虽然你说的是事实。）<br>9.那我多陪陪你吧。（陪伴肯定是有效的，但是对话的过程怎么处理呢？一不小心，又走上了12345678）<br>那理论听了那么多，我到底怎么说比较合适呢？<br><strong>重复她所说的话，让她自然而流畅的倾述。（作弊技能，但具有一定的通用性。）</strong><br><strong>重复她所说的话，让她自然而流畅的倾述。</strong></p>
<p><strong>重复她所说的话，让她自然而流畅的倾述。</strong></p>
<p>闺蜜：我男朋友出轨了。</p>
<p>你：出轨了？</p>
<p>闺蜜：我看见他和谁谁谁一起牵着手逛街。</p>
<p>你：一起逛街？</p>
<p>。</p>
<p>。</p>
<p>。</p>
<p>过程中还可以加入一些语气词，嗯，啊。</p>
<p>当然这是一个作弊技能，更多的时候，还是要合适引导倾述对象的表述，和适当的支持，但这种支持最好不涉及价值观判断，建议等等。而一旦开始表述以后，持续不断的负面情绪也会同时感染你，你得和倾述者同时承担这些负面情绪，所以是很累的。</p>
<p>（不要建议，所有的话要倾述者自己说出来才有力量。是让她表达，你只是听，呵呵，是不是感觉被捆绑一样的不自由，那么多意见建议，好想说对不对，哈哈哈哈。）</p>
<p>总的来说，就是理解她，不把自己对这件事情的看法强行灌输给他。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>但是如果这是一个对自己很重要的人，再做一件错的事情呢或者总是抱怨同一件事情呢？</p>
<p>我觉得还是要提供解决方法，或者提出有帮助的办法，不是为了安慰而安慰，不去解决根本问题，问题永远不会结束。</p>
<p>关键还是这个提供解决方法的时机，不要一个劲的埋怨对方做的不对，这只会让他更加陷入情绪之中，也没有人会那么理性，跟别谈听不听得进去了。要等他缓和情绪后，再平静的提出解决方法，或许更加有效。</p>
</body></html>]]></content>
      <categories>
        <category>生活</category>
        <category>思考</category>
      </categories>
      <tags>
        <tag>围围</tag>
        <tag>宝藏</tag>
      </tags>
  </entry>
  <entry>
    <title>天线科普</title>
    <url>/2020/01/07/%E5%AD%A6%E4%B9%A0-%E7%94%B5%E5%AD%90-%E5%A4%A9%E7%BA%BF%E7%A7%91%E6%99%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>以下文章来源于<a href="https://mp.weixin.qq.com/s/HTSM6jpzfO62CLS19G_iow" target="_blank" rel="noopener">无线深海</a>，作者蜉蝣采采</p>
</blockquote>
<blockquote>
<p>通信天线，最经常和手机直接眉目传情的就是这货。天线之所以能高速地传递信息，就是因为它能把载有信息的电磁波发射到空气中，以光速进行传播，最终抵达接收天线。如下图所示，相对于理想的点辐射源和半波振子，天线在可以把能量聚集在主瓣方向，能把电磁波发送地更远，相当于在主瓣方向上增强了。半功率角越窄，主瓣方向信号传播地越远，增益就越高。第二就是机械下倾这种调整方式太过简单粗暴，而天线垂直分量和水平分量的幅值是不变的，因此会导致覆盖方向图被强行压扁，产生畸变。</p>
</blockquote>
<h2 id="什么是天线？"><a href="#什么是天线？" class="headerlink" title="什么是天线？"></a>什么是天线？</h2><p><strong>基站的天线，比基站本身更为醒目</strong>。“天线”这两个字，也不像它们看上去那样简单。但是，蜉蝣君努力把它说得简单有趣。</p>
<p><strong>看完本篇关于天线的介绍，你将会了解：</strong></p>
<p><strong>①</strong> 到底什么是天线？</p>
<p><strong>②</strong> 天线是怎样发射信号的？</p>
<p><strong>③</strong> 天线有哪些关键指标？</p>
<h3 id="1-揭开天线的面纱"><a href="#1-揭开天线的面纱" class="headerlink" title="1. 揭开天线的面纱"></a><strong>1. 揭开天线的面纱</strong></h3><p>众所周知，天线是基站和手机发射信号用的。</p>
<p>天线这个词的英文是Antenna，原意为触须的意思。触须就是昆虫头顶上的两根长长的细丝，可别小瞧这样不起眼的玩意儿，昆虫正是由这些触角发送的各种化学信号来传递各种社交信息的。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322213538.png"  alt="触须"></p>
<p>与此类似，在人类世界里，无线通信也是通过天线来传递信息的，只不过传递的是承载着有用信息的电磁波。下图就是手机和基站之间相互通信的一个示例。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322213649.png"  alt></p>
<p>如果你抬起头仔细端详基站的话，会发现在铁塔的最上端，有一些板状的东西，这就是本文的主角：通信天线，最经常和手机直接眉目传情的就是这货。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322213820.png"  alt></p>
<p>这种天线叫做定向天线，顾名思义，就是信号发射是有方向的。如果它正面对着你，那信号刚刚的；如果站在了它的背后，那对不起，不在服务区！</p>
<p>目前，绝大部分的基站上都用的是定向天线，一般需要三幅天线来完成360度覆盖。要揭开这货神秘的面纱，就要拆开来看看内部到底装了些什么东西。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322220442.png"  alt></p>
<p>内部空荡荡的，结构并不复杂嘛，就是由振子，反射板，馈电网络和天线罩组成。这些内部结构都是做什么的，怎样就实现了定向发射接收信号的功能呢？</p>
<p>这一切就要从电磁波来说起了。</p>
<h3 id="2-剥开天线的外衣"><a href="#2-剥开天线的外衣" class="headerlink" title="2. 剥开天线的外衣"></a><strong>2. 剥开天线的外衣</strong></h3><p>天线之所以能高速地传递信息，就是因为它能把载有信息的电磁波发射到空气中，以光速进行传播，最终抵达接收天线。</p>
<p>这就好像用高速列车运送乘客一样，如果把信息比作乘客，那么运送乘客的工具：高速列车就是电磁波，而天线就相当于车站，负责管理调度电磁波的发送。</p>
<p>那么，什么是电磁波呢？</p>
<p>科学家对电和磁这两种神秘力量研究了上百年，最终英国的麦克斯韦提出：电流能在其周边产生电场，变化的电场产生磁场，变化的磁场又产生电场。最终这个理论被赫兹的实验所证实。</p>
<p>电磁场在这样的周期性变换中，电磁波就辐射出来，向空间传播。详情见文章：“<a href="http://mp.weixin.qq.com/s?__biz=MzU3NzM4OTI1OA==&mid=2247484072&idx=1&sn=466f3e43634ec57a9304fb5eea5a0f77&chksm=fd04150dca739c1b9001b99c7b77fd4c579e4d82f358fb9b992afd5ae42e5fc983295d2afc03&scene=21#wechat_redirect" target="_blank" rel="noopener">电磁波看不见摸不着，这个年轻人的奇思妙想改变了世界</a>”。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322220500.png"  alt></p>
<p>如上图所示，红色的线表示电场，蓝色的线表示磁场，电磁波的传播方向同时垂直于电场和磁场的方向。</p>
<p>那么，天线是怎样把这些电磁波发送出去的呢？看完下图就明白了。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322220517.png"  alt></p>
<p>上面这种产生电磁波的这两根导线就叫做“振子”。一般情况下，振子的大小在半个波长的时候效果最好，所以也经常被称作“半波振子”。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322221522.png"  alt></p>
<p>有了振子，电磁波就可以源源不断地往外发射了。如下图所示。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322221538.png"  alt></p>
<p>真实的振子长下图这样。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322221716.png"  alt></p>
<p>半波振子把电磁波源源不断地向空间传播，但信号强度在空间上的分布却并不均匀，像是轮胎一样的环形。水平方向信号强，但垂直方向很弱。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322221727.png"  alt></p>
<p>实际上，我们基站的覆盖需要在水平方向上更远一些，毕竟需要打电话的人都在地上；垂直方向就到高空了，高空中也没啥需要边飞边刷抖音的人（航线覆盖是另外一个话题，后续再讲）。</p>
<p>因此，在电磁波能量的发射上，尽管半波振子的垂直方向的能量已经比较弱了，但还需要进一步地增强水平方向，把垂直方向再削弱一些。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322221738.png"  alt></p>
<p>根据能量守恒原理，能量既不会增加也不会减少，如果要提高水平方向的发射能量，就要削弱垂直方向的能量。因此就只有把标准半波阵子的能量辐射方向图拍扁了，如下图所示。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322221746.png"  alt></p>
<p>那么怎样拍扁呢？答案就是增加半波振子的数量。多个振子的发射在中心汇聚起来，边缘的能量得到了削弱，就实现了拍扁辐射方向，集中水平方向能量的目的。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322221757.png"  alt></p>
<p>在一般的宏基站系统中，定向天线的使用最为普遍。一般情况下，一个基站被划分为3个扇区，用3个天线来覆盖，每个天线覆盖120度的范围。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322221806.png"  alt></p>
<p>从上图我们可以清楚地看出，这个基站由三个扇区组成，用了3个射频单元，也就需要三副定向天线来实现。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322221822.png"  alt></p>
<p>上面这个示意图更为直观一些。基站位于圆心，把一个大饼分为3份，每份都是一个120度的扇形区域，因此叫做三扇区。</p>
<p>那么，天线是怎样实现电磁波的定向发射呢？</p>
<p>这当然难不倒聪明的设计师。给振子增加反射板，把本该向另外一边的辐射的信号反射回来不就行了么？</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322221901.png"  alt></p>
<p>就这样增加振子让电磁波在水平方向传得更远，再增加反射板控制方向，经过这么两下折腾，定向天线的雏形诞生，电磁波的发射方向变成了下图这样。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322221913.png"  alt></p>
<p>水平方的主瓣向发射地远远地，但垂直方向产生了上旁瓣和下旁瓣，同时由于反射不完全，后面还有个尾巴，称为后瓣。</p>
<p>到了这里，对天线的最重要的指标：“增益”的解释就水到渠成了。</p>
<p>顾名思义，增益就是指天线能把信号增强。按理说天线是不需要电源的，只是把传给它的电磁波发射出去，怎么又会有“增益呢”？</p>
<p>其实，有没有“增益”，关键看跟谁比，怎么比。</p>
<p>如下图所示，相对于理想的点辐射源和半波振子，天线在可以把能量聚集在主瓣方向，能把电磁波发送地更远，相当于在主瓣方向上增强了。也就是说，所谓增益是在某个方向上相对于点辐射源或者半波振子来说的。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322222205.png"  alt></p>
<p>那么，到底怎么衡量天线主波瓣的覆盖范围和增益呢？这就需要再引入一个“波束宽度”的概念。我们把主瓣上中心线两侧电磁波强度衰减到一半时的范围称为波束宽度。</p>
<p>因为强度衰减一半，也就是3dB，所以波束宽度也叫“半功率角”，或者“3dB功率角”。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322222219.png"  alt></p>
<p>常见的天线半功率角以60°居多，也有窄一些的33°天线。半功率角越窄，主瓣方向信号传播地越远，增益就越高。</p>
<p>下来我们把天线的水平方向图和垂直方向图结合起来，就得到了立体图辐射图，看起来直观多了。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322222230.png"  alt></p>
<p>显然，后瓣的存在破坏了定向天线的方向性，是要极力缩小的。前后波瓣之间的能量比值叫做“前后比”，这个值越大越好，是天线的重要指标。</p>
<p>上旁瓣的宝贵的功率白白地发射向了天空，也是不小的浪费，所以在设计定向天线时要尽量把上旁瓣抑制到最小。</p>
<p>另外，主瓣和下旁瓣之间有一些空洞，也称为下部零陷，导致离天线较近的地方信号不好，在设计天线的时候要尽量减少这些空洞，称作“零点填充”。</p>
<h3 id="3-与天线坦诚相见"><a href="#3-与天线坦诚相见" class="headerlink" title="3. 与天线坦诚相见"></a><strong>3. 与天线坦诚相见</strong></h3><p>下面再说天线的另一个重要概念：<strong>极化</strong>。</p>
<p>前面已经提到过，电磁波的传播本质上是电磁场的传播，而电场是有方向的。</p>
<p>如果电场方向垂直于地面，我们称它为垂直极化波。同理，平行于地面，就是水平极化波。</p>
<p>如果电场的方向和地面成45°夹角，我们就其称为±45°极化。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322222243.png"  alt></p>
<p>由于电磁波的特性，决定了水平极化传播的信号在贴近地面时会在大地表面产生极化电流，从而使电场信号迅速衰减，而垂直极化方式则不易产生极化电流，从而避免了能量的大幅衰减，保证了信号的有效传播。</p>
<p>作为优化方案，现在主流的天线都是采用的±45°两种极化方式叠加起来，由两个振子在一个单元内形成两个正交的极化波，被称为双极化。这种实现方式在保证性能的同时，也使得天线的集成度大大提高。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322222253.png"  alt> </p>
<p>这就是天线示意图里面喜欢画上若干个叉叉的原因，这些叉叉既形象地表示了极化方向，也表示了振子的数量。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322222305.png"  alt></p>
<p>有了高增益的定向天线，直接挂在塔上就可以了吗？</p>
<p>显然，挂地低了建筑物遮挡太多，不行；挂高了，空中又没人，白白浪费信号，而且让信号传得太远的话，基站还可以勉强接受，但手机的发射功率太小，发了基站也收不到。</p>
<p>因此，这天线得对着有人的地面上发射信号，覆盖的范围还得控制住。这就需要把天线下倾一个角度，像路灯一样，每根天线各自负责各自区域的覆盖。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322222321.png"  alt></p>
<p>这就引入了天线<strong>下倾角</strong>的概念。</p>
<p>所有天线都在其安装支架上设有带角度刻度的旋钮，通过扭动旋钮来控制支架的机械运动，就可以调节下倾角了。所以，通过这种方式调整下倾角又叫机械下倾。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322222330.png"  alt></p>
<p>但这种方式有两个明显的弊端。</p>
<p>第一就是麻烦。为了做网络优化调整个角度，就需要工程师上站爬塔，实际效果咋样还不好说，实在是不方便，成本高。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322222340.png"  alt></p>
<p>第二就是机械下倾这种调整方式太过简单粗暴，而天线垂直分量和水平分量的幅值是不变的，因此会导致覆盖方向图被强行压扁，产生畸变。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322222349.png"  alt></p>
<p>费了这么大劲，调整前后的覆盖完全变了，很难达到预期的效果，而且还由于后瓣的上翘导致对其他基站的干扰也增加了，因此机械下倾角只能小幅调整。</p>
<p>那么，有没有更好的办法呢？</p>
<p>办法还真有，就是使用电子下倾。电子下倾的原理是通过改变共线阵天线振子的相位，改变垂直分量和水平分量的幅值大小，改变合成分量场强强度，从而使天线的垂直方向图下倾。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322222359.png"  alt></p>
<p>也就是说，电子下倾无需真地让天线倾斜，只需要工程师在电脑前，点点鼠标，用软件调整就可以了。而且，电子下倾也不会引起辐射方向图的畸变。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322222626.png"  alt></p>
<p>电子下倾的简单，方便也不是凭空而来，而是经过了业界的共同努力才实现的。</p>
<p>2001年，几个天线厂家凑在一起，成立了一个叫做AISG ( 天线接口标准组Antenna Interface Standards Group )的组织，想要把电调天线的接口标准化。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322222638.png"  alt></p>
<p>截止目前，已经有了两个版本的协议：AISG 1.0和AISG 2.0。</p>
<p>有了这两个协议，即使天线和基站是由不同厂家的生产的，只要它们都遵从相同的AISG协议，它们之间就能互相传递天线下倾角的控制信息，实现下倾角的远程调整。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200322222649.png"  alt></p>
<p>随着AISG协议的向后演进，不但垂直方向的下倾角可以远程调整，连水平方向的方位角，还有主波瓣的宽度和增益都可以远程调整了。</p>
<p>并且，由于各运营商的无线频段越来越多，加之4G的MIMO等技术对天线端口数量的要求剧增，天线也逐渐由单频双端口向多频多端口演进。</p>
<p>天线的原理看似简单，但对性能精益求精的追求却没有止境。本文到此，也只是定性地描述了基站的基本知识，至于里面更深的奥妙，如何更好地支持向5G的演进，一波波的通信人还在上下而求索。</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>电子</category>
      </categories>
      <tags>
        <tag>电子电路</tag>
      </tags>
  </entry>
  <entry>
    <title>相机成像原理之镜头篇</title>
    <url>/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="问题1：相机是如何成像的？"><a href="#问题1：相机是如何成像的？" class="headerlink" title="问题1：相机是如何成像的？"></a>问题1：相机是如何成像的？</h2><p>我们可以把相机的成像简单的抽象成下图：</p>
<p><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584443161209.png"  alt="凸透镜成像"></p>
<p>由凸透镜成像原理，我们可以知道当物距大于2倍<a href="https://baike.baidu.com/item/%E7%84%A6%E8%B7%9D" target="_blank" rel="noopener">焦距</a>时，则像距在1倍焦距和2倍焦距之间，成倒立、缩小的实像。此时像距小于物距，像比物小，物像异侧。设 f=OB 表示透镜的焦距，m=OC 为像距，n=AO 为物距，有：</p>
<p><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584443172143.png"  alt></p>
<p>一般地，由于物距远大于焦距，即 n>>f，所以 m≈f，此时可以用小孔模型代替透镜成像。</p>
<p>用数学方式表示成像模型：<a href="https://zhuanlan.zhihu.com/p/23090593" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23090593</a></p>
<h2 id="问题2：-对焦和变焦有什么区别？"><a href="#问题2：-对焦和变焦有什么区别？" class="headerlink" title="问题2： 对焦和变焦有什么区别？"></a>问题2： 对焦和变焦有什么区别？</h2><h3 id="对焦"><a href="#对焦" class="headerlink" title="对焦"></a>对焦</h3><p>对焦（聚焦）就是把镜片移动到适合的位置，其要实现清晰成像，则物体应当在两倍焦距之外，像平面在一倍至两倍焦距之间，这样就可以成倒立缩小的图像，这是照相机的原理。简单的来说，就是把成的像准确的落在sensor（camera传感器）上。对焦有两种：自动对焦，手动对焦。</p>
<p><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584496858674.png"  alt></p>
<p>虚线是sensor的位置，当虚线落在像的位置上就是对焦完成。</p>
<p><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584444268181.png"  alt></p>
<p>左图对焦清楚，而右图没有对焦清楚，sensor在像的左边或者右边都会导致右边的效果。</p>
<h3 id="变焦"><a href="#变焦" class="headerlink" title="变焦"></a>变焦</h3><p>变焦有光学变焦和数字变焦。</p>
<p><strong>光学变焦：</strong>就是改变透镜的焦距。由于改变了焦距，根据上面的结论，焦距改变了，视场角也就变了，就可以实现拉近拉远的功能。</p>
<p><strong>数码变焦：</strong>是通过数码相机的处理器，把图片内的每个像素面积增大，从而达到放大的目的，当前变焦过的时图像就会出现失真，因为放大的过程会对图像进程插值。</p>
<p><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584443741713.png"  alt></p>
<p>当焦距越大，成的像也就越大，像距也就越远。</p>
<p>反之，焦距越小，成的像也就越小，像距越小。</p>
<p>同一个物体，成的像越小，sensor的面积一样的情况下，可以看到的东西就越多，视野也就越大，因此焦距越小，视场角也就越大。</p>
<table>
<thead>
<tr>
<th>焦距</th>
<th>像</th>
<th>视场角（视野）</th>
</tr>
</thead>
<tbody><tr>
<td>长</td>
<td>大</td>
<td>小</td>
</tr>
<tr>
<td>短</td>
<td>小</td>
<td>大</td>
</tr>
</tbody></table>
<p>下图是将焦距拉长后，图像放大的效果<br><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584443788740.png"  alt="长焦的放大效果"></p>
<h2 id="问题3：-景深是什么？又和什么有关？"><a href="#问题3：-景深是什么？又和什么有关？" class="headerlink" title="问题3： 景深是什么？又和什么有关？"></a>问题3： 景深是什么？又和什么有关？</h2><p>相机景深：其指的是在某个物距之间，还能够清晰成像的距离，如下图：</p>
<p><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584446216577.png"  alt></p>
<p>如果sensor刚好在像距的位置上，物体的一个点，成的像也就是一个点。如果sensor在像距的前面或者后面，这个点也就成了一个圆，专业术语叫弥散圆。当这个圆大到一定的程度的时候，照片也就糊了。</p>
<p> <img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584446225792.png"  alt></p>
<h3 id="景深三要素"><a href="#景深三要素" class="headerlink" title="景深三要素"></a>景深三要素</h3><h4 id="光圈"><a href="#光圈" class="headerlink" title="光圈"></a>光圈</h4><p>光圈就是用来控制光线透过镜头的一个装置，光圈越大，进光量越多。</p>
<p>光圈值，是镜头的<a href="https://baike.baidu.com/item/%E7%84%A6%E8%B7%9D/1880759" target="_blank" rel="noopener">焦距</a>/镜头通光直径得出的相对值（相对孔径的倒数），光圈值越小，光圈越大。相同光圈值，sensor表面的照度相同。</p>
<p>光圈越大，景深越小。</p>
<p><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584446332231.png"  alt></p>
<p>如图，当光圈减小，虚线位置的弥散圈也在减小。弥散圈越小，成的像就越清晰。原来看不清楚的物体，弥散圈变小了，就能看清了，景深就变大了。</p>
<p>夜间摄影的时候，增大光圈可以提高进光量，提升图像质量，但是大光圈也会导致景深太小，这个时候就需要两者权衡。拍人像的时候，我们又会要求景深小，这样就有背景虚化的效果，这个时候就需要大光圈。</p>
<h4 id="物距"><a href="#物距" class="headerlink" title="物距"></a>物距</h4><p>物体越近，景深越小</p>
<p><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584619471712.png"  alt></p>
<p>物体123是等距的，他们成的像分别是像123，但是像的位置不是等距的。由于sensor聚焦好之后只能在一个位置上，在这个位置上能看到更多的物体，就是景深大。物体1比较远，我们将sensor聚焦在像1上，像2距离像1很近，弥散圈很小，很容易看清楚物体2。相反的，物体3比较近，我们将sensor聚焦在像3上，像2离像3比较远，弥散圈大，不容易看清楚物体2。所以从图中可以很容易的看出，物体越近，景深越小。</p>
<h4 id="焦距"><a href="#焦距" class="headerlink" title="焦距"></a>焦距</h4><p>焦距越长，景深越小。</p>
<p><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584619537675.png"  alt></p>
<p>两个物体1和2，焦距fa < fb。当焦距为fa，成的像分别是1a和2a，当焦距为fb时，成的像分别为1b和2b。当焦距比较小，为fa的时候，可以很明显的看到像1a和像1b距离很近，由于sensor只能固定在一个位置，更容易同时看清两个物体。因此焦距越短，景深越大。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><table>
<thead>
<tr>
<th>景深</th>
<th>大</th>
<th>小</th>
</tr>
</thead>
<tbody><tr>
<td>光圈</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>物距</td>
<td>远</td>
<td>近</td>
</tr>
<tr>
<td>焦距</td>
<td>短</td>
<td>长</td>
</tr>
</tbody></table>
<h2 id="问题4：镜头对图像质量的影响"><a href="#问题4：镜头对图像质量的影响" class="headerlink" title="问题4：镜头对图像质量的影响"></a>问题4：镜头对图像质量的影响</h2><h3 id="（一）暗角"><a href="#（一）暗角" class="headerlink" title="（一）暗角"></a>（一）暗角</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>对着亮度均匀景物，图像画面四角有变暗的现象，叫做“失光”或“暗角”。暗角对于任何镜头都不可避免，这是由于镜头对于光学折射不均匀。</p>
<p><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584446795831.png"  alt="chrom/color shading 原因"></p>
<h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><p>a. luma shading</p>
<p>由于Lens的光学特性，Sensor影像区的边缘区域接收的光强比中心小，所造成的中心和四角亮度不一致的现象。</p>
<p>b. chrom/color shading：<br> 由于各种颜色的波长不同，经过了透镜的折射，折射的角度也不一样，因此会造成color shading的现象<br><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584634628389.png"  alt="暗角现象"></p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol>
<li><p>sensor和镜头的 <a href="https://blog.csdn.net/weixin_39839293/article/details/82118991" target="_blank" rel="noopener">CRA</a>需要匹配</p>
</li>
<li><p>镜头阴影校正（Lens Shading Correction）</p>
</li>
</ol>
<p>lens shading的校正是分别对于bayer的四个通道进行校正，每个通道的校正过程是相对独立的过程。</p>
<p><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584446824830.png"  alt="暗角矫正"></p>
<h3 id="（二）炫光"><a href="#（二）炫光" class="headerlink" title="（二）炫光"></a>（二）炫光</h3><h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><p>入射光线进入摄像头模组后多次反射造成的</p>
<p>有兴趣的可以看一下：<a href="https://wenku.baidu.com/view/8e119588fab069dc502201f4.html?from=search" target="_blank" rel="noopener">https://wenku.baidu.com/view/8e119588fab069dc502201f4.html?from=search</a></p>
<p><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584496549851.png"  alt></p>
<h4 id="炫光现象"><a href="#炫光现象" class="headerlink" title="炫光现象"></a>炫光现象</h4><p><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584446906977.png"  alt="眩光现象"></p>
<h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>1.加镜头罩</p>
<p>2.镀AR增透膜，减少反射</p>
<p>3.使用蓝玻璃IR滤光片，减少IR-cut的反射</p>
<p><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584446961985.png"  alt="使用蓝玻璃IR-CUT示意图"></p>
<h3 id="（三）畸变"><a href="#（三）畸变" class="headerlink" title="（三）畸变"></a>（三）畸变</h3><h4 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h4><p>镜头畸变是由远离光圈的镜片的球面像差造成的。</p>
<h4 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h4><p><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584446999722.png"  alt="畸变现象"></p>
<p>理想的针孔成像模型确定的坐标变换关系均为线性的，而实际上，现实中使用的相机由于镜头中镜片因为光线的通过产生的不规则的折射，镜头畸变（lens distortion）总是存在的，即根据理想针孔成像模型计算出来的像点坐标与实际坐标存在偏差。畸变导致的成像失真可分为径向失真和切向失真两类。</p>
<h4 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h4><p>这里只介绍算法上的畸变校正，通过标定，建立一个实际位置和理想位置的映射关系，具体的可以看另一篇文章《镜头畸变那些事儿》</p>
<p><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584446992626.png"  alt></p>
<h3 id="（四）清晰度不均匀"><a href="#（四）清晰度不均匀" class="headerlink" title="（四）清晰度不均匀"></a>（四）清晰度不均匀</h3><h4 id="现象-2"><a href="#现象-2" class="headerlink" title="现象"></a>现象</h4><p>不同的镜头清晰度会有区别，用同一个镜头，中心和边缘的画面清晰度也会有区别，下图是一幅图像的MTF曲线</p>
<p><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584447041683.png"  alt="MTF曲线"></p>
<p><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584447165526.png"  alt="镜头的清晰度说明书"></p>
<h4 id="解决方法-3"><a href="#解决方法-3" class="headerlink" title="解决方法"></a>解决方法</h4><p>高通660平台会根据离中心的距离,对同一幅画面中的不同区域去设置不同的降噪和锐化参数</p>
<h3 id="（五）色像差"><a href="#（五）色像差" class="headerlink" title="（五）色像差"></a>（五）色像差</h3><h4 id="原因-3"><a href="#原因-3" class="headerlink" title="原因"></a>原因</h4><p>光学玻璃的折射率随通过的光波的波长变化而变，它对短波长的光的折射率比长波长的折射率更大。这种起因于不同波长的像差，我们称它为色像差(Chromatic aberration)。</p>
<p> <img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584447241923.png"  alt="色像差的原因"></p>
<h4 id="现象-3"><a href="#现象-3" class="headerlink" title="现象"></a>现象</h4><p><img src="/" class="lazyload" data-src="/2019/12/17/%E5%8E%9F%E5%88%9B-%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B9%8B%E9%95%9C%E5%A4%B4%E7%AF%87/1584447202840.png"  alt="色像差的现象"></p>
<p>具体体现在图像上，就是物体边缘原本是单纯白色，因为色差而变成RGB三原色不能重叠在同一线。最为常见的就是紫边（Purple Fringe）</p>
<h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p>Color Aliasing Correction(CAC)检测图像中视觉伪像,对伪像颜色进行补偿</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>ISP</tag>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title>AI超微光简介</title>
    <url>/2019/11/27/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-AI%E8%B6%85%E5%BE%AE%E5%85%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="任何一个函数都可以被一个两层的神经网络近似-–李宏毅"><a href="#任何一个函数都可以被一个两层的神经网络近似-–李宏毅" class="headerlink" title="任何一个函数都可以被一个两层的神经网络近似 –李宏毅"></a>任何一个函数都可以被一个两层的神经网络近似 –李宏毅</h2><p>这是神经网络的基础，可以去逼近真实的函数，不过也终究不会超过真实的函数<br><a href="http://neuralnetworksanddeeplearning.com/chap4.html" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap4.html</a></p>
<h2 id="低照增强算法主要流程"><a href="#低照增强算法主要流程" class="headerlink" title="低照增强算法主要流程"></a>低照增强算法主要流程</h2><p><img src="/" class="lazyload" data-src="/2019/11/27/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-AI%E8%B6%85%E5%BE%AE%E5%85%89/AL%E8%B6%85%E5%BE%AE%E5%85%89%E6%B5%81%E7%A8%8B.png"  alt="AI超微光实现流程"></p>
<p>最初的输入是曝光为10ms的raw图，最后的输出是曝光是1s的RGB图像，中间相差100倍的增益，因此中间会先给raw图一个100倍的增益</p>
<p><strong>疑问</strong>：这样固定增益不会过曝么？</p>
<p>回答：因此后来这个增益是自适应的，raw图算出一个平均亮度，再从isp取一个目标亮度，算出一个倍数作为增益</p>
<p><strong>疑问</strong>：如果去掉黑电平和增益会怎么样？ </p>
<p>回答：如果包含了太多的操作，可能会导致函数不收敛，难训练</p>
<p><strong>疑问</strong>：为什么深度学习不直接RAW to RAW，对RAW进行滤波和增强处理，再由ISP进行处理？</p>
<p>回答：ISP后续的gamma，降噪等模块可能会引入很多的噪声，和抹去很多的细节</p>
<h2 id="网络架构的设计"><a href="#网络架构的设计" class="headerlink" title="网络架构的设计"></a>网络架构的设计</h2><p><img src="/" class="lazyload" data-src="/2019/11/27/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-AI%E8%B6%85%E5%BE%AE%E5%85%89/1584540035684.png"  alt></p>
<p>encoder是不断降采样的过程，减少运算，decoder是不断升采样的过程</p>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p><img src="/" class="lazyload" data-src="/2019/11/27/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-AI%E8%B6%85%E5%BE%AE%E5%85%89/1584540832671.png"  alt></p>
<p>就实验而言，L1>L2, L1就是一次方，求绝对值。L2就是平方差。L1可以防止不拟合，或者找的只是局部最优解</p>
<p>带来的问题，L1损失基于全图的平均，导致图像模糊，细节丢失。这个损失函数也就决定了这个模型训练出来的就类似一个低通滤波器</p>
<p><strong>疑问</strong>：为什么不可以直接用统计值去训练，而不是直接用像素一一对应  </p>
<p>回答：如果只需要统计值，那可以说是非监督训练，一般来说，非监督训练99.9%不如监督训练，能用监督训练，就尽量用监督训练 </p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>一维卡尔曼滤波</title>
    <url>/2019/11/27/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E4%B8%80%E7%BB%B4%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">I = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> xk_1 == <span class="number">0</span> </span><br><span class="line">    xk_1 = x;</span><br><span class="line">    xk = x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    zk = H*x;                   <span class="comment">% 观测量方程</span></span><br><span class="line">    <span class="comment">% 预测</span></span><br><span class="line">    X = A*xk_1;                 <span class="comment">% 状态预测             </span></span><br><span class="line">    P = A*Pk_1*A' + Q;          <span class="comment">% 误差协方差预测 	P = Pk-1 +Q</span></span><br><span class="line">    <span class="comment">% 更新(校正)</span></span><br><span class="line">    K = P*H'*inv(H*P*H'+R);     <span class="comment">% 卡尔曼增益更新	K = P * inv(P + R)</span></span><br><span class="line">    xk = X + K*(zk - H*X);      <span class="comment">% 更新校正	</span></span><br><span class="line">    xk_1 = xk;                  <span class="comment">% 保存校正后的值，下一次滤波使用	</span></span><br><span class="line">    Pk = (I - K*H)*P;           <span class="comment">% 更新误差协方差	Pk = (1 - K *H)*p</span></span><br><span class="line">    Pk_1 = Pk;                  <span class="comment">% 保存校正后的误差协方差，下一次滤波使用</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>以下是我的卡尔曼滤波代码</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kalman_filter</span><span class="params">(self,input_array,Q=<span class="number">0.0001</span>,R=<span class="number">0.005</span>)</span>:</span></span><br><span class="line">        <span class="comment"># r 测量噪声， Q预测噪声</span></span><br><span class="line">        out_array = []</span><br><span class="line">        xk = <span class="number">0</span></span><br><span class="line">        pk2_k = R*R</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(input_array)):</span><br><span class="line">            <span class="keyword">if</span>(i >= <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># zk = input_array[i]	k = xk + 0.005*(input_array[i]-xk)</span></span><br><span class="line">                zk = input_array[i]</span><br><span class="line">                pk2_k_1 = pk2_k + Q*Q	</span><br><span class="line">                kk = math.sqrt(pk2_k_1/(pk2_k_1 + R*R))</span><br><span class="line">                xk = xk + kk*(zk - xk)</span><br><span class="line">                pk2_k = (<span class="number">1</span>-kk)*pk2_k_1</span><br><span class="line">                out_array.append(xk)n </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                out_array.append(input_array[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> out_array</span><br></pre></td></tr></tbody></table></figure>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>经过实验对比，用注释的一句代码替换代码的9-14行并没什么区别。注释的那句话用的是互补滤波的方法写的。</p>
<p>卡尔曼滤波和互补滤波相比，主要特点是增益Kg可以变动的，会根据方差等计算出一个最优的增益。<br>不过这个公式里面的Kg跟输入一点关系都没有，只和Q和R有关，算来算去，就是这个增益按照一定的规则变化而已。<br>那为什么会有低通滤波的效果呢，因为你的Q值很小，这就导致了这个增益很小，更加信任上一次的值。 </p>
<p>其实说到底这段程序就是上一次的值加上这次测量值的乘以一个很小的系数，而上一次的值又是之前的值累加起来的。<br>如果这个系数（增益）保持固定，就是普通的一阶低通滤波。</p>
<p>一维的卡尔曼滤波退化成了一个普通的低通滤波。</p>
<p>而这个增益的话，我觉得可以用自己的逻辑去控制，不需要用卡尔曼滤波这种看似复杂的算法。</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习简介</title>
    <url>/2019/11/26/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>以从零DIY MNIST分类作为例子，来解释一下深度学习的原理</p>
<p><img src="/" class="lazyload" data-src="/2019/11/26/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/1584538518218.png"  alt></p>
<h2 id="（一）损失函数"><a href="#（一）损失函数" class="headerlink" title="（一）损失函数"></a>（一）损失函数</h2><p>就是计算模型出来的函数与实际值之间的差距</p>
<p><img src="/" class="lazyload" data-src="/2019/11/26/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/1584538775923.png"  alt></p>
<h2 id="（二）过拟合和欠拟合"><a href="#（二）过拟合和欠拟合" class="headerlink" title="（二）过拟合和欠拟合"></a>（二）过拟合和欠拟合</h2><ol>
<li>第一个图是欠拟合，说明模型太简单了</li>
<li>第三个图是过拟合，模型太复杂了</li>
</ol>
<p><img src="/" class="lazyload" data-src="/2019/11/26/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/1584538805796.png"  alt></p>
<p><img src="/" class="lazyload" data-src="/2019/11/26/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/1584538822068.png"  alt></p>
<h2 id="（三）神经网络"><a href="#（三）神经网络" class="headerlink" title="（三）神经网络"></a>（三）神经网络</h2><p>如果不存在线性解，就需要将这个模型变得更加复杂。w是线性变换，g是非线性变换，wg(w1g1x)就组成了简单的神经网络</p>
<p><img src="/" class="lazyload" data-src="/2019/11/26/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/1584538842934.png"  alt></p>
<p><img src="/" class="lazyload" data-src="/2019/11/26/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/1584538855608.png"  alt></p>
<h2 id="（四）神经网络的基本单元"><a href="#（四）神经网络的基本单元" class="headerlink" title="（四）神经网络的基本单元"></a>（四）神经网络的基本单元</h2><p>层数的多少不一定代表好坏，层数少了有利于计算</p>
<h3 id="1-全连接层"><a href="#1-全连接层" class="headerlink" title="1. 全连接层"></a>1. 全连接层</h3><p>就是上面的w</p>
<p><img src="/" class="lazyload" data-src="/2019/11/26/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/1584539135418.png"  alt></p>
<h3 id="2-卷积层"><a href="#2-卷积层" class="headerlink" title="2. 卷积层"></a>2. 卷积层</h3><p>就是滤波器 ，和传统的滤波器不一样的地方是，这个值是学习出来的，不是预设的</p>
<p>卷积层没必要规定输入的大小，但是全连接层需要规定输入的大小，参考图像卷积</p>
<p><img src="/" class="lazyload" data-src="/2019/11/26/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/1584539149546.png"  alt></p>
<p><img src="/" class="lazyload" data-src="/2019/11/26/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/1584539161436.png"  alt></p>
<h3 id="3-pooling层"><a href="#3-pooling层" class="headerlink" title="3. pooling层"></a>3. pooling层</h3><p>为了降采样 -> 可以减少计算，提取边缘</p>
<p><img src="/" class="lazyload" data-src="/2019/11/26/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/1584539085149.png"  alt></p>
<h3 id="4-dropout层"><a href="#4-dropout层" class="headerlink" title="4. dropout层"></a>4. dropout层</h3><p>为了减少过拟合</p>
<p><img src="/" class="lazyload" data-src="/2019/11/26/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/1584539189846.png"  alt></p>
<h3 id="5-batch-normalization归一化"><a href="#5-batch-normalization归一化" class="headerlink" title="5. batch normalization归一化"></a>5. batch normalization归一化</h3><p><img src="/" class="lazyload" data-src="/2019/11/26/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/1584539217241.png"  alt></p>
<h2 id="（五）常用的激活函数"><a href="#（五）常用的激活函数" class="headerlink" title="（五）常用的激活函数"></a>（五）常用的激活函数</h2><p><img src="/" class="lazyload" data-src="/2019/11/26/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/1584539242812.png"  alt></p>
<h2 id="（六）网络模型优化"><a href="#（六）网络模型优化" class="headerlink" title="（六）网络模型优化"></a>（六）网络模型优化</h2><p>梯度 （偏导数，利用反向传播求解）-> 更新参数 </p>
<h2 id="（七）问题"><a href="#（七）问题" class="headerlink" title="（七）问题"></a>（七）问题</h2><p>门禁设备从一万张照片中训练识别出一千个人，那如果加一个人，是否这个模型就需要重新训练呢？</p>
<p>答案：当然不是，他这个训练其实训练出来的是一个人脸的特征，一张人脸的特征有很多个。如果说识别到的人脸和数据库里面的某张人脸特征十分类似，就可以说明这是同一个人</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：帧率切换遇到的问题</title>
    <url>/2019/10/23/%E5%B7%A5%E4%BD%9C-BUG-BUG-%E5%B8%A7%E7%8E%87%E5%88%87%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>切换夜模式后，切换采集帧率，图像会出现斑点<br><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200330111659.png"  alt="切换夜模式后，切换采集帧率，图像会出现斑点"></p>
<h3 id="排查方法"><a href="#排查方法" class="headerlink" title="排查方法"></a>排查方法</h3><p>RAW图正常，YUV不正常。</p>
<h3 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h3><p>夜模式会有两个动作，一个是硬件操作（打开红外，关闭IRCUT），一个是软件的黑白效果。</p>
<p>经过实测，主要问题在黑白效果这里，当开启黑白效果后，切换采集帧率，图像会出现斑点。</p>
<p>向高通提交了case，待解决。</p>
<p>在设置帧率时候强制切换到日模式，设置完再切换到夜模式，这种方法不可行。可以成功切到日模式，但是夜模式不能生效。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>开启夜模式或者自动模式的同时会设置帧率为30帧，并保存日模式时的帧率。<br>开启日模式的同时会设置存储的帧率，如果没有存储帧率，就不进行设置。<br>在切换帧率的时候，如果判断是在夜模式，就不进行切换。</p>
<h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><h3 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h3><p>出图出不了</p>
<h3 id="排查方法-1"><a href="#排查方法-1" class="headerlink" title="排查方法"></a>排查方法</h3><ol>
<li>骁龙相机可以出图，而执法仪APP不能出图，可以缩小问题范围到媒控或者isp组件。</li>
<li>ispversion没有打印，代表ispctrl没有初始化。也没有startpreview，说明媒控没有开启采集。</li>
<li>媒控设置分辨率和帧率的时候，会获取camera的能力集，帧率需要大于15帧，支持的分辨率需要大于等于设置的分辨率，<br>否则就不会加载ispctrl，也不会开启采集。preview支持的分辨率最大只有320*240</li>
</ol>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>Android8.0的代码对上报的preview尺寸做了限制，最大为屏幕尺寸</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>去除相关逻辑</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>摸清楚帧率的整个初始化设置流程。最一开始，camera初始化会有一个初始帧率，然后媒控初始化，会再次设置一个帧率。然后ISP组件初始化的时候，会根据抗闪烁模式和编码帧率设置一个采集帧率。</li>
<li>高通设备不要在黑白模式下切换采集帧率，图像会出现异常！</li>
<li>Android8.0之后的代码对preview的原始支持的分辨率有限制，最大为屏幕尺寸</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>帧率</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：fd泄露总结</title>
    <url>/2019/10/14/%E5%B7%A5%E4%BD%9C-BUG-BUG-fd%E6%B3%84%E9%9C%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>web登陆不了，cameraserver的fd泄露</p>
<h2 id="排查方法"><a href="#排查方法" class="headerlink" title="排查方法"></a>排查方法</h2><p>fd泄露的排查方法：<br>查看cameraserver进程的PID：<code>ps -ef|grep cameraserver</code><br>查看这个进程打开的fd数量，804是进程的PID：<code>cd proc/804/fd | ls |wc -l</code><br>最大的数量是1024，接近这个数量就是fd泄露了，正常来说应该一百多<br>可以查看一下打开的fd路径：<code>lsof -p 804</code></p>
<h2 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h2><p>查看一下哪些fd重复打开没有关闭</p>
<ol>
<li><p>如果是CAM_KSocketServer0，是ISP的socket通信没有释放fd</p>
<ul>
<li>linux有安全子系统SElinux，会对进程的权限进行控制，没有权限就创建不了文件，直接退出，没有释放fd</li>
<li>摄像头关闭的时候，cameraserver服务端没有关闭连接的socket文件</li>
</ul>
</li>
<li><p>如果是sof_freeze_dump.txt，可能是出现了<code>sof timeout</code>和recover的错误</p>
<ul>
<li>timeout一般是帧数据接收超时的错误，是通过相邻两帧的时间戳确定的，如果上层进行了时间同步，也会出现超时错误</li>
<li>recover的操作是在下一帧数据又正常的情况下出现的，把之前的log文件覆盖掉，此时高通的代码删除文件的时候没有先把文件关闭</li>
</ul>
</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li>如果是ISP的socket通信没有释放fd<ol>
<li>没有该目录下的权限<ul>
<li>修改启动文件init.qcom.rc，修改对应目录的对应权限</li>
<li>对没有权限的情况进行处理，服务端和客户端都需要进行处理</li>
<li>向驱动申请在SElinux中增加cameraserver进程的权限</li>
</ul>
</li>
<li>socket服务端关闭的时候，需要关闭连接的文件，用到epoll注意需要关闭所有的连接文件</li>
</ol>
</li>
<li>如果是sof_freeze_dump.txt<ol>
<li>如果是上层时间同步引起的超时错误，只有一帧会出现问题。所以判断超时错误的时候再加一个判断，确定两帧都超时了才算超时错误</li>
<li>在删除sof_freeze_dump.txt文件之前把文件关闭（server_debug.c）</li>
</ol>
</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>用到文件fd的地方一定要检查程序的各个结束的情况，有打开就必须要有关闭。</li>
<li>文件的打开关闭可以在构造和析构函数中进行，更加不容易忘记。</li>
<li>创建和打开文件、property的时候，都需要注意是否有权限，更要注意没有权限时的处理。</li>
<li>时间同步的时候，需要注意规避高通原生代码fd泄露的bug</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>hal</tag>
        <tag>fd泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：高温导致帧率异常</title>
    <url>/2019/08/06/%E5%B7%A5%E4%BD%9C-BUG-BUG-%E9%AB%98%E6%B8%A9%E5%AF%BC%E8%87%B4%E5%B8%A7%E7%8E%87%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><ul>
<li>温度过高时户外出现过曝，夏天出现的频率更高</li>
<li>图像高温下出现偏绿的情况</li>
<li>设备崩溃，崩溃在thermal</li>
<li>界面上调节自动快门的下限图像上不生效</li>
</ul>
<h2 id="排查方式"><a href="#排查方式" class="headerlink" title="排查方式"></a>排查方式</h2><ol>
<li>增加thermal level的打印，可以在QCamera2HWI.cpp中的updateThermalLevel中增加thermal_level的打印</li>
<li>打开sensor，stats模块的打印，<code>logcat|grep  fps</code>，查看是否有帧率有异常，比如说负数</li>
<li>此时如果打开骁龙相机，会出现异常而打不开</li>
</ol>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>温控策略中的bug</p>
<p>QCamera2HWI.cpp中的updateThermalLevel是对不同温度等级实现帧率控制，温度比较高，实行降帧策略。</p>
<p>其中的<code>calcThermalLevel</code>是根据温度等级计算目标的帧率。当在<code>QCAMERA_THERMAL_SHUTDOWN</code>模式下，却没有对目标帧率进行赋值，<code>adjustPreviewFpsRange</code>函数就将没有赋初值的帧率设置下去了，导致异常。</p>
<p>这个异常的设置不会影响到sensor的采集帧率，也不会影响到hal层每帧回调的输出帧率，但是会影响到stats模块，导致最大曝光行等参数错误，随后写入sensor的曝光时间出错，最终导致图像或者设备异常。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>去除温度对帧率的控制代码</li>
</ul>
<ol>
<li>注释掉updateThermalLevel函数中的内容</li>
<li>注释掉setPreviewFpsRange函数中<code>QCAMERA_THERMAL_ADJUST_FPS</code>模式下对帧率的控制</li>
</ol>
<ul>
<li>联系驱动提高ISP温度上限</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>BUG</tag>
        <tag>高通camera</tag>
      </tags>
  </entry>
  <entry>
    <title>高通预览流实现60帧</title>
    <url>/2019/07/25/%E5%B7%A5%E4%BD%9C-%E7%BC%96%E7%A8%8B-%E9%AB%98%E9%80%9A%E9%A2%84%E8%A7%88%E6%B5%81%E5%AE%9E%E7%8E%B060%E5%B8%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>首先需要实现高通平台采集帧率的切换，参考前一篇文章</p>
</blockquote>
<p>我们拍照和录像的数据流一直都是使用的预览流，由媒控去编码，实现拍照和录像的功能。高通的高帧率HFR模式需要在video流下实现，这就意味着我们的很多代码都失效了，加上初步配置video流出现异常的问题，最后还是决定在preview数据流上实现60帧采集</p>
<ol>
<li><p>首先我们需要工作在普通的预览模式，sensor配置文件中out_info的mode需要是SENSOR_DEFAULT_MODE，而非是SENSOR_HFR_MODE</p>
</li>
<li><p>相比于配置30帧，注意一下60帧需要的寄存器配置更多，主要是<code>global timing</code>。我们需要根据sensor手册修改60帧对应的寄存器列表<code>RES_1080P60_REG_ARRAY</code>，如下图：</p>
<p><img src="/" class="lazyload" data-src="/2019/07/25/%E5%B7%A5%E4%BD%9C-%E7%BC%96%E7%A8%8B-%E9%AB%98%E9%80%9A%E9%A2%84%E8%A7%88%E6%B5%81%E5%AE%9E%E7%8E%B060%E5%B8%A7/1584288030980.png"  alt></p>
</li>
<li><p>preview默认限制在最高30帧，我们修改到60帧</p>
</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mct_pipeline.c mct_pipeline_fill_dimensions_snapshot() #ifdef IPC_60FPS_SUPPORT   property_get("persist.camera.max.previewfps", fps_str, "60"); #else   property_get("persist.camera.max.previewfps", fps_str, "30"); #endif</span></span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li>注意在xml里面增加50帧和60帧的chromatix文件配置</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>帧率</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 入门</title>
    <url>/2019/07/20/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-web-docker%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="（一）简介"><a href="#（一）简介" class="headerlink" title="（一）简介"></a>（一）简介</h2><p>Docker 是一个开源的应用容器引擎,可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。<br>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<h3 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h3><p>• Web 应用的自动化打包和发布。<br>• 自动化测试和持续集成、发布。<br>• 在服务型环境中部署和调整数据库或其他的后台应用。<br>• 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</p>
<h3 id="Docker-的优点"><a href="#Docker-的优点" class="headerlink" title="Docker 的优点"></a>Docker 的优点</h3><p>• 1、简化程序：<br>    Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成。<br>• 2、避免选择恐惧症：<br>    如果你有选择恐惧症，还是资深患者。那么你可以使用 Docker 打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。<br>• 3、节省开支：<br>    一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。</p>
<p>我的理解是可以将依赖程序等打包好，就像一个镜像一下，下载下来可以直接用，省了一大堆的安装步骤</p>
<h3 id="介绍与优点"><a href="#介绍与优点" class="headerlink" title="介绍与优点"></a>介绍与优点</h3><p><a href="https://blog.csdn.net/nfzhlk/article/details/78430152" target="_blank" rel="noopener">https://blog.csdn.net/nfzhlk/article/details/78430152</a><br>可以在windows上使用</p>
<h2 id="（二）安装"><a href="#（二）安装" class="headerlink" title="（二）安装"></a>（二）安装</h2><p>从官网下载比较慢：<br>在这个DaoCloud网站可以快速下载<br><a href="https://www.jianshu.com/p/b21c508514ae" target="_blank" rel="noopener">https://www.jianshu.com/p/b21c508514ae</a><br><a href="https://www.cnblogs.com/mq0036/p/8512703.html" target="_blank" rel="noopener">https://www.cnblogs.com/mq0036/p/8512703.html</a></p>
<h3 id="加速"><a href="#加速" class="headerlink" title="加速"></a>加速</h3><p>Docker For Windows<br>在桌面右下角状态栏中右键 docker 图标，修改在 Docker Daemon 标签页中的 json ，把下面的地址:<br><a href="http://f1361db2.m.daocloud.io" target="_blank" rel="noopener">http://f1361db2.m.daocloud.io</a><br>加到” registry-mirrors”的数组里。点击 Apply 。</p>
<h3 id="pull报错"><a href="#pull报错" class="headerlink" title="pull报错"></a>pull报错</h3><p>在docker pull 镜像时一直报错：<br>Error response from daemon: Get <a href="https://registry-1.docker.io/v2/" target="_blank" rel="noopener">https://registry-1.docker.io/v2/</a>: dial tcp: lookup registry-1.docker.io on 10.0.2.3:53: server misbehaving<br>一开始以为服务器挂了，后来觉得不太可能，就网上搜了下，原来是dns服务器的错误，把服务器改成8.8.8.8或者114.114.114.114即可<br>linux下安装不了也可能是DNS错误</p>
<h3 id="官网docker安装"><a href="#官网docker安装" class="headerlink" title="官网docker安装"></a>官网docker安装</h3><pre><code>1. 建立
Docker镜像是一个私有文件系统，仅适用于您的容器。它提供了容器所需的所有文件和代码。运行docker build命令可以使用Dockerfile创建Docker镜像。此构建的映像位于计算机的本地Docker映像注册表中。

cd doodle\cheers2019 ; docker build -t qinxing/cheers2019 .

2. run
docker run -it --rm qinxing/cheers2019
3. 分享
docker login ; docker push qinxing/cheers2019</code></pre><h2 id="（三）常用命令："><a href="#（三）常用命令：" class="headerlink" title="（三）常用命令："></a>（三）常用命令：</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker run ubuntu:15.10 /bin/echo "Hello world"</span><br><span class="line">docker run -i -t ubuntu:15.10 /bin/bash</span><br></pre></td></tr></tbody></table></figure>
<p>• -t:在新容器内指定一个伪终端或终端。<br>• -i:允许你对容器内的标准输入 (STDIN) 进行交互<br>• ubuntu:15.10指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。<br>• /bin/echo “Hello world”: 在启动的容器里执行的命令</p>
<ol>
<li>查看运行的容器：<code>docker ps</code></li>
<li>查看容器标准输出 ：<code>docker logs</code></li>
<li>载入镜像: <code>docker pull name</code></li>
<li><code>docker run -d -P training/webapp python app.py</code><ul>
<li>-d:让容器在后台运行。</li>
<li>-P:将容器内部使用的网络端口映射到我们使用的主机上。</li>
<li>-p : 是容器内部端口绑定到指定的主机端口。<br>可以通过 -p 参数来设置不一样的端口，前面的是主机端口，后者是docker端口<br><code>docker run -d -p 5000:5000 training/webapp python app.py</code></li>
</ul>
</li>
<li>查看docker底层信息： <code>docker inspect</code></li>
</ol>
<h2 id="（四）使用docker现成的xwiki模板来部署"><a href="#（四）使用docker现成的xwiki模板来部署" class="headerlink" title="（四）使用docker现成的xwiki模板来部署"></a>（四）使用docker现成的xwiki模板来部署</h2><h3 id="安装教程："><a href="#安装教程：" class="headerlink" title="安装教程："></a>安装教程：</h3><ol>
<li><a href="https://github.com/xwiki-contrib/docker-xwiki/blob/master/README.md#docker-run-example" target="_blank" rel="noopener">https://github.com/xwiki-contrib/docker-xwiki/blob/master/README.md#docker-run-example</a></li>
<li><a href="http://help.websoft9.com/lms-guide/xwiki/install.html" target="_blank" rel="noopener">http://help.websoft9.com/lms-guide/xwiki/install.html</a></li>
</ol>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>创建网络<br><code>docker network create -d bridge xwiki-nw</code></p>
</li>
<li><p>创建mysql<br><code>docker run --net=xwiki-nw --name mysql-xwiki -v /my/own/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=xwiki -e MYSQL_USER=xwiki -e MYSQL_PASSWORD=xwiki -e MYSQL_DATABASE=xwiki -d mysql:5.7 --character-set-server=utf8 --collation-server=utf8_bin --explicit-defaults-for-timestamp=1</code></p>
</li>
<li><p>创建xwiki<br><code>docker run -d --net=xwiki-nw --name xwiki -p 0.0.0.0:8080:8080 -v /my/own/xwiki:/usr/local/xwiki -e DB_USER=xwiki -e DB_PASSWORD=xwiki -e DB_DATABASE=xwiki -e DB_HOST=mysql-xwiki xwiki:mysql-tomcat</code></p>
</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>外网可以访问需要指定IP：0.0.0.0<br>之前是127.0.0.1，结果外网无法访问，需要改成0.0.0.0。要去搞清楚两者的区别。</li>
</ol>
<h3 id="TIPS-0-0-0-0-127-0-0-1和localhost之间有什么区别？"><a href="#TIPS-0-0-0-0-127-0-0-1和localhost之间有什么区别？" class="headerlink" title="TIPS:0.0.0.0,127.0.0.1和localhost之间有什么区别？"></a>TIPS:0.0.0.0,127.0.0.1和localhost之间有什么区别？</h3><h4 id="127-0-0-1"><a href="#127-0-0-1" class="headerlink" title="127.0.0.1"></a>127.0.0.1</h4><p>是个（特殊的）IP地址，往往被分配给了loopback或仅局域网可以访问的接口本地接口<br>这是一个伪照的，假的，网络适配器，其只能于同主机的主机内通信<br>常用于：让一个可以支持网络的程序，仅仅响应于同主机的主机内的客户端<br>一个程序监听127.0.0.1的话，则只能接受来自于本地的访问</p>
<h4 id="localhost"><a href="#localhost" class="headerlink" title="localhost"></a>localhost</h4><p>往往是127.0.0.1这个IP地址的主机名的主机名</p>
<ul>
<li>Linux的中是在/etc/hosts中设置的</li>
<li>windows中等价于host，往往在％WINDIR％中设置的<ul>
<li>换句话说，你也可以设置为其它名字</li>
<li>ping localhost，则会输出：127.0.0.1</li>
</ul>
</li>
</ul>
<h4 id="0-0-0-0"><a href="#0-0-0-0" class="headerlink" title="0.0.0.0"></a>0.0.0.0</h4><p>本身包含很多方面的含义，但是此处指的是：<br>当一个服务器监听这个IP地址的话，意味着：监听所有的网络请求<br>（对应着IP地址为127.0.0.1的）回送这个适配器适配器的请求，就像其它本机中的其它的网络适配器一样。<br>如果一个服务器有两个IP地址：192.168.1.1和10.1.2.1，则本机中的一个服务监听0.0.0.0的话，则两个IP地址都可以访问该服务</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>高通660平台实现实时切换采集帧率</title>
    <url>/2019/07/16/%E5%B7%A5%E4%BD%9C-%E7%BC%96%E7%A8%8B-%E9%AB%98%E9%80%9A660%E5%B9%B3%E5%8F%B0%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E5%88%87%E6%8D%A2%E9%87%87%E9%9B%86%E5%B8%A7%E7%8E%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="配置及代码改动（ROM"><a href="#配置及代码改动（ROM" class="headerlink" title="配置及代码改动（ROM)"></a>配置及代码改动（ROM)</h2><h3 id="（一）寄存器配置"><a href="#（一）寄存器配置" class="headerlink" title="（一）寄存器配置"></a>（一）寄存器配置</h3><p>按照已经配置好的imx327.lib.h为例，之后新的sensor可以照着配置</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">.out_info_array =</span><br><span class="line">    {</span><br><span class="line">        .out_info =</span><br><span class="line">        {</span><br><span class="line">            #<span class="keyword">if</span> IMX327_INC_RES_1920x1080P25</span><br><span class="line">            {</span><br><span class="line">                .x_output           = <span class="number">1948</span>, <span class="comment">/* 4+8+1920+9+4+3 */</span></span><br><span class="line">                .y_output           = <span class="number">1097</span>, <span class="comment">/* 8+1080+9 */</span></span><br><span class="line">                .line_length_pclk   = <span class="number">5280</span>,</span><br><span class="line">                .frame_length_lines = <span class="number">1125</span>,</span><br><span class="line">                .vt_pixel_clk       = <span class="number">148500000</span>,</span><br><span class="line">                .op_pixel_clk       = <span class="number">237600000</span>,</span><br><span class="line">                .binning_factor     = <span class="number">1</span>,</span><br><span class="line">                .min_fps            = <span class="number">12.5</span>,</span><br><span class="line">                .max_fps            = <span class="number">25.0</span>,</span><br><span class="line">                .mode               = SENSOR_DEFAULT_MODE,</span><br><span class="line">                .offset_x           = <span class="number">0</span>,</span><br><span class="line">                .offset_y           = <span class="number">0</span>,</span><br><span class="line">                .scale_factor       = <span class="number">0</span>,</span><br><span class="line">            },</span><br><span class="line">           #endif</span><br><span class="line">            #<span class="keyword">if</span> IMX327_INC_RES_1920x1080P30</span><br><span class="line">            {</span><br><span class="line">                .x_output           = <span class="number">1948</span>, <span class="comment">/* 4+8+1920+9+4+3 */</span></span><br><span class="line">                .y_output           = <span class="number">1097</span>, <span class="comment">/* 8+1080+9 */</span></span><br><span class="line">                .line_length_pclk   = <span class="number">4400</span>,</span><br><span class="line">                .frame_length_lines = <span class="number">1125</span>,</span><br><span class="line">                .vt_pixel_clk       = <span class="number">148500000</span>,<span class="comment">//74250000,</span></span><br><span class="line">                .op_pixel_clk       = <span class="number">237600000</span>,<span class="comment">//74250000, //DDR 92.8125,4 lane,10bit</span></span><br><span class="line">                .binning_factor     = <span class="number">1</span>,</span><br><span class="line">                .min_fps            = <span class="number">15.0</span>,</span><br><span class="line">                .max_fps            = <span class="number">30.0</span>,</span><br><span class="line">                .mode               = SENSOR_DEFAULT_MODE,</span><br><span class="line">                .offset_x           = <span class="number">0</span>,</span><br><span class="line">                .offset_y           = <span class="number">0</span>,</span><br><span class="line">                .scale_factor       = <span class="number">0</span>,</span><br><span class="line">            },</span><br><span class="line">           #endif</span><br><span class="line">           ...</span><br><span class="line">        },</span><br><span class="line">        .<span class="built_in">size</span> = <span class="number">0</span></span><br><span class="line">        #<span class="keyword">if</span> IMX327_INC_RES_1920x1080P25</span><br><span class="line">         +<span class="number">1</span></span><br><span class="line">        #endif</span><br><span class="line">        #<span class="keyword">if</span> IMX327_INC_RES_1920x1080P30</span><br><span class="line">         +<span class="number">1</span></span><br><span class="line">        #endif</span><br><span class="line">         ...</span><br><span class="line">        ,</span><br><span class="line">    },</span><br></pre></td></tr></tbody></table></figure>

<h3 id="（二）寄存器选择"><a href="#（二）寄存器选择" class="headerlink" title="（二）寄存器选择"></a>（二）寄存器选择</h3><p>由于原生高通代码没有切换sensor采集帧率的功能，我们只是在此基础上修改。<br>out_info_array是每组寄存器配置的属性。sensor_pick_res.c文件中sensor_pick_resolution则是根据上层设置的帧率分辨率等去选择最适合的一组寄存器值。<br>但是由于这个原先是用来设置分辨率的，相同分辨率的情况下它永远会选择第一套配置，这就导致我们不能根据帧率切换寄存器。因此注释掉下面的函数。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_FPS_SWITCH</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">sensor_pick_check_aspect_ratio</span><span class="params">(<span class="keyword">sensor_pick_data_t</span> *pick_data)</span></span></span><br><span class="line"><span class="function"> </span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> IPC_FPS_SWITCH</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  ......</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="（三）xml配置"><a href="#（三）xml配置" class="headerlink" title="（三）xml配置"></a>（三）xml配置</h3><p>每组分辨率以及帧率都有对应的chromatix头文件，如果没有进行配置，会出现没有图像或者崩溃的情况。需要注意！</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag"><<span class="name">ChromatixName</span> <span class="attr">sensor_resolution_index</span>=<span class="string">"0"</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">ISPPreview</span>></span>imx327_preview<span class="tag"></<span class="name">ISPPreview</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">ISPSnapshot</span>></span>imx327_preview<span class="tag"></<span class="name">ISPSnapshot</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">ISPVideo</span>></span>imx327_preview<span class="tag"></<span class="name">ISPVideo</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">CPPPreview</span>></span>imx327_cpp_preview<span class="tag"></<span class="name">CPPPreview</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">CPPSnapshot</span>></span>imx327_cpp_preview<span class="tag"></<span class="name">CPPSnapshot</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">CPPVideo</span>></span>imx327_cpp_preview<span class="tag"></<span class="name">CPPVideo</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">CPPLiveshot</span>></span>imx327_cpp_preview<span class="tag"></<span class="name">CPPLiveshot</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">A3Preview</span>></span>imx327_default_preview_3a<span class="tag"></<span class="name">A3Preview</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">A3Video</span>></span>imx327_default_preview_3a<span class="tag"></<span class="name">A3Video</span>></span></span><br><span class="line"><span class="tag"></<span class="name">ChromatixName</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">ChromatixName</span> <span class="attr">sensor_resolution_index</span>=<span class="string">"1"</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">ISPPreview</span>></span>imx327_preview<span class="tag"></<span class="name">ISPPreview</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">ISPSnapshot</span>></span>imx327_preview<span class="tag"></<span class="name">ISPSnapshot</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">ISPVideo</span>></span>imx327_preview<span class="tag"></<span class="name">ISPVideo</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">CPPPreview</span>></span>imx327_cpp_preview<span class="tag"></<span class="name">CPPPreview</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">CPPSnapshot</span>></span>imx327_cpp_preview<span class="tag"></<span class="name">CPPSnapshot</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">CPPVideo</span>></span>imx327_cpp_preview<span class="tag"></<span class="name">CPPVideo</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">CPPLiveshot</span>></span>imx327_cpp_preview<span class="tag"></<span class="name">CPPLiveshot</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">A3Preview</span>></span>imx327_default_preview_3a<span class="tag"></<span class="name">A3Preview</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">A3Video</span>></span>imx327_default_preview_3a<span class="tag"></<span class="name">A3Video</span>></span></span><br></pre></td></tr></tbody></table></figure>

<p>有几组寄存器配置，sensor_resolution_index就需要写几组。</p>
<h3 id="（四）能力集配置"><a href="#（四）能力集配置" class="headerlink" title="（四）能力集配置"></a>（四）能力集配置</h3><p>由于媒控设置帧率的时候需要检测设备是否支持这个帧率，这就需要提供该设备的能力集，告诉媒控我们支持哪些帧率。帧率的能力集不仅仅是我们lib.h中配置的那几个帧率，还有高通默认帧率，这就可能出现设备并不支持这个帧率，能力集中却依旧有的情况。因此我们把默认支持的帧率清空，让这个能力集呈现出来的全部都是我们自己配置的。<br><strong>注意：</strong>部分8953设备不支持，因为老媒控检测到能力集中没有30帧，会停止采集，如果想设置25帧，会出现没有图像的情况。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mct_pipeline.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_FPS_SWITCH</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">cam_fps_range_t</span> default_fps_ranges[] = {</span><br><span class="line">#ifdef IPC_FPS_SWITCH</span><br><span class="line">  {  <span class="number">0.0</span>,  <span class="number">0.0</span>,  <span class="number">0.0</span>,  <span class="number">0.0</span>},</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">   { <span class="number">15.0</span>, <span class="number">15.0</span>, <span class="number">15.0</span>, <span class="number">15.0</span>},</span><br><span class="line">   { <span class="number">20.0</span>, <span class="number">20.0</span>, <span class="number">20.0</span>, <span class="number">20.0</span>},</span><br><span class="line">   { <span class="number">24.0</span>, <span class="number">24.0</span>, <span class="number">24.0</span>, <span class="number">24.0</span>},</span><br><span class="line">   { <span class="number">30.0</span>, <span class="number">30.0</span>, <span class="number">30.0</span>, <span class="number">30.0</span>},</span><br><span class="line">   { <span class="number">60.0</span>, <span class="number">60.0</span>, <span class="number">60.0</span>, <span class="number">60.0</span>},</span><br><span class="line">#endif</span><br><span class="line"> };</span><br></pre></td></tr></tbody></table></figure>
<h3 id="（五）hal层设置代码修改"><a href="#（五）hal层设置代码修改" class="headerlink" title="（五）hal层设置代码修改"></a>（五）hal层设置代码修改</h3><h4 id="1-帧率设置需要重启"><a href="#1-帧率设置需要重启" class="headerlink" title="1. 帧率设置需要重启"></a>1. 帧率设置需要重启</h4><p>采集帧率只有在camera启动的时候才会去设置。高通设置参数有两种方式，一种是不需要重启，一种是重启才能把参数设置进去。原生的程序没有去修改采集帧率，所以走的是需要重启的方式。</p>
<p>如果想让设置参数之后重启camera，只需要加上一句<code>m_bNeedRestart = true;</code>。</p>
<h4 id="2-删除其他可能对帧率造成影响的代码"><a href="#2-删除其他可能对帧率造成影响的代码" class="headerlink" title="2. 删除其他可能对帧率造成影响的代码"></a>2. 删除其他可能对帧率造成影响的代码</h4><p>防止帧率对，删去温度对帧率的影响代码</p>
<h4 id="3-需要将帧率立刻传到vendor层"><a href="#3-需要将帧率立刻传到vendor层" class="headerlink" title="3. 需要将帧率立刻传到vendor层"></a>3. 需要将帧率立刻传到vendor层</h4><p><strong>注意：</strong>在<code>ADD_SET_PARAM_ENTRY_TO_BATCH</code>之后需要加上<code>rc = commitSetBatch();</code>,让帧率立刻传递到vendor层，否则可能会出现启动之后帧率还没有传下去，用的是上一次的值的BUG。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">QCameraParameters::setPreviewFpsRange</span><span class="params">(<span class="keyword">int</span> min_fps,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> max_fps, <span class="keyword">int</span> vid_min_fps,<span class="keyword">int</span> vid_max_fps)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int32_t</span> rc = NO_ERROR;</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> REMOVE_THERMAL_ADJUST</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> != m_AdjustFPS ) {</span><br><span class="line">        <span class="keyword">if</span> (m_ThermalMode == QCAMERA_THERMAL_ADJUST_FPS &&</span><br><span class="line">                !m_bRecordingHint_new) {</span><br><span class="line">            <span class="keyword">float</span> minVideoFps = min_fps, maxVideoFps = max_fps;</span><br><span class="line">            <span class="keyword">if</span> (isHfrMode()) {</span><br><span class="line">                minVideoFps = m_hfrFpsRange.video_min_fps;</span><br><span class="line">                maxVideoFps = m_hfrFpsRange.video_max_fps;</span><br><span class="line">            }</span><br><span class="line">            m_AdjustFPS->recalcFPSRange(min_fps, max_fps, minVideoFps,</span><br><span class="line">                                         maxVideoFps, fps_range, m_bRecordingHint_new);</span><br><span class="line">            LOGH(<span class="string">"Thermal adjusted Preview fps range %3.2f,%3.2f, %3.2f, %3.2f"</span>,</span><br><span class="line">                   fps_range.min_fps, fps_range.max_fps,</span><br><span class="line">                  fps_range.video_min_fps, fps_range.video_max_fps);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_FPS_RANGE, fps_range)) {</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> IPC_SET_FPS</span></span><br><span class="line">    rc = commitSetBatch();</span><br><span class="line">    <span class="keyword">if</span> (rc != NO_ERROR) {</span><br><span class="line">        LOGE(<span class="string">"Failed to parameter changes"</span>);</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    }</span><br><span class="line">    m_bNeedRestart = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="对外接口（ispctrl部分）"><a href="#对外接口（ispctrl部分）" class="headerlink" title="对外接口（ispctrl部分）"></a>对外接口（ispctrl部分）</h2><h3 id="（一）帧率切换代码逻辑"><a href="#（一）帧率切换代码逻辑" class="headerlink" title="（一）帧率切换代码逻辑"></a>（一）帧率切换代码逻辑</h3><p>高通配置sensor输出帧率只有在sensor启动时设置分辨率的时候进行配置。寄存器手册中也要求设置帧率等寄存器时需要先让sensor进入standby模式。也就是说设置帧率的时候，得重启一下。之前切换帧率是媒控帮忙停流，我们再去设置帧率，会浪费比较多的时间。现在我们可以在hal层设置参数后让sensor重启，减少了需要重新设置的模块，实测切换速度不少。<br>这样帧率可以我们自己控制，我们可以提供给外部接口，这就需要修改ispctrl层的代码。</p>
<h3 id="（二）ispctrl接口修改"><a href="#（二）ispctrl接口修改" class="headerlink" title="（二）ispctrl接口修改"></a>（二）ispctrl接口修改</h3><h4 id="解除帧率与抗闪烁的绑定"><a href="#解除帧率与抗闪烁的绑定" class="headerlink" title="解除帧率与抗闪烁的绑定"></a>解除帧率与抗闪烁的绑定</h4><p>50Hz的抗闪烁要求快门是1/100的整数倍，60Hz的抗闪烁要求快门是1/120的整数倍。帧率是限制了快门的最大值，30帧意味着快门最大1/30，但是同样是可以支持50Hz的抗闪烁。25帧也可以支持60Hz的抗闪烁，这两者并没有必然联系。因此将它们之间的联系去除。<br><strong>注意：</strong>25帧的采集帧率，有利于50Hz供电频率的抗闪烁。即使曝光时间小于10ms，25帧仍然可以让日光灯产生条纹带稳定在图像的同一个位置。如果是30帧，条纹就会不停的跳动，让人难以接受。所以最后还是加上了采集帧率和抗闪烁的绑定，不过优化了代码结构。</p>
<h3 id="（三）平台的适配"><a href="#（三）平台的适配" class="headerlink" title="（三）平台的适配"></a>（三）平台的适配</h3><p>apq8056_one是比较老的设备，更注重稳定性，不会去解除绑定帧率与抗闪烁的关系</p>
<p>平台的识别，取自媒控</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">platform_e <span class="title">GetPlatform</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    FILE *pfile;</span><br><span class="line">    <span class="keyword">char</span> tmp[<span class="number">128</span>], *buf;</span><br><span class="line">    <span class="keyword">static</span> s32 is_first = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> platform_e platform = PLATFORM_UNKNOWN;</span><br><span class="line">    <span class="keyword">if</span> (is_first)</span><br><span class="line">    {</span><br><span class="line">        is_first = <span class="number">0</span>;</span><br><span class="line">        pfile = fopen(<span class="string">"/proc/cpuinfo"</span>, <span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">if</span> (pfile == <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            PRINT(<span class="string">"open %s error\n"</span>, <span class="string">"/proc/cpuinfo"</span>);</span><br><span class="line">            <span class="keyword">return</span> PLATFORM_UNKNOWN;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            buf = fgets(tmp, <span class="keyword">sizeof</span>(tmp), pfile);</span><br><span class="line">            <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                PRINT(<span class="string">"%s fgets error\n"</span>, __func__);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(tmp, <span class="string">"Hardware"</span>, <span class="number">8</span>))</span><br><span class="line">            {</span><br><span class="line">                PRINT(<span class="string">"%s\n"</span>, tmp);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strstr</span>(tmp, <span class="string">"8076"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">                {</span><br><span class="line">                    platform = PLATFORM_QCOM8076;</span><br><span class="line">                    PRINT(<span class="string">"this platfom is qcom 8076\n"</span>);</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strstr</span>(tmp, <span class="string">"8056"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">                {</span><br><span class="line">                    platform = PLATFORM_QCOM8056;</span><br><span class="line">                    PRINT(<span class="string">"this platfom is qcom 8056\n"</span>);</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strstr</span>(tmp, <span class="string">"8094"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">                {</span><br><span class="line">                    platform = PLATFORM_QCOM8094;</span><br><span class="line">                    PRINT(<span class="string">"this platfom is qcom 8094\n"</span>);</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strstr</span>(tmp, <span class="string">"8939"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">                {</span><br><span class="line">                    platform = PLATFORM_QCOM8939;</span><br><span class="line">                    PRINT(<span class="string">"this platfom is qcom 8039\n"</span>);</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strstr</span>(tmp, <span class="string">"SDM660"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">                {</span><br><span class="line">                platform = PLATFORM_SDM660;</span><br><span class="line">                PRINT(<span class="string">"this platfom is SDM660\n"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">       fclose(pfile);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> platform;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="（四）遇到过的问题"><a href="#（四）遇到过的问题" class="headerlink" title="（四）遇到过的问题"></a>（四）遇到过的问题</h3><p>现象：图像偶尔会闪烁</p>
<p>排查结果：采集帧率在25帧和30帧跳动，ispctrl收到业务设置的帧率值也在25和30帧跳动</p>
<p>原因：业务那边做过一个根据网络状况改变帧率的逻辑。很可能是由于网络问题，导致设置的帧率一直在跳动，需要让业务修改或者去掉这个逻辑。</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>帧率</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode使用技巧</title>
    <url>/2019/05/27/%E5%AD%A6%E4%B9%A0-%E5%B7%A5%E5%85%B7-vscode-vscode%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ol>
<li>按住ctrl点击一下函数名，在当前窗口下跳转到定义。<br>按住ctrl点击两下函数名，跳转到定义并打开新窗口。</li>
<li>自定义快捷键：在使用终端情况下，ctrl+左右：切换聚焦的终端</li>
<li>ctrl+M放大或者缩小终端面板，ctrl+shift+M关闭终端面板</li>
<li>安装remote deployment实现远程开发遇到的问题（新版本已解决）：<ol>
<li>ssh连接失败，安装openssh之后，执行quitstart.txt中的命令，</li>
<li>连接失败，会提示realpath找不到，将远程服务器上的脚本server.sh第10行的(dirname”(realpath “0”)”)改成(dirname “$0”)</li>
</ol>
</li>
<li>行尾换行LF/CRLF切换：右下角LF/CRLF可以手动切换</li>
<li>F3/F4是跳转上一个和下一个搜索结果。对一个单词ctrl+d，就不需要ctrl+f，直接在本文中搜索</li>
<li>菜单和侧边栏的字体改不了大小，在设置中搜索zoomLevel，调整整体的放大等级即可</li>
<li>c++ 书写函数注释， /** 自动会出来， 紧接着的是函数名称，下面的是函数变量，变量值前面需要加上@，最后是函数的作用和意义，与上面的定义空出一行</li>
<li>vscode online 可以自己配置服务器，参考<a href="https://www.cnblogs.com/lee-li/p/12041546.html" target="_blank" rel="noopener">博客</a>，也可以使用腾讯的cloud studio(五人以下免费)</li>
</ol>
<h2 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h2><ol>
<li>settings.json:<br>pythonPath: 告诉你用的python.exe的地址</li>
<li>launch.json: 配置运行脚本<br>比如python:<br>program:后面代表运行的文件<br>argv：代表后面运行的参数</li>
<li>ssh配置<br>远程连接ssh服务器时需要加上两句话：<br>PreferredAuthentications publickey<br>PubkeyAuthentication yes</li>
<li>添加未定义的宏<br>在c_cpp_properties.json中的configuration中增加一项<br>“defines”: [<pre><code>    "U2P_CAMERA_FEATURE"
],</code></pre></li>
</ol>
<h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><ol>
<li>Comment Translate: 很多API的注释都是英文的，对于英文不好的同学来说，都是煎熬，这个可以把函数定义等注释翻译成中文，简直是神奇</li>
<li>Remote Development: 远程开发神器！不用把代码下载下来，终端、端口映射、docker和代码管理特别方便</li>
<li>One Dark Pro: 推荐的主题</li>
<li>Prettier: 代码格式化</li>
<li>Markdown All in One: markdown必备插件</li>
<li>Live server: web实时预览</li>
<li>Gitlens: git加强版版本管理</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>工具</category>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>使用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>网站推荐</title>
    <url>/2019/05/20/%E7%94%9F%E6%B4%BB-%E6%8E%A8%E8%8D%90-%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h4 id="搞学习"><a href="#搞学习" class="headerlink" title="搞学习"></a>搞学习</h4><ul>
<li>知乎：<a href="http://www.zhihu.com" target="_blank" rel="noopener">www.zhihu.com</a></li>
<li>iData（论文搜索）：<a href="http://www.cn-ki.net" target="_blank" rel="noopener">www.cn-ki.net</a></li>
<li>鸠摩搜书：<a href="http://www.jiumodiary.com" target="_blank" rel="noopener">www.jiumodiary.com</a></li>
<li>网易公开课：<a href="https://open.163.com/ted/" target="_blank" rel="noopener">https://open.163.com/ted/</a></li>
<li>网易云课堂：<a href="https://study.163.com/" target="_blank" rel="noopener">https://study.163.com/</a></li>
<li>中国大学 MOOC：<a href="http://www.icourse163.org" target="_blank" rel="noopener">www.icourse163.org</a></li>
<li>B站：<a href="http://www.bilibili.com" target="_blank" rel="noopener">www.bilibili.com</a></li>
<li>猫咪论文：<a href="https://lunwen.im/" target="_blank" rel="noopener">https://lunwen.im/</a></li>
<li>码农之家（计算机电子书下载）：<a href="http://www.xz577.com" target="_blank" rel="noopener">www.xz577.com</a></li>
</ul>
<h4 id="小工具"><a href="#小工具" class="headerlink" title="小工具"></a>小工具</h4><ul>
<li>云端超级应用空间（PS，PPT，Excel，Ai）：<a href="https://uzer.me/" target="_blank" rel="noopener">https://uzer.me/</a></li>
<li>在线接口测试（Getman）：<a href="https://getman.cn/" target="_blank" rel="noopener">https://getman.cn/</a></li>
<li>二维码生成：<a href="https://cli.im/" target="_blank" rel="noopener">https://cli.im/</a></li>
<li>熵数（图表制作）：<a href="https://dydata.io/appv2/#/pages/index/home" target="_blank" rel="noopener">https://dydata.io/appv2/#/pages/index/home</a></li>
<li>图片无限变放大：<a href="http://bigjpg.com/zh" target="_blank" rel="noopener">http://bigjpg.com/zh</a></li>
<li>拷贝兔：<a href="https://cp.anyknew.com/" target="_blank" rel="noopener">https://cp.anyknew.com/</a></li>
<li>奶牛快传（在线传输文件利器）：<a href="https://cowtransfer.com/" target="_blank" rel="noopener">https://cowtransfer.com/</a></li>
<li>在线转换器（在线转换器转换任何测量单位）：<a href="https://zh.justcnw.com/" target="_blank" rel="noopener">https://zh.justcnw.com/</a></li>
<li>调查问卷制作：<a href="https://www.wenjuan.com/" target="_blank" rel="noopener">https://www.wenjuan.com/</a></li>
<li>果核剥壳（软件下载）：<a href="https://www.ghpym.com/" target="_blank" rel="noopener">https://www.ghpym.com/</a></li>
</ul>
<h4 id="资源搜索"><a href="#资源搜索" class="headerlink" title="资源搜索"></a>资源搜索</h4><ul>
<li>DogeDoge 搜索引擎：<a href="http://www.dogedoge.com" target="_blank" rel="noopener">www.dogedoge.com</a></li>
<li>秘迹搜索：<a href="https://mijisou.com/" target="_blank" rel="noopener">https://mijisou.com/</a></li>
<li>小白盘：<a href="https://www.xiaobaipan.com/" target="_blank" rel="noopener">https://www.xiaobaipan.com/</a></li>
<li>云盘精灵（资源搜索）：<a href="http://www.yunpanjingling.com" target="_blank" rel="noopener">www.yunpanjingling.com</a></li>
<li>虫部落（资源搜索）：<a href="http://www.chongbuluo.com" target="_blank" rel="noopener">www.chongbuluo.com</a></li>
<li>如风搜（资源搜索）：<a href="http://www.rufengso.net/" target="_blank" rel="noopener">http://www.rufengso.net/</a></li>
<li>爱扒：<a href="https://www.zyboe.com/" target="_blank" rel="noopener">https://www.zyboe.com/</a></li>
</ul>
<h4 id="导航页（工具集）"><a href="#导航页（工具集）" class="headerlink" title="导航页（工具集）"></a>导航页（工具集）</h4><ul>
<li>NiceTool.net 好工具网：<a href="http://www.nicetool.net/" target="_blank" rel="noopener">http://www.nicetool.net/</a></li>
<li>现实君工具箱（综合型在线工具集成网站）：<a href="http://tool.uixsj.cn/" target="_blank" rel="noopener">http://tool.uixsj.cn/</a></li>
<li>蓝调网站：<a href="http://lcoc.top/" target="_blank" rel="noopener">http://lcoc.top/</a></li>
<li>偷渡鱼：<a href="https://touduyu.com/" target="_blank" rel="noopener">https://touduyu.com/</a></li>
<li>牛导航：<a href="http://www.ziliao6.com/" target="_blank" rel="noopener">http://www.ziliao6.com/</a></li>
<li>小呆导航：<a href="https://www.webjike.com/index.html" target="_blank" rel="noopener">https://www.webjike.com/index.html</a></li>
<li>简法主页：<a href="http://www.jianfast.com/" target="_blank" rel="noopener">http://www.jianfast.com/</a></li>
<li>KIM 主页：<a href="https://kim.plopco.com/" target="_blank" rel="noopener">https://kim.plopco.com/</a></li>
<li>聚 BT：<a href="https://jubt.net/cn/index.html" target="_blank" rel="noopener">https://jubt.net/cn/index.html</a></li>
<li>精准云工具合集：<a href="https://jingzhunyun.com/" target="_blank" rel="noopener">https://jingzhunyun.com/</a></li>
<li>兔 2 工具合集：<a href="https://www.tool2.cn/" target="_blank" rel="noopener">https://www.tool2.cn/</a></li>
<li>爱资料工具（在线实用工具集合）：<a href="http://www.toolnb.com" target="_blank" rel="noopener">www.toolnb.com</a></li>
<li>工具导航：<a href="https://hao.logosc.cn/" target="_blank" rel="noopener">https://hao.logosc.cn/</a></li>
</ul>
<h4 id="看视频"><a href="#看视频" class="headerlink" title="看视频"></a>看视频</h4><ul>
<li>电影推荐（分类别致）：<a href="http://www.mvcat.com" target="_blank" rel="noopener">http://www.mvcat.com</a></li>
<li>去看 TV：<a href="https://www.qukantv.net/" target="_blank" rel="noopener">https://www.qukantv.net/</a></li>
<li>动漫视频网：<a href="http://www.zzzfun.com/" target="_blank" rel="noopener">http://www.zzzfun.com/</a></li>
<li>94 神马电影网：<a href="http://www.9rmb.com/" target="_blank" rel="noopener">http://www.9rmb.com/</a></li>
<li>NO 视频官网：<a href="http://www.novipnoad.com/" target="_blank" rel="noopener">http://www.novipnoad.com/</a></li>
<li>蓝光画质电影：<a href="http://www.languang.co/" target="_blank" rel="noopener">http://www.languang.co/</a></li>
<li>在线看剧：<a href="http://dy.27234.cn/" target="_blank" rel="noopener">http://dy.27234.cn/</a></li>
<li>大数据导航：<a href="http://hao.199it.com/" target="_blank" rel="noopener">http://hao.199it.com/</a></li>
<li>牛牛 TV：<a href="http://www.ziliao6.com/tv/" target="_blank" rel="noopener">http://www.ziliao6.com/tv/</a></li>
<li>蓝调网站：<a href="http://lcoc.top/vip2.3/" target="_blank" rel="noopener">http://lcoc.top/vip2.3/</a></li>
</ul>
<h4 id="学设计"><a href="#学设计" class="headerlink" title="学设计"></a>学设计</h4><ul>
<li>免费音频素材：<a href="https://icons8.cn/music" target="_blank" rel="noopener">https://icons8.cn/music</a></li>
<li>新 CG 儿（视频素材模板，无水印 + 免费下载）：<a href="https://www.newcger.com/" target="_blank" rel="noopener">https://www.newcger.com/</a></li>
<li>小图标下载：<a href="https://www.easyicon.net/" target="_blank" rel="noopener">https://www.easyicon.net/</a></li>
<li>第一字体转换器：<a href="http://www.diyiziti.com/" target="_blank" rel="noopener">http://www.diyiziti.com/</a></li>
<li>doyoudosh（平面设计）：<a href="http://www.doyoudo.com" target="_blank" rel="noopener">www.doyoudo.com</a></li>
<li>企业宣传视频在线制作：<a href="https://duomu.tv/" target="_blank" rel="noopener">https://duomu.tv/</a></li>
<li>MAKE 海报设计官网：<a href="http://maka.im/" target="_blank" rel="noopener">http://maka.im/</a></li>
<li>一键海报神器：<a href="https://www.logosc.cn/photo/?utmsource=hao.logosc.cn&utmmedium=referral" target="_blank" rel="noopener">https://www.logosc.cn/photo/?utmsource=hao.logosc.cn&utmmedium=referral</a></li>
<li>字由（字体设计）：<a href="http://www.hellofont.cn/" target="_blank" rel="noopener">http://www.hellofont.cn/</a></li>
<li>查字体网站：<a href="https://fonts.safe.360.cn/" target="_blank" rel="noopener">https://fonts.safe.360.cn/</a></li>
<li>爱给网（免费素材下载的网站，包括音效、配乐，3D、视频、游戏，平面、教程）：<a href="http://www.aigei.com/" target="_blank" rel="noopener">http://www.aigei.com/</a></li>
<li>在线视频剪辑：<a href="https://bilibili.clipchamp.com/editor" target="_blank" rel="noopener">https://bilibili.clipchamp.com/editor</a></li>
</ul>
<h4 id="搞文档"><a href="#搞文档" class="headerlink" title="搞文档"></a>搞文档</h4><ul>
<li>即书（在线制作 PPT）：<a href="https://www.keysuper.com/" target="_blank" rel="noopener">https://www.keysuper.com/</a></li>
<li>PPT 在线制作：<a href="https://www.woodo.cn/" target="_blank" rel="noopener">https://www.woodo.cn/</a></li>
<li>优品 PPT（模板下载）：<a href="http://www.ypppt.com/" target="_blank" rel="noopener">http://www.ypppt.com/</a></li>
<li>第一 PPT（模板下载）：<a href="http://www.1ppt.com/xiazai/" target="_blank" rel="noopener">http://www.1ppt.com/xiazai/</a></li>
</ul>
<ul>
<li>PDF 处理：<a href="https://smallpdf.com/cn" target="_blank" rel="noopener">https://smallpdf.com/cn</a></li>
<li>PDF 处理：<a href="https://www.ilovepdf.com/zh-cn" target="_blank" rel="noopener">https://www.ilovepdf.com/zh-cn</a></li>
<li>PDF 处理：<a href="https://www.pdfpai.com/" target="_blank" rel="noopener">https://www.pdfpai.com/</a></li>
</ul>
<ul>
<li><p>腾讯文档（在线协作编辑和管理文档）：<a href="https://docs.qq.com/" target="_blank" rel="noopener">https://docs.qq.com/</a></p>
</li>
<li><p>ProcessOn（在线协作制作结构图）：<a href="http://www.processon.com" target="_blank" rel="noopener">www.processon.com</a></p>
</li>
<li><p>福昕云编辑（在线编辑 PDF）：edit.foxitcloud.cn</p>
</li>
<li><p>UZER.ME（在线使用各种大应用，在线使用 CAD，MATLAB，Office 三件套）：uzer.me</p>
</li>
<li><p>三顿 PPT 导航：sandunppt.com</p>
</li>
</ul>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><ul>
<li>免费版权图片搜索：<a href="https://www.logosc.cn/so/" target="_blank" rel="noopener">https://www.logosc.cn/so/</a></li>
<li>壹伴图片搜索：<a href="https://yiban.io/image_editor" target="_blank" rel="noopener">https://yiban.io/image_editor</a></li>
<li>IMGBOT（在线图片处理）：<a href="http://www.imgbot.ai" target="_blank" rel="noopener">www.imgbot.ai</a></li>
<li>TinyPNG（在线压缩图片）：<a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a></li>
<li><a href="https://unsplash.com/" target="_blank" rel="noopener">https://unsplash.com/</a></li>
<li><a href="https://pixabay.com/" target="_blank" rel="noopener">https://pixabay.com/</a></li>
<li><a href="https://www.pexels.com/" target="_blank" rel="noopener">https://www.pexels.com/</a></li>
<li><a href="https://visualhunt.com/" target="_blank" rel="noopener">https://visualhunt.com/</a></li>
<li><a href="https://www.ssyer.com/" target="_blank" rel="noopener">https://www.ssyer.com/</a></li>
<li>电脑壁纸：<a href="http://lcoc.top/bizhi/" target="_blank" rel="noopener">http://lcoc.top/bizhi/</a></li>
<li>彼岸图网：<a href="http://pic.netbian.com/" target="_blank" rel="noopener">http://pic.netbian.com/</a></li>
<li>极像素（超高清大图）：<a href="https://www.sigoo.com/" target="_blank" rel="noopener">https://www.sigoo.com/</a></li>
</ul>
</body></html>]]></content>
      <categories>
        <category>生活</category>
        <category>推荐</category>
      </categories>
      <tags>
        <tag>网站</tag>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>v2ray 配置</title>
    <url>/2019/04/20/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-web-v2ray%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="1-服务端搭建"><a href="#1-服务端搭建" class="headerlink" title="1. 服务端搭建"></a>1. 服务端搭建</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">bash <(curl -s -L https://git.io/v2ray.sh)</span><br></pre></td></tr></tbody></table></figure>
<p>然后选择安装，即是输入 1 回车<br>选择传输协议，如果没有特别的需求，使用默认的 TCP 传输协议即可，直接回车<br>选择端口，如果没有特别的需求，使用默认的端口即可，直接回车<br>是否屏蔽广告，除非你真的需要，一般来说，直接回车即可<br>有什么疑问可以参考<a href="https://github.com/233boy/v2ray/wiki/V2Ray%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">wiki</a></p>
<h2 id="2-时间需要同步"><a href="#2-时间需要同步" class="headerlink" title="2. 时间需要同步"></a>2. 时间需要同步</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">timedatectl # 查看时间状态</span><br><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu</span></span><br><span class="line">sudo apt-get install -y ntp # 安装NTP服务</span><br><span class="line">systemctl ntp status # 查看NTP服务</span><br><span class="line"><span class="meta">#</span><span class="bash"> Centos</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo yum install chrony</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> timedatectl <span class="built_in">set</span>-timezone Asia/Shanghai <span class="comment"># 设置中国时区</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> timedatectl <span class="built_in">set</span>-ntp yes <span class="comment"># 启用NTP同步</span></span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-防火墙配置"><a href="#3-防火墙配置" class="headerlink" title="3. 防火墙配置"></a>3. 防火墙配置</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo ufw default deny</span><br><span class="line">sudo ufw enable</span><br><span class="line">sudo ufw allow 端口号 # 端口号是服务端v2ray配置的端口号</span><br></pre></td></tr></tbody></table></figure>
<p>可以参考<a href="https://www.cnblogs.com/exmyth/p/5770691.html" target="_blank" rel="noopener">防火墙配置文档</a></p>
<h2 id="4-客户端手册"><a href="#4-客户端手册" class="headerlink" title="4. 客户端手册"></a>4. 客户端手册</h2><p>参考<a href="https://tlanyan.me/v2ray-clients-download/" target="_blank" rel="noopener">博客</a></p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>v2ray</tag>
      </tags>
  </entry>
  <entry>
    <title>线程学习</title>
    <url>/2019/04/12/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-c-%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>深入解析锁和条件变量</p>
</blockquote>
<p>锁的概念：在CPU运行过程中，不会单一的取执行一个事件，而是通过线程，或者进程来进行执行，这样CPU的利用率才得以提高，但是在不同的线程之间，由于互相独立，那么对于资源的访问来说，就可能同时进行，假如A进程获取一个临时变量temp的值，但是在获取的同时，B进程却将temp的值改变了，这时就会出现资源访问的冲突，为了更好的解决这个问题，就有了锁的概念，说的明白些，他就像现实中的锁一样，我们程序中所有的资源，包括变量，内存等都存放在一个房子里，开始时，锁处于开锁状态，如果某一个线程需要访问资源时，就需要拿到这把锁，进到房子里，把门锁上，这样就不会有其他人来干扰你，等你对资源访问结束后，在把锁打开，放下锁，这样别人就可以进入，这样就保证了对资源访问的顺序，这种锁叫互斥锁，这种机制是我们所说的避免竞争。</p>
<p>条件变量：条件变量是线程同步的一种机制。它给多个线程提供一个回合场所。所谓的条件变量就是需要满足这个条件，才可以继续进行操作。</p>
<h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><h2 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h2><p>1)动态方式</p>
<p>int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr);<br>mutex   出参，互斥锁<br>attr    互斥锁的属性，NULL表示默认/缺省的属性</p>
<p>2)静态的方式<br>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;     //一般都选择静态方式</p>
<h2 id="加锁："><a href="#加锁：" class="headerlink" title="加锁："></a>加锁：</h2><p>int pthread_mutex_lock(pthread_mutex_t *mutex);<br>给mutex互斥锁加锁<br>1.互斥锁没有被锁：加锁<br>2.互斥锁已经被锁：阻塞/等待，直到被解锁，然后再对mutex互斥锁加锁</p>
<h2 id="解锁："><a href="#解锁：" class="headerlink" title="解锁："></a>解锁：</h2><p>int pthread_mutex_unlock(pthread_mutex_t *mutex);</p>
<h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><h2 id="什么是条件变量"><a href="#什么是条件变量" class="headerlink" title="什么是条件变量"></a>什么是条件变量</h2><p>条件变量是线程的另外一种同步机制，这些同步对象为线程提供了会合的场所，理解起来就是两个（或者多个）线程需要碰头（或者说进行交互-一个线程给另外的一个或者多个线程发送消息），我们指定在条件变量这个地方发生，一个线程用于修改这个变量使其满足其它线程继续往下执行的条件，其它线程则接收条件已经发生改变的信号。</p>
<p>（核心作用）条件变量同锁一起使用使得线程可以以一种<strong>无竞争</strong>的方式等待任意条件的发生。所谓无竞争就是，条件改变这个信号会发送到所有等待这个信号的线程。而不是说一个线程接受到这个消息而其它线程就接收不到了。</p>
<h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化:"></a>初始化:</h3><p>动态方式:<br>int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);<br>静态的方式：<br>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</p>
<h3 id="等待条件变量"><a href="#等待条件变量" class="headerlink" title="等待条件变量"></a>等待条件变量</h3><p>int pthread_cond_wait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex);</p>
<p>原子性的解锁并阻塞/等待条件变量。</p>
<h3 id="唤醒条件变量"><a href="#唤醒条件变量" class="headerlink" title="唤醒条件变量"></a>唤醒条件变量</h3><p>int pthread_cond_signal(pthread_cond_t *cond);</p>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>下例实现了生产者和消费者模型，生产者向队列中插入数据，消费者则在生产者发出<strong>队列准备好（有数据了）</strong>后接收消息，然后取出数据进行处理。实现的关键点在以下几个方面：</p>
<ul>
<li>生产者和消费者都对条件变量的使用加了锁</li>
<li>消费者调用pthread_cond_wait,等待队列是否准备好的信息，注意参数有两个，一个是pthread_cond_t，另外一个是pthread_mutex_t.</li>
</ul>
<p>代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">m_next</span>;</span></span><br><span class="line"><span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">workq</span>;</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> qready = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> qlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">process_msg(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">    pthread_mutex_lock(&qlock);</span><br><span class="line">    <span class="keyword">while</span> (workq == <span class="literal">NULL</span>)</span><br><span class="line">        pthread_cond_wait(&qready, &qlock);</span><br><span class="line">    mp = workq;</span><br><span class="line">    workq = mp->m_next;</span><br><span class="line">    pthread_mutex_unlock(&qlock);</span><br><span class="line">    <span class="comment">/* now process the message mp */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">enqueue_msg(struct msg *mp)</span><br><span class="line">{</span><br><span class="line">    pthread_mutex_lock(&qlock);</span><br><span class="line">    mp->m_next = workq;</span><br><span class="line">    workq = mp;</span><br><span class="line">    pthread_mutex_unlock(&qlock);</span><br><span class="line">    pthread_cond_signal(&qready);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="配合"><a href="#配合" class="headerlink" title="配合"></a>配合</h1><p>上面的是函数的介绍，为了方便查看，接下来说一下为什么cond和mutex要配合使用。</p>
<p>首先：在pthread_cond_wait()函数之前，要人为获取一把锁，在pthread_cond_wait()执行时，会自动释放这个锁，并且处于等待/阻塞条件，等待信号来临，一但信号来临，那么在pthread_cond_wait()函数调用返回之前，自动将指定的互斥量重新锁住，所以必须在pthread_cond_wait()之后再人为释放锁。其结实际用法为下：</p>
<p>pthread_mutex_lock(&mutex);         //加锁</p>
<p>pthread_cond_wait(&flag,&mutex); //等待，清除标记flag</p>
<p>pthread_mutex_unlock(&mutex);    //解锁<br>其次：对于pthread_cond_signal()函数有两种用法，第一种在加锁与解锁之间，第二种是在加锁解锁之后：</p>
<p>pthread_mutex_lock(&mutex);</p>
<p>pthread_cond_signal(&flag);</p>
<p>pthread_mutex_unlock(&mutex);</p>
<p>这种方式的缺点是：在某线程中，会遭虫等待线程从内核中唤醒(cond_signal是有内核发起的)，然后又回到内核空间(cond_wait返回后会有原子加锁的行为)，所以这一来一回会产生性能的问题，但是在Linux下或者NPTL里面不会，因为Linux线程中有两个队列即cond_wait和cond_signal两个队列，pthread_cond_signal()只是让线程在从wait队列移动到cond队列，不会再永和空间和内核之间往返，不会有应能损耗。</p>
<p>pthread_mutex_lock(&mutex);</p>
<p>pthread_mutex_unlock(&mutex);</p>
<p>pthread_cond_signal(&flag);<br>这种方式的缺点是：如果在unlock和signal之前有一个优先级更低的线程正在等待mutex的话，那么他就会抢占高优先级的线程，而上面的情况则不会出现。</p>
<p>优点是：不会产生性能的损耗，因为在signal之前就已经解锁了。</p>
<h2 id="cond和mutex两个组合使用是为了避免，在一个线程中，如果在wait之前，另一个函数已经完成signal了，那么这个线程将阻塞在这里，从而错过了signal，所以用mutex来实现两个进程的同步，当我等待前上锁，等待后释放锁，然后另一个线程获取锁，产生signal信号，在释放锁。"><a href="#cond和mutex两个组合使用是为了避免，在一个线程中，如果在wait之前，另一个函数已经完成signal了，那么这个线程将阻塞在这里，从而错过了signal，所以用mutex来实现两个进程的同步，当我等待前上锁，等待后释放锁，然后另一个线程获取锁，产生signal信号，在释放锁。" class="headerlink" title="cond和mutex两个组合使用是为了避免，在一个线程中，如果在wait之前，另一个函数已经完成signal了，那么这个线程将阻塞在这里，从而错过了signal，所以用mutex来实现两个进程的同步，当我等待前上锁，等待后释放锁，然后另一个线程获取锁，产生signal信号，在释放锁。"></a>cond和mutex两个组合使用是为了避免，在一个线程中，如果在wait之前，另一个函数已经完成signal了，那么这个线程将阻塞在这里，从而错过了signal，所以用mutex来实现两个进程的同步，当我等待前上锁，等待后释放锁，然后另一个线程获取锁，产生signal信号，在释放锁。</h2></body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>同步与互斥</title>
    <url>/2019/04/12/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-c-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>多线程的同步与互斥</p>
<p>学习<a href="https://blog.csdn.net/daaikuaichuan/article/details/82950711" target="_blank" rel="noopener">https://blog.csdn.net/daaikuaichuan/article/details/82950711</a></p>
</blockquote>
<h1 id="一、同步与互斥的概念"><a href="#一、同步与互斥的概念" class="headerlink" title="一、同步与互斥的概念"></a>一、同步与互斥的概念</h1><p>现代操作系统基本都是多任务操作系统，即同时有大量可调度实体在运行。在多任务操作系统中，同时运行的多个任务可能：</p>
<p>都需要访问/使用同一种资源；<br>多个任务之间有依赖关系，某个任务的运行依赖于另一个任务。<br>同步】：</p>
<p>是指散步在不同任务之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。最基本的场景就是：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。比如 A 任务的运行依赖于 B 任务产生的数据。</p>
<p>【互斥】：</p>
<p>是指散步在不同任务之间的若干程序片断，当某个任务运行其中一个程序片段时，其它任务就不能运行它们之中的任一程序片段，只能等到该任务运行完这个程序片段后才可以运行。最基本的场景就是：一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。</p>
<h1 id="二、互斥锁（同步）"><a href="#二、互斥锁（同步）" class="headerlink" title="二、互斥锁（同步）"></a>二、互斥锁（同步）</h1><p>在多任务操作系统中，同时运行的多个任务可能都需要使用同一种资源。这个过程有点类似于，公司部门里，我在使用着打印机打印东西的同时（还没有打印完），别人刚好也在此刻使用打印机打印东西，如果不做任何处理的话，打印出来的东西肯定是错乱的。<br>在线程里也有这么一把锁——互斥锁（mutex），互斥锁是一种简单的加锁的方法来控制对共享资源的访问，互斥锁只有两种状态,即上锁( lock )和解锁( unlock )。</p>
<h2 id="【特点】"><a href="#【特点】" class="headerlink" title="【特点】"></a>【特点】</h2><ol>
<li><p>原子性：把一个互斥量锁定为一个原子操作，这意味着操作系统（或pthread函数库）保证了如果一个线程锁定了一个互斥量，没有其他线程在同一时间可以成功锁定这个互斥量；</p>
</li>
<li><p>唯一性：如果一个线程锁定了一个互斥量，在它解除锁定之前，没有其他线程可以锁定这个互斥量；</p>
</li>
<li><p>非繁忙等待：如果一个线程已经锁定了一个互斥量，第二个线程又试图去锁定这个互斥量，则第二个线程将被挂起（不占用任何cpu资源），直到第一个线程解除对这个互斥量的锁定为止，第二个线程则被唤醒并继续执行，同时锁定这个互斥量。</p>
</li>
</ol>
<h2 id="【操作流程】"><a href="#【操作流程】" class="headerlink" title="【操作流程】"></a>【操作流程】</h2><ol>
<li>在访问共享资源后临界区域前，对互斥锁进行加锁；</li>
<li>在访问完成后释放互斥锁导上的锁。在访问完成后释放互斥锁导上的锁；</li>
<li>对互斥锁进行加锁后，任何其他试图再次对互斥锁加锁的线程将会被阻塞，直到锁被释放。对互斥锁进行加锁后，任何其他试图再次对互斥锁加锁的线程将会被阻塞，直到锁被释放。<h2 id="【函数】"><a href="#【函数】" class="headerlink" title="【函数】"></a>【函数】</h2></li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"time.h"</span></span></span><br><span class="line"><span class="comment">// 初始化一个互斥锁。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, </span></span></span><br><span class="line"><span class="function"><span class="params">						<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对互斥锁上锁，若互斥锁已经上锁，则调用者一直阻塞，</span></span><br><span class="line"><span class="comment">// 直到互斥锁解锁后再上锁。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用该函数时，若互斥锁未加锁，则上锁，返回 0；</span></span><br><span class="line"><span class="comment">// 若互斥锁已加锁，则函数直接返回失败，即 EBUSY。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当线程试图获取一个已加锁的互斥量时，pthread_mutex_timedlock 互斥量</span></span><br><span class="line"><span class="comment">// 原语允许绑定线程阻塞时间。即非阻塞加锁互斥量。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_timedlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abs_timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对指定的互斥锁解锁。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁指定的一个互斥锁。互斥锁在使用完毕后，</span></span><br><span class="line"><span class="comment">// 必须要对互斥锁进行销毁，以释放资源。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="【实例1】"><a href="#【实例1】" class="headerlink" title="【实例1】"></a>【实例1】</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//使用互斥量解决多线程抢占资源的问题</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span>* buf[<span class="number">5</span>]; <span class="comment">//字符指针数组  全局变量</span></span><br><span class="line"><span class="keyword">int</span> pos; <span class="comment">//用于指定上面数组的下标</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//1.定义互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">task</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//3.使用互斥量进行加锁</span></span><br><span class="line">    pthread_mutex_lock(&mutex);</span><br><span class="line"> </span><br><span class="line">    buf[pos] = (<span class="keyword">char</span> *)p;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    pos++;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//4.使用互斥量进行解锁</span></span><br><span class="line">    pthread_mutex_unlock(&mutex);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//2.初始化互斥量, 默认属性</span></span><br><span class="line">    pthread_mutex_init(&mutex, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//1.启动一个线程 向数组中存储内容</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid, tid2;</span><br><span class="line">    pthread_create(&tid, <span class="literal">NULL</span>, task, (<span class="keyword">void</span> *)<span class="string">"zhangfei"</span>);</span><br><span class="line">    pthread_create(&tid2, <span class="literal">NULL</span>, task, (<span class="keyword">void</span> *)<span class="string">"guanyu"</span>);</span><br><span class="line">    <span class="comment">//2.主线程进程等待,并且打印最终的结果</span></span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//5.销毁互斥量</span></span><br><span class="line">    pthread_mutex_destroy(&mutex);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"字符指针数组中的内容是："</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i < pos; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s "</span>, buf[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="【实例2】"><a href="#【实例2】" class="headerlink" title="【实例2】"></a>【实例2】</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"time.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tout</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tmp</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_lock (&lock);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"mutex is locked\n"</span>);</span><br><span class="line">    clock_gettime (CLOCK_REALTIME, &tout);</span><br><span class="line">    tmp = localtime (&tout.tv_sec); </span><br><span class="line">    strftime (buf, <span class="keyword">sizeof</span> (buf), <span class="string">"%r"</span>, tmp);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"current time is %s\n"</span>, buf);</span><br><span class="line">    tout.tv_sec += <span class="number">10</span>;</span><br><span class="line">    err = pthread_mutex_timedlock (&lock, &tout);</span><br><span class="line">    clock_gettime (CLOCK_REALTIME, &tout);</span><br><span class="line">    tmp = localtime (&tout.tv_sec);</span><br><span class="line">    strftime (buf, <span class="keyword">sizeof</span> (buf), <span class="string">"%r"</span>, tmp);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"the time is now %s\n"</span>, buf);</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"mutex locked again\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"can`t lock mutex again:%s\n"</span>, strerror (err));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="三、条件变量（同步）"><a href="#三、条件变量（同步）" class="headerlink" title="三、条件变量（同步）"></a>三、条件变量（同步）</h1><h2 id="【特点】-1"><a href="#【特点】-1" class="headerlink" title="【特点】"></a>【特点】</h2><p>与互斥锁不同，条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。<br>条件变量使我们可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步 的一种机制，主要包括两个动作：</p>
<p>一个线程等待”条件变量的条件成立”而挂起；<br>另一个线程使 “条件成立”（给出条件成立信号）。</p>
<h2 id="【原理】"><a href="#【原理】" class="headerlink" title="【原理】"></a>【原理】</h2><p>  条件的检测是在互斥锁的保护下进行的。线程在改变条件状态之前必须首先锁住互斥量。如果一个条件为假，一个线程自动阻塞，并释放等待状态改变的互斥锁。如果另一个线程改变了条件，它发信号给关联的条件变量，唤醒一个或多个等待它的线程，重新获得互斥锁，重新评价条件。如果两进程共享可读写的内存，条件变量 可以被用来实现这两进程间的线程同步。</p>
<h2 id="【条件变量的操作流程如下】"><a href="#【条件变量的操作流程如下】" class="headerlink" title="【条件变量的操作流程如下】"></a>【条件变量的操作流程如下】</h2><ol>
<li><p>初始化：init()或者pthread_cond_tcond=PTHREAD_COND_INITIALIER；属性置为NULL；</p>
</li>
<li><p>等待条件成立：pthread_wait，pthread_timewait.wait()释放锁,并阻塞等待条件变量为真 timewait()设置等待时间,仍未signal,返回ETIMEOUT(加锁保证只有一个线程wait)；</p>
</li>
<li><p>激活条件变量：pthread_cond_signal,pthread_cond_broadcast(激活所有等待线程)</p>
</li>
<li><p>清除条件变量：destroy;无线程等待,否则返回EBUSY清除条件变量:destroy;无线程等待,否则返回EBUSY</p>
</li>
</ol>
<h2 id="【实例】"><a href="#【实例】" class="headerlink" title="【实例】"></a>【实例】</h2><p>生产者和消费者模型，生产者向队列中插入数据，消费者则在生产者发出<strong>队列准备好（有数据了）</strong>后接收消息，然后取出数据进行处理。实现的关键点在以下几个方面：</p>
<ul>
<li>生产者和消费者都对条件变量的使用加了锁</li>
<li>消费者调用pthread_cond_wait,等待队列是否准备好的信息，注意参数有两个，一个是pthread_cond_t，另外一个是pthread_mutex_t.</li>
</ul>
<p>代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">m_next</span>;</span></span><br><span class="line"><span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">workq</span>;</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> qready = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> qlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">process_msg(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">    pthread_mutex_lock(&qlock);</span><br><span class="line">    <span class="keyword">while</span> (workq == <span class="literal">NULL</span>)</span><br><span class="line">        pthread_cond_wait(&qready, &qlock);</span><br><span class="line">    mp = workq;</span><br><span class="line">    workq = mp->m_next;</span><br><span class="line">    pthread_mutex_unlock(&qlock);</span><br><span class="line">    <span class="comment">/* now process the message mp */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">enqueue_msg(struct msg *mp)</span><br><span class="line">{</span><br><span class="line">    pthread_mutex_lock(&qlock);</span><br><span class="line">    mp->m_next = workq;</span><br><span class="line">    workq = mp;</span><br><span class="line">    pthread_mutex_unlock(&qlock);</span><br><span class="line">    pthread_cond_signal(&qready);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="【疑问】"><a href="#【疑问】" class="headerlink" title="【疑问】"></a>【疑问】</h2><h3 id="为什么pthread-cond-wait需要加锁？？"><a href="#为什么pthread-cond-wait需要加锁？？" class="headerlink" title="为什么pthread_cond_wait需要加锁？？"></a>为什么pthread_cond_wait需要加锁？？</h3><p>pthread_cond_wait中的mutex用于保护条件变量，调用这个函数进行等待条件的发生时,mutex会被自动释放，以供其它线程（生产者）改变条件，pthread_cond_wait中的两个步骤必须是原子性的(atomically,万恶的APUE中文版把这个单词翻译成了『自动』，误人子弟啊)，也就是说必须把两个步骤捆绑到一起：</p>
<ul>
<li>把调用线程放到条件等待队列上</li>
<li>释放mutex</li>
</ul>
<p>不然呢，如果不是原子性的，上面的两个步骤中间就可能插入其它操作。比如，如果先释放mutex，这时候生产者线程向队列中添加数据，然后signal,之后消费者线程才去『把调用线程放到等待队列上』，signal信号就这样被丢失了。</p>
<p>如果先把调用线程放到条件等待队列上，这时候另外一个线程发送了pthread_cond_signal（我们知道这个函数的调用是不需要mutex的），然后调用线程立即获取mutex，两次获取mutex会产生deadlock.</p>
<h3 id="在生产者线程中修改条件时为什么要加mutex？？"><a href="#在生产者线程中修改条件时为什么要加mutex？？" class="headerlink" title="在生产者线程中修改条件时为什么要加mutex？？"></a>在生产者线程中修改条件时为什么要加mutex？？</h3><p>如果不这么做信号可能会丢失，看下面的例子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Thead A                             Thread B</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&qlock);</span><br><span class="line">while (workq == NULL)</span><br><span class="line">                                   mp->m_next = workq;</span><br><span class="line">                                   workq = mp;</span><br><span class="line">                                   pthread_cond_signal(&cond);</span><br><span class="line"></span><br><span class="line">pthread_cond_wait(&qready, &qlock);</span><br></pre></td></tr></tbody></table></figure>

<p>在while判断之后向队列中插入数据，虽然已经有数据了，但线程A还是调用了pthread_cond_wait等待下一个信号到来。。</p>
<h3 id="消费者线程中判断条件为什么要放在while中？？"><a href="#消费者线程中判断条件为什么要放在while中？？" class="headerlink" title="消费者线程中判断条件为什么要放在while中？？"></a>消费者线程中判断条件为什么要放在while中？？</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">while (workq == NULL)</span><br><span class="line">    pthread_cond_wait(&qready, &qlock);</span><br><span class="line">mp = workq;</span><br></pre></td></tr></tbody></table></figure>

<p>我们把while换成if可不可以呢？</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if (workq == NULL)</span><br><span class="line">    pthread_cond_wait(&qready, &qlock);</span><br><span class="line">mp = workq;</span><br></pre></td></tr></tbody></table></figure>

<p>答案是不可以，一个生产者可能对应着多个消费者，生产者向队列中插入一条数据之后发出signal，然后各个消费者线程的pthread_cond_wait获取mutex后返回，当然，这里只有一个线程获取到了mutex，然后进行处理，其它线程会pending在这里，处理线程处理完毕之后释放mutex，刚才等待的线程中有一个获取mutex，如果这里用if，就会在当前队列为空的状态下继续往下处理，这显然是不合理的。</p>
<h3 id="signal到底是放在unlock之前还是之后？？"><a href="#signal到底是放在unlock之前还是之后？？" class="headerlink" title="signal到底是放在unlock之前还是之后？？"></a>signal到底是放在unlock之前还是之后？？</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">void</span><br><span class="line">enqueue_msg(struct msg *mp)</span><br><span class="line">{</span><br><span class="line">    pthread_mutex_lock(&qlock);</span><br><span class="line">    mp->m_next = workq;</span><br><span class="line">    workq = mp;</span><br><span class="line">    pthread_mutex_unlock(&qlock);</span><br><span class="line">    pthread_cond_signal(&qready);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果先unlock，再signal,如果这时候有一个消费者线程恰好获取mutex，然后进入条件判断，这里就会判断成功，从而跳过pthread_cond_wait,下面的signal就会不起作用；另外一种情况，一个优先级更低的不需要条件判断的线程正好也需要这个mutex，这时候就会转去执行这个优先级低的线程，就违背了设计的初衷。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">    void</span><br><span class="line">enqueue_msg(struct msg *mp)</span><br><span class="line">{</span><br><span class="line">    pthread_mutex_lock(&qlock);</span><br><span class="line">    mp->m_next = workq;</span><br><span class="line">    workq = mp;</span><br><span class="line">    pthread_cond_signal(&qready);</span><br><span class="line">    pthread_mutex_unlock(&qlock);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果把signal放在unlock之前，消费者线程会被唤醒，获取mutex发现获取不到，就又去sleep了。浪费了资源.但是在LinuxThreads或者NPTL里面，就不会有这个问题，因为在Linux 线程中，有两个队列，分别是cond_wait队列和mutex_lock队列， cond_signal只是让线程从cond_wait队列移到mutex_lock队列，而不用返回到用户空间，不会有性能的损耗。<br>所以在Linux中推荐使用这种模式。</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言设计模式</title>
    <url>/2019/04/01/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-c-C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>有哪些设计模式？c语言如何实现这些设计模式？<br>《C现代编程》读书笔记</p>
</blockquote>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>管理资源（文件或者内存）是一件很麻烦的事情，因为分配资源后还必须释放资源，如fopen和fclose需要对应，malloc和free需要对应。因此处理资源的代码总是显得非常繁杂。</p>
<p>如果函数在处理到一半的时候，返回了，而不去释放文件或内存，让文件或者内存一直处于打开状态，就会出现问题。但是如果加入的话，又容易出现代码混乱。</p>
<p>方法：将程序中的部分处理作为可以被替换的函数，将其他处理作为固定处理，使其可以重复利用，这里资源的分配和释放处理是固定处理，而获取文件中数值范围的处理则是可以被替换的处理。</p>
<p>优点：</p>
<p>首先， 文件的打开和关闭等操作都集中在 read_file函数中。也就是说只能在其中分配和释放资源。通常情况下，最好尽量将分配和释放资源的处理放在一起，否则很容易忘记。另外 ， 该结构将文件处理分离到 processor函数中。 这样一来． 各函数的职责更加清晰明确 。也可以避免中途退出循环时发生的问题。</p>
<h3 id="升级1：返回非int值"><a href="#升级1：返回非int值" class="headerlink" title="升级1：返回非int值"></a>升级1：返回非int值</h3><p>C语言中多用void或者联合体解决问题</p>
<p>这里可以使用一个结构体，需要什么返回值，就增加一个什么样的结构体。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FileReaderContext</span> {</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> pFname;</span><br><span class="line">    <span class="keyword">void</span>(*<span class="keyword">const</span> processor)(struct FileReaderContext *pThis, FILE *p);</span><br><span class="line">}FileReaderContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    FileReaderContext base;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">}MyFileReaderContext;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="升级二：处理其他资源"><a href="#升级二：处理其他资源" class="headerlink" title="升级二：处理其他资源"></a>升级二：处理其他资源</h3><p>实现将一个文件中的数据读取到内存中，进行排序后，再输出给另一个文件的功能。</p>
<p>将最常用的写成模板，而不是将整体写成模板。</p>
<p>处理文件+处理内存</p>
<blockquote>
<p>源码：<a href="https://github.com/xiaoqinxing/myrepo_c" target="_blank" rel="noopener">https://github.com/xiaoqinxing/myrepo_c</a></p>
</blockquote>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：两路摄像头自动日夜切换问题</title>
    <url>/2019/03/22/%E5%B7%A5%E4%BD%9C-%E7%BC%96%E7%A8%8B-2412M%E8%AE%BE%E5%A4%87%E8%A1%A5%E5%85%89%E7%81%AF%E5%8F%8AIR-CUT%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><ol>
<li>手动切换没有问题</li>
<li>单路摄像头自动切换日夜没有问题</li>
<li>双路摄像头自动切换日夜不受控制</li>
</ol>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li><input checked disabled type="checkbox"> 查看两路camera是如何实现对应参数的传递</li>
<li><input checked disabled type="checkbox"> 了解如何实现两路摄像头的分别控制</li>
<li><input checked disabled type="checkbox"> 了解日夜切换的逻辑</li>
</ul>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li>两路camera是如何实现不同的参数的？<br>需要看HAL层camera类的构造函数。可以看到HWI中是总的类，里面包含状态机，回调函数等等函数封装，初始化用QCamera2HardwareInterface(camera_id)，多一个摄像头就增加一个对象。<br>在hal层里面加一个对cameraid的判断，由于是创建了两个对象，互不干扰，因此只需要对id号进行判断，赋值还是一样的赋值。<br>注意了ispctrl参数是用QCameraParameters进行传递，它是在QCameraParametersIntf类里面的，随着QCamera2HardwareInterface类的定义而定义。QCamera2HardwareInterface又是在QCamera2HardwareInterface中定义的，也就是说随着一个摄像头的创建，会创建这个摄像头的整个实现方法。</li>
<li>高通代码是以面向对象的思想去写的，日夜切换的代码只有一套，由上层创建了两个摄像头，分别进行控制，两个摄像头的运行互不干扰。</li>
<li>问题就出现在两个摄像头的运行受到了干扰，每个摄像头都需要保存上次切换的时间，而这个时间应该是分离的，但是用的是static变量，导致这两个摄像头用的是同一个变量。</li>
</ol>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>C++中的static变量是静态数据成员<br>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，<strong>静态成员是类的所有对象中共享的成员，而不是某个对象的成员。</strong><br>但是遇到一个问题，需要保存上一个动作的时间，以前都是用static的方法保存，但是用对象的方法时，就不能这样了，创建一个新的对象，这个时间不能自动增加一个。就会导致异常！！<br>因此static变量要注意使用的时机。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>将static变量转成私有的类成员变量，既能保证私有性，又能保证创建新对象的时候自动新建变量。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>c++：面向对象的写法中，慎重使用static变量</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>IR-CUT</tag>
        <tag>2412M</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>编译版本信息打印功能实现</title>
    <url>/2019/03/20/%E5%B7%A5%E4%BD%9C-%E7%BC%96%E7%A8%8B-%E7%BC%96%E8%AF%91%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF%E6%89%93%E5%8D%B0%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>如何打印分支和目标设备的信息？<br>如何进行Makefile的编写？<br>如何引用Makefile中的宏定义？</p>
</blockquote>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>能够获取到分支信息、编译时间</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>下面有四种方案，下面的一种方案是上面方案的改进版</p>
<h3 id="方案一：用fopen打开文件"><a href="#方案一：用fopen打开文件" class="headerlink" title="方案一：用fopen打开文件"></a>方案一：用fopen打开文件</h3><p>git是编译服务器上的程序，git log也仅仅存在于服务器上，而代码的运行位置是在设备上。所以如果想要自动打印版本信息的话，log信息保存在设备的某个位置下，然后在代码中读取文件。<br>可以利用git log格式化输出</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git log --pretty=format:"\"%h\",\"%s\"" -n 1 > source/debug/git_log.txt</span><br></pre></td></tr></tbody></table></figure>

<h3 id="方案二：用头文件包含的方案"><a href="#方案二：用头文件包含的方案" class="headerlink" title="方案二：用头文件包含的方案"></a>方案二：用头文件包含的方案</h3><p>为了减少读取文件这种开销，可以把log信息放到头文件里面，具体可以参考高通camera 3A信息的头文件。<br><code>注意：</code>发现#include必须要写在最前面，表达式中间不能有#，但是却有一个投机取巧的方法，就是定义一个结构体，将文档文件读取成结构体。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line"><span class="keyword">char</span> hash[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> commit_log[<span class="number">64</span>];</span><br><span class="line">}GitVersion_t;</span><br><span class="line"><span class="keyword">static</span> GitVersion_t s_GitVersion = {</span><br><span class="line">#include <span class="string">"git_log.txt"</span></span><br><span class="line">};</span><br><span class="line">OsApi_Printf(<span class="number">1</span>,<span class="number">0</span>,<span class="string">"Commit ID:%s\nDetail: %s"</span>,s_GitVersion.hash, s_GitVersion.commit_log);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="方案三：用宏定义进行读取"><a href="#方案三：用宏定义进行读取" class="headerlink" title="方案三：用宏定义进行读取"></a>方案三：用宏定义进行读取</h3><p><code>注意：</code></p>
<ol>
<li><p>Android.mk对宏定义进行字符串赋值的时候，一定要注意用转义字符<code>\</code><br>例如：<code>CFLAGS += -DMY_PATH=\"/etc/mycfg\"</code></p>
</li>
<li><p>编译一个宏定义后，就算Makefile里面删除了，也还会存在</p>
</li>
<li><p>在make.mk中定义一个自定义的mk变量，但是在子Makefile中引用这个变量不行，因为子Makefile文件的一开始会把变量全部清空</p>
</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_PRODUCT</span></span><br><span class="line">    OsApi_Printf(<span class="number">1</span>,<span class="number">0</span>, (<span class="keyword">char</span> *)<span class="string">"TARGET_VERSION = %s"</span>, TARGET_PRODUCT);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="方案四：利用mk脚本生成宏定义"><a href="#方案四：利用mk脚本生成宏定义" class="headerlink" title="方案四：利用mk脚本生成宏定义"></a>方案四：利用mk脚本生成宏定义</h4><ol>
<li>首先获取git log的信息。<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 脚本一（媒控的）：</span></span><br><span class="line">git log -1 2> /dev/null # 打印最近一条commit信息</span><br><span class="line">head -n 1 # 取第一行</span><br><span class="line"><span class="meta">#</span><span class="bash"> 脚本二：</span></span><br><span class="line">git log --pretty=format:"%H" -n 1 |cut -b -8</span><br></pre></td></tr></tbody></table></figure></li>
<li>利用Makefile脚本生成文件<br>makefile中call是调用函数的意思 后面的第一个参数是函数名，下面的参数就是函数的参数了<br>第二句话是定义了一个函数，1是第一个参数，也就是说这个函数的作用就是往文件1中写入hello<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># function call</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> autogenerate_modesubversion,<span class="variable">$(AUTO_SUBVERSION_FILE_NAME)</span>)</span></span><br><span class="line"><span class="comment"># function define</span></span><br><span class="line">autogenerate_modesubversion = <span class="variable">$(<span class="built_in">shell</span> echo "hello" > $(1)</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>增加版本信息的宏定义，在文件中进行读取<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">current_makefile := <span class="variable">$(<span class="built_in">lastword</span> <span class="variable">$(MAKEFILE_LIST)</span>)</span></span><br><span class="line">current_make_path := <span class="variable">$(<span class="built_in">patsubst</span> %/,%,$(<span class="built_in">dir</span> $(current_makefile:%/=%)</span>))/..</span><br><span class="line"><span class="comment"># MODULE_SUBVERSION := $(shell cd $(current_make_path) && git log -1 2> /dev/null | head -n 1 | awk ' {print $$2 } ' | cut -b -8)</span></span><br><span class="line">MODULE_SUBVERSION := <span class="variable">$(<span class="built_in">shell</span> cd <span class="variable">$(current_make_path)</span> && git log --pretty=format:"%H" -n 1 |cut -b -8)</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(MODULE_SUBVERSION)</span>,)</span><br><span class="line">MODULE_SUBVERSION := AA5555AA</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment"># module_auto_subversion_gen = $(shell echo "Do nothing..")</span></span><br><span class="line">autogenerate_modesubversion = <span class="variable">$(<span class="built_in">shell</span> echo "/**" > $(1)</span> ; \</span><br><span class="line">echo <span class="string">" * Kedacom module subversion defines."</span> >> $(1) ; \</span><br><span class="line">echo <span class="string">" * Automatically generated file, DO NOT EDIT."</span> >> $(1) ; \</span><br><span class="line">echo <span class="string">" * Don't push it to repository."</span> >> $(1) ; \</span><br><span class="line">echo <span class="string">" *"</span> >> $(1) ; \</span><br><span class="line">echo <span class="string">" */"</span> >> $(1) ; \</span><br><span class="line">echo <span class="string">"\#define MODULE_SUBVERSION 0x<span class="variable">$(MODULE_SUBVERSION)</span>"</span> >> $(1))</span><br></pre></td></tr></tbody></table></figure></li>
<li>注意提交代码的时候不要把生成的头文件提交上去。每次编译都会更新生成的版本文件，从而去更新编译时间和版本号。</li>
</ol>
<h2 id="附录（完整代码）"><a href="#附录（完整代码）" class="headerlink" title="附录（完整代码）"></a>附录（完整代码）</h2><figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">current_makefile := <span class="variable">$(<span class="built_in">lastword</span> <span class="variable">$(MAKEFILE_LIST)</span>)</span></span><br><span class="line">current_make_path := <span class="variable">$(<span class="built_in">patsubst</span> %/,%,$(<span class="built_in">dir</span> $(current_makefile:%/=%)</span>))/..</span><br><span class="line"></span><br><span class="line"><span class="comment"># MODULE_SUBVERSION := $(shell cd $(current_make_path) && git log -1 2> /dev/null | head -n 1 | awk ' {print $$2 } ' | cut -b -8)</span></span><br><span class="line">MODULE_SUBVERSION := <span class="variable">$(<span class="built_in">shell</span> cd <span class="variable">$(current_make_path)</span> && git log --pretty=format:"%H" -n 1 |cut -b -8)</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(MODULE_SUBVERSION)</span>,)</span><br><span class="line">MODULE_SUBVERSION := AA5555AA</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">MODULE_GIT_COMMIT := <span class="variable">$(<span class="built_in">shell</span> git -C <span class="variable">$(current_make_path)</span> rev-parse --short=8 HEAD 2>/dev/null)</span></span><br><span class="line"></span><br><span class="line">MODULE_GIT_BRANCH := <span class="variable">$(<span class="built_in">shell</span> cd <span class="variable">$(current_make_path)</span> && git branch 2> /dev/null | grep "*" | awk ' {print $$2 } ')</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(MODULE_GIT_BRANCH)</span>,)</span><br><span class="line">MODULE_GIT_BRANCH := branch-unknow</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">BranchDetached:= (detached</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(MODULE_GIT_BRANCH)</span>,<span class="variable">$(BranchDetached)</span>)</span><br><span class="line">MODULE_GIT_BRANCH := <span class="variable">$(<span class="built_in">shell</span> cd <span class="variable">$(current_make_path)</span> && git branch -a 2> /dev/null | grep "\->" |cut -d '>' -f 2 | cut -d '/' -f 2 )</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># module_auto_subversion_gen = $(shell echo "Do nothing..")</span></span><br><span class="line">autogenerate_modesubversion = <span class="variable">$(<span class="built_in">shell</span> echo "/**" > $(1)</span> ; \</span><br><span class="line">    echo <span class="string">" * Kedacom module subversion defines."</span> >> $(1) ; \</span><br><span class="line">    echo <span class="string">" * Automatically generated file, DO NOT EDIT."</span> >> $(1) ; \</span><br><span class="line">    echo <span class="string">" * Don't push it to repository."</span> >> $(1) ;\</span><br><span class="line">    echo <span class="string">" *"</span> >> $(1) ;	\</span><br><span class="line">    echo <span class="string">" */"</span> >> $(1) ;\</span><br><span class="line">    echo <span class="string">"\#ifndef _AUTO_MODSUBVER_H_"</span> >> $(1) ; \</span><br><span class="line">    echo <span class="string">"\#define _AUTO_MODSUBVER_H_"</span> >> $(1) ; \</span><br><span class="line">    echo <span class="string">""</span> >> $(1) ; \</span><br><span class="line">    echo <span class="string">"\#define MODULE_GIT_BRANCH \"<span class="variable">$(MODULE_GIT_BRANCH)\"</span>"</span> >> $(1) ; \</span><br><span class="line">    echo <span class="string">"\#define MODULE_BUILD_DATE \"`date "</span>+%Y-%m-%d %H:%M:%S<span class="string">"`\""</span> >> $(1) ; \</span><br><span class="line">    echo <span class="string">"\#define MODULE_GIT_COMMIT \"<span class="variable">$(MODULE_GIT_COMMIT)\"</span>"</span> >> $(1) ; \</span><br><span class="line">    echo <span class="string">"\#define MODULE_SUBVERSION 0x<span class="variable">$(MODULE_SUBVERSION)</span>"</span> >> $(1);\</span><br><span class="line">    echo <span class="string">""</span> >> $(1) ; \</span><br><span class="line">    echo <span class="string">"\#endif /* _AUTO_MODSUBVER_H_ */"</span> >> $(1))</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>version</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>c-使用结构和指针</title>
    <url>/2019/03/20/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-c-c-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E5%92%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表就是一些包含数据的独立数据结构的集合。每个节点通过链或者指针连接在一起。程序通过指针访问链表的节点，节点通常是动态分配的，但有时你也能看到有节点数组构建的链表。即使这种情况下，程序也是通过指针来遍历链表的。</p>
<h3 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1. 单链表"></a>1. 单链表</h3><p>每个节点饱和一个指向链表下一个节点的指针。链表最后一个节点的指针字段的值为NULL，提示链表后面不在有其他节点。</p>
<p>找到链表的第一个节点后，指针就可以带你访问剩余的所有节点。为了记住链表的起始位置，可以用一个根指针（root pointer)。根指针指向链表的第一个节点。<strong>注意根指针只是一个指针，不包含数据。</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">typedef struct NODE {</span><br><span class="line">    struct NODE *link;</span><br><span class="line">    int          value;</span><br><span class="line">}NODE;</span><br></pre></td></tr></tbody></table></figure>

<p>单链表可以通过链从开始位置遍历链表知道结束位置，<strong>但是链表无法从相反的方向进行遍历。</strong></p>
<p><strong>疑问：</strong>为什么无法从相反方向遍历？通过&查找不行么？</p>
<p><strong>思考：</strong>一个内存地址可以由很多指针指向。地址说到底也只是一串数，指针就是在内存的其他位置存着这一串数，可能你又怎么知道那个位置存着这一串数呢？这串数可能出现很多次，也根本没法判断。<strong>&符号只是取出地址，而这个地址可以给其他任意地方存着。</strong></p>
<h3 id="2-双链表"><a href="#2-双链表" class="headerlink" title="2. 双链表"></a>2. 双链表</h3><p>相比单链表，就是增加一个指向上一个节点的指针</p>
<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>由于正常的堆栈没有给堆栈设置一个限额，为了安全起见，本文为堆栈设置了一个限制，如果需要取消这个限制，就<code>#define STACK_LIMIT 0</code></p>
<h3 id="1-结构体定义"><a href="#1-结构体定义" class="headerlink" title="1. 结构体定义"></a>1. 结构体定义</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment">*   作    者    ：xiaoqinxing</span></span><br><span class="line"><span class="comment">*   功能描述    ：单链表实现的动态堆栈</span></span><br><span class="line"><span class="comment">*   使用说明    ：</span></span><br><span class="line"><span class="comment">******************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  __STACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __STACK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//定义存储数据类型（可以定义为指针）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_TYPE int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//是否限制堆栈长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_LIMIT 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//堆栈默认长度，开启STACK_LIMIT后生效</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_LIMIT_DEFAULT_LENTH 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">STACK_NODE</span> {</span></span><br><span class="line">        STACK_TYPE value;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">STACK_NODE</span> *<span class="title">next</span>;</span></span><br><span class="line">}StackNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">STACK_PRIVATE</span>{</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_len;</span><br><span class="line">}STACK_PRIVATE;</span><br><span class="line"><span class="comment">//结构体里面的函数指针 参数中包含结构体时一定要加struct，否则会报错，</span></span><br><span class="line"><span class="comment">//但是c文件里面可以不加；可能是Stack还没有定义完就使用了</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">//第一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">char</span> <span class="params">(*is_empty_func)</span><span class="params">(struct Stack *stack_obj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*push_func)</span><span class="params">(struct Stack *stack_obj, STACK_TYPE value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pop_func)</span><span class="params">(struct Stack *stack_obj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">STACK_TYPE</span><span class="params">(*top_func)</span><span class="params">(struct Stack *stack_obj)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> {</span></span><br><span class="line">    StackNode *node;</span><br><span class="line">    is_empty_func is_empty;</span><br><span class="line">    push_func push;</span><br><span class="line">    pop_func pop;</span><br><span class="line">    top_func top;</span><br><span class="line">}Stack;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> {</span></span><br><span class="line">    StackNode *node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> STACK_LIMIT</span></span><br><span class="line">    STACK_PRIVATE stack_private;</span><br><span class="line">    <span class="keyword">char</span>(*is_full)(struct Stack *stack_obj);</span><br><span class="line">    <span class="keyword">void</span>(*set_length)(struct Stack *stack_obj);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">char</span>(*is_empty)(struct Stack *stack_obj);</span><br><span class="line">    <span class="keyword">void</span>(*push)(struct Stack *stack_obj, STACK_TYPE value);</span><br><span class="line">    STACK_TYPE(*pop)(struct Stack *stack_obj);</span><br><span class="line">    STACK_TYPE(*top)(struct Stack *stack_obj);</span><br><span class="line">}Stack;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">is_stack_full</span><span class="params">(struct Stack *stack_obj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_stack_length</span><span class="params">(struct Stack *stack_obj, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">is_stack_empty</span><span class="params">(Stack * stack_obj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Stack * stack_obj, STACK_TYPE value)</span></span>;</span><br><span class="line"><span class="function">STACK_TYPE <span class="title">pop</span><span class="params">(Stack * stack_obj)</span></span>;</span><br><span class="line"><span class="function">STACK_TYPE <span class="title">top</span><span class="params">(Stack * stack_obj)</span></span>;</span><br><span class="line"><span class="function">Stack* <span class="title">create_stack</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_stack</span><span class="params">(Stack *stack_obj)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-创建和销毁"><a href="#2-创建和销毁" class="headerlink" title="2. 创建和销毁"></a>2. 创建和销毁</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Stack* <span class="title">create_stack</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    Stack *stack_obj=MALLOC(<span class="number">1</span>,Stack);</span><br><span class="line">    stack_obj->node = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> STACK_LIMIT</span></span><br><span class="line">    stack_obj->stack_private.length = <span class="number">0</span>;</span><br><span class="line">    stack_obj->stack_private.max_len = STACK_LIMIT_DEFAULT_LENTH;</span><br><span class="line">    stack_obj->set_length = set_stack_length;</span><br><span class="line">    stack_obj->is_full = is_stack_full;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    stack_obj->push = push;</span><br><span class="line">    stack_obj->pop  = pop;</span><br><span class="line">    stack_obj->top = top;</span><br><span class="line">    stack_obj->is_empty = is_stack_empty;</span><br><span class="line">    <span class="keyword">return</span> stack_obj;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_stack</span><span class="params">(Stack *stack_obj)</span></span>{</span><br><span class="line">    <span class="keyword">while</span> (!is_stack_empty(stack_obj)) {</span><br><span class="line">        pop(stack_obj);</span><br><span class="line">    }</span><br><span class="line">    FREE(stack_obj);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-判断是否为空或满"><a href="#3-判断是否为空或满" class="headerlink" title="3. 判断是否为空或满"></a>3. 判断是否为空或满</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> STACK_LIMIT</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">is_stack_full</span><span class="params">(Stack * stack_obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> stack_obj->stack_private.length >= stack_obj->stack_private.max_len;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">is_stack_empty</span><span class="params">(Stack *stack_obj)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> stack_obj->node == <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-设置堆栈最大长度"><a href="#4-设置堆栈最大长度" class="headerlink" title="4. 设置堆栈最大长度"></a>4. 设置堆栈最大长度</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> STACK_LIMIT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_stack_length</span><span class="params">(Stack * stack_obj, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    stack_obj->stack_private.max_len = value;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-push"><a href="#5-push" class="headerlink" title="5. push"></a>5. push</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Stack *stack_obj, STACK_TYPE value)</span></span>{</span><br><span class="line">    StackNode *new_node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> STACK_LIMIT</span></span><br><span class="line">    <span class="keyword">if</span> (is_stack_full(stack_obj)) {</span><br><span class="line">        LOGE(<span class="string">"stack is full,push is error"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    new_node = MALLOC(<span class="number">1</span>, StackNode);</span><br><span class="line">    new_node->value = value;</span><br><span class="line">    new_node->next = stack_obj->node;</span><br><span class="line">    stack_obj->node = new_node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> STACK_LIMIT</span></span><br><span class="line">    stack_obj->stack_private.length++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="6-pop"><a href="#6-pop" class="headerlink" title="6. pop"></a>6. pop</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">STACK_TYPE <span class="title">pop</span><span class="params">(Stack *stack_obj)</span> </span>{</span><br><span class="line">    StackNode *first_node = stack_obj->node;</span><br><span class="line">    <span class="keyword">if</span> (is_stack_empty(stack_obj)) {</span><br><span class="line">        LOGE(<span class="string">"stack is empty,pop is error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    STACK_TYPE rc = first_node->value;</span><br><span class="line">    stack_obj->node = stack_obj->node->next;</span><br><span class="line">    FREE(first_node);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> STACK_LIMIT</span></span><br><span class="line">    stack_obj->stack_private.length--;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>与堆栈类似，这里就不列出来了，具体可以参考我的代码仓库</p>
<blockquote>
<p><code>代码位置</code>：<a href="https://github.com/xiaoqinxing/myrepo_c" target="_blank" rel="noopener">https://github.com/xiaoqinxing/myrepo_c</a></p>
</blockquote>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>c 动态内存分配</title>
    <url>/2019/03/19/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-c-c-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>为什么要使用动态内存分配？函数的局部变量会进行回收，相比于函数的局部变量，有什么好处呢？</p>
</blockquote>
<blockquote>
<p>《c和指针》阅读笔记</p>
</blockquote>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>动态内存分配就是在程序运行的时候去再去申请所需要的内存空间。</p>
<h2 id="malloc-和free"><a href="#malloc-和free" class="headerlink" title="malloc 和free"></a>malloc 和free</h2><p>malloc所分配的是一块连续的内存。并没有进行初始化，要么手动初始化，要么用calloc进行初始化。</p>
<p>注意：如果内存池是空的，或者他的可用内存无法满足你的需要，会返回一个NULL指针，因此对每个从malloc返回的指针进行检查，确保它并非NULL非常重要。</p>
<p>malloc又是如何知道你说请求的内存是整数，浮点还是数组呢？它并不知情，它只是返回了一个void *指针。标准表示一个void *类型的指针可以转换为其他任何类型的指针，但是有些编译器，可能要求你在转换时强制类型转换。</p>
<h2 id="calloc和realloc"><a href="#calloc和realloc" class="headerlink" title="calloc和realloc"></a>calloc和realloc</h2><p>malloc和calloc的主要区别是后者在返回指向内存的指针之前将它初始化为0。另一个小区别是，它们请求内存数量的方式不同，calloc的参数包括所需元素的数量和每个元素的字节数，根据这个值去计算出总共需要分配多少内存。</p>
<p>realloc用于修改一个原先已经分配的内存块的大小。使用这个函数，你可以是一块内存扩大或者缩小。扩大的话，不会对原先的内容有所改变，缩小的话，剩余部分的内容也依然保留。</p>
<p>如果原先的内存块无法改变大小，会将另外分配一个正确大小的内存，并把原先的内存内容复制到新的块上。<strong>因此，使用realloc之后，就不能再使用指向就内存的指针，而是应该改用realloc返回的指针。</strong></p>
<p>如果realloc的第一个参数是NULL，那么和malloc一样。</p>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>对NULL指针进行解引用操作</p>
<p>对分配的内存进行操作是越过边界</p>
<p>释放并非动态分配的内存</p>
<p>试图释放一块动态分配的内存的一部分</p>
<p>一块动态内存被释放后被继续使用</p>
<h1 id="实例测试"><a href="#实例测试" class="headerlink" title="实例测试"></a>实例测试</h1><h2 id="不易发生错误的内存分配器实现"><a href="#不易发生错误的内存分配器实现" class="headerlink" title="不易发生错误的内存分配器实现"></a>不易发生错误的内存分配器实现</h2><p>动态内存分配最常见的错误是忘记检查所请求的内存是否成功分配。下面是一种技巧，可以很可靠的进行这个错误检查。不经过直接调用malloc函数，通过自定义的alloc函数调用malloc，并对malloc进行检查。</p>
<p>这个#define malloc指令，是用于防止由于其他代码块直接调用malloc的行为。增加这个指令后，直接调用malloc将会因为语法错误而无法编译。在alloc.v中必须加入#undef，这样它才能调用malloc而不至于出错。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">**alloc.h</span></span><br><span class="line"><span class="comment">**定义一个不易发生错误的内存分配器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="comment">//不要直接调用malloc!</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC(num, type) (type *)alloc((num) * sizeof(type))</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">alloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">**alloc.c</span></span><br><span class="line"><span class="comment">**不易发生错误的内存分配器的实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"alloc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> malloc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">alloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>{</span><br><span class="line">    <span class="keyword">void</span> *new_mem;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ** 请求所需的内存</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    new_mem = <span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span>(new_mem == <span class="literal">NULL</span>){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"out of memory\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> new_mem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">**a_client.c</span></span><br><span class="line"><span class="comment">**一个使用很少引起错误的内存分配器的程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> *new_memory;</span><br><span class="line">    mew_memory = MALLOC(<span class="number">25</span>,<span class="keyword">int</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当动态内存分配的程序失败时，我们很容易将问题责任推给malloc和free函数，其实往往都是出现在了自己的程序中，而且常常是由于访问了分配内存以外的区域而引起的。</p>
<p>当使用free的时候，可能会出现不同的错误，传递给free的指针必须死一个从malloc，calloc，realloc返回的指针。让free函数释放一块不是动态分配的内存可能导致程序立刻终止或者晚些时候终止。</p>
<p><strong>试图释放一块动态内存的一部分也可能会引起类似问题</strong>。比如说在程序中对指针进行了修改，如自增自减之后，再去free，就可能会出现问题。</p>
<p><strong>必须小心不要访问已经被free函数释放了的内存</strong>。（很容易出现）假设你对一个指向动态分配的内存的指针进行了赋值，而且这个指针的几个拷贝散布于程序各处。<strong>你无法保证当你使用其中一个指针的时候它所指向的内存是不是已经被另一个指针释放。</strong>另一方面，你必须确保程序中所有使用这块内存的地方在这块内存被释放之前停止对它的使用。</p>
<h2 id="内存分配实例"><a href="#内存分配实例" class="headerlink" title="内存分配实例"></a>内存分配实例</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//invendor.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __INVENDOR_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INVENDOR_H__</span></span><br><span class="line"><span class="comment">//定义一个存货记录的声明</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">	<span class="keyword">int</span> cost;</span><br><span class="line">	<span class="keyword">int</span> supplier;</span><br><span class="line">}Partinfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">	<span class="keyword">char</span> partno[<span class="number">20</span>];</span><br><span class="line">	short quan;</span><br><span class="line">}SUBASSYPART;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">	<span class="keyword">int</span> n_parts;</span><br><span class="line">	SUBASSYPART *part;</span><br><span class="line">}Subassyinfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">	<span class="keyword">char</span> partno[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> quan;</span><br><span class="line">	<span class="keyword">enum</span> {PART, SUBASSY}type;</span><br><span class="line">	<span class="keyword">union</span> {</span><br><span class="line">		Partinfo *part;</span><br><span class="line">		Subassyinfo *subassy;</span><br><span class="line">	}info;</span><br><span class="line">}Invrec;</span><br><span class="line"></span><br><span class="line"><span class="function">Invrec *<span class="title">create_subassy_record</span><span class="params">(<span class="keyword">int</span> n_parts)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discard_inventory_record</span><span class="params">(Invrec *record)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !__DATA_TYPE_H__</span></span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">**invrecord.c</span></span><br><span class="line"><span class="comment">**用于创建SUBASSEMBLY存货纪录的函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"invendor.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建存货信息</span></span><br><span class="line"><span class="function">Invrec *<span class="title">create_subassy_record</span><span class="params">(<span class="keyword">int</span> n_parts)</span> </span>{</span><br><span class="line">	Invrec *new_rec;</span><br><span class="line">	<span class="comment">//尝试为Invrec部分分配内存</span></span><br><span class="line">	new_rec = MALLOC(<span class="number">1</span>, Invrec);</span><br><span class="line">	new_rec->info.subassy = MALLOC(<span class="number">1</span>, Subassyinfo);</span><br><span class="line">	new_rec->info.subassy->part = MALLOC(n_parts, SUBASSYPART);</span><br><span class="line">	new_rec->type = SUBASSY;</span><br><span class="line">	new_rec->info.subassy->n_parts = n_parts;</span><br><span class="line">	<span class="keyword">return</span> new_rec;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除存货信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discard_inventory_record</span><span class="params">(Invrec *record)</span> </span>{</span><br><span class="line">	<span class="keyword">switch</span> (record->type) {</span><br><span class="line">	<span class="keyword">case</span> SUBASSY:</span><br><span class="line">		<span class="built_in">free</span>(record->info.subassy->part);</span><br><span class="line">		<span class="built_in">free</span>(record->info.subassy);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PART:</span><br><span class="line">		<span class="built_in">free</span>(record->info.part);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"record type is error"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">free</span>(record);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"invendor.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Invrec *a;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	**注意了，由于动态分配的内存需要释放，如果将这个指针进行了运算</span></span><br><span class="line"><span class="comment">	**free的时候就会出问题，另外如果运算了，其他地方进行引用，也容易</span></span><br><span class="line"><span class="comment">	**出现找错内存块的问题。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	a = create_subassy_record(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">//将参与运算的指针保护起来。</span></span><br><span class="line">	SUBASSYPART *new_part = a->info.subassy->part;</span><br><span class="line">	<span class="built_in">strcpy</span>(new_part->partno,<span class="string">"hello world"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%p\r\n"</span>, new_part);</span><br><span class="line">	new_part++;</span><br><span class="line">	<span class="built_in">strcpy</span>(new_part->partno, <span class="string">"this is my"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%p\r\n"</span>, new_part);</span><br><span class="line">	new_part++;</span><br><span class="line">	<span class="comment">//注意此处如果拷贝的数据超过数组长度，内存溢出</span></span><br><span class="line">	<span class="built_in">strcpy</span>(new_part->partno, <span class="string">"first function"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%p\r\n"</span>, new_part);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s"</span>, new_part->partno);</span><br><span class="line">	discard_inventory_record(a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ok"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>出现过的问题：</p>
<ul>
<li>注意了，由于动态分配的内存需要释放，如果将这个指针进行了运算，free的时候就会出问题，可能<strong>只释放了内存的一部分</strong>。另外如果运算了，其他地方进行引用，也容易内存块<strong>位置偏移</strong>的问题。</li>
<li>用strcpy的时候需要注意不能超出规定的内存范围，注意不能越界访问</li>
</ul>
<p><code>代码位置</code>：<a href="https://github.com/xiaoqinxing/myrepo_c" target="_blank" rel="noopener">https://github.com/xiaoqinxing/myrepo_c</a></p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>c 结构和联合</title>
    <url>/2019/03/19/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-c-c-%E7%BB%93%E6%9E%84%E5%92%8C%E8%81%94%E5%90%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>结构体和联合体的简单介绍</p>
<a id="more"></a>

<blockquote>
<p>《c和指针》阅读笔记</p>
</blockquote>
<h1 id="（一）结构（struct）"><a href="#（一）结构（struct）" class="headerlink" title="（一）结构（struct）"></a>（一）结构（struct）</h1><p>聚合数据类型就是能够同时存储超过一个的单个数据。包括数据和结构，数组是相同类型的集合，结构的各个成员可能有不同的类型。</p>
<p>数组元素可以通过下标访问，这是因为数组的元素长度相同；而结构成员都有自己的名字，大小可能不同，只能通过名字访问的。</p>
<h2 id="结构体声明"><a href="#结构体声明" class="headerlink" title="结构体声明"></a>结构体声明</h2><p><strong>注意：</strong>定义两个结构体的声明，即使他们的成员列表完全相同，也会被当做两种截然不同的类型，因此不能进行赋值或者指针的赋值。</p>
<p><strong>解决方案：</strong>用标签来创建变量，可以用typedef创建一种新的类型。  </p>
<p>只有当两个变量是同一结构体类型，才可以进行赋值或者指向。</p>
<p>如果你想在多个源文件中使用同一种类型的结构体，你应该吧标签声明或者typedef形式的声明放在一个头文件中。当源文件需要这个声明是可以使用#include指令将头文件包含进来。</p>
<h2 id="成员访问"><a href="#成员访问" class="headerlink" title="成员访问"></a>成员访问</h2><p>直接访问，直接访问结构的成员：<strong>.</strong></p>
<p>结合性：从左往右</p>
<p>间接访问，访问变量所指向的结构的成员：<strong>-></strong></p>
<h2 id="自引用"><a href="#自引用" class="headerlink" title="自引用"></a>自引用</h2><p>一个结构体中不可以包含它自身，这样重复包含自己永无止境。</p>
<p>但是可以包含一个指向该结构类型本身的指针。如：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF</span> {</span></span><br><span class="line">    <span class="keyword">int</span>    a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF</span> *<span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">int</span>    c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>它事实上所指向的是<strong>同类型的不同结构</strong>。更加高级的数据结构，如链表和树都是用这个技巧实现的。</p>
<p>注意下面这个是错误的：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">int</span>     a;</span><br><span class="line">    SELF_REF *b;</span><br><span class="line">    <span class="keyword">int</span>     c;</span><br><span class="line">}SELF_REF;</span><br></pre></td></tr></tbody></table></figure>

<p>类型名知道声明的末尾才定义，所以在结构体声明的内部它尚未定义。</p>
<p>应该写成</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF_TAG</span>{</span></span><br><span class="line">    <span class="keyword">int</span>     a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF_TAG</span> *<span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">int</span>     c;</span><br><span class="line">}SELF_REF;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="不完整声明"><a href="#不完整声明" class="headerlink" title="不完整声明"></a>不完整声明</h2><p>偶尔要声明一些互相之间存在依赖的结构，也就是说其中一个结构包含了另一个结构体的一个或者多个成员，那么哪个结构应该首先声明呢？</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> *<span class="title">p</span>;</span></span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">p</span>;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>解决方案是不完整声明，它先声明一个作为结构标签的标识符。然后可以把这个标签用在不需要知道这个结构长度的声明中，如声明指向这个结构体的指针（指针长度都一样）。接下来的声明吧这个标签和成员列表联系在一起。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>用花括号和逗号隔开。如果初始化列表的值不够，剩余的结构成员将使用缺省值进行初始化。</p>
<h2 id="结构的存储分配"><a href="#结构的存储分配" class="headerlink" title="结构的存储分配"></a>结构的存储分配</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALIGH</span>{</span></span><br><span class="line">    <span class="keyword">char</span>  a;</span><br><span class="line">    <span class="keyword">int</span>   b;</span><br><span class="line">    <span class="keyword">char</span>  c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果某个机器的整型值长度为4，并且它的其实存储位置必须要能够被4整除，那么这个结构体的长度为12个字节。因为系统静止编译器在一个结构的其实位置跳过几个字节来满足边界对齐要求，因此所有结构的其实存储位置必须死结构中边界要求最严格的数据类型所要求的位置。</p>
<p><strong>解决方案：</strong>我们可以对结构的成员列表重新排泄，让那些对边界要求最严格的成员首先出现，对边界要求最弱的成员最后出现，可以最大限度的减少因为边界对齐带来的空间损失。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALIGN</span>{</span></span><br><span class="line">    <span class="keyword">int</span>   b;</span><br><span class="line">    <span class="keyword">char</span>  a;</span><br><span class="line">    <span class="keyword">char</span>  c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果需要确定结构体中某个成员的实际位置，应该考虑边界对齐因素的影响，可以使用<strong>offsetof宏</strong>（定义于stddef.h）</p>
<p>offsetof ( type,  member);  表示一个指定成员开始存储的位置距离结构体开始存储的位置偏移几个字节。</p>
<h2 id="作为函数参数的结构"><a href="#作为函数参数的结构" class="headerlink" title="作为函数参数的结构"></a>作为函数参数的结构</h2><p>如果用按值传递的调用方式效率很低，会把结构体中的所有数据复制到堆栈再丢弃。</p>
<p>我们可以用按地址传递的调用方式，只是传递结构体的地址，可以大大提高效率，也节省了内存。</p>
<p>在许多机器中，可以把参数声明为寄存器变量，从而进一步提高指针传递方案的效率。在有些机器上，这种声明在函数的起始部分还需要一条额外的指令，用于吧堆栈中的参数（参数先传递给堆栈）赋值到寄存器，供函数使用。但是如果函数对这个指针的间接访问次数超过两三次，那么使用这种方法所节省的时间将远远高于一条额外指令所花费的时间。</p>
<p>但是这个缺陷是函数会对调用程序的结构变量进行修改。</p>
<p>如果我们不希望如此，可以在函数中使用const关键字来防止这类修改。现在函数原型变成了：</p>
<p><code>void print_rec(register SELF_REF const *trans );</code></p>
<h1 id="（二）位段"><a href="#（二）位段" class="headerlink" title="（二）位段"></a>（二）位段</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>位段的声明和普通的结构成员声明相同，但是有两个例外，位段成员必须声明为int、unsigned int类型。其次，在成员名的后面是一个冒号和整数，这个整数指定该位段所占用的位的数目。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>可移植性程序应该避免使用位段，因为不同的系统，位段可能有不同的结构。</p>
<ol>
<li>int位段被当做有符号数还是无符号书</li>
<li>位段中位的最大数目。许多编译器把位段成员的长度限制在一个整型值的长度以内，所以32位机器上运行的16位可能不能运行。</li>
<li>位段中的成员在内存中是从左往右分配的还是从右往左分配的</li>
<li>当一个声明指定了两个位段，第二个位段比较大，无法容纳于第一个位段剩余的位时，编译器可能吧第二个位段放在内存的下一个字，也可能直接放在第一个位段后面，从而在两个内存位置的边界上形成重叠。</li>
</ol>
<p>是用于控制寄存器的较好的方法。任何可以用位段实现的功能都可以用移位和屏蔽（用与或者非）实现，在源代码中用位段表示这个处理过程更加简单一点，但在目标代码中，这两种方法并不存在任何区别。</p>
<h1 id="（三）联合（union）"><a href="#（三）联合（union）" class="headerlink" title="（三）联合（union）"></a>（三）联合（union）</h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>当你想在不同的时刻把不同的东西存储于同一个位置时，就可以用联合。</p>
<p>一般和自定义的类型连用，如：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VARIABLE</span> {</span></span><br><span class="line">    <span class="keyword">enum</span> {INT, FLOAT, STRING} type;</span><br><span class="line">    <span class="keyword">union</span> {</span><br><span class="line">        <span class="keyword">int</span>   i;</span><br><span class="line">        <span class="keyword">float</span> f;</span><br><span class="line">        <span class="keyword">char</span>  *s;</span><br><span class="line">    }value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在高通的代码中就很常见，通常是一个模块的接口，不同的事件请求 携带不同的数据。</p>
<p><strong>疑问：为何不能不同的事件请求都用相同的data指针，这个data指针根据事件请求指向不同的地址。高通的代码中两种写法都有，是不是如果用union传递可以保护原来的变量不被修改？</strong></p>
<p>在成员长度不同的联合里，分配给联合的内存数量取决于它的最长成员的长度，这样联合的长度总是足以容纳它最大的长远，如果这些成员的长度相差悬殊，节省的空间相当可观。</p>
<p>在这种情况下，更好的方法是：在联合中存储指向不同成员的指针，而不是直接存储成员本身。所有的指针长度都是相同的，这样就解决了内存浪费的问题。</p>
<p><strong>疑问：这样还有必要去声明一个union么？直接定义一个data指针，不同的时候指向不同的地址不就行了么？</strong></p>
<h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><p>可以初始化，但是这个初始值必须是联合第一个成员的类型，而且他必须位于一对花括号里面。</p>
<p>比如定义一个union，第一个成员是int，第二个是float；我们不能把这个变量初始化为一个浮点数或者字符值。如果给出的初始值是其他类型，它可能会转换为int类型，进行使用。</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 网络编程</title>
    <url>/2019/03/19/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-python-python-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的<strong>IP地址</strong>和<strong>端口号</strong>，再指定<strong>协议类型</strong>即可。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 导入socket库:</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个socket:</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 建立连接:</span></span><br><span class="line">s.connect((<span class="string">'www.sina.com.cn'</span>, <span class="number">80</span>))</span><br></pre></td></tr></tbody></table></figure>

<p>创建<code>Socket</code>时，<code>AF_INET</code>指定使用IPv4协议，如果要用更先进的IPv6，就指定为<code>AF_INET6</code>。<code>SOCK_STREAM</code>指定使用面向流的TCP协议，这样，一个<code>Socket</code>对象就创建成功，但是还没有建立连接。</p>
<p>客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。新浪网站的IP地址可以用域名<code>www.sina.com.cn</code>自动转换到IP地址，但是怎么知道新浪服务器的端口号呢？</p>
<p>答案是作为服务器，提供什么样的服务，端口号就必须固定下来。由于我们想要访问网页，因此新浪提供网页服务的服务器必须把端口号固定在<code>80</code>端口，因为<code>80</code>端口是Web服务的标准端口。其他服务都有对应的标准端口号，例如SMTP服务是<code>25</code>端口，FTP服务是<code>21</code>端口，等等。端口号小于1024的是Internet标准服务的端口，端口号大于1024的，可以任意使用。</p>
<p>建立TCP连接后，我们就可以向新浪服务器发送请求，要求返回首页的内容：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 发送数据:</span></span><br><span class="line">s.send(<span class="string">b'GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>TCP连接创建的是双向通道，双方都可以同时给对方发数据。但是谁先发谁后发，怎么协调，要根据具体的协议来决定。例如，HTTP协议规定客户端必须先发请求给服务器，服务器收到后才发数据给客户端。</p>
<p>发送的文本格式必须符合HTTP标准，如果格式没问题，接下来就可以接收新浪服务器返回的数据了：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 接收数据:</span></span><br><span class="line">buffer = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 每次最多接收1k字节:</span></span><br><span class="line">    d = s.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> d:</span><br><span class="line">        buffer.append(d)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">data = <span class="string">b''</span>.join(buffer)</span><br></pre></td></tr></tbody></table></figure>

<p><strong>接收数据时，调用<code>recv(max)</code>方法，一次最多接收指定的字节数，因此，在一个while循环中反复接收，直到<code>recv()</code>返回空数据，表示接收完毕，退出循环。</strong></p>
<p><strong>join函数指的是用指定字符连接生成一个新的字符串，由于这个字符是空，因此就是将list连接，生成新的字符串。</strong></p>
<p>当我们接收完数据后，调用<code>close()</code>方法关闭Socket，这样，一次完整的网络通信就结束了：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭连接:</span></span><br><span class="line">s.close()</span><br></pre></td></tr></tbody></table></figure>

<p><strong>split()</strong> 函数通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串；也就是说第一句是将data分割成两块</p>
<p>接收到的数据包括HTTP头和网页本身，我们只需要把HTTP头和网页分离一下，把HTTP头打印出来，网页内容保存到文件：——http头和网页分离是通过两个\r\n识别的</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">header, html = data.split(<span class="string">b'\r\n\r\n'</span>, <span class="number">1</span>)</span><br><span class="line">print(header.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="comment"># 把接收的数据写入文件:</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'sina.html'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(html)</span><br></pre></td></tr></tbody></table></figure>

<h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><p>和客户端编程相比，服务器编程就要复杂一些。</p>
<p>服务器进程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。</p>
<p>所以，服务器会打开固定端口（比如80）监听，每来一个客户端连接，就创建该Socket连接。由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。</p>
<p>但是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。</p>
<p>我们来编写一个简单的服务器程序，它接收客户端连接，把客户端发过来的字符串加上<code>Hello</code>再发回去。</p>
<h1 id="网页介绍"><a href="#网页介绍" class="headerlink" title="网页介绍"></a>网页介绍</h1><p>安装好Chrome浏览器后，打开Chrome，在菜单中选择“视图”，“开发者”，“开发者工具”，就可以显示开发者工具：</p>
<p><img src="/" class="lazyload" data-src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001399878215246e5c00e9142244698a91c5d558c5901a1000"  alt="chrome-dev-tools"></p>
<p><code>Elements</code>显示网页的结构，<code>Network</code>显示浏览器和服务器的通信。我们点<code>Network</code>，确保第一个小红灯亮着，Chrome就会记录所有浏览器和服务器之间的通信：</p>
<p><img src="/" class="lazyload" data-src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001399878404470cf9e8257a27a4807b856b7dfa23f93a0000"  alt="chrome-devtools-network"></p>
<p>当我们在地址栏输入<code>www.sina.com.cn</code>时，浏览器将显示新浪的首页。在这个过程中，浏览器都干了哪些事情呢？通过<code>Network</code>的记录，我们就可以知道。在<code>Network</code>中，定位到第一条记录，点击，右侧将显示<code>Request Headers</code>，点击右侧的<code>view source</code>，我们就可以看到浏览器发给新浪服务器的请求：</p>
<p><img src="/" class="lazyload" data-src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001399877287994279bc3d41b3040f985e3e8b838211465000"  alt="sina-http-request"></p>
<p>最主要的头两行分析如下，第一行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br></pre></td></tr></tbody></table></figure>

<p><code>GET</code>表示一个读取请求，将从服务器获得网页数据，<code>/</code>表示URL的路径，URL总是以<code>/</code>开头，<code>/</code>就表示首页，最后的<code>HTTP/1.1</code>指示采用的HTTP协议版本是1.1。目前HTTP协议的版本就是1.1，但是大部分服务器也支持1.0版本，主要区别在于1.1版本允许多个HTTP请求复用一个TCP连接，以加快传输速度。</p>
<p>从第二行开始，每一行都类似于<code>Xxx: abcdefg</code>：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Host: www.sina.com.cn</span><br></pre></td></tr></tbody></table></figure>

<p>表示请求的域名是<code>www.sina.com.cn</code>。如果一台服务器有多个网站，服务器就需要通过<code>Host</code>来区分浏览器请求的是哪个网站。</p>
<p>继续往下找到<code>Response Headers</code>，点击<code>view source</code>，显示服务器返回的原始响应数据：</p>
<p><img src="/" class="lazyload" data-src="https://cdn.liaoxuefeng.com/cdn/files/attachments/0013998772979993bf20079a3d8452f9b44f9ec88f8a5c8000"  alt="sina-http-response"></p>
<p>HTTP响应分为Header和Body两部分（Body是可选项），我们在<code>Network</code>中看到的Header最重要的几行如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">200 OK</span><br></pre></td></tr></tbody></table></figure>

<p><code>200</code>表示一个成功的响应，后面的<code>OK</code>是说明。失败的响应有<code>404 Not Found</code>：网页不存在，<code>500 Internal Server Error</code>：服务器内部出错，等等。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Content-Type: text/html</span><br></pre></td></tr></tbody></table></figure>

<p><code>Content-Type</code>指示响应的内容，这里是<code>text/html</code>表示HTML网页。请注意，浏览器就是依靠<code>Content-Type</code>来判断响应的内容是网页还是图片，是视频还是音乐。浏览器并不靠URL来判断响应的内容，所以，即使URL是<code>http://example.com/abc.jpg</code>，它也不一定就是图片。</p>
<p>HTTP响应的Body就是HTML源码，我们在菜单栏选择“视图”，“开发者”，“查看网页源码”就可以在浏览器中直接查看HTML源码：</p>
<p><img src="/" class="lazyload" data-src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001399877306431ffee0ff7d3fe48bb88da759bb977c1e0000"  alt="sina-http-source"></p>
<p>当浏览器读取到新浪首页的HTML源码后，它会解析HTML，显示页面，然后，根据HTML里面的各种链接，再发送HTTP请求给新浪服务器，拿到相应的图片、视频、Flash、JavaScript脚本、CSS等各种资源，最终显示出一个完整的页面。所以我们在<code>Network</code>下面能看到很多额外的HTTP请求。</p>
<h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p>跟踪了新浪的首页，我们来总结一下HTTP请求的流程：</p>
<p>步骤1：浏览器首先向服务器发送HTTP请求，请求包括：</p>
<p>方法：GET还是POST，GET仅请求资源，POST会附带用户数据；</p>
<p>路径：/full/url/path；</p>
<p>域名：由Host头指定：Host: <a href="http://www.sina.com.cn" target="_blank" rel="noopener">www.sina.com.cn</a></p>
<p>以及其他相关的Header；</p>
<p>如果是POST，那么请求还包括一个Body，包含用户数据。</p>
<p>步骤2：服务器向浏览器返回HTTP响应，响应包括：</p>
<p>响应代码：200表示成功，3xx表示重定向，4xx表示客户端发送的请求有错误，5xx表示服务器端处理时发生了错误；</p>
<p>响应类型：由Content-Type指定；</p>
<p>以及其他相关的Header；</p>
<p>通常服务器的HTTP响应会携带内容，也就是有一个Body，包含响应的内容，网页的HTML源码就在Body中。</p>
<p>步骤3：如果浏览器还需要继续向服务器请求其他资源，比如图片，就再次发出HTTP请求，重复步骤1、2。</p>
<p>Web采用的HTTP协议采用了非常简单的请求-响应模式，从而大大简化了开发。当我们编写一个页面时，我们只需要在HTTP请求中把HTML发送出去，不需要考虑如何附带图片、视频等，浏览器如果需要请求图片和视频，它会发送另一个HTTP请求，因此，一个HTTP请求只处理一个资源。</p>
<p>HTTP协议同时具备极强的扩展性，虽然浏览器请求的是<code>http://www.sina.com.cn/</code>的首页，但是新浪在HTML中可以链入其他服务器的资源，比如<code> class="lazyload" data-src="http://i1.sinaimg.cn/home/2013/1008/U8455P30DT20131008135420.png" <img src="/"></code>，从而将请求压力分散到各个服务器上，并且，一个站点可以链接到其他站点，无数个站点互相链接起来，就形成了World Wide Web，简称WWW。</p>
<h3 id="HTTP格式"><a href="#HTTP格式" class="headerlink" title="HTTP格式"></a>HTTP格式</h3><p>每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分，其中Body是可选的。</p>
<p>HTTP协议是一种文本协议，所以，它的格式也非常简单。HTTP GET请求的格式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">GET /path HTTP/1.1</span><br><span class="line">Header1: Value1</span><br><span class="line">Header2: Value2</span><br><span class="line">Header3: Value3</span><br></pre></td></tr></tbody></table></figure>

<p>每个Header一行一个，换行符是<code>\r\n</code>。</p>
<p>HTTP POST请求的格式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">POST /path HTTP/1.1</span><br><span class="line">Header1: Value1</span><br><span class="line">Header2: Value2</span><br><span class="line">Header3: Value3</span><br><span class="line"></span><br><span class="line">body data goes here...</span><br></pre></td></tr></tbody></table></figure>

<p>当遇到连续两个<code>\r\n</code>时，Header部分结束，后面的数据全部是Body。</p>
<p>HTTP响应的格式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">200 OK</span><br><span class="line">Header1: Value1</span><br><span class="line">Header2: Value2</span><br><span class="line">Header3: Value3</span><br><span class="line"></span><br><span class="line">body data goes here...</span><br></pre></td></tr></tbody></table></figure>

<p>HTTP响应如果包含body，也是通过<code>\r\n\r\n</code>来分隔的。请再次注意，Body的数据类型由<code>Content-Type</code>头来确定，如果是网页，Body就是文本，如果是图片，Body就是图片的二进制数据。</p>
<p>当存在<code>Content-Encoding</code>时，Body数据是被压缩的，最常见的压缩方式是gzip，所以，看到<code>Content-Encoding: gzip</code>时，需要将Body数据先解压缩，才能得到真正的数据。压缩的目的在于减少Body的大小，加快网络传输。</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>手动快门增益功能实现</title>
    <url>/2019/03/14/%E5%B7%A5%E4%BD%9C-%E7%BC%96%E7%A8%8B-%E6%89%8B%E5%8A%A8%E5%BF%AB%E9%97%A8%E5%A2%9E%E7%9B%8A%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>如何实现手动设置快门和增益？<br>如何避免因为不同的数据流在不同的地方设置增益和快门？</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>拍照和预览设置增益可能会发生改变，如果用手动AE也可能出问题。最好的地方是他们共用的地方，可以想到的是sensor模块，sensor模块是和硬件最密切的，在这里可以进行寄存器的设置。我们找到不论何种模式都会进行设置的地方进行修改就行了。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>拿imx290举例，它的常用寄存器地址和函数是在imx290_lib.h中定义的。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">sensor_lib_t</span> sensor_lib_ptr =</span><br><span class="line">{</span><br><span class="line">    .sensor_slave_info =</span><br><span class="line">    {</span><br><span class="line">        .sensor_name    = SENSOR_MODEL,</span><br><span class="line">        .slave_addr     = <span class="number">0x34</span>,</span><br><span class="line">        .i2c_freq_mode  = SENSOR_I2C_MODE_FAST,</span><br><span class="line">        .addr_type      = CAMERA_I2C_WORD_ADDR,</span><br><span class="line">        .sensor_id_info =</span><br><span class="line">        {</span><br><span class="line">            .sensor_id_reg_addr = <span class="number">0x301E</span>, <span class="comment">// a fake id register</span></span><br><span class="line">            .sensor_id          = <span class="number">0xB201</span>, <span class="comment">// a fixed value</span></span><br><span class="line">        }</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这是对结构体的乱序赋值，既能初始化时赋值，也可以不考虑顺序。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">.exposure_func_table =</span><br><span class="line">    {</span><br><span class="line">        .sensor_calculate_exposure  = sensor_calculate_exposure,</span><br><span class="line">        .sensor_fill_exposure_array = sensor_fill_exposure_array,</span><br><span class="line">    },</span><br></pre></td></tr></tbody></table></figure>
<p>仔细看其中，会发现这个结构体里还有函数方法。而这个函数就是具体不同型号中对寄存器的操作，就比如写入增益寄存器，可能存在有的有一个字节，有的需要两个字节。给一个相同的函数入口，其实就是实现了面向对象编程中的多态。</p>
<p>我们需要修改的是写入sensor的增益和快门，因此越接近底层越不容易出现问题，比如避免因为预览和拍照流的参数位置不同造成的影响。</p>
<p><code>sensor_fill_exposure_array</code>函数是对曝光类寄存器进行操作，<br>由于<code>sensor_fill_exposure_array</code>是对曝光表的直接寄存器操作，因此可以说是最底层了，但是不同的sensor这个函数的内容也不一样，因此我们需要先找到调用它的函数。</p>
<p>我们可以看到sensor模块中的<code>sensor_apply_exposure</code>和<code>sensor_set_exposure</code>函数不仅仅是在sensor aec的init中进行调用，还有双摄，从摄，手动AE，自动AE的设置，可以说它是所有数据流设置曝光增益流程的必经之处。</p>
<p>在<code>sensor_apply_exposure</code>中会对aec的最大曝光行最大增益等进行判断，保证不会超过lib.h的限制之后，然后通过<code>sensor_fill_exposure_array</code>写入。不希望我们写入的值超过了sensor的设置，因此我们最好在apply函数之前，也就是<code>sensor_set_exposure</code>函数之后进行修改。</p>
<p>在<code>sensor_calculate_exposure</code>函数中，将增益转换成了可以写入寄存器的整型，因此我们也不要动，在<code>sensor_calculate_exposure</code>之前进行修改，同时又尽可能的少，就选择在<code>sensor_set_exposure</code>函数里的<code>sensor_calculate_exposure</code>对曝光和增益进行修改。</p>
<p>让人吐血的是，这里已经有高通的设置了。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_MANUAL_EXPOSURE_UPDATE</span></span><br><span class="line">  <span class="keyword">if</span>(updateExtGain(&ext_real_gain) == SENSOR_SUCCESS)</span><br><span class="line">    real_gain = ext_real_gain;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(updateExtLinecount(&ext_linecount) == SENSOR_SUCCESS)</span><br><span class="line">    linecount = ext_linecount;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int32_t</span> <span class="title">updateExtGain</span><span class="params">(<span class="keyword">float</span> *real_gain)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">char</span> ext_real_gain[PROPERTY_VALUE_MAX];</span><br><span class="line"></span><br><span class="line">  RETURN_ERROR_ON_NULL(real_gain);</span><br><span class="line"></span><br><span class="line">  property_get(<span class="string">"persist.camera.sensor.gain"</span>, ext_real_gain, <span class="string">"0"</span>);</span><br><span class="line">  *real_gain = atoi(ext_real_gain);</span><br><span class="line">  <span class="keyword">if</span> (*real_gain > <span class="number">0</span>) {</span><br><span class="line">    SERR(<span class="string">"Updated gain: %f"</span>, *real_gain);</span><br><span class="line">    <span class="keyword">return</span> SENSOR_SUCCESS;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SENSOR_FAILURE;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int32_t</span> <span class="title">updateExtLinecount</span><span class="params">(<span class="keyword">uint32_t</span> *linecount)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">char</span> ext_linecount[PROPERTY_VALUE_MAX];</span><br><span class="line"></span><br><span class="line">  RETURN_ERROR_ON_NULL(linecount);</span><br><span class="line"></span><br><span class="line">  property_get(<span class="string">"persist.camera.sensor.linecount"</span>, ext_linecount, <span class="string">"0"</span>);</span><br><span class="line">  *linecount = atoi(ext_linecount);</span><br><span class="line">  <span class="keyword">if</span> (*linecount > <span class="number">0</span>) {</span><br><span class="line">    SERR(<span class="string">"Updated linecount: %d"</span>, *linecount);</span><br><span class="line">    <span class="keyword">return</span> SENSOR_SUCCESS;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SENSOR_FAILURE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是将<code>ENABLE_MANUAL_EXPOSURE_UPDATE</code>定义一下，去修改<code>persist.camera.sensor.gain</code>和<code>persist.camera.sensor.linecount</code>，没有发现图像有明显变化。</p>
<p>发现赋值过去的real_gain和linecount两个变量根本没有用到，没有进行设置，于是将</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* 修改前   </span></span><br><span class="line"><span class="comment">   lib->sensor_lib_ptr->exposure_func_table.sensor_calculate_exposure(</span></span><br><span class="line"><span class="comment">       exposure.real_gain, exposure.linecount, &exp_info, &exposure.hdr_exposure);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    lib->sensor_lib_ptr->exposure_func_table.sensor_calculate_exposure(</span><br><span class="line">       real_gain, linecount, &exp_info, &exposure.hdr_exposure);</span><br></pre></td></tr></tbody></table></figure>
<p>对比660设备的代码，发现660代码进行了设置。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (lib->sensor_lib_ptr->exposure_func_table.calc_exp_array_type ==</span><br><span class="line">  CALC_CUSTOM_IN_LIB &&</span><br><span class="line">  lib->sensor_lib_ptr->exposure_func_table.sensor_calculate_exposure) {</span><br><span class="line">  lib->sensor_lib_ptr->exposure_func_table.sensor_calculate_exposure(</span><br><span class="line">     real_gain, linecount, &exp_info, exposure.s_real_gain);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  sensor_cmn_calc_exposure(lib->sensor_lib_ptr,</span><br><span class="line">    real_gain, linecount, &exp_info, exposure.s_real_gain);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里应该是高通之前代码的错误，并没有像手册一样实现手动控制增益的功能。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/1552546053938.png"  alt></p>
<h2 id="功能叙述"><a href="#功能叙述" class="headerlink" title="功能叙述"></a>功能叙述</h2><p><code>persist.camera.sensor.gain</code>用来设置手动增益，默认是整数，我改成了浮点数，方便去细调。如果不设置或者设置为0,则增益是自动</p>
<p><code>persist.camera.sensor.linecount</code>用来设置手动快门，需要是整数，同样不进行设置或者设置为0，快门是自动。</p>
<p><strong>注意：</strong> 8056平台不适用这套代码逻辑</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>手动增益实现</tag>
        <tag>sensor模块</tag>
      </tags>
  </entry>
  <entry>
    <title>sensor模块代码理解及学习</title>
    <url>/2019/03/13/%E5%B7%A5%E4%BD%9C-%E7%BC%96%E7%A8%8B-sensor%E6%A8%A1%E5%9D%97%E5%8C%BA%E5%88%86%E4%B8%8D%E5%90%8C%E5%9E%8B%E5%8F%B7%E7%9A%84%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>sensor模块如何识别不同的设备和型号？如何选用相应型号的头文件？</p>
</blockquote>
<p>拿imx290举例，它的常用寄存器地址和函数是在imx290_lib.h中定义的。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">sensor_lib_t</span> sensor_lib_ptr =</span><br><span class="line">{</span><br><span class="line">    .sensor_slave_info =</span><br><span class="line">    {</span><br><span class="line">        .sensor_name    = SENSOR_MODEL,</span><br><span class="line">        .slave_addr     = <span class="number">0x34</span>,</span><br><span class="line">        .i2c_freq_mode  = SENSOR_I2C_MODE_FAST,</span><br><span class="line">        .addr_type      = CAMERA_I2C_WORD_ADDR,</span><br><span class="line">        .sensor_id_info =</span><br><span class="line">        {</span><br><span class="line">            .sensor_id_reg_addr = <span class="number">0x301E</span>, <span class="comment">// a fake id register</span></span><br><span class="line">            .sensor_id          = <span class="number">0xB201</span>, <span class="comment">// a fixed value</span></span><br><span class="line">        }</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这是对结构体的乱序赋值，既能初始化时赋值，也可以不考虑顺序。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">.exposure_func_table =</span><br><span class="line">    {</span><br><span class="line">        .sensor_calculate_exposure  = sensor_calculate_exposure,</span><br><span class="line">        .sensor_fill_exposure_array = sensor_fill_exposure_array,</span><br><span class="line">    },</span><br></pre></td></tr></tbody></table></figure>
<p>仔细看其中，会发现这个结构体里还有函数方法。而这个函数就是具体不同型号中对寄存器的操作，就比如写入增益寄存器，可能存在有的有一个字节，有的需要两个字节。给一个相同的函数入口，其实就是实现了面向对象编程中的多态。</p>
<p>我们需要修改的是写入sensor的增益和快门，因此越接近底层越不容易出现问题，比如避免因为预览和拍照流的参数位置不同造成的影响。</p>
<p><code>sensor_fill_exposure_array</code>函数是对曝光类寄存器进行操作，</p>
<p>在头文件中初始化如何引用？不是说变量不要在头文件中初始化么？<br>虽然在代码中好像使用了相同的变量，但是实际上使用的是不同的变量，在每个源文件中都有单独的变量。所以，在头文件中定义static变量会造成变量多次定义，造成内存空间的浪费，而且也不是真正的全局变量。应该避免使用这种定义方式。<br>先假定为声明，多次声明是没错的，最后才是定义<br>问：</p>
<p>一般来说，静态全局变量只应该定义在实现文件中，但有时由于一些特殊的目的，也可能定义在头文件中。比如在有些标准库的实现中，就用这种方法来初始化标准流cin, cout，或者在在tr1库中，也用这种方法来定义占位符。每一个包含该头文件的实现文件中都拥有该变量的一份拷贝，这些变量放在运行体的data段或者bss段。<br>比如下面这个变量定义在一个头文件中：<br>static int data[1024*1024];<br>我把这个文件同时包含在几个cpp文件中，按我的理解，这个程序占用的内存应该显著增大，但是，从实际运行结果来看，并没有变化，生成的exe文件大小也没有变化，这是因为延迟加载呢，还是被编译器优化掉了？有没有明白的达人解释一下。</p>
<p>答：<br>这不是编译器的问题，而是OS的virtual memeory管理机制导致的。数据在实际使用之前，是不会占用内存的——缺页异常处理程序会为数据分配需要的内存。</p>
<p>要理解static，就必须要先理解另一个与之相对的关键字，很多人可能都还不知道有这个关键字，那就是auto，其实我们通常声明的不用static修饰的变量，都是auto的，因为它是默认的，就象short和long总是默认为int一样；我们通常声明一个变量：<br>int a;<br>string s;<br>其实就是：<br>auto int a;<br>auto string s;<br>而static变量的声明是：<br>static int a;<br>static string s;<br>这样似乎可以更有利于理解auto和static是一对成对的关键字吧，就像private，protected，public一样；<br>对于static的不理解，其实就是对于auto的不理解，因为它是更一般的；有的东西你天天在用，但未必就代表你真正了解它；auto的含义是由程序自动控制变量的生存周期，通常指的就是变量在进入其作用域的时候被分配，离开其作用域的时候被释放；而static就是不auto，变量在程序初始化时被分配，直到程序退出前才被释放；也就是static是按照程序的生命周期来分配释放变量的，而不是变量自己的生命周期；所以，像这样的例子：<br>void func()<br>{<br>int a;<br>static int b;<br>}<br>每一次调用该函数，变量a都是新的，因为它是在进入函数体的时候被分配，退出函数体的时候被释放，所以多个线程调用该函数，都会拥有各自独立的变量a，因为它总是要被重新分配的；而变量b不管你是否使用该函数，在程序初始化时就被分配的了，或者在第一次执行到它的声明的时候分配（不同的编译器可能不同），所以多个线程调用该函数的时候，总是访问同一个变量b，这也是在多线程编程中必须注意的！ </p>
<p>只在cpp内有效的全局变量：<br>在cpp文件的全局范围内声明：<br>static int g_ = 0;<br>这个变量的含义是在该cpp内有效，但是其他的cpp文件不能访问这个变量；如果有两个cpp文件声明了同名的全局静态变量，那么他们实际上是独立的两个变量；<br>如果不使用static声明全局变量：<br>int g_ = 0;<br>那么将无法保证这个变量不被别的cpp共享，也无法保证一定能被别的cpp共享，因为要让多个cpp共享一个全局变量，应将它声明为extern（外部）的；也有可能编译会报告变量被重复定义；总之不建议这样的写法，不明确这个全局变量的用法；<br>如果在一个头文件中声明：<br>static int g_vaule = 0;<br>那么会为每个包含该头文件的cpp都创建一个全局变量，但他们都是独立的；所以也不建议这样的写法，一样不明确需要怎样使用这个变量，因为只是创建了一组同名而不同作用域的变量。<br>这里顺便说一下如何声明所有cpp可共享的全局变量，在头文件里声明为extern的：<br>extern int g_; // 注意，不要初始化值！<br>然后在其中任何一个包含该头文件的cpp中初始化（一次）就好：<br>int g_ = 0; // 初始化一样不要extern修饰，因为extern也是声明性关键字；<br>然后所有包含该头文件的cpp文件都可以用g_这个名字访问相同的一个变量； </p>
<p>也就是说在头文件中定义变量，调用一次其实就会创建一个新变量。那么这个的好处是什么呢？为什么不放在C语言中呢？</p>
<p>利用<code>sensor_open_lib</code>函数传递相应设备的结构体（包含方法和变量），但是他是如何引用？</p>
<p>在sensor.c中的<code>sensor_load_library</code>函数中用到了<code>sensor_open_lib</code>;也就是说在这个地方进行了调用。从此函数可以看出来是根据sensor的名字进行调用。</p>
<p>把容易变化的放在动态库中，</p>
<p>注意：sensor_lib.h</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">  <span class="comment">/** Tells the way the gain is computed and how gain and exposure are applied</span></span><br><span class="line"><span class="comment">   fill_exp_array_type     -> Mentions how exposure and gain api is implemented</span></span><br><span class="line"><span class="comment">   calc_exp_array_type     -> Mentions how gain is calculated</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  fill_exp fill_exp_array_type;</span><br><span class="line">  calc_exp calc_exp_array_type;</span><br><span class="line">  <span class="comment">/** Function to calculate exosure based on real gain and</span></span><br><span class="line"><span class="comment">   *  linecount value, 1st param - real gain, 2nd param -</span></span><br><span class="line"><span class="comment">   *  linecount, 3rd param - exposure info output, return staus -</span></span><br><span class="line"><span class="comment">   *  success / failure */</span></span><br><span class="line">  <span class="keyword">int</span> (*sensor_calculate_exposure) (<span class="keyword">float</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>,</span><br><span class="line">    <span class="keyword">sensor_exposure_info_t</span> *, <span class="keyword">float</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Function to create register table from exposure settings</span></span><br><span class="line"><span class="comment">   * input param1 - register gain value</span></span><br><span class="line"><span class="comment">   * input param2 - digital gain value</span></span><br><span class="line"><span class="comment">   * input param3 - coarse integration time value</span></span><br><span class="line"><span class="comment">   * input param4 - frame length line value</span></span><br><span class="line"><span class="comment">   * input param5 - hdr luma</span></span><br><span class="line"><span class="comment">   * input param6 - hdr param</span></span><br><span class="line"><span class="comment">   * input param7 - register settings</span></span><br><span class="line"><span class="comment">   * return value - 0 for success and negative value for</span></span><br><span class="line"><span class="comment">   * failure **/</span></span><br><span class="line">  <span class="keyword">int</span> (*sensor_fill_exposure_array)(<span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>,</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>, struct camera_i2c_reg_setting *,</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">} <span class="keyword">sensor_exposure_table_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sensor_calculate_exposure</span><span class="params">(<span class="keyword">float</span> real_gain,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">unsigned</span> <span class="keyword">int</span> line_count, <span class="keyword">sensor_exposure_info_t</span> *exp_info, <span class="keyword">float</span> s_real_gain)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sensor_fill_exposure_array</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gain,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">unsigned</span> <span class="keyword">int</span> digital_gain, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">line</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">unsigned</span> <span class="keyword">int</span> fl_lines, <span class="keyword">int</span> luma_avg, <span class="keyword">unsigned</span> <span class="keyword">int</span> hdr_param,</span></span></span><br><span class="line"><span class="function"><span class="params">  struct camera_i2c_reg_setting* reg_setting,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">unsigned</span> <span class="keyword">int</span> s_reg_gain, <span class="keyword">int</span> s_linecount, <span class="keyword">int</span> is_hdr_enabled)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>结构体中的函数指针和函数名相同，并没直接引用。而是在imx290_lib.h文件中进行了引用。</p>
<p>.exposure_func_table =<br>    {<br>        .sensor_calculate_exposure  = sensor_calculate_exposure,<br>        .sensor_fill_exposure_array = sensor_fill_exposure_array,<br>    },</p>
<p>其实这两者虽然名字相同，但是并没有进行对应。结构体中的int(*p)（int,int)其实就是定义的一个函数。我觉得虽然加了括号，但是其实本质还是定义了一个指针，交代了指向的区域是什么类型。是否这个括号是必须的？</p>
<p>*p[4] 是一个指针数组，首先它是一个数组，数组中存的是指针，存指针的数组。<br>(*q)[4] 是数组指针，加括号先与 *结合，它是一个指针，指向一个第一维包含2个元素的2维数组，存数组地址的指针。</p>
<p>也就是说int(*p)（int,int)是一个函数指针，p指向这个函数。</p>
<p>当引用的时候可以直接把函数指针p当做函数名耐用，也可以用*p。</p>
<p><strong>注意区分：</strong></p>
<table>
<thead>
<tr>
<th>声明</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>int p(int);</td>
<td>简单的使用名字调用函数P,但是执行过程可能和我想象的不太一样，函数名p首先转换为一个函数指针，该指针指定函数在内存中的位置。然后函数调用操作符调用该函数，执行开始于这个地址的代码。</td>
</tr>
<tr>
<td>int  *p();</td>
<td>声明和普通的表达式在求值所用的规则相同。首先执行的是函数调用操作符()，因为它的优先级高于间接访问操作符*；因此p是一个函数，它的返回类型是一个整型的指针。</td>
</tr>
<tr>
<td>int (*p)();</td>
<td>第二队括号是函数调用操作符，第一对括号迫使间接访问在函数调用之前进行，使f成为一个函数指针，他所指向的函数返回一个整型值。</td>
</tr>
<tr>
<td>int *(*p)();</td>
<td>p是一个函数指针，所指向的函数的返回值是一个整型指针。</td>
</tr>
</tbody></table>
<p>​       </p>
<p>刚刚看到一个有意思的问题：float可以表示的数范围大的多，那么float是否能比int表示更多不同的值呢？</p>
<p>答案是否定的，float和int长度一样，这就代表他们能够表示的不同的值的数量是相同的，但是在绝大多数浮点系统中，这个答案是错误的，0通常有很多种表示形式，而且通过使用不规范的小数形式，其他值也具有多种不同的表示形式。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *(*sensor_open_lib)(<span class="keyword">void</span>) = <span class="literal">NULL</span>;<span class="comment">//初始化声明</span></span><br><span class="line">*(<span class="keyword">void</span> **)&sensor_open_lib = dlsym(sensor_lib_params->sensor_lib_handle,</span><br><span class="line">    open_lib_str);<span class="comment">//赋值</span></span><br><span class="line">sensor_lib_params->sensor_lib_ptr = (<span class="keyword">sensor_lib_t</span> *)sensor_open_lib();<span class="comment">//调用</span></span><br></pre></td></tr></tbody></table></figure>

<p>但是这么多指针什么意思需要考虑一下</p>
<p>由于<code>sensor_fill_exposure_array</code>是对曝光表的直接寄存器操作，因此可以说是最底层了，但是不同的sensor这个函数的内容也不一样，因此我们需要先找到调用它的函数。</p>
<p>我们可以看到sensor模块中的``sensor_apply_exposure<code>和</code>sensor_set_exposure`函数不仅仅是在sensor aec的init中进行调用，还有双摄，从摄，手动AE，自动AE的设置，可以说它是所有数据流设置曝光增益流程的必经之处。</p>
<p>在<code>sensor_apply_exposure</code>中会对aec的最大曝光行最大增益等进行判断，保证不会超过lib.h的限制之后，然后通过<code>sensor_fill_exposure_array</code>写入。不希望我们写入的值超过了sensor的设置，因此我们最好在apply函数之前，也就是<code>sensor_set_exposure</code>函数之后进行修改。</p>
<p>在<code>sensor_calculate_exposure</code>函数中，将增益转换成了可以写入寄存器的整型，因此我们也不要动，在<code>sensor_calculate_exposure</code>之前进行修改，同时又尽可能的少，就选择在<code>sensor_set_exposure</code>函数里的<code>sensor_calculate_exposure</code>对曝光和增益进行修改。</p>
<p>让人吐血的是，这里已经有高通的设置了。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_MANUAL_EXPOSURE_UPDATE</span></span><br><span class="line">  <span class="keyword">if</span>(updateExtGain(&ext_real_gain) == SENSOR_SUCCESS)</span><br><span class="line">    real_gain = ext_real_gain;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(updateExtLinecount(&ext_linecount) == SENSOR_SUCCESS)</span><br><span class="line">    linecount = ext_linecount;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>但是将<code>ENABLE_MANUAL_EXPOSURE_UPDATE</code>定义一下，发现并没有出现问题。</p>
<p>但是会有一个问题，打印可能不会显示。</p>
<p>typedef 允许为各种数据类型定义新名字。typedef声明的写法和普通的声明基本相同，只是把typedef这个关键字出现在了声明前面。</p>
<p>如：char  *ptr;代表ptr声明为一个指向字符的指针。加上typedef之后：</p>
<p>typedef char  *ptr;把标识符ptr作为指向字符类型的指针类型的新名字。</p>
<p>ptr a;就是声明a是一个指向字符的指针。</p>
<p>一直以为typedef和define类似，走进了这个误区。</p>
<p>可以在sensor_load_library看到通过sensor name加载不同的动态库。<br>又是如何确定sensor name呢？<br>通过sebsor_probe调用，又被init_xml_probe函数通过xml文件，配置相应的sensor及chromatix。<br>#define CONFIG_XML_SYSTEM_PATH “/system/etc/camera/“<br>进入/system/etc/camera/会发现几个文件：camera_config.xml csidtg_camera.xml csidtg_chromatix.xml imx290_chromatix.xml<br>这就代表了这个用的是290的sensor</p>
<p>可是你会发现在文件夹media-controller\modules\sensors\configs中，xml文件又有很多很多，每个设备都有对应的xml</p>
<p>那么又是如何区分的呢？</p>
<p>media-controller/modules/sensors/configs/Android.mk文件中</p>
<p>LOCAL_SRC_FILES代表着根据不同的设备选用不同的xml文件</p>
<p><img src="/" class="lazyload" data-src="/2019/03/13/%E5%B7%A5%E4%BD%9C-%E7%BC%96%E7%A8%8B-sensor%E6%A8%A1%E5%9D%97%E5%8C%BA%E5%88%86%E4%B8%8D%E5%90%8C%E5%9E%8B%E5%8F%B7%E7%9A%84%E9%80%BB%E8%BE%91/../../../Users/keda/Pictures/photo/1553493767329.png"  alt></p>
<p>看xml文件，里面交代了每个sensor的名字，以及镜头，视场角等信息，</p>
<p>xml里面还有HWID，每个HWID对应了不同的sensor和chromatix文件</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>手动增益实现</tag>
        <tag>sensor模块</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile基础和编译模板</title>
    <url>/2019/03/13/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-c-makefile%E7%BC%96%E8%AF%91%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>如何进行Makefile的编写？<br>如何编译动态库？<br>如何引用动态库？</p>
</blockquote>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="Makefile-gcc的参数"><a href="#Makefile-gcc的参数" class="headerlink" title="Makefile gcc的参数"></a>Makefile gcc的参数</h2><p>-Wall： 是打开警告开关，</p>
<p>-O：    代表默认优化，可选：-O0不优化，-O1低级优化，-O2中级优化，-O3高级优化，-Os代码空间优化。</p>
<p>-g：     是生成调试信息，生成的可执行文件具有和源代码关联的可调试的信息。 </p>
<p>-I（大写的i）：代表后面跟的目录为第一个寻找<strong>头文件</strong>的目录</p>
<p>-L：     代表后面跟的目录为第一个寻找<strong>库文件</strong>的目录</p>
<p>-l（小写的L）：表示libxxx.so<strong>库文件</strong></p>
<p>-static：  静态编译的</p>
<p>-c（小写）：    只编译，不链接</p>
<p>-C（大写）：   切换到指定目录再执行 make 过程，makefile 在这个指定目录里面，然后返回到当前目录继续读入、执行当前的Makefile。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">gcc -o hello hello.c -I /home/hello/include -L /home/hello/lib -lworld</span><br><span class="line"></span><br><span class="line">上面这句表示在编译hello.c时：</span><br><span class="line"></span><br><span class="line">-I /home/hello/include表示将/home/hello/include目录作为第一个寻找头文件的目录，寻找的顺序是：/home/hello/include-->/usr/include-->/usr/local/include</span><br><span class="line"></span><br><span class="line">-L /home/hello/lib表示将/home/hello/lib目录作为第一个寻找库文件的目录，寻找的顺序是：/home/hello/lib-->/lib-->/usr/lib-->/usr/local/lib</span><br><span class="line"></span><br><span class="line">-lworld表示在上面的lib的路径中寻找libworld.so动态库文件（如果gcc编译选项中加入了“-static”表示寻找libworld.a静态库文件）</span><br></pre></td></tr></tbody></table></figure>

<h1 id="android-mk"><a href="#android-mk" class="headerlink" title="android.mk"></a>android.mk</h1><p>官方介绍：<a href="http://android.mk/" target="_blank" rel="noopener">http://android.mk/</a></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>可以生成一下几个类别：</p>
<table>
<thead>
<tr>
<th>JAVA代码的</th>
<th>C/C++代码的</th>
</tr>
</thead>
<tbody><tr>
<td>JAR包</td>
<td>二进制可执行文件：ELF (BUILD_EXECUTABLE)</td>
</tr>
<tr>
<td>应用程序：APK</td>
<td>动态库：.so　　         (BUILD_SHARED_LIBRARY)</td>
</tr>
<tr>
<td></td>
<td>静态库：.a                (BUILD_STATIC_LIBRARY)</td>
</tr>
</tbody></table>
<p>常用的变量：</p>
<table>
<thead>
<tr>
<th><code>名字</code></th>
<th>含义</th>
<th>常用的方式</th>
</tr>
</thead>
<tbody><tr>
<td><code>LOCAL_PATH</code></td>
<td>当前模块的相对路径</td>
<td>LOCAL_PATH := $(call my-dir)</td>
</tr>
<tr>
<td><code>LOCAL_MODULE</code></td>
<td>编译生成的目标名称</td>
<td>LOCAL_MODULE := test</td>
</tr>
<tr>
<td>LOCAL_SRC_FILES</td>
<td>编译该模块需要的源文件</td>
<td>LOCAL_SRC_FILES := test.c</td>
</tr>
<tr>
<td>LOCAL_C_INCLUDES</td>
<td>包含C的头文件目录</td>
<td></td>
</tr>
<tr>
<td>LOCAL_SHARED_LIBRARIES</td>
<td>导入共享库</td>
<td>LOCAL_SHARED_LIBRARIES += liblog</td>
</tr>
</tbody></table>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hejin@desk-ubuntu:/home/desk/myandroid$ ls external/test/</span><br><span class="line">Android.mk  test2.c  test2.h  test.c</span><br></pre></td></tr></tbody></table></figure>



<p>分别查看四个源文件的内容：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hejin@desk-ubuntu:/home/desk/myandroid$ cat external/test/test.c</span><br><span class="line">#include "stdio.h"</span><br><span class="line">#include "test2.h"</span><br><span class="line">int main(){</span><br><span class="line">        printf("hello world\n");</span><br><span class="line">        test2();</span><br><span class="line">        return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hejin@desk-ubuntu:/home/desk/myandroid$ cat external/test/test2.c</span><br><span class="line">#include"stdio.h"</span><br><span class="line"></span><br><span class="line">void test2(){</span><br><span class="line">        printf("hello test2\n");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hejin@desk-ubuntu:/home/desk/myandroid$ cat external/test/test2.h</span><br><span class="line">void test2();</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Android.mk:</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hejin@desk-ubuntu:/home/desk/myandroid$ cat external/test/Android.mk</span><br><span class="line">LOCAL_PATH := $(call my-dir)      #定义了当前模块的相对路径</span><br><span class="line">include $(CLEAR_VARS)             #清空当前环境变量， 除了LOCAL_PATH</span><br><span class="line">LOCAL_MODULE := libtest              #编译生成的目标名称</span><br><span class="line">LOCAL_SRC_FILES := test.c \       #编译该模块需要的源文件</span><br><span class="line">                   test2.c</span><br><span class="line">include $(BUILD_SHARED_LIBRARY)       #编译所生成的目标文件格（在这里是动态库文件）</span><br></pre></td></tr></tbody></table></figure>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hejin@desk-ubuntu:/home/desk/myandroid$ source build/envsetup.sh</span><br><span class="line">hejin@desk-ubuntu:/home/desk/myandroid$ lunch</span><br><span class="line">hejin@desk-ubuntu:/home/desk/myandroid$ mmm external/test/</span><br><span class="line">============================================</span><br><span class="line">PLATFORM_VERSION_CODENAME=REL</span><br><span class="line">PLATFORM_VERSION=5.1.1</span><br><span class="line">TARGET_PRODUCT=sabresd_6dq</span><br><span class="line">TARGET_BUILD_VARIANT=user</span><br><span class="line">TARGET_BUILD_TYPE=release</span><br><span class="line">TARGET_BUILD_APPS=</span><br><span class="line">TARGET_ARCH=arm</span><br><span class="line">TARGET_ARCH_VARIANT=armv7-a-neon</span><br><span class="line">TARGET_CPU_VARIANT=cortex-a9</span><br><span class="line">TARGET_2ND_ARCH=</span><br><span class="line">TARGET_2ND_ARCH_VARIANT=</span><br><span class="line">TARGET_2ND_CPU_VARIANT=</span><br><span class="line">HOST_ARCH=x86_64</span><br><span class="line">HOST_OS=linux</span><br><span class="line">HOST_OS_EXTRA=Linux-3.16.0-30-generic-x86_64-with-Ubuntu-14.04-trusty</span><br><span class="line">HOST_BUILD_TYPE=release</span><br><span class="line">BUILD_ID=2.1.0-ga-rc3</span><br><span class="line">OUT_DIR=out</span><br><span class="line">============================================</span><br><span class="line">No private recovery resources for TARGET_DEVICE sabresd_6dq</span><br><span class="line">make: Entering directory `/home/desk/myandroid'</span><br><span class="line">target thumb C: test <= external/test/test.c</span><br><span class="line">target thumb C: test <= external/test/test2.c</span><br><span class="line">target Executable: test (out/target/product/sabresd_6dq/obj/EXECUTABLES/test_intermediates/LINKED/test)</span><br><span class="line">target Symbolic: test (out/target/product/sabresd_6dq/symbols/system/bin/test)    </span><br><span class="line">target Strip: test (out/target/product/sabresd_6dq/obj/EXECUTABLES/test_intermediates/test)</span><br><span class="line">Install: out/target/product/sabresd_6dq/system/bin/test    //将可执行文件安装到这个目录下</span><br><span class="line">make: Leaving directory `/home/desk/myandroid'</span><br><span class="line"></span><br><span class="line">#### make completed successfully (1 seconds) ####</span><br></pre></td></tr></tbody></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>makefile文件有一个基础的东西就是变量。大家可以自己了解下。这里我们说说android.mk这个变量的不同的地方。主要是用它来做代码管理。</p>
<p>首先在执行make文件的时候这些变量是全局有效的，一些公共的变量会通过include $(CLEAR_VARS)给清除掉。我们这里主要是添加自己的变量。我们在使用自己定义变量的时候有两种情况，一种是在mk中使用，一种是在cpp中使用。注意java不支持的。这两种情况有点不同，请注意。</p>
<p>首先我们得定义这个变量，一般来讲都是在产品的BoardConfig.mk中定义，例如：</p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">TARGET_MEMORY_STYLE := TARGET_MEM_256MB</span><br><span class="line"><span class="comment">#TARGET_MEMORY_STYLE := TARGET_MEM_256MB_ST</span></span><br><span class="line"><span class="comment">#TARGET_MEMORY_STYLE := TARGET_MEM_512MB</span></span><br><span class="line"><span class="comment">#TARGET_MEMORY_STYLE := TARGET_MEM_512MB_ST</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># board-specific configuration</span></span><br><span class="line">BOARD_OPENCORE_FLAGS := -DTELECHIPS_ALSA</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(BOARD_KERNEL_BASE)</span>,0x40000000)</span><br><span class="line">BOARD_MEM_FLAGS := -DTCC_MEM_256MB</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">BOARD_MEM_FLAGS := -DTCC_MEM_512MB</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></tbody></table></figure>

<p>这里总共有两个我们经常用的东西。</p>
<p><strong>第一：</strong><br>如果是mk中使用，定义如前四行就可以了。  </p>
<p>变量 := 字符串</p>
<p>在mk中的使用方法就像后面例子一样。</p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span>($(变量),对比值)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>第二：</strong>如果你想在cpp中使用，请定义方式如下：  </p>
<p>变量 := -D+变量名</p>
<p>如后面几行示例一样的。</p>
<p>如果想在cpp中应用，首先必须在cpp对于的mk文件中，声明如下<br>LOCAL_CFLAGS += $(BOARD_MEM_FLAGS)</p>
<p>格式：   LOCAL_CFLAGS += $(变量)</p>
<p>然后它的cpp中就可以引用如下：<br>此时去掉了-D前缀。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ifdef TCC_MEM_512MB</span><br><span class="line">......</span><br><span class="line">endif</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Android-mk变量"><a href="#Android-mk变量" class="headerlink" title="Android.mk变量"></a>Android.mk变量</h3><p>这些是您在Android.mk文件中常见的变量，按字母顺序列出。首先，关于变量命名的注释：</p>
<ul>
<li><p><strong>LOCAL_</strong> - 这些变量是按模块设置的。它们被行清除<code>include $(CLEAR_VARS)</code>，因此您可以在包含该文件后依赖它们为空。您将在大多数模块中使用的大多数变量都是LOCAL_变量。</p>
</li>
<li><p><strong>PRIVATE_</strong> - 这些变量是特定于make-target的变量。这意味着它们只能在该模块的命令中使用。这也意味着他们不可能从你的后面的模块背后改变。此 <a href="http://www.gnu.org/software/make/manual/make.html#Target_002dspecific" target="_blank" rel="noopener">make链接提供了</a> 有关特定于目标的变量的更多信息。</p>
</li>
<li><p><strong>HOST_</strong>和<strong>TARGET_</strong> - 包含特定于主机或目标版本的目录和定义。不要在makefile中设置以HOST_或TARGET_开头的变量。</p>
</li>
<li><p><strong>BUILD_</strong>和<strong>CLEAR_VARS</strong> - 包含要包含的明确定义的模板makefile的名称。一些示例是CLEAR_VARS和BUILD_HOST_PACKAGE。</p>
</li>
<li><p>任何其他名称都是公平游戏，供您在Android.mk中使用。但是，请记住，这是一个非递归构建系统，因此您的变量可能会被稍后包含的另一个Android.mk更改，并且在执行规则/模块的命令时会有所不同。</p>
</li>
<li><p><strong>定义C/CPP编译的宏时，注意格式，后面=1，不能带空格！</strong></p>
<p>LOCAL_CFLAGS += -DLIBUTILS_NATIVE=1</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LOCAL_AAPT_FLAGS</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_ACP_UNAVAILABLE</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_ADDITIONAL_JAVA_DIR</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_AIDL_INCLUDES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_ALLOW_UNDEFINED_SYMBOLS</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_ARM_MODE</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_ASFLAGS</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_ASSET_DIR</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_ASSET_FILES</td>
<td>在Android.mk文件中，<code>include $(BUILD_PACKAGE)</code>将此文件设置为您希望在应用程序中内置的文件集。通常：<code>LOCAL_ASSET_FILES += $(call find-subdir-assets)</code></td>
</tr>
<tr>
<td align="left">LOCAL_BUILT_MODULE_STEM</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_C_INCLUDES</td>
<td>指示C / C ++编译器查找头文件的其他目录。这些路径根植于树的顶部。<code>LOCAL_PATH</code>如果您在包含路径中包含您想要的子目录，请使用 此选项。例如：<code>LOCAL_C_INCLUDES += extlibs/zlib-1.2.3LOCAL_C_INCLUDES += $(LOCAL_PATH)/src</code>您不应该添加include的子目录 <code>LOCAL_C_INCLUDES</code>，而应该在<code>#include</code>语句中引用这些文件及其子目录。例如：<code>#include <utils/KeyedVector.h></code> 不 <code>#include <KeyedVector.h></code></td>
</tr>
<tr>
<td align="left">LOCAL_CC</td>
<td>如果要为此模块使用不同的C编译器，请将LOCAL_CC设置为编译器的路径。如果LOCAL_CC为空，则使用相应的默认编译器。</td>
</tr>
<tr>
<td align="left">LOCAL_CERTIFICATE</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_CFLAGS</td>
<td><strong>如果您有其他标志要传递到C或C ++编译器，请在此处添加它们。例如：</strong><code>LOCAL_CFLAGS += -DLIBUTILS_NATIVE=1</code></td>
</tr>
<tr>
<td align="left">LOCAL_CLASSPATH</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_COMPRESS_MODULE_SYMBOLS</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_COPY_HEADERS</td>
<td>要复制到安装的文件集包括树。你还必须提供<code>LOCAL_COPY_HEADERS_TO</code>。这会消失，因为复制标题会混淆错误消息，并可能导致人们编辑这些标题而不是正确标题。它还可以更容易地在系统中执行错误的分层，我们希望避免这种分层。我们也没有使用C / C ++ SDK，因此没有最终要求复制任何标头。</td>
</tr>
<tr>
<td align="left">LOCAL_COPY_HEADERS_TO</td>
<td>“include”中的目录，用于复制<code>LOCAL_COPY_HEADERS</code>to中列出的标题 。这会消失，因为复制标题会混淆错误消息，并可能导致人们编辑这些标题而不是正确标题。它还可以更容易地在系统中执行错误的分层，我们希望避免这种分层。我们也没有使用C / C ++ SDK，因此没有最终要求复制任何标头。</td>
</tr>
<tr>
<td align="left">LOCAL_CPP_EXTENSION</td>
<td>如果您的C ++文件以“ <code>.cpp</code>” 之外的其他内容结尾，则可以在此处指定自定义扩展名。例如：<code>LOCAL_CPP_EXTENSION := .cc</code>请注意，给定模块的所有C ++文件必须具有相同的扩展名; 目前无法混合不同的扩展。</td>
</tr>
<tr>
<td align="left">LOCAL_CPPFLAGS</td>
<td>如果还有其他标志<em>只</em>传递给C ++编译器，请在此处添加。例如：<code>LOCAL_CPPFLAGS += -ffriend-injection``LOCAL_CPPFLAGS</code>保证<code>LOCAL_CFLAGS</code> 在编译行之后，因此您可以使用它来覆盖中列出的标志 <code>LOCAL_CFLAGS</code></td>
</tr>
<tr>
<td align="left">LOCAL_CXX</td>
<td>如果要为此模块使用不同的C ++编译器，请将LOCAL_CXX设置为编译器的路径。如果LOCAL_CXX为空，则使用相应的默认编译器。</td>
</tr>
<tr>
<td align="left">LOCAL_DX_FLAGS</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_EXPORT_PACKAGE_RESOURCES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_FORCE_STATIC_EXECUTABLE</td>
<td>如果您的可执行文件应静态链接，请设置 <code>LOCAL_FORCE_STATIC_EXECUTABLE:=true</code>。我们以静态形式存在一个非常短的库列表（目前只有libc）。这实际上只用于根文件系统上/ sbin中的可执行文件。</td>
</tr>
<tr>
<td align="left">LOCAL_GENERATED_SOURCES</td>
<td>添加到的文件<code>LOCAL_GENERATED_SOURCES</code>将自动生成，然后在构建模块时链接。有关示例，请参阅<a href="http://android.mk/#custom-tools" target="_blank" rel="noopener">自定义工具</a>模板makefile。</td>
</tr>
<tr>
<td align="left">LOCAL_INSTRUMENTATION_FOR</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_INSTRUMENTATION_FOR_PACKAGE_NAME</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_INTERMEDIATE_SOURCES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_INTERMEDIATE_TARGETS</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_IS_HOST_MODULE</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_JAR_MANIFEST</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_JARJAR_RULES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_JAVA_LIBRARIES</td>
<td>链接Java应用程序和库时，<code>LOCAL_JAVA_LIBRARIES</code> 指定要包含的Java类集。目前有两个：<code>core</code>和<code>framework</code>。在大多数情况下，它看起来像这样：<code>LOCAL_JAVA_LIBRARIES := core framework</code>请注意，<code>LOCAL_JAVA_LIBRARIES</code>使用“ <code>include $(BUILD_PACKAGE)</code>” 构建APK时，无需进行设置（并且不允许）。将自动包含适当的库。</td>
</tr>
<tr>
<td align="left">LOCAL_JAVA_RESOURCE_DIRS</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_JAVA_RESOURCE_FILES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_JNI_SHARED_LIBRARIES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_LDFLAGS</td>
<td>您可以通过设置将其他标志传递给链接器 <code>LOCAL_LDFLAGS</code>。请记住，参数的顺序对于ld非常重要，因此请测试您在所有平台上执行的操作。</td>
</tr>
<tr>
<td align="left">LOCAL_LDLIBS</td>
<td><code>LOCAL_LDLIBS</code>允许您指定不属于可执行文件或库的构建的其他库。在-lxxx格式中指定所需的库; 它们直接传递给链接线。但是，请记住，不会为这些库生成依赖关系。它在您希望使用主机上预安装的库的模拟器构建中最有用。链接器（ld）是一个特别挑剔的野兽，所以如果你做鬼鬼祟祟的话，有时候必须在这里传递其他标志。一些例子：<code>LOCAL_LDLIBS += -lcurses -lpthreadLOCAL_LDLIBS += -Wl,-z,origin</code></td>
</tr>
<tr>
<td align="left">LOCAL_MODULE</td>
<td><code>LOCAL_MODULE</code>是应该从Android.mk生成的名称。例如，对于libkjs，它<code>LOCAL_MODULE</code>是“libkjs”（构建系统添加适当的后缀 - .so .dylib .dll）。对于应用程序模块，请使用<code>LOCAL_PACKAGE_NAME</code>而不是 <code>LOCAL_MODULE</code>。</td>
</tr>
<tr>
<td align="left">LOCAL_MODULE_PATH</td>
<td>指示构建系统将模块放在除其类型之外的其他位置。如果覆盖它，请确保您还设置 <code>LOCAL_UNSTRIPPED_PATH</code>它是可执行文件还是共享库，以便未提取的二进制文件可以去哪里。如果忘记，将会发生错误。有关更多信息，请参阅<a href="http://android.mk/#moving-modules" target="_blank" rel="noopener">将模块置于其</a></td>
</tr>
<tr>
<td align="left">LOCAL_MODULE_STEM</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_MODULE_TAGS</td>
<td>设置<code>LOCAL_MODULE_TAGS</code>为任意数量的以空格分隔的标记。此变量控制包所包含的构造风格。例如：<code>user</code>：在user / userdebug构建中包含此内容<code>eng</code>：在eng版本中包含此内容<code>tests</code>：目标是测试目标并使其可用于测试<code>optional</code>：不包括这个</td>
</tr>
<tr>
<td align="left">LOCAL_NO_DEFAULT_COMPILER_FLAGS</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_NO_EMMA_COMPILE</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_NO_EMMA_INSTRUMENT</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_NO_STANDARD_LIBRARIES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_OVERRIDES_PACKAGES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_PACKAGE_NAME</td>
<td><code>LOCAL_PACKAGE_NAME</code>是应用程序的名称。例如，拨号器，联系人等</td>
</tr>
<tr>
<td align="left">LOCAL_POST_PROCESS_COMMAND</td>
<td>对于主机可执行文件，您可以指定在链接后在模块上运行的命令。由于早期或晚期变量评估，您可能必须经历一些扭曲以获得正确的变量：<code>module := $(HOST_OUT_EXECUTABLES)/$(LOCAL_MODULE)LOCAL_POST_PROCESS_COMMAND := /Developer/Tools/Rez -d __DARWIN__ -t APPL\       -d __WXMAC__ -o $(module) Carbon.r</code></td>
</tr>
<tr>
<td align="left">LOCAL_PREBUILT_EXECUTABLES</td>
<td>包含$（BUILD_PREBUILT）或$（BUILD_HOST_PREBUILT）时，请将这些设置为要复制的可执行文件。它们自动位于正确的bin目录中。</td>
</tr>
<tr>
<td align="left">LOCAL_PREBUILT_JAVA_LIBRARIES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_PREBUILT_LIBS</td>
<td>包含$（BUILD_PREBUILT）或$（BUILD_HOST_PREBUILT）时，请将这些设置为要复制的库。它们自动位于右侧lib目录中。</td>
</tr>
<tr>
<td align="left">LOCAL_PREBUILT_OBJ_FILES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_PRELINK_MODULE</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_REQUIRED_MODULES</td>
<td>设置<code>LOCAL_REQUIRED_MODULES</code>为任意数量的以空格分隔的模块名称，例如“libblah”或“Email”。如果安装了此模块，则还将安装所需的所有模块。这可用于例如确保在安装给定应用程序时安装必要的共享库或提供程序。</td>
</tr>
<tr>
<td align="left">LOCAL_RESOURCE_DIR</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_SDK_VERSION</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_SHARED_LIBRARIES</td>
<td>这些是您直接链接的库。您不需要传递包含传递的库。指定不带后缀的名称：<code>LOCAL_SHARED_LIBRARIES := \    libutils \    libui \    libaudio \    libexpat \    libsgl</code></td>
</tr>
<tr>
<td align="left">LOCAL_SRC_FILES</td>
<td>构建系统会查看<code>LOCAL_SRC_FILES</code>要编译的源文件 - .cpp .c .y .l .java。对于lex和yacc文件，它知道如何自动正确执行中间.h和.c / .cpp文件。如果文件位于包含Android.mk的文件的子目录中，请在其前面加上目录名称：<code>LOCAL_SRC_FILES := \    file1.cpp \    dir/file2.cpp</code></td>
</tr>
<tr>
<td align="left">LOCAL_STATIC_JAVA_LIBRARIES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_STATIC_LIBRARIES</td>
<td>这些是要包含在模块中的静态库。大多数情况下，我们使用共享库，但有几个地方，比如sbin和主机可执行文件中的可执行文件，我们使用静态库代替。<code>LOCAL_STATIC_LIBRARIES := \    libutils \    libtinyxml</code></td>
</tr>
<tr>
<td align="left">LOCAL_UNINSTALLABLE_MODULE</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_UNSTRIPPED_PATH</td>
<td>指示构建系统将模块的未剥离版本放在除了其类型的正常之外的某个位置。通常，您重写此操作是因为您<code>LOCAL_MODULE_PATH</code>为可执行文件或共享库进行了覆盖。如果您覆盖<code>LOCAL_MODULE_PATH</code>但不是 <code>LOCAL_UNSTRIPPED_PATH</code>，则会发生错误。有关更多信息，请参阅<a href="http://android.mk/#moving-modules" target="_blank" rel="noopener">将模块置于其</a></td>
</tr>
<tr>
<td align="left">LOCAL_WHOLE_STATIC_LIBRARIES</td>
<td>这些是您希望包含在模块中的静态库，而不允许链接器从中删除死代码。如果要将静态库添加到共享库并从共享库中公开静态库的内容，这将非常有用。<code>LOCAL_WHOLE_STATIC_LIBRARIES := \    libsqlite3_android</code></td>
</tr>
<tr>
<td align="left">LOCAL_YACCFLAGS</td>
<td>要传递给模块的yacc调用的任何标志。这里的一个已知限制是，对于模块的所有YACC调用，标志都是相同的。这可以修复。如果您需要它，请问。<code>LOCAL_YACCFLAGS := -p kjsyy</code></td>
</tr>
<tr>
<td align="left">OVERRIDE_BUILT_MODULE_PATH</td>
<td></td>
</tr>
</tbody></table>
<h1 id="Makefile模板"><a href="#Makefile模板" class="headerlink" title="Makefile模板"></a>Makefile模板</h1><h2 id="文件目录结构："><a href="#文件目录结构：" class="headerlink" title="文件目录结构："></a>文件目录结构：</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">- dynamiclibapp.c</span><br><span class="line">- Makefile</span><br><span class="line">- comm/inc/apue.h</span><br><span class="line">- comm/errorhandle.c</span><br><span class="line">- dynamiclib/Makefile</span><br><span class="line">- dynamiclib/dynamiclib_add.c</span><br><span class="line">- dynamiclib/dynamiclib_mul.c</span><br><span class="line">- dynamiclib/inc/dynamiclibs.h</span><br><span class="line">- dynamiclib/libs/</span><br></pre></td></tr></tbody></table></figure>
<h2 id="dynamiclib目录"><a href="#dynamiclib目录" class="headerlink" title="dynamiclib目录"></a>dynamiclib目录</h2><ul>
<li>dynamiclib/inc/dynamiclibs.h （对两个c文件中函数的声明）  </li>
</ul>
<p>文件内容如下:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">ifndef</span> __dynamic_libs_h__</span></span><br><span class="line"><span class="number">2</span> <span class="meta">#<span class="meta-keyword">define</span> __dynamic_libs_h__</span></span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="number">5</span> <span class="function"><span class="keyword">int</span> <span class="title">dynamic_lib_func_add</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span></span>;</span><br><span class="line"><span class="number">6</span> <span class="function"><span class="keyword">int</span> <span class="title">dynamic_lib_func_mul</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span></span>;</span><br><span class="line"><span class="number">7</span> </span><br><span class="line"><span class="number">8</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>dynamiclib/dynamiclib_add.c 文件内容如下:</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dynamiclibs.h"</span></span></span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> <span class="function"><span class="keyword">int</span> <span class="title">dynamic_lib_func_add</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span></span><br><span class="line"><span class="function">4 </span>{</span><br><span class="line"><span class="number">5</span>     <span class="keyword">int</span> iret = i1 + i2; </span><br><span class="line"><span class="number">6</span>     <span class="built_in">printf</span>(<span class="string">"... in .so func, %d add %d,return %d\n"</span>, i1, i2, iret);</span><br><span class="line"><span class="number">7</span>     <span class="keyword">return</span> iret;</span><br><span class="line"><span class="number">8</span> }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>dynamiclib/dynamiclib_mul.c 文件内容如下:</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dynamiclibs.h"</span></span></span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> <span class="function"><span class="keyword">int</span> <span class="title">dynamic_lib_func_mul</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span></span><br><span class="line"><span class="function">4 </span>{</span><br><span class="line"><span class="number">5</span>     <span class="keyword">int</span> iret = i1 * i2; </span><br><span class="line"><span class="number">6</span>     <span class="built_in">printf</span>(<span class="string">"... in .so func, %d multiplys %d, retun %d\n"</span>, i1, i2, iret);</span><br><span class="line"><span class="number">7</span>     <span class="keyword">return</span> iret;</span><br><span class="line"><span class="number">8</span> }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>dynamiclib/Makefile 文件内容如下:</li>
</ul>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line"> 1 CC       = gcc </span><br><span class="line"> 2 CFLAGS   = -Wall -g -O -fPIC     </span><br><span class="line">   <span class="comment"># 需要加上 -fPIC</span></span><br><span class="line">   <span class="comment"># 为了兼容各个系统，在生成位置无关的代码的时候，应该使用-fPIC参数。</span></span><br><span class="line"> 3 CXXFLAGS = </span><br><span class="line"> 4 INCLUDE  = -I ./inc -I ../comm/inc</span><br><span class="line"> 5 TARGET   = libmytest.so</span><br><span class="line"> 6 LIBPATH  = ./libs/</span><br><span class="line"> 7 </span><br><span class="line"> 8 <span class="keyword">vpath</span> %.h ./inc</span><br><span class="line"> 9 </span><br><span class="line">10 OBJS     = dynamiclib_add.o dynamiclib_mul.o</span><br><span class="line">11 SRCS     = dynamiclib_add.c dynamiclib_mul.c</span><br><span class="line">12 </span><br><span class="line">13 <span class="variable">$(OBJS)</span>:<span class="variable">$(SRCS)</span></span><br><span class="line">14    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(INCLUDE)</span> -c <span class="variable">$^</span></span><br><span class="line">15 </span><br><span class="line">16 all:<span class="variable">$(OBJS)</span></span><br><span class="line">17    <span class="variable">$(CC)</span> -shared -fPIC -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span>    需要加上 -shared -fPIC</span><br><span class="line">18    mv <span class="variable">$(TARGET)</span> <span class="variable">$(LIBPATH)</span></span><br><span class="line">19 </span><br><span class="line">20 clean:</span><br><span class="line">21    rm -f *.o</span><br><span class="line">22    rm -f <span class="variable">$(LIBPATH)</span>*</span><br></pre></td></tr></tbody></table></figure>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>以上文件，就可以生成动态库文件 libmytest.so，应用程序以两种方式加载动态库函数，如下</p>
<h4 id="在编译应用程序时加载动态库"><a href="#在编译应用程序时加载动态库" class="headerlink" title="在编译应用程序时加载动态库"></a>在编译应用程序时加载动态库</h4><p>dynamiclibapp.c 文件内容如下</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dynamiclibs.h"</span></span></span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> 5 </span>{</span><br><span class="line"> <span class="number">6</span>     err_msg(<span class="string">"step in main\n"</span>);</span><br><span class="line"> <span class="number">7</span>     dynamic_lib_func_add(<span class="number">1</span>, <span class="number">9</span>); </span><br><span class="line"> <span class="number">8</span>     dynamic_lib_func_mul(<span class="number">1</span>, <span class="number">9</span>); </span><br><span class="line"> <span class="number">9</span>     err_msg(<span class="string">"step out main\n"</span>);</span><br><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">11</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">12</span> }</span><br></pre></td></tr></tbody></table></figure>
<p>Makefile 文件内容如下：</p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line"> 1 CC       = gcc </span><br><span class="line"> 2 CFLAGS   = -Wall -O -g</span><br><span class="line"> 3 CXXFLAGS = </span><br><span class="line"> 4 INCLUDE  = -I ./comm/inc -I ./dynamiclib/inc</span><br><span class="line"> 5 TARGET   = dynamiclibapp</span><br><span class="line"> 6 LIBVAR   = -lmytest             指明需要链接动态库 libmytest.so</span><br><span class="line"> 7 LIBPATH  = -L./dynamiclib/libs  指明 libmytest.so 的路径</span><br><span class="line"> 8 <span class="comment">#search paths for errorhandler.c</span></span><br><span class="line"> 9 <span class="keyword">vpath</span> %.c ./comm</span><br><span class="line">10 <span class="comment">#下行是为依赖项 apue.h 准备的，比如 [errorhandler.o:errorhandler.c apue.h] 里的 apue.h</span></span><br><span class="line">11 <span class="keyword">vpath</span> %.h ./comm/inc</span><br><span class="line">12 </span><br><span class="line">13 OBJS     = errorhandler.o dynamiclibapp.o</span><br><span class="line">14 <span class="comment">#下行的 apue.h，可以不必写出来</span></span><br><span class="line">15 errorhandler.o:errorhandler.c apue.h</span><br><span class="line">16    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(INCLUDE)</span> -c <span class="variable">$^</span></span><br><span class="line">17 dynamiclibapp.o:dynamiclibapp.c apue.h</span><br><span class="line">18    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(INCLUDE)</span> -c <span class="variable">$^</span></span><br><span class="line">19 </span><br><span class="line">20 all:<span class="variable">$(OBJS)</span> <span class="variable">$(LIB)</span></span><br><span class="line">21    cd ./dynamiclib && make all</span><br><span class="line">22    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(INCLUDE)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span> <span class="variable">$(LIBPATH)</span> <span class="variable">$(LIBVAR)</span></span><br><span class="line">23    在上行中，在执行编译时，加载了 libmytest.so 中函数</span><br><span class="line">24 clean:</span><br><span class="line">25    rm -f *.o</span><br><span class="line">26    rm -f comm/inc/*.gch</span><br><span class="line">27    rm -f <span class="variable">$(TARGET)</span></span><br><span class="line">28    cd ./dynamiclib && make clean</span><br></pre></td></tr></tbody></table></figure>
<p>对于这种方式编译出来的动态库文件，还需要在 /etc/ld.so.conf.d/ 目录中添加 libmytest.so 库文件的路径说明，即在 /etc/ld.so.conf.d/ 目录中新建配置文件 mytest.conf，且执行 ldconfig， /etc/ld.so.conf.d/mytest.conf 的文件内容为 libmytest.so 库文件的绝对路径，例如：1 /home/lijiangtao/dynamiclib/libs<br>如果不在编译应用程序时加载动态库文件里的函数，而是改为在应用程序执行时(比如：程序的main函数启动期间，或在程序执行期间)加载 libmytest.so 里函数，那么就可以不需在 /etc/ld.so.conf.d/ 目录中配置 libmytest.so路径，具体如下所述。</p>
<h4 id="在应用程序执行时加载动态库"><a href="#在应用程序执行时加载动态库" class="headerlink" title="在应用程序执行时加载动态库"></a>在应用程序执行时加载动态库</h4><p>dynamiclibapp.c 文件内容如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dynamiclibs.h"</span></span></span><br><span class="line"> <span class="number">3</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><dlfcn.h></span></span></span><br><span class="line"> <span class="number">4</span> </span><br><span class="line"> <span class="number">5</span> <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*fp_lib_add)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"> <span class="number">6</span> <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*fp_lib_mul)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"> <span class="number">7</span> <span class="keyword">typedef</span> <span class="keyword">void</span>* dlhandle;</span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span> dlhandle      dll      = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">10</span> fp_lib_add    func_add = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">11</span> fp_lib_mul    func_mul = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">13</span> <span class="function">dlhandle <span class="title">load_dynamic_func</span><span class="params">(<span class="keyword">char</span> *psopath, fp_lib_add *padd, fp_lib_mul *pmul)</span></span>;</span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">16 </span>{</span><br><span class="line"><span class="number">17</span>     <span class="keyword">char</span> *pso = <span class="string">"/home/lijiangtao/dynamiclib/libs/libmytest.so"</span>;<span class="comment">//指定 .so 路径</span></span><br><span class="line"><span class="number">18</span>     dll = load_dynamic_func(pso, &func_add, &func_mul);<span class="comment">//程序执行时，加载动态函数</span></span><br><span class="line"><span class="number">19</span>     err_msg(<span class="string">"step in main\n"</span>);</span><br><span class="line"><span class="number">20</span>     func_add(<span class="number">1</span>, <span class="number">9</span>);<span class="comment">//执行 add 函数</span></span><br><span class="line"><span class="number">21</span>     func_mul(<span class="number">1</span>, <span class="number">9</span>);<span class="comment">//执行 mul 函数</span></span><br><span class="line"><span class="number">22</span>     err_msg(<span class="string">"step out main\n"</span>);</span><br><span class="line"><span class="number">23</span> </span><br><span class="line"><span class="number">24</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">25</span> }</span><br><span class="line"><span class="number">26</span> </span><br><span class="line"><span class="number">27</span> <span class="function">dlhandle <span class="title">load_dynamic_func</span><span class="params">(<span class="keyword">char</span> *psopath, fp_lib_add *padd, fp_lib_mul *pmul)</span></span></span><br><span class="line"><span class="function">28 </span>{</span><br><span class="line"><span class="number">29</span>     <span class="keyword">if</span>(<span class="literal">NULL</span> == psopath ||<span class="string">'\0'</span> == psopath[<span class="number">0</span>])</span><br><span class="line"><span class="number">30</span>         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">31</span>     <span class="keyword">char</span> *perrormsg = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">32</span>     dlhandle dllhandle = dlopen(psopath, RTLD_LAZY);</span><br><span class="line"><span class="number">33</span>     <span class="keyword">if</span>(<span class="literal">NULL</span> == dllhandle) </span><br><span class="line"><span class="number">34</span>     {   </span><br><span class="line"><span class="number">35</span>         <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, dlerror());</span><br><span class="line"><span class="number">36</span>         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">37</span>     } </span><br><span class="line"><span class="number">38</span>     <span class="keyword">if</span>(<span class="literal">NULL</span> != padd)</span><br><span class="line"><span class="number">39</span>     {</span><br><span class="line"><span class="number">40</span>         *padd = dlsym(dllhandle, <span class="string">"dynamic_lib_func_add"</span>);<span class="comment">//加载 add 函数</span></span><br><span class="line"><span class="number">41</span>         perrormsg = dlerror();</span><br><span class="line"><span class="number">42</span>         <span class="keyword">if</span>(<span class="literal">NULL</span> != perrormsg)</span><br><span class="line"><span class="number">43</span>             <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, perrormsg);</span><br><span class="line"><span class="number">44</span>     }</span><br><span class="line"><span class="number">45</span>     <span class="keyword">if</span>(<span class="literal">NULL</span> != pmul)</span><br><span class="line"><span class="number">46</span>     {</span><br><span class="line"><span class="number">47</span>         *pmul = dlsym(dllhandle, <span class="string">"dynamic_lib_func_mul"</span>);<span class="comment">//加载 mul 函数</span></span><br><span class="line"><span class="number">48</span>         perrormsg = dlerror();</span><br><span class="line"><span class="number">49</span>         <span class="keyword">if</span>(<span class="literal">NULL</span> != perrormsg)</span><br><span class="line"><span class="number">50</span>             <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, perrormsg);</span><br><span class="line"><span class="number">51</span>     }</span><br><span class="line"><span class="number">52</span>     <span class="keyword">return</span> dllhandle;</span><br><span class="line"><span class="number">53</span> }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="c-c-混合编译"><a href="#c-c-混合编译" class="headerlink" title="c/c++ 混合编译"></a>c/c++ 混合编译</h3><p>c用gcc编译，c++用g++编译，分别生成.o文件，最后变成最终的库</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CC = arm-poky-linux-gnueabi-gcc</span><br><span class="line">C++ = arm-poky-linux-gnueabi-g++</span><br><span class="line">LINK = arm-poky-linux-gnueabi-g++</span><br><span class="line"> </span><br><span class="line">LIBS = -lz -lm -lpcre -lpthread</span><br><span class="line">#编译.so must add -fPIC option  https://www.cnblogs.com/cswuyg/p/3830703.html</span><br><span class="line">CCFLAGS = -c -g -fPIC</span><br><span class="line">C++FLAGS = -c -g -fPIC</span><br><span class="line"></span><br><span class="line">#期望得到的执行文件或动态库.so</span><br><span class="line">TARGET=libxx.so</span><br><span class="line"> </span><br><span class="line">INCLUDES = -I. -I../../</span><br><span class="line"> </span><br><span class="line">C++FILES = $(wildcard *.cpp ./../common/*.cpp)</span><br><span class="line">CFILES = $(wildcard *.c ./../common/*.c)</span><br><span class="line"> </span><br><span class="line">OBJFILE = $(CFILES:.c=.o) $(C++FILES:.cpp=.o)</span><br><span class="line"> </span><br><span class="line">all:$(TARGET)</span><br><span class="line"> </span><br><span class="line">$(TARGET): $(OBJFILE)</span><br><span class="line">	$(LINK) $^ $(LIBS) -Wall -fPIC -shared -o $@</span><br><span class="line"> </span><br><span class="line">%.o:%.c</span><br><span class="line">	$(CC) -o $@ $(CCFLAGS) $< $(INCLUDES)</span><br><span class="line"> </span><br><span class="line">%.o:%.cpp</span><br><span class="line">	$(C++) -o $@ $(C++FLAGS) $< $(INCLUDES)</span><br><span class="line"> </span><br><span class="line">install:</span><br><span class="line">	tsxs -i -o $(TARGET)</span><br><span class="line"> </span><br><span class="line">clean:</span><br><span class="line">	rm -rf $(TARGET)</span><br><span class="line">    rm -rf $(OBJFILE)</span><br></pre></td></tr></tbody></table></figure>

<p>需要注意的是为了能够让C++调用C语言代码，需要在头文件加上extern “C”，代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus <span class="comment">//而这一部分就是告诉编译器，如果定义了__cplusplus(即如果是cpp文件， </span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>{ <span class="comment">//因为cpp文件默认定义了该宏),则采用C语言方式进行编译</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：AE打印延迟</title>
    <url>/2019/03/08/%E5%B7%A5%E4%BD%9C-BUG-BUG-AE%E6%89%93%E5%8D%B0%E5%BB%B6%E8%BF%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a><strong>现象</strong></h2><p>在HWI的ProcessAEinfo函数中进行打印，发现AE有延迟</p>
<a id="more"></a>

<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a><strong>解决思路</strong></h2><ol>
<li>查看ProcessAEinfo函数的执行位置，发现ProcessAEinfo函数是在状态机中的<code>QCAMERA_INTERNAL_EVT_AE_UPDATE</code>状态下1执行的</li>
<li>相应的找到了只有<code>matadata_stream_cb_routine</code>函数对状态机发送这个状态事件，在执行processEVT的地方进行打印，发现这个AE打印是没有延时的；在对状态机这个状态下加打印，发现这个AE打印是有延时的</li>
<li>processAEinfo函数里的内容，会发现，状态机状态下的AE打印又没有异常了</li>
<li>当时在想，为什么输出和输入对不上呢？先对processAEinfo里的内容进行删减，查看加上那句话会造成AE打印有延时</li>
<li>发现加上persist进行赋值的地方，ae就会有延迟，对persist设置的函数前后进行打印，发现这个赋值语句需要10Ms才能执行完成。</li>
<li>需要重新设置HAL对ispctrl层传递的方法，不能使用persist的方法了</li>
</ol>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a><strong>疑问</strong></h2><p>callback一直在给statemachine发送事件消息，假设每帧发10个事件，但是statemachine由于什么问题，只处理了9个事件，并不会造成太大的影响，图像还是正常出，就是控制可能慢了0.003s</p>
<p>但是存在一个问题，那个事件被callback创建了，并没有被处理完，释放内存，当过了100帧率，就有10个事件没有进行处理，那这些事件依旧在内存中，没有被释放，长此以往，内存被占满了，程序不就各种崩溃了么。</p>
<h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a><strong>解决方案</strong>：</h2><p>是否在检查队列的时候对队列的长度进行判断，防止队列太长崩溃。</p>
<p>另外就是我们在调试代码的时候，在端口的输入端加上打印，查看每个模块处理的速度，如果低于正常的帧率，就抛出异常。当然一帧看不出什么问题，100帧检测一次，看时间是否超过了正常的时间。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><ol>
<li><p>如果上一个模块的输出和下一个模块的输入对不上，很可能是由于FIFO导致的，如果下一个模块的处理跟不上上一个</p>
</li>
<li><p>函数中尽量不要去设置persist的值，根据打印发现，平均设置需要10ms，大大影响运行性能。</p>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>persist_set</tag>
        <tag>hal</tag>
      </tags>
  </entry>
  <entry>
    <title>高通WNR滤波理解</title>
    <url>/2019/03/08/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-%E9%AB%98%E9%80%9AWNR%E6%BB%A4%E6%B3%A2%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p><strong>详细原理：</strong></p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/1552274631266.png"  alt></p>
<p>先将原图和经过双边滤波之后的图相减，得到下图的噪声和细节分布图，是第一个+号的输出。edge softness来调节这个滤波器的强度。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/1552274655450.png"  alt></p>
<p>这个噪声和细节分布图和阈值λ进行比较，profile*scale就是阈值λ，1-w就是斜率。横坐标是每个像素点的差值，而Y轴是将要去除的噪声大小。第二个+号的过程是将原图和第二个图的Y（输出）进行相减，也就是用原图减去噪声得到滤波后的图。</p>
<p>当w=0，就是斜率等于1，X=Y，也就是说小于λ将会完全用双边滤波得到的图片。</p>
<p>如果说平坦区域的降噪不符合要求，应该加大edge softness，也就是第一个滤波器的强度，加大阈值是没有用的。</p>
<p><strong>调试顺序：</strong></p>
<p>由于WNR是先进行双边滤波(edge softness)，再利用scale和weight进行边缘和噪声的选择，那我们可以先将weight调到0，scale很大，去确定前面的edge，因为一旦动了edge，之后的都会改变，我们先将图片调节到可以接受的噪声的规模，在将scale调小，放出更多的边缘，最后增大weight，获取更多的细节。</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像效果调试</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>WNR</tag>
        <tag>滤波</tag>
      </tags>
  </entry>
  <entry>
    <title>aec重载chromatix功能实现</title>
    <url>/2019/03/07/%E5%B7%A5%E4%BD%9C-%E7%BC%96%E7%A8%8B-8056%E5%B9%B3%E5%8F%B0aec%E6%A8%A1%E5%9D%97%E9%87%8D%E8%BD%BDchromatix%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>8056平台中如何实现对aec模块重载chromatix？</p>
</blockquote>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="第一版本"><a href="#第一版本" class="headerlink" title="第一版本"></a>第一版本</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search_dynamic_region</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">array</span>, <span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">-1</span>; i < <span class="number">2</span>; i++) {</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">-1</span>; j < <span class="number">2</span>; j++) {</span><br><span class="line">    			<span class="keyword">if</span> (x + i >= <span class="number">0</span> && x + i < row &&</span><br><span class="line">    				y + j >= <span class="number">0</span> && y + j < col &&</span><br><span class="line">    				(x || y == <span class="number">1</span>) && <span class="built_in">array</span>[(x + i)*col + y + j] == <span class="number">1</span>) {</span><br><span class="line">				<span class="built_in">array</span>[(x + i)*col + y + j] = <span class="number">2</span>;</span><br><span class="line">				search_dynamic_region(<span class="built_in">array</span>, x + i, y + j, row, col);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//BRIGHT_REGION_RANGE range:0.1-1.0 值越小，亮区越大</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BRIGHT_REGION_RANGE 0.6</span></span><br><span class="line"><span class="comment">//DYNAMIC_REGION_THRESHOLD range:>1.0 值越小，越容易判定为动态亮区</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DYNAMIC_REGION_THRESHOLD 1.2</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">keda_backlight_algo</span><span class="params">(<span class="keyword">aec_biz_t</span> *aec, <span class="keyword">const</span> <span class="keyword">stats_t</span>* stats)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//detect input</span></span><br><span class="line">    <span class="keyword">if</span> (!aec || !stats) {</span><br><span class="line">      AEC_ERR(<span class="string">"Invalid input: %p,%p"</span>,aec, stats);</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//define var</span></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="keyword">float</span> aec_ratio = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">float</span> aec_dynamic_ratio=<span class="number">1000</span>,aec_static_ratio=<span class="number">1</span>;</span><br><span class="line">    chromatix_3a_parms_type *chromatix;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">q3a_bg_stats_t</span>* q3a_bg_stats = stats->bayer_stats.p_q3a_bg_stats;</span><br><span class="line">    <span class="keyword">uint32_t</span> threhold_h = q3a_bg_stats->rMax * q3a_bg_stats->region_pixel_cnt * BRIGHT_REGION_RANGE /<span class="number">4</span>;</span><br><span class="line">    chromatix = (chromatix_3a_parms_type*)backlight_set_parameter.u.init_param.chromatix;</span><br><span class="line">    <span class="keyword">if</span> (!chromatix) {</span><br><span class="line">        AEC_ERR(<span class="string">"Invalid chromatix: %p"</span>, chromatix)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> v_step = q3a_bg_stats->bg_region_v_num/NUM_AEC_STATS;</span><br><span class="line">    <span class="keyword">int</span> h_step = q3a_bg_stats->bg_region_h_num/NUM_AEC_STATS;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint32_t</span> bg_sum[MAX_BG_STATS_NUM]={<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">char</span> grid_region[MAX_BG_STATS_NUM] ={<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">int</span> grid_v_num, grid_h_num;</span><br><span class="line">    <span class="keyword">int</span> weight_grid_count[NUM_AEC_STATS][NUM_AEC_STATS] = {{<span class="number">0</span>}};</span><br><span class="line">    <span class="keyword">uint32_t</span> bg_count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (property_get(<span class="string">"persist.liqinxing.backlight"</span>, value, <span class="string">""</span>) > <span class="number">0</span>){</span><br><span class="line">        aec_static_ratio = atoi(value)/<span class="number">1000.0</span>;</span><br><span class="line">        <span class="comment">//reduce traverse times and prevent data overflow</span></span><br><span class="line">        <span class="keyword">int</span> grid_count = q3a_bg_stats->bg_region_h_num * q3a_bg_stats->bg_region_v_num;</span><br><span class="line">        <span class="comment">//find bright region and dynamic spot</span></span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i < grid_count; i++){</span><br><span class="line">            <span class="keyword">if</span>(q3a_bg_stats->bg_r_sum[i] > threhold_h ||</span><br><span class="line">               q3a_bg_stats->bg_gr_sum[i] > threhold_h ||</span><br><span class="line">               q3a_bg_stats->bg_b_sum[i] > threhold_h){</span><br><span class="line">                    bg_count = q3a_bg_stats->bg_r_sum[i]+q3a_bg_stats->bg_gr_sum[i]+</span><br><span class="line">                    q3a_bg_stats->bg_gb_sum[i]+q3a_bg_stats->bg_b_sum[i];</span><br><span class="line">                    <span class="keyword">if</span>(bg_count*<span class="number">10</span>/bg_sum[i] > <span class="number">12</span>)</span><br><span class="line">                        grid_region[i] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        grid_region[i] = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            bg_sum[i] = q3a_bg_stats->bg_r_sum[i]+q3a_bg_stats->bg_gr_sum[i]+</span><br><span class="line">                    q3a_bg_stats->bg_gb_sum[i]+q3a_bg_stats->bg_b_sum[i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//find dynamic bright region</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i < grid_count; i++){</span><br><span class="line">            <span class="keyword">if</span>(grid_region[i] == <span class="number">2</span>){</span><br><span class="line">                search_dynamic_region(grid_region, i/q3a_bg_stats->bg_region_h_num,</span><br><span class="line">                    i%q3a_bg_stats->bg_region_h_num, q3a_bg_stats->bg_region_v_num,</span><br><span class="line">                    q3a_bg_stats->bg_region_h_num);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//convert to aec weight grid table</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i<grid_count; i++){</span><br><span class="line">            <span class="keyword">if</span>(grid_region[i] != <span class="number">0</span>){</span><br><span class="line">                grid_v_num = i/q3a_bg_stats->bg_region_h_num/v_step;<span class="comment">//calculate current position v</span></span><br><span class="line">                grid_h_num = i%q3a_bg_stats->bg_region_h_num/h_step;<span class="comment">//calculate current position h</span></span><br><span class="line">                <span class="keyword">if</span>(grid_region[i] == <span class="number">2</span>)</span><br><span class="line">                    weight_grid_count[grid_v_num][grid_h_num] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(weight_grid_count[grid_v_num][grid_h_num] != <span class="number">2</span>)</span><br><span class="line">                    weight_grid_count[grid_v_num][grid_h_num] = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//pthread_rwlock_wrlock(&chromatix->lock);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i < NUM_AEC_STATS; i++){</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>; j < NUM_AEC_STATS; j++){</span><br><span class="line">                <span class="keyword">if</span>(weight_grid_count[i][j] == <span class="number">2</span>){</span><br><span class="line">                    chromatix->AEC_algo_data.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span><br><span class="line">                        keda_exposure_weight[i][j] * aec_dynamic_ratio;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(weight_grid_count[i][j] == <span class="number">1</span>)</span><br><span class="line">                    chromatix->AEC_algo_data.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span><br><span class="line">                        keda_exposure_weight[i][j] * aec_static_ratio;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    chromatix->AEC_algo_data.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span><br><span class="line">                        keda_exposure_weight[i][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//pthread_rwlock_unlock(&chromatix->lock);</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (aec->aec_algo_ops.set_parameters) {</span><br><span class="line">            aec->aec_algo_ops.set_parameters(aec->handle, &backlight_set_parameter);</span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">          }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="问题一：一运行就崩溃"><a href="#问题一：一运行就崩溃" class="headerlink" title="问题一：一运行就崩溃"></a>问题一：一运行就崩溃</h3><p>访问了禁止访问的区域？</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">chromatix_3a_parms_type *chromatix = (chromatix_3a_parms_type*)param->u.init_param.chromatix;</span><br><span class="line">backlight_set_parameter.type = AEC_SET_INIT_CHROMATIX_SENSOR;</span><br><span class="line"><span class="built_in">memcpy</span>(&backlight_set_parameter.u.init_param, &param->u.init_param,</span><br><span class="line">  <span class="keyword">sizeof</span>(<span class="keyword">aec_set_parameter_init_t</span>));</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i < NUM_AEC_STATS; i++)</span><br><span class="line">  <span class="keyword">for</span>(j=<span class="number">0</span>;j < NUM_AEC_STATS; j++)</span><br><span class="line">      keda_exposure_weight[i][j] =</span><br><span class="line">      chromatix->AEC_algo_data.aec_metering_tables.AEC_weight_center_weighted[i][j];</span><br></pre></td></tr></tbody></table></figure>
<p>这里主要定义了二维数组<code>keda_exposure_weight</code>和<code>backlight_set_parameter</code>，其中<code>backlight_set_parameter</code>中有数组指针，很可能是指针的访问越界了。</p>
<blockquote>
<p>指针有两个属性:指向变量/对象的地址和长度，但是指针只存储地址,长度则取决于指针的类型</p>
<p>void指针赋值给其他类型的指针时都要进行转换，void指针不能参与指针运算,除非进行转换 </p>
</blockquote>
<p>这是他们初始化的地方，直接对<code>backlight_set_parameter</code>进行memcpy，值得注意的是其中有一个void*指针，由于指针只是一个8个或者4个字节的类型，因此这样赋值是没有问题的，而指针的类型只是和指针的运算有关系，在后面的运算中进行强制类型转换就可以了。</p>
<p>这里还需要注意两个问题：</p>
<ul>
<li><p>这个初始化函数是否运行，因为没有运行意味着没有对void*指针进行初始化</p>
</li>
<li><p>对void*指向的内容进行读取或者修改，也就是说对chromatix参数进行修改，是否这个参数只是一个函数的局部变量或者形参。运行完函数就会丢弃。</p>
</li>
</ul>
<p>相比较来说，第二种情况更有可能，因此进行分析，从初始化的地方搜寻chromatix指针的来源。在<code>aec_port</code>中我们可以发现：此处init_param.chromatix的数据，指向的是<code>event->u.module_event->module_event_data->chromatix3APtr</code></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">modulesChromatix_t *mod_chrom =</span><br><span class="line">    (modulesChromatix_t *)mod_evt->module_event_data;</span><br><span class="line"><span class="keyword">q3a_thread_aecawb_msg_t</span> *aec_msg = aec_port_malloc_msg(MSG_AEC_SET,</span><br><span class="line">      AEC_SET_PARAM_INIT_CHROMATIX_SENSOR);</span><br><span class="line">aec_msg->u.aec_set_parm.u.init_param.chromatix = mod_chrom->chromatix3APtr;</span><br><span class="line">rc = q3a_aecawb_thread_en_q_msg(<span class="keyword">private</span>->thread_data, aec_msg);</span><br></pre></td></tr></tbody></table></figure>

<p>在sensor模块中的<code>sensor_util_post_chromatix_event_downstream</code>函数中我们可以看到</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">module_chromatix.chromatix3APtr =</span><br><span class="line">   s_bundle->chromatix_metadata.a3_chromatix_ptr =</span><br><span class="line">     chromatix_params->chromatix_ptr[SENSOR_CHROMATIX_3A];</span><br><span class="line"> new_event.u.module_event.module_event_data =</span><br><span class="line">   (<span class="keyword">void</span> *)&module_chromatix;</span><br></pre></td></tr></tbody></table></figure>

<p>module_event中就可以获取到chromatix数据的地址，我们只需要将chromatix数据的地址保存下来，就算之后module_event的数据发生了改变，但是chromatix的数据还没进行改变就行了。</p>
<p>不过此时需要注意memcpy的地方，因为这个地方就不是传递地址了，是对值进行传递，后来的变量可能会被回收。</p>
<p>可以看到eztune获取chromatix数据时就是将<code>chromatix_params.chromatix_ptr[SENSOR_CHROMATIX_3A]</code>复制到eztune的结构体中，而设置chromatix参数时是将extune结构体中的chromatix参数复制到<code>chromatix_params.chromatix_ptr[SENSOR_CHROMATIX_3A]</code>中，由此我们也可以进行对chromatix的重载。</p>
<h3 id="重载chromatix的新想法"><a href="#重载chromatix的新想法" class="headerlink" title="重载chromatix的新想法"></a>重载chromatix的新想法</h3><p>是否可以对chromatix数据进行实时加载？通过设置persist，告诉chromatix修改了哪些地方的值，一个type对应一组数据，这个type可以用ADD_ENTRY的方式去定义数组字符串的方式去查找。而数据的话如果比较多就写入文件，这样就不需要全文读取。</p>
<p><code>memcpy(chromatix->aaa_chromatixData,
      chromatix_params.chromatix_ptr[SENSOR_CHROMATIX_3A],
      sizeof(chromatix_3a_parms_type));</code></p>
<p>回归正题，可以既然extune是可以对chromatix数据进行修改，且能够生效，我们就可以确定chromatix_params.chromatix_ptr[SENSOR_CHROMATIX_3A]这里的数据是没有问题的。</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：手动增益不能连续增大</title>
    <url>/2019/03/07/%E5%B7%A5%E4%BD%9C-BUG-BUG-%E5%A2%9E%E7%9B%8A%E8%AE%BE%E7%BD%AE%E4%B8%8D%E6%AD%A3%E7%A1%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p><strong>现象</strong>：从web端将增益快门改成手动，会发现随着增益的增大，图片亮度先递增，到了54时，图片瞬间变暗，再继续递增。  </p>
<p><strong>思路</strong>：从增益从上到下传递的地方推断出可能会改变的地方：<br>业务–ispctrl层–hal层–camera层的aec输出（aec.biz）–camera层的sensor模块的（设置）–写入寄存器</p>
<p><strong>过程</strong>：经过排查发现随着web界面上增益的增大，aec的输出是逐步增大的，对sensor模块进行打印，发现寄存器写入的值也是正确的。怀疑是寄存器初始化有问题，和8056平台的IMX385进行比较，没有找到异常。查看手册，发现相比于290，增益寄存器是两个字节组成的，而web界面上的53对应的是0xff，54对应的是0x100，猜测可能是寄存器只写了低八位。</p>
<p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/20200317001223.png"  alt></p>
<p>查看代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">reg_setting->reg_setting[reg_count].reg_addr =</span><br><span class="line">sensor_lib_ptr.exp_gain_info.global_gain_addr;</span><br><span class="line">reg_setting->reg_setting[reg_count].reg_data = gain & 0xFF;</span><br><span class="line">reg_setting->reg_setting[reg_count].delay = 0;</span><br><span class="line">reg_count = reg_count + 1;</span><br></pre></td></tr></tbody></table></figure>

<p>发现代码真的仅仅对地址0x3014h进行了赋值，没有将高八位赋值。<br>增加代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">reg_setting->reg_setting[reg_count].reg_addr =</span><br><span class="line">sensor_lib_ptr.exp_gain_info.global_gain_addr+1;</span><br><span class="line">reg_setting->reg_setting[reg_count].reg_data = (gain & 0x100) >> 8;</span><br><span class="line">reg_setting->reg_setting[reg_count].delay = 0;</span><br><span class="line">reg_count = reg_count + 1;</span><br></pre></td></tr></tbody></table></figure>

<p>解决问题。但是需要注意代码中<code>reg_setting[reg_count]</code>的<code>reg_count</code>是否进行初始化，是否会出现数组溢出的问题？此处没有细查。<br><strong>小结</strong>：<br>对增益从web端的传递到寄存器的过程加深了理解。</p>
<h2 id="帮助对日夜切换代码修改"><a href="#帮助对日夜切换代码修改" class="headerlink" title="帮助对日夜切换代码修改"></a>帮助对日夜切换代码修改</h2><ol>
<li>将结构体从HAL层的qcameraparameter传递到qcameraHWI。实现按值传递和按地址传递，最终选择按地址传递。</li>
<li>定位日夜切换代码会对ISP传递过来的参数造成影响的BUG<br><strong>小结</strong>：由于高通将每个模块的变量都分离开来，不能随意获取，同样每个模块的函数也不能随意使用，可能会将这个模块中定义的实例又刷新一遍</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>增益设置</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript学习笔记</title>
    <url>/2019/03/04/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%AB%AF-JavaScript%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>JavaScript 是一种轻量级的可插入 HTML 页面的编程语言。那么JavaScript如何编写？如何实现逻辑？</p>
<a id="more"></a>

<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><ul>
<li><p>可以写入html输出、对时间做出反应、改变HTML的内容、图像、样式等等</p>
</li>
<li><p>HTML 中的脚本必须位于 <script> 与 <script> 标签之间。</p>
</li>
<li><p><strong>脚本可被放置在 HTML 页面的<body> 和 <head> 部分中。</strong>通常的做法是把函数放入 <head&gt 部分中，或者放在页面底部。这样就可以把它们安置到同一处位置，不会干扰页面的内容。</p>
</li>
<li><p>如需在 HTML 页面中插入 JavaScript，请使用 <script> 标签。</p>
</li>
<li><p><body>中的JavaScript会在页面加载时运行</p>
</li>
<li><p>通常，我们需要在某个事件发生时执行代码，比如当用户点击按钮时。</p>
<p>如果我们把 JavaScript 代码放入函数中，就可以在事件发生时调用该函数。</p>
</li>
<li><p>如需使用外部文件，请在 <script> 标签的 “src” 属性中设置该 .js 文件，注意外部脚本不能包含 <script>标签。</p>
</li>
<li><p>document.write() 仅仅在加载时向文档输出写内容。</p>
<p>如果在文档已完成加载后再执行 document.write，整个 HTML 页面将被覆盖</p>
</li>
<li><p>注释和C语言一样</p>
</li>
<li><p>变量为var</p>
</li>
<li><p>对象的定义-名称和值对的形式：var person={firstname:”Bill”, lastname:”Gates”, id:5566};</p>
</li>
<li><p>函数定义不用定义参数类型</p>
</li>
</ul>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>JavaScript HTML DOM（Document Object Model）文档对象模型</p>
<p><strong>可访问 JavaScript HTML 文档的所有元素。</strong></p>
<p><img src="/" class="lazyload" data-src="http://www.w3school.com.cn/i/ct_htmltree.gif"  alt="DOM HTML 树"></p>
<p>我们可以通过id、标签名、类名找到html元素</p>
<p>可以对html元素内容进行修改</p>
<p>添加和删除节点（HTML元素）</p>
<h1 id="常用对象"><a href="#常用对象" class="headerlink" title="常用对象"></a>常用对象</h1><ul>
<li><p>对象建立类似c++，但是它可以直接创建新的实例，而不需要定义，在之后进行添加就行</p>
</li>
<li><p>只有一种数字类型，所有数字都会存储为根为10的64位浮点数</p>
</li>
<li><p>字符串长度length</p>
</li>
<li><p>Date 日期对象  getdate、setdate 可以用大小直接比较日期的先后</p>
</li>
<li><p>array 数组 sort 排序</p>
</li>
<li><p>Boolean 对象 用于将非逻辑值转换为逻辑值（true 或者 false）。</p>
</li>
<li><p><strong>正则表达式</strong>：RegExp 对象用于规定在文本中检索的内容。RegExp 对象有 3 个方法：test()、exec() 以及 compile()。</p>
<ul>
<li>test() 方法检索字符串中的指定值。返回值是 true 或 false。</li>
<li>exec() 方法检索字符串中的指定值。返回值是被找到的值。如果没有发现匹配，则返回 null。</li>
<li>compile() 方法用于改变 RegExp, 既可以改变检索模式，也可以添加或删除第二个参数。</li>
</ul>
</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>高通设备代码更新及版本更换</title>
    <url>/2019/03/01/%E5%B7%A5%E4%BD%9C-%E7%BC%96%E7%A8%8B-%E9%AB%98%E9%80%9A%E8%AE%BE%E5%A4%87%E4%BB%A3%E7%A0%81%E6%9B%B4%E6%96%B0%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E6%8D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="8056"><a href="#8056" class="headerlink" title="8056"></a>8056</h1><h2 id="代码更新"><a href="#代码更新" class="headerlink" title="代码更新"></a>代码更新</h2><p>短的没有日期的分支是封闭流，长的有日期的分支是每日流，注意hal层和camera层的分支和版本要一致。</p>
<h2 id="代码编译"><a href="#代码编译" class="headerlink" title="代码编译"></a>代码编译</h2><h3 id="ISP层"><a href="#ISP层" class="headerlink" title="ISP层"></a>ISP层</h3><ol>
<li><p>cd到第二个ispctrl目录下  </p>
<p><code>source makerulers/build/tools/init.sh</code>  </p>
</li>
<li><p>cd 到第三个ispctrl目录下   </p>
</li>
<li><p>sys-build config依次选择1 3 2</p>
</li>
<li><p>sys-build</p>
<p>由于每次上电初始化都会将/system/stc中的updata.bz2解压，</p>
<p>覆盖掉ispctrl的编译，所以我们可以将updata.bz2重命名，</p>
<p>让设备找不到，防止覆盖</p>
</li>
</ol>
<h3 id="hal和camera层"><a href="#hal和camera层" class="headerlink" title="hal和camera层"></a>hal和camera层</h3><ol>
<li>在根目录设置环境：<code>source build/envsetup.sh</code> 将用到的命令加在到环境变量里去</li>
<li>选择编译目标:lunch</li>
<li>选择s618-eng然后选择ipc_8056</li>
<li>mm –j24</li>
</ol>
<h3 id="生成代码位置"><a href="#生成代码位置" class="headerlink" title="生成代码位置"></a>生成代码位置</h3><ul>
<li><p>hal层: 生成<code>out\target\product\s618\obj_arm\lib\camera.sdm660.so</code> –>通过adb push推送到<code>/system/lib/hw</code></p>
</li>
<li><p>camera层：在此目录下生成的其他动态库文件通过adb push推送到<code>/system/vendor/lib</code>(对文件生成时间排序，可以知道哪些是新生成的文件)</p>
</li>
<li><p>ispctrl层：  </p>
<p>由于每次上电初始化都会将/system/stc中的updata.bz2解压，</p>
<p>覆盖掉ispctrl的编译，所以我们可以将updata.bz2重命名，</p>
<p>让设备找不到，防止覆盖</p>
</li>
</ul>
<h3 id="17230端口及网络ADB设置"><a href="#17230端口及网络ADB设置" class="headerlink" title="17230端口及网络ADB设置"></a>17230端口及网络ADB设置</h3><h2 id="网络ADB及17230端口设置"><a href="#网络ADB及17230端口设置" class="headerlink" title="网络ADB及17230端口设置"></a>网络ADB及17230端口设置</h2><p>可以将其配置成xshell中的脚本，以IP：10.82.1.123举例：</p>
<ul>
<li><p>17230端口连接：  </p>
<p>首先在web界面上确认打开了配置->系统->用户安全->安全服务->ssh登录</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">telnet 10.82.1.123 17230</span><br><span class="line">admin</span><br><span class="line">admin123</span><br><span class="line">openssh</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>23端口连接及root：  </p>
<p>需要首先打开17230端口</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">telnet 10.82.1.123</span><br><span class="line">admin</span><br><span class="line">admin123</span><br><span class="line">setprop service.adb.tcp.port 5555 && stop adbd && start adbd</span><br><span class="line">setprop service.ipc.root 1</span><br></pre></td></tr></tbody></table></figure>

<p>adb连接及root</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">adb connect 10.82.1.123</span><br><span class="line">adb root</span><br><span class="line">adb remount</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<h3 id="USB-adb-打开root"><a href="#USB-adb-打开root" class="headerlink" title="USB adb 打开root"></a>USB adb 打开root</h3><p>当推入某个动态库，设备挂掉，连不上网络的时候，可以用usb线进行adb push：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">setprop service.ipc.root 1</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>USB adb 打开root:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">setprop service.ipc.root 1</span><br></pre></td></tr></tbody></table></figure>


</li>
</ul>
<h2 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h2><h3 id="pkg"><a href="#pkg" class="headerlink" title="pkg:"></a>pkg:</h3><ul>
<li><p>txt文档中对应了每个设备的安装包;</p>
</li>
<li><p>在17230端口中输入ipcsetpkghead 8056_185；不同的设备需</p>
<p>要不同的升级包，改下这个，让其匹配才能升级(不需要这一步了)</p>
</li>
<li><p>在IE浏览器中输入IP，用户名是<code>admin</code>，密码是<code>admin123</code>，</p>
<p>进入摄像机的界面，在配置->系统->系统维护->升级</p>
</li>
</ul>
<h3 id="fastboot"><a href="#fastboot" class="headerlink" title="fastboot"></a>fastboot</h3><ul>
<li>如果正常开机模式下，通过adb进入fastboot模式：<code>adb reboot-bootloader</code></li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">fastboot flash boot C:\work\ROM\boot.img</span><br><span class="line">fastboot flash persist C:\work\ROM\persist.img</span><br><span class="line">fastboot flash system C:\work\ROM\system.img</span><br><span class="line">fastboot flash userdata C:\work\ROM\userdata.img</span><br><span class="line">fastboot flash recovery C:\work\ROM\recovery.img</span><br><span class="line"></span><br><span class="line">fastboot reboot</span><br></pre></td></tr></tbody></table></figure>

<p>fastboot reboot重启设备并进去正常启动模式（退出fastboot）</p>
<ul>
<li><p>需要用IPCSearch重新设置IP</p>
<ul>
<li><p>设备激活(密码设置为admin123)</p>
</li>
<li><p>网络参数修改</p>
<p>IP:10.82.x.xxx</p>
<p>子网掩码：255.255.0.0</p>
<p>网关：10.82.255.254</p>
</li>
</ul>
</li>
</ul>
<h2 id="版本地址"><a href="#版本地址" class="headerlink" title="版本地址"></a>版本地址</h2><h3 id="pkg-1"><a href="#pkg-1" class="headerlink" title="pkg"></a>pkg</h3><ul>
<li><p>用户名密码都是：<code>kdm</code></p>
</li>
<li><p>pkg: <code>\\10.9.0.99\ReleaseVersions\KDM\Mobile\S618\IPC2255_L6.0\ROM_Release\IPC2255_ROM_20190228_IPC-8056-V1.0.549-rel-user\ota</code></p>
</li>
</ul>
<hr>
<h1 id="执法记录仪"><a href="#执法记录仪" class="headerlink" title="执法记录仪"></a>执法记录仪</h1><h2 id="打开17230端口"><a href="#打开17230端口" class="headerlink" title="打开17230端口"></a>打开17230端口</h2><p>adb forward tcp:17230 tcp:17230</p>
<p>在xshell中连接17230端口：</p>
<p>telnet 127.0.0.1 17230</p>
<h2 id="代码编译-1"><a href="#代码编译-1" class="headerlink" title="代码编译"></a>代码编译</h2><h3 id="hal和camera层-1"><a href="#hal和camera层-1" class="headerlink" title="hal和camera层"></a>hal和camera层</h3><ul>
<li><p>进入工程的根目录下进行编译环境配置  </p>
<p><code>$source build/envsetup.sh</code></p>
<p><code>Lunch 37</code></p>
</li>
<li><p>进入对应的文件夹下<code>mm –j24</code></p>
</li>
</ul>
<h3 id="isp层"><a href="#isp层" class="headerlink" title="isp层"></a>isp层</h3><p>android-ispctrl/android-isp1/下执行：</p>
<pre><code>source makerulers/build/tools/init.sh      
sys-build config  132
sys-build 
sys-build TARGET_PRODUCT=sdm660_mobile</code></pre><p>这里的TARGET_PRODUCT，可以在make.mk里修改默认定义(只在调试时用，不要提交代码)</p>
<h3 id="推库"><a href="#推库" class="headerlink" title="推库"></a>推库</h3><p>获取权限 </p>
<pre><code>adb shell 
setprop service.user.test 1    
setenforce 0
Kdb remount</code></pre><h3 id="生成代码位置-1"><a href="#生成代码位置-1" class="headerlink" title="生成代码位置"></a>生成代码位置</h3><ul>
<li><p>hal层: 生成<code>out\target\product\u2p\system\lib\hw\camera.sdm660.so</code> –>通过adb push推送到<code>/system/lib/hw</code></p>
</li>
<li><p>camera层：在此目录下生成的其他动态库文件通过adb push推送到<code>/system/vendor/lib</code></p>
</li>
<li><p>ispctrl层：生成<code>android-ispctrl\android-isp1\packages\android-ispctrl\release\cbb\ispctrl\lib\linux_android\release\sdm660_mobile\libispctrl.so</code> –>通过adb push推送到<code>/data/app/com.kedacom.ptt-1/lib/arm</code></p>
<p>修改ispctrl中的代码，要将APK进程杀死，不能重启设备，不然又被覆盖掉了。Kdb shell pkill ptt</p>
</li>
</ul>
<h2 id="升级过程-1"><a href="#升级过程-1" class="headerlink" title="升级过程"></a>升级过程</h2><h3 id="fastboot-1"><a href="#fastboot-1" class="headerlink" title="fastboot"></a>fastboot</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">adb reboot-bootloader </span><br><span class="line">fastboot flash boot boot.img</span><br><span class="line">fastboot flash cache cache.img</span><br><span class="line">fastboot flash persist persist.img</span><br><span class="line">fastboot flash recovery recovery.img</span><br><span class="line">fastboot flash system system.img</span><br><span class="line">fastboot flash userdata userdata.img</span><br><span class="line">REM 最后一个system比较大</span><br><span class="line">fastboot flash -S 500000K system system.img</span><br><span class="line">fastboot flash aboot aboot emmc_appsboot.mbn</span><br></pre></td></tr></tbody></table></figure>

<p>变砖后进入fastboot：<br>拔电池，再放上，按住音量下连USB线，会进到fastboot</p>
<h2 id="版本地址-1"><a href="#版本地址-1" class="headerlink" title="版本地址"></a>版本地址</h2><p>APK:</p>
<p><code>\\172.16.0.99\ReleaseVersions\KDM\Solution\VS-P-a0\YDPT_ANDROID\20180810_DSJ_SDM660_APK\20180828\DSJ_SDM660_APK_R8250#0958\apk</code></p>
<hr>
<h1 id="660IPC"><a href="#660IPC" class="headerlink" title="660IPC"></a>660IPC</h1><p>门禁设备PKG：</p>
<p>\10.9.0.99\ReleaseVersions\system\android\android-rom\SDM660\KSCA120</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>版本更新</tag>
        <tag>adb</tag>
        <tag>推库</tag>
      </tags>
  </entry>
  <entry>
    <title>递归函数设计</title>
    <url>/2019/02/27/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>问题可用递归来解决需要具备的条件：<br>1.子问题需与原问题为同样的事，且规模更小 2.程序停止条件。</p>
<p>递归函数常用方法:<br>1.分治法 2.后置递归法 3.回溯法</p>
<a id="more"></a>

<h1 id="如何思考递归"><a href="#如何思考递归" class="headerlink" title="如何思考递归"></a>如何思考递归</h1><p>那我们怎么判断这个递归计算是否是正确的呢？Paul Graham 提到一种方法，如下：</p>
<blockquote>
<p>如果下面这两点是成立的，我们就知道这个递归对于所有的 n 都是正确的。<br>当 n=0,1 时，结果正确；<br>假设递归对于 n 是正确的，同时对于 n+1 也正确。</p>
</blockquote>
<p>这种方法很像<strong>数学归纳法</strong>，也是递归正确的思考方式，上述的第 1 点称为基本情况，第 2 点称为通用情况。</p>
<p>在递归中，我们通常把第 1 点称为终止条件，因为这样更容易理解，其作用就是终止递归，防止递归无限地运行下去。</p>
<h1 id="分治法设计思想"><a href="#分治法设计思想" class="headerlink" title="分治法设计思想"></a>分治法设计思想</h1><ul>
<li><p>对于一个输入规模为n的函数或问题，用某种方法把输入分割成k(1<k≤n)个子集，从而产生<em>k</em>个相似的子问题；</p>
</li>
<li><p>分别求解这k个子问题，得出<em>k</em>个问题的子解;再用某种方法把它们<strong>组合成原来问题的解</strong>；</p>
</li>
<li><p>若子问题还相当大，则可以反复使用分治法，直至最后所分得的子问题足够小，以至可以直接求解为止。</p>
</li>
</ul>
<p>常见的解决问题有：斐波那契数列，汉诺塔问题等<br>举个例子：如绘制标尺，标出两段，找到中点并将其标出，然后同样的操作作用于标尺的左半部分和右半部分。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len=<span class="number">66</span>;   </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> divs=<span class="number">6</span>;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subdivide</span><span class="params">(<span class="keyword">char</span> ar[],<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> level)</span></span>;   </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>{   </span><br><span class="line">    <span class="keyword">char</span> ruler[len];   </span><br><span class="line">    <span class="keyword">int</span> i;   </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i<len<span class="number">-2</span>;i++)   </span><br><span class="line">        ruler[i]=<span class="string">' '</span>;   </span><br><span class="line">    ruler[len<span class="number">-1</span>]=<span class="string">'\0'</span>;   </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span>=len<span class="number">-2</span>;   </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span>=<span class="number">0</span>;   </span><br><span class="line">    ruler[<span class="built_in">min</span>]=ruler[<span class="built_in">max</span>]=<span class="string">'|'</span>;   </span><br><span class="line">    <span class="built_in">cout</span><<ruler<<<span class="built_in">endl</span>;   </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i<=divs;i++)   </span><br><span class="line">    {   </span><br><span class="line">        subdivide(ruler,<span class="built_in">min</span>,<span class="built_in">max</span>,i);   </span><br><span class="line">        <span class="built_in">cout</span><<ruler<<<span class="built_in">endl</span>;   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j<len<span class="number">-2</span>;j++)   </span><br><span class="line">            ruler[j]=<span class="string">' '</span>;   </span><br><span class="line">    }   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line"></span><br><span class="line">}   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subdivide</span><span class="params">(<span class="keyword">char</span> ar[],<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> level)</span>   </span></span><br><span class="line"><span class="function"></span>{   </span><br><span class="line">    <span class="keyword">if</span>(level==<span class="number">0</span>)   </span><br><span class="line">        <span class="keyword">return</span>;   </span><br><span class="line">    <span class="keyword">int</span> mid=(high+low)/<span class="number">2</span>;   </span><br><span class="line">    ar[mid]=<span class="string">'|'</span>;   </span><br><span class="line">    subdivide(ar,low,mid,level<span class="number">-1</span>);   </span><br><span class="line">    subdivide(ar,mid,high,level<span class="number">-1</span>);   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="后置递归设计思想"><a href="#后置递归设计思想" class="headerlink" title="后置递归设计思想"></a>后置递归设计思想</h1><p>假如某个问题的求解过程可以分成若干步进行，并且<strong>当前这一步的解可以直接求得</strong>，则<strong>先求出当前这一步的解</strong>，对于<strong>余下的问题</strong>，若问题的性质和原问题类似，则又可<strong>递归求解</strong>。</p>
<p>后置递归算法的典型举例:删除单链表中所有值为x的数据元素</p>
<p><strong>分析:</strong></p>
<p>1)单链表是一种顺序结构，必须从第一个结点起，逐个检查每个结点的数据元素;</p>
<p>2)从另一角度看，链表又是一个递归结构，若L是带头结点线性链表(a1,a2,¼, an)的头指针，则 L->next是线性链表(a2,¼, an)的头指针。</p>
<p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20180831154918148?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXhpYW5nMTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"  alt></p>
<h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><p>回溯法是一种“穷举搜索”方法。其基本思想为:</p>
<ul>
<li><p>假设问题的解为 n 元组 (x1, x2, …, xn)；</p>
</li>
<li><p>如果n 元组的部分解为 (x1, x2, …, xi) (i<n) ,且应满足一定的约束条件；</p>
</li>
<li><p>对于已求得的部分解 (x1, x2, …, xi) ，若在添加 xi+1 之后仍然满足约束条件，则得到一个新的部分解 (x1, x2, …, xi+1) ；之后继续添加 xi+2并检查之；</p>
</li>
<li><p>若找不到一个xi+1满足约束条件，则从当前部分解中删去xi, 回溯到前一个部分解(x1,x2, × × ×,xi-1 ),重新添加那些尚未考察过的xi，并检查之；</p>
</li>
<li><p>如此反复进行，直至求得满足约束条件的问题的解，或者证明问题无解；</p>
</li>
</ul>
<p>设四皇后问题的解为 (x1, x2, x3, x4), 其中:</p>
<p> xi (i=1,2,3,4) ，约束条件为: 其中任意两个xi 和xj不能位于棋盘的同行、同列及同对角线.</p>
<p>皇后问题回溯算法关键:</p>
<p>搜索策略: 深度优先，依次取 xi=1,2,3,4;</p>
<p>约束条件: xi和xj不位于棋盘的同行、同列及同对角线上；</p>
<p>终止条件: 找到满足条件的x1,x2 x3,x4；即:i=n</p>
<p>回溯条件:  在当前初始条件下无解；无解: 回溯到了起始状态,i=0；</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trial</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">  <span class="comment">// 进入本函数时，在n×n棋盘前i-1行已放置了互不攻</span></span><br><span class="line">  <span class="comment">// 击的i-1个棋子。现从第 i 行起继续为后续棋子选择 </span></span><br><span class="line">  <span class="comment">// 满足约束条件的位置。当求得(i>n)的一个合法布局</span></span><br><span class="line">  <span class="comment">// 时，输出之。i 的初始值为1。</span></span><br><span class="line">  <span class="keyword">if</span>(i=<span class="number">0</span>)  无解；</span><br><span class="line">  <span class="keyword">if</span> (i>n) 输出棋盘的当前布局;                <span class="comment">//终止</span></span><br><span class="line">  <span class="keyword">else</span>  <span class="keyword">for</span> (j=<span class="number">1</span>;  j<=n; ++j) {                     <span class="comment">//试探策略</span></span><br><span class="line">      在第 i 行第 j 列放置一个棋子;</span><br><span class="line">      <span class="keyword">if</span> (当前布局合法) Trial(i+<span class="number">1</span>, n); <span class="comment">//约束-递归</span></span><br><span class="line">      移去第 i 行第 j 列的棋子;          <span class="comment">//回溯</span></span><br><span class="line">  }        </span><br><span class="line">} <span class="comment">// Trial</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="递归注意事项"><a href="#递归注意事项" class="headerlink" title="递归注意事项"></a>递归注意事项</h1><p>1.先写出问题求解的递归定义,包括两项内容:</p>
<ul>
<li><p>基本项:描述一个或几个递归过程的终结状态；</p>
</li>
<li><p>归纳项:描述如何从当前状态到下一状态的转换；</p>
</li>
</ul>
<p>2 写递归函数时注意: </p>
<p>严格定义函数的功能和接口;<br> 将每一个递归看成一个简单的操作;<br> <strong>切忌想得太深太远！</strong>  </p>
<p>3.分析递归算法的工具是<strong>递归树</strong>，从递归树上可以得到递归函数的各种相关信息。</p>
<ul>
<li><p>递归树的深度即为递归函数的<strong>递归深度</strong></p>
</li>
<li><p>递归树上的结点数目恰为函数中的主要操作<strong>重复进行的次数</strong>；</p>
</li>
<li><p>若递归树蜕化为<strong>单支树</strong>或者递归树中<strong>含有很多相同的结点</strong>，则表明该递归函数不适用。比如fib(n) = fib(n-1)+fib(n-2)</p>
</li>
</ul>
<p>在这种情况下会重复计算很多比n小的值得fib值，重复太多！！！<br>所以这种情况下用迭代会更适合一些！！！</p>
<p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20180831160036212?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXhpYW5nMTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"  alt>  </p>
<h1 id="我的实践"><a href="#我的实践" class="headerlink" title="我的实践"></a>我的实践</h1><p>找到与之相连的联通域</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search_dynamic_region</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-1</span>; i < <span class="number">2</span>; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">-1</span>; j < <span class="number">2</span>; j++) {</span><br><span class="line">            <span class="keyword">if</span> (x + i >= <span class="number">0</span> && x + i < row &&</span><br><span class="line">                y + j >= <span class="number">0</span> && y + j < col &&</span><br><span class="line">                p[(x + i)*row + y + j] == <span class="number">1</span>) {</span><br><span class="line">                p[(x + i)*row + y + j] = <span class="number">2</span>;</span><br><span class="line">                search_dynamic_region(p, x + i, y + j, row, col);</span><br><span class="line">            }    </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ROW = <span class="number">10</span>,COL = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> s[<span class="number">10</span>][<span class="number">10</span>] = { {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>},</span><br><span class="line">                         {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>},</span><br><span class="line">                         {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>},</span><br><span class="line">                         {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>},</span><br><span class="line">                         {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>},</span><br><span class="line">                         {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>},</span><br><span class="line">                         {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>},</span><br><span class="line">                         {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>},</span><br><span class="line">                         {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>},</span><br><span class="line">                         {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>} };</span><br><span class="line">    <span class="keyword">int</span> str[] = {  <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, </span><br><span class="line">                    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, </span><br><span class="line">                    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, </span><br><span class="line">                    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, </span><br><span class="line">                    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, </span><br><span class="line">                    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>, </span><br><span class="line">                    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>, </span><br><span class="line">                    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < ROW; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < COL; j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//一维数组的方式</span></span><br><span class="line">            <span class="comment">//if (str[i*ROW + j] == 2)</span></span><br><span class="line">            <span class="comment">//    search_dynamic_region(str, i, j,ROW,COL);</span></span><br><span class="line">            <span class="comment">//二维数组的方式</span></span><br><span class="line">            <span class="keyword">if</span>(s[i][j]==<span class="number">2</span>)</span><br><span class="line">                search_dynamic_region((<span class="keyword">int</span>*)s, i, j, ROW, COL);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>五子棋算法设计</title>
    <url>/2019/02/27/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-%E7%AE%97%E6%B3%95-%E4%BA%94%E5%AD%90%E6%A3%8B%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>如何设计一个五子棋逻辑以及算法？</p>
<p>如何计算哪个位置更好？——极大值极小值算法</p>
<p>如何使程序运行更快？——alpha-beta剪枝算法</p>
<a id="more"></a>

<h1 id="极大值极小值算法"><a href="#极大值极小值算法" class="headerlink" title="极大值极小值算法"></a>极大值极小值算法</h1><p>这是一个双方博弈的游戏，双方都会下对自己有利的棋子，但对方下了一个，我可以全盘搜索，找到一个最有利的，但是对方也会找到一个对自己最有利的，这样就完全没有了防守。我们可以把棋盘进行打分，这个分数代表对我有利的程度。当对方落子之后，我有n个可以落子的地方，假设我落一个子，对方有n-1个落子的地方，它会取分数最小的一种情况，那么这就是对方会走的路子，而我的责任就是让分数最大，在这n个分数中找到一个最大值。这就是极大值极小值的算法。但是人往往可以预测好几步，所以我们也需要预测好几步，我这只是列举的两层的</p>
<h1 id="alpha-beta剪枝算法"><a href="#alpha-beta剪枝算法" class="headerlink" title="alpha-beta剪枝算法"></a>alpha-beta剪枝算法</h1><p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/alphabeta%E5%89%AA%E6%9E%9D%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3.jpg"  alt></p>
<p>这是四层的alpha-beta剪枝算法，达到快速删去无用分支的目的。在四层之后对棋盘做一个统计分数的行为，代表我方的得分，得分越高，对我方越有利。<br>我方要使这个数最大，因此遇到会产生小值的节点要舍弃，这里定一个alpha。<br>对方要使我的得分最小，因此遇到会产生大值得节点要舍弃，这里定一个beta，最后可以接受的节点范围是在区间（alpha，beta）<br>在这个图中，最难懂的是第三个值返回了8，为什么要舍弃这个节点？<br>误区：由于返回了8，值比beta大，肯定是对对方不利，才会删去这个节点。可是这正好是对方的回合，他完全可以寻找这个节点中有没有更小的值，它会选择一个最小的值<br>那是否是它写错了呢？其实不然<br>解释：MAX节点的目标是最大化以该节点为根的子树的值。也就是取子节点的最大值，那应该是对方，因为只要到了我方，才会要求本回合的值最大。也就是说这里的MAX是对方，MIN是我方，我方一定会下最大的值，8比6大，那么他一定会选择第二种方案，但是对方一定不会走这上一个节点（由于比上一个节点得到的值还大），因此其他节点都不需要考虑了。</p>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alpha_beta</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> player, <span class="keyword">int</span> alpha, <span class="keyword">int</span> beta)</span>      <span class="comment">//h搜索深度，player=1表示自己,player=0表示对手 </span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(h==<span class="number">6</span> || (result != <span class="number">0</span>))   <span class="comment">//若到达深度 或是出现胜负 </span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(result != <span class="number">0</span>){        <span class="comment">//若是胜负返回-inf 或+inf </span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> evaluate(player) - evaluate(player^<span class="number">1</span>);   <span class="comment">//否则返回此局面的评价值 </span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">if</span>(player){<span class="comment">//自己</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i<=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j<=n; j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(ch[i][j] == <span class="string">'.'</span>)</span><br><span class="line">            {</span><br><span class="line">                ch[i][j] = <span class="string">'o'</span>;</span><br><span class="line">                <span class="keyword">int</span> ans = alpha_beta(h+<span class="number">1</span>, player^<span class="number">1</span>, alpha, beta);</span><br><span class="line">                ch[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                <span class="keyword">if</span>(ans > alpha){    <span class="comment">//通过向上传递的子节点beta值修正alpha值 </span></span><br><span class="line">                    alpha = ans;</span><br><span class="line">                    ansx = i;       <span class="comment">//记录位置 </span></span><br><span class="line">                    ansy = j;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(alpha >= beta)   <span class="comment">//发生 alpha剪枝 </span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">return</span> alpha;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> alpha;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{<span class="comment">//对手</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i<=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j<=n; j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(ch[i][j] == <span class="string">'.'</span>)</span><br><span class="line">            {</span><br><span class="line">                ch[i][j] = <span class="string">'x'</span>;</span><br><span class="line">                <span class="keyword">int</span> ans = alpha_beta(h+<span class="number">1</span>, player^<span class="number">1</span>, alpha, beta);</span><br><span class="line">                ch[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                <span class="keyword">if</span>(ans < beta){     <span class="comment">//通过向上传递的子节点alpha值修正beta值 </span></span><br><span class="line">                    beta = ans;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(alpha >= beta)   <span class="comment">//发生 beta剪枝</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">return</span> beta;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> beta;    </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h1 id="我的五子棋实现"><a href="#我的五子棋实现" class="headerlink" title="我的五子棋实现"></a>我的五子棋实现</h1><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//基于C#</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.Data;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> xDialog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">five_in_a_row</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//棋子状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> ChessBoardState</span><br><span class="line">    {</span><br><span class="line">        empty = <span class="number">0</span>,</span><br><span class="line">        black = <span class="number">1</span>,</span><br><span class="line">        white = <span class="number">2</span>,</span><br><span class="line">        outrange =<span class="number">3</span></span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">private</span> ChessBoardState nextstate;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">bool</span> GameEnable = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">private</span> Point ChessLocation;</span><br><span class="line">        <span class="keyword">private</span> Rule rule=<span class="keyword">new</span> Rule();</span><br><span class="line">        <span class="keyword">private</span> GameJudge myjudge = <span class="keyword">new</span> GameJudge();</span><br><span class="line">        <span class="keyword">private</span> ChessBoardState mystate;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            <span class="keyword">this</span>.nextstate = ChessBoardState.empty;</span><br><span class="line">            <span class="comment">//将下拉框设置为不可编辑状态,只能选择</span></span><br><span class="line">            <span class="keyword">this</span>.comboBox1.Text = <span class="keyword">this</span>.comboBox1.Items[<span class="number">0</span>].ToString();</span><br><span class="line">            <span class="keyword">this</span>.comboBox1.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;</span><br><span class="line">            <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"请点击开始游戏\r\n祝您游戏愉快"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//棋盘界面初始化</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pictureBox1_Paint</span>(<span class="params"><span class="keyword">object</span> sender, PaintEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            Graphics g = e.Graphics;</span><br><span class="line">            Pen pen2 = <span class="keyword">new</span> Pen(Color.Brown, <span class="number">3</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">19</span>; i++)</span><br><span class="line">            {</span><br><span class="line">                g.DrawLine(pen2, <span class="number">15</span>, <span class="number">15</span> + i * <span class="number">30</span>, <span class="number">615</span>, <span class="number">15</span> + i * <span class="number">30</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">21</span>; i++)</span><br><span class="line">            {</span><br><span class="line">                g.DrawLine(pen2, <span class="number">15</span> + i * <span class="number">30</span>, <span class="number">15</span>, <span class="number">15</span> + i * <span class="number">30</span>, <span class="number">465</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//开始游戏</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="keyword">this</span>.textBox1.ResetText();</span><br><span class="line">            <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"黑子先行\n"</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.comboBox1.Text==<span class="string">"黑子"</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"您执黑子\n"</span>);</span><br><span class="line">                mystate = ChessBoardState.white;</span><br><span class="line">                <span class="keyword">this</span>.nextstate = ChessBoardState.black;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"您执白子\n"</span>);</span><br><span class="line">                mystate = ChessBoardState.black;</span><br><span class="line">                <span class="keyword">this</span>.nextstate = ChessBoardState.white;</span><br><span class="line">                rule.SetChessBoardState(<span class="number">9</span>, <span class="number">10</span>, ChessBoardState.black);</span><br><span class="line">                myjudge.ChessJudgeInitSet(<span class="number">9</span>, <span class="number">10</span>, ChessBoardState.black);</span><br><span class="line">                ChessLocation.X = <span class="number">9</span>;</span><br><span class="line">                ChessLocation.Y = <span class="number">10</span>;</span><br><span class="line">                <span class="comment">//画棋子</span></span><br><span class="line">                Graphics g = <span class="keyword">this</span>.pictureBox1.CreateGraphics();</span><br><span class="line">                    Pen pen3 = <span class="keyword">new</span> Pen(Color.Black, <span class="number">10</span>);</span><br><span class="line">                    g.DrawEllipse(pen3, <span class="number">10</span> + <span class="number">30</span> * ChessLocation.X, <span class="number">10</span> + <span class="number">30</span> * ChessLocation.Y, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">                g.Dispose();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">this</span>.comboBox1.Enabled = <span class="literal">false</span>;</span><br><span class="line">            GameEnable = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//悔棋</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button2_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="comment">//悔棋其实是把这次存储的棋盘删掉，然后将棋盘重画，少画最后一个点</span></span><br><span class="line">            <span class="keyword">this</span>.textBox1.ResetText();</span><br><span class="line">            <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"只能悔棋一次哦:-)\n"</span>);</span><br><span class="line">            rule.SetChessBoardState(ChessLocation.X, ChessLocation.Y, ChessBoardState.empty);</span><br><span class="line">            myjudge.ChessJudgeInitSet(ChessLocation.X, ChessLocation.Y, ChessBoardState.empty);</span><br><span class="line">            <span class="keyword">this</span>.pictureBox1.Refresh();</span><br><span class="line">            Graphics g = <span class="keyword">this</span>.pictureBox1.CreateGraphics();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<Rule.COL;i++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j<Rule.ROW;j++)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (rule.GetChessBoardState(i, j) == ChessBoardState.black)</span><br><span class="line">                    {</span><br><span class="line">                        Pen pen3 = <span class="keyword">new</span> Pen(Color.Black, <span class="number">10</span>);</span><br><span class="line">                        g.DrawEllipse(pen3, <span class="number">10</span> + <span class="number">30</span> * i, <span class="number">10</span> + <span class="number">30</span> * j, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">                        pen3.Dispose();</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(rule.GetChessBoardState(i, j) == ChessBoardState.white)</span><br><span class="line">                    {</span><br><span class="line">                        Pen pen4 = <span class="keyword">new</span> Pen(Color.Aqua, <span class="number">10</span>);</span><br><span class="line">                        g.DrawEllipse(pen4, <span class="number">10</span> + <span class="number">30</span> * i, <span class="number">10</span> + <span class="number">30</span> * j, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">                        pen4.Dispose();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//下一个棋子倒退回去</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.nextstate == ChessBoardState.black)</span><br><span class="line">                <span class="keyword">this</span>.nextstate = ChessBoardState.white;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">this</span>.nextstate = ChessBoardState.black;</span><br><span class="line">            g.Dispose();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//退出游戏</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button3_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="keyword">this</span>.Close();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//落子判断</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pictureBox1_MouseDown</span>(<span class="params"><span class="keyword">object</span> sender, MouseEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="comment">//只有当游戏开始之后才能落子</span></span><br><span class="line">            <span class="keyword">if</span>(GameEnable == <span class="literal">true</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//通过鼠标位置判断棋子的位置</span></span><br><span class="line">                ChessLocation.X = (e.X + <span class="number">30</span>) / <span class="number">30</span> - <span class="number">1</span>;</span><br><span class="line">                ChessLocation.Y = (e.Y + <span class="number">30</span>) / <span class="number">30</span> - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//防止此处已经落下棋子</span></span><br><span class="line">                <span class="keyword">if</span> (rule.GetChessBoardState(ChessLocation.X, ChessLocation.Y) != ChessBoardState.empty)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//画棋子</span></span><br><span class="line">                Graphics g = <span class="keyword">this</span>.pictureBox1.CreateGraphics();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.nextstate == ChessBoardState.black)</span><br><span class="line">                {</span><br><span class="line">                    Pen pen3 = <span class="keyword">new</span> Pen(Color.Black, <span class="number">10</span>);</span><br><span class="line">                    g.DrawEllipse(pen3, <span class="number">10</span> + <span class="number">30</span> * ChessLocation.X, <span class="number">10</span> + <span class="number">30</span> * ChessLocation.Y, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    Pen pen4 = <span class="keyword">new</span> Pen(Color.Aqua, <span class="number">10</span>);</span><br><span class="line">                    g.DrawEllipse(pen4, <span class="number">10</span> + <span class="number">30</span> * ChessLocation.X, <span class="number">10</span> + <span class="number">30</span> * ChessLocation.Y, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//判断是否五子连珠：若五子连珠就结束</span></span><br><span class="line">                rule.SetChessBoardState(ChessLocation.X, ChessLocation.Y, <span class="keyword">this</span>.nextstate);</span><br><span class="line">                myjudge.ChessJudgeInitSet(ChessLocation.X, ChessLocation.Y, <span class="keyword">this</span>.nextstate);</span><br><span class="line">                <span class="comment">//Console.WriteLine("此子得分:{0}分",rule.GetPointScore(ChessLocation.X, ChessLocation.Y, this.nextstate));</span></span><br><span class="line">                <span class="keyword">if</span> (rule.CheckCountLIne(ChessLocation.X, ChessLocation.Y, <span class="keyword">this</span>.nextstate) == <span class="literal">true</span>)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>.nextstate == ChessBoardState.white)</span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"\n白子胜利！\n"</span>);</span><br><span class="line">                        DialogResult result = MsgBox.Show(<span class="string">"白子胜利"</span>, <span class="string">"本局结束"</span>, </span><br><span class="line">                            MsgBox.Buttons.OK, MsgBox.Icon.Exclamation, MsgBox.AnimateStyle.SlideDown);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"\n黑子胜利！\n"</span>);</span><br><span class="line">                        DialogResult result = MsgBox.Show(<span class="string">"黑子胜利"</span>, <span class="string">"本局结束"</span>, </span><br><span class="line">                            MsgBox.Buttons.OK, MsgBox.Icon.Exclamation, MsgBox.AnimateStyle.SlideDown);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < Rule.COL; i++)</span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < Rule.ROW; j++)</span><br><span class="line">                        {</span><br><span class="line">                            rule.SetChessBoardState(i, j, ChessBoardState.empty);</span><br><span class="line">                            myjudge.ChessJudgeInitSet(i, j, ChessBoardState.empty);</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">this</span>.pictureBox1.Refresh();</span><br><span class="line">                    <span class="keyword">this</span>.textBox1.ResetText();</span><br><span class="line">                    <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"请点击开始游戏"</span>);</span><br><span class="line">                    <span class="keyword">this</span>.comboBox1.Enabled = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">this</span>.textBox1.ResetText();</span><br><span class="line">                    <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"此子得分:"</span> +</span><br><span class="line">                            myjudge.GetPointScore(ChessLocation.X, ChessLocation.Y, <span class="keyword">this</span>.nextstate).ToString()</span><br><span class="line">                            + <span class="string">"分\r\n"</span>);</span><br><span class="line">                    Point next = myjudge.NextJudge(mystate,<span class="keyword">out</span> <span class="keyword">int</span> max_score);</span><br><span class="line">                    rule.SetChessBoardState(next.X,next.Y,mystate);</span><br><span class="line">                    myjudge.ChessJudgeInitSet(next.X, next.Y, mystate);</span><br><span class="line">                    <span class="keyword">if</span> (mystate == ChessBoardState.black)</span><br><span class="line">                    {</span><br><span class="line">                        Pen pen3 = <span class="keyword">new</span> Pen(Color.Black, <span class="number">10</span>);</span><br><span class="line">                        g.DrawEllipse(pen3, <span class="number">10</span> + <span class="number">30</span> * next.X, <span class="number">10</span> + <span class="number">30</span> * next.Y, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    {</span><br><span class="line">                        Pen pen4 = <span class="keyword">new</span> Pen(Color.Aqua, <span class="number">10</span>);</span><br><span class="line">                        g.DrawEllipse(pen4, <span class="number">10</span> + <span class="number">30</span> * next.X, <span class="number">10</span> + <span class="number">30</span> * next.Y, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">                    }</span><br><span class="line">                    g.Dispose();</span><br><span class="line">                    <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"电脑预测:"</span> + max_score.ToString()+<span class="string">"分"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (rule.CheckCountLIne(next.X, next.Y, mystate) == <span class="literal">true</span>)</span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">if</span> (mystate == ChessBoardState.white)</span><br><span class="line">                        {</span><br><span class="line">                            <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"\n白子胜利！\n"</span>);</span><br><span class="line">                            DialogResult result = MsgBox.Show(<span class="string">"白子胜利"</span>, <span class="string">"本局结束"</span>,</span><br><span class="line">                                MsgBox.Buttons.OK, MsgBox.Icon.Exclamation, MsgBox.AnimateStyle.SlideDown);</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        {</span><br><span class="line">                            <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"\n黑子胜利！\n"</span>);</span><br><span class="line">                            DialogResult result = MsgBox.Show(<span class="string">"黑子胜利"</span>, <span class="string">"本局结束"</span>,</span><br><span class="line">                                MsgBox.Buttons.OK, MsgBox.Icon.Exclamation, MsgBox.AnimateStyle.SlideDown);</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < Rule.COL; i++)</span><br><span class="line">                        {</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < Rule.ROW; j++)</span><br><span class="line">                            {</span><br><span class="line">                                rule.SetChessBoardState(i, j, ChessBoardState.empty);</span><br><span class="line">                                myjudge.ChessJudgeInitSet(i, j, ChessBoardState.empty);</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">this</span>.pictureBox1.Refresh();</span><br><span class="line">                        <span class="keyword">this</span>.textBox1.ResetText();</span><br><span class="line">                        <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"请点击开始游戏"</span>);</span><br><span class="line">                        <span class="keyword">this</span>.comboBox1.Enabled = <span class="literal">true</span>;</span><br><span class="line">                    }</span><br><span class="line">                        <span class="comment">//if (this.nextstate == ChessBoardState.white)</span></span><br><span class="line">                        <span class="comment">//{</span></span><br><span class="line">                        <span class="comment">//    this.nextstate = ChessBoardState.black;</span></span><br><span class="line">                        <span class="comment">//    this.textBox1.AppendText("请黑方落子");</span></span><br><span class="line">                        <span class="comment">//}</span></span><br><span class="line">                        <span class="comment">//else</span></span><br><span class="line">                        <span class="comment">//{</span></span><br><span class="line">                        <span class="comment">//    this.nextstate = ChessBoardState.white;</span></span><br><span class="line">                        <span class="comment">//    this.textBox1.AppendText("请白方落子");</span></span><br><span class="line">                        <span class="comment">//}</span></span><br><span class="line">                    }    </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//重新开始游戏</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button4_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            GameEnable = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.pictureBox1.Refresh();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < Rule.COL; i++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < Rule.ROW; j++)</span><br><span class="line">                {</span><br><span class="line">                    rule.SetChessBoardState(i, j, ChessBoardState.empty);</span><br><span class="line">                    myjudge.ChessJudgeInitSet(i, j, ChessBoardState.empty);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">this</span>.textBox1.ResetText();</span><br><span class="line">            <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"请点击开始游戏"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Rule</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">int</span> ROW = <span class="number">18</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">int</span> COL = <span class="number">21</span>;</span><br><span class="line">        <span class="keyword">private</span> ChessBoardState[,] ChessBoard;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> CurrentX;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> CurrentY;</span><br><span class="line">        <span class="keyword">private</span> ChessBoardState CurrentState;</span><br><span class="line">        <span class="comment">//通过构造函数初始化</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Rule</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="keyword">this</span>.ChessBoard = <span class="keyword">new</span> ChessBoardState[COL, ROW];</span><br><span class="line">            <span class="keyword">this</span>.CurrentX = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">this</span>.CurrentY = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">this</span>.CurrentState = ChessBoardState.empty;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//获取棋盘该位置的状态</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ChessBoardState <span class="title">GetChessBoardState</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="keyword">if</span> (x < <span class="number">0</span> || x >= COL || y < <span class="number">0</span> || y >= ROW)</span><br><span class="line">                <span class="keyword">return</span> ChessBoardState.outrange;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.ChessBoard[x, y];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//设置棋盘该位置的状态</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">SetChessBoardState</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y, ChessBoardState state</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="keyword">if</span> (x < <span class="number">0</span> || x >= COL || y < <span class="number">0</span> || y >= ROW)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">this</span>.ChessBoard[x, y] = state;</span><br><span class="line">                <span class="keyword">this</span>.CurrentX = x;</span><br><span class="line">                <span class="keyword">this</span>.CurrentY = y;</span><br><span class="line">                <span class="keyword">this</span>.CurrentState = state;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">SetChessBoardState</span>(<span class="params">Point point, ChessBoardState state</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="keyword">if</span> (point.X < <span class="number">0</span> || point.X >= COL || point.Y < <span class="number">0</span> || point.Y >= ROW)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">this</span>.ChessBoard[point.X, point.Y] = state;</span><br><span class="line">                <span class="keyword">this</span>.CurrentX = point.X;</span><br><span class="line">                <span class="keyword">this</span>.CurrentY = point.Y;</span><br><span class="line">                <span class="keyword">this</span>.CurrentState = state;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//检查是否已经五子连珠</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">CheckCountLIne</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y, ChessBoardState state</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">             * 原理：找到四个方向上的第一个子，从第一个子开始查找是否存在连续的五个字</span></span><br><span class="line"><span class="comment">             * 版本改进：while ((y - j > ROW || GetChessBoardState(x, y - j) != state) &&j < 0)</span></span><br><span class="line"><span class="comment">             *           由于越界的棋子都设置为空，因此查找第一个棋子的时候不需要判断是否越界</span></span><br><span class="line"><span class="comment">             * bug：存在隔一个子不能判断的bug;由于需要找到第一个子存在oxooooo的情况不能识别</span></span><br><span class="line"><span class="comment">             ***********************************************************</span></span><br><span class="line"><span class="comment">            int j = -4;</span></span><br><span class="line"><span class="comment">            while (GetChessBoardState(x, y - j) != state && j < 0)</span></span><br><span class="line"><span class="comment">                j += 1;</span></span><br><span class="line"><span class="comment">            while (GetChessBoardState(x, y - j - 1) == state)</span></span><br><span class="line"><span class="comment">            {</span></span><br><span class="line"><span class="comment">                count += 1;</span></span><br><span class="line"><span class="comment">                j += 1;</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">            Console.WriteLine("垂直方向上有{0}个棋子",count);</span></span><br><span class="line"><span class="comment">            if (count >= 5)</span></span><br><span class="line"><span class="comment">                result = true;</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                count = 1;</span></span><br><span class="line"><span class="comment">            j = -4;</span></span><br><span class="line"><span class="comment">            //找到第一个自己的子</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            while (GetChessBoardState(x + j, y) != state && j < 0)</span></span><br><span class="line"><span class="comment">                j += 1;</span></span><br><span class="line"><span class="comment">            while (GetChessBoardState(x + j + 1, y) == state)</span></span><br><span class="line"><span class="comment">            {</span></span><br><span class="line"><span class="comment">                count = count + 1;</span></span><br><span class="line"><span class="comment">                j += 1;</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">            Console.WriteLine("水平方向上有{0}个棋子", count);</span></span><br><span class="line"><span class="comment">            if (count >= 5)</span></span><br><span class="line"><span class="comment">                result = true;</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                count = 1;</span></span><br><span class="line"><span class="comment">            j = -4;</span></span><br><span class="line"><span class="comment">            //    break;</span></span><br><span class="line"><span class="comment">            //case Rule.LineDirection.upslope:</span></span><br><span class="line"><span class="comment">            while ( GetChessBoardState(x + j, y - j) != state && j < 0)</span></span><br><span class="line"><span class="comment">                j += 1;</span></span><br><span class="line"><span class="comment">            while (GetChessBoardState(x + j + 1, y - j - 1) == state)</span></span><br><span class="line"><span class="comment">            {</span></span><br><span class="line"><span class="comment">                count += 1;</span></span><br><span class="line"><span class="comment">                j += 1;</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">            Console.WriteLine("右下方向上有{0}个棋子", count);</span></span><br><span class="line"><span class="comment">            if (count >= 5)</span></span><br><span class="line"><span class="comment">                result = true;</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                count = 1;</span></span><br><span class="line"><span class="comment">            j = -4;</span></span><br><span class="line"><span class="comment">            //    break;</span></span><br><span class="line"><span class="comment">            //case Rule.LineDirection.downslop:</span></span><br><span class="line"><span class="comment">            while (GetChessBoardState(x + j, y + j) != state && j < 0)</span></span><br><span class="line"><span class="comment">                j += 1;</span></span><br><span class="line"><span class="comment">            while (GetChessBoardState(x + j + 1, y + j + 1) == state)</span></span><br><span class="line"><span class="comment">            {</span></span><br><span class="line"><span class="comment">                count += 1;</span></span><br><span class="line"><span class="comment">                j += 1;</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">            Console.WriteLine("左下方向上有{0}个棋子", count);</span></span><br><span class="line"><span class="comment">            if (count >= 5)</span></span><br><span class="line"><span class="comment">                result = true;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            <span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">             * 版本：第三版</span></span><br><span class="line"><span class="comment">             * 原理：在前后总共九个子中寻找连续数量的是否超过5</span></span><br><span class="line"><span class="comment">             * 未发现bug</span></span><br><span class="line"><span class="comment">             ***********************************************************/</span></span><br><span class="line">            <span class="keyword">int</span> j, count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">-4</span>; j < <span class="number">5</span>; j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (GetChessBoardState(x + j, y) == state)</span><br><span class="line">                {</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (count >= <span class="number">5</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">-4</span>; j < <span class="number">5</span>; j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (GetChessBoardState(x, y - j) == state)</span><br><span class="line">                {</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//Console.WriteLine("垂直方向上有{0}个棋子", count);</span></span><br><span class="line">                    <span class="keyword">if</span> (count >= <span class="number">5</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">-4</span>; j < <span class="number">5</span>; j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (GetChessBoardState(x + j, y + j) == state)</span><br><span class="line">                {</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//Console.WriteLine("右下方向上有{0}个棋子", count);</span></span><br><span class="line">                    <span class="keyword">if</span> (count >= <span class="number">5</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">-4</span>; j < <span class="number">5</span>; j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (GetChessBoardState(x + j, y - j) == state)</span><br><span class="line">                {</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//Console.WriteLine("左下方向上有{0}个棋子", count);</span></span><br><span class="line">                    <span class="keyword">if</span> (count >= <span class="number">5</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">     * 人机规则</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * ***********************************************************/</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/棋型估值</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">GameJudge</span></span><br><span class="line">    {</span><br><span class="line">        Rule chessjudge = <span class="keyword">new</span> Rule();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> BE_FIVE = <span class="number">10000000</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> ACTIVIE_FOUR = <span class="number">40000</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> NON_FOUR = <span class="number">5000</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> ACTIVIE_THREE = <span class="number">5000</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> NON_THREE = <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> ACTIVE_TWO = <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> NON_TWO = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> OTHER = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> SEARCH_RANGE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChessJudgeInitSet</span>(<span class="params"><span class="keyword">int</span> x,<span class="keyword">int</span> y,ChessBoardState state</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            chessjudge.SetChessBoardState(x, y, state);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//计算棋子的得分</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetPointScore</span>(<span class="params"><span class="keyword">int</span> x,<span class="keyword">int</span> y,ChessBoardState state</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="keyword">int</span> j, count=<span class="number">0</span>,count_max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">bool</span> non_flag = <span class="literal">false</span>, now_non_flag=<span class="literal">false</span>;</span><br><span class="line">            ChessBoardState non_state;<span class="comment">//获得相反的状态</span></span><br><span class="line">            <span class="keyword">if</span> (state == ChessBoardState.black)</span><br><span class="line">                non_state = ChessBoardState.white;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                non_state = ChessBoardState.black;</span><br><span class="line">            <span class="comment">//水平方向</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">-4</span>; j <= <span class="number">4</span>; j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (chessjudge.GetChessBoardState(x + j, y) == state)</span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">//判断是否有一段截断了</span></span><br><span class="line">                    <span class="keyword">if</span> (count == <span class="number">0</span> && (chessjudge.GetChessBoardState(x + j - <span class="number">1</span>, y) == non_state</span><br><span class="line">                        || chessjudge.GetChessBoardState(x + j - <span class="number">1</span>, y) == ChessBoardState.outrange))</span><br><span class="line">                        non_flag = <span class="literal">true</span>;</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">//判断是否结束截断了</span></span><br><span class="line">                    <span class="keyword">if</span> (chessjudge.GetChessBoardState(x + j, y) == non_state</span><br><span class="line">                        || chessjudge.GetChessBoardState(x + j, y) == ChessBoardState.outrange)</span><br><span class="line">                        non_flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (count > count_max)</span><br><span class="line">                    {</span><br><span class="line">                        count_max = count;</span><br><span class="line">                        now_non_flag = non_flag;</span><br><span class="line">                    }</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    non_flag =<span class="literal">false</span>;</span><br><span class="line">                }   </span><br><span class="line">            }</span><br><span class="line">            score += ScoreJudge(count_max, now_non_flag);</span><br><span class="line">            <span class="comment">//Console.WriteLine("水平得分:{0}分", score);</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            count_max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//垂直方向</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">-4</span>; j <= <span class="number">4</span>; j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (chessjudge.GetChessBoardState(x, y - j) == state)</span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">//判断是否有一段截断了</span></span><br><span class="line">                    <span class="keyword">if</span> (count == <span class="number">0</span> && (chessjudge.GetChessBoardState(x, y - j + <span class="number">1</span>) == non_state</span><br><span class="line">                        || chessjudge.GetChessBoardState(x, y - j + <span class="number">1</span>) == ChessBoardState.outrange))</span><br><span class="line">                        non_flag = <span class="literal">true</span>;</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">//判断是否结束截断了</span></span><br><span class="line">                    <span class="keyword">if</span> (chessjudge.GetChessBoardState(x, y - j) == non_state</span><br><span class="line">                        || chessjudge.GetChessBoardState(x, y - j) == ChessBoardState.outrange)</span><br><span class="line">                        non_flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (count > count_max)</span><br><span class="line">                    {</span><br><span class="line">                        count_max = count;</span><br><span class="line">                        now_non_flag = non_flag;</span><br><span class="line">                    }</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    non_flag = <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            score += ScoreJudge(count_max, now_non_flag);</span><br><span class="line">            <span class="comment">//Console.WriteLine("垂直得分:{0}分", score);</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            count_max = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//右下方向</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">-4</span>; j < <span class="number">5</span>; j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (chessjudge.GetChessBoardState(x + j, y + j) == state)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (count == <span class="number">0</span> && (chessjudge.GetChessBoardState(x + j - <span class="number">1</span>, y + j - <span class="number">1</span>) == non_state</span><br><span class="line">                        || chessjudge.GetChessBoardState(x + j - <span class="number">1</span>, y + j - <span class="number">1</span>) == ChessBoardState.outrange))</span><br><span class="line">                        non_flag = <span class="literal">true</span>;</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">//判断是否结束截断了</span></span><br><span class="line">                    <span class="keyword">if</span> (chessjudge.GetChessBoardState(x + j, y + j) == non_state</span><br><span class="line">                        || chessjudge.GetChessBoardState(x + j, y + j) == ChessBoardState.outrange)</span><br><span class="line">                        non_flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (count > count_max)</span><br><span class="line">                    {</span><br><span class="line">                        count_max = count;</span><br><span class="line">                        now_non_flag = non_flag;</span><br><span class="line">                    }</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    non_flag = <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            score += ScoreJudge(count_max, now_non_flag);</span><br><span class="line">            <span class="comment">//Console.WriteLine("右下得分:{0}分，count_max={1},non_flag={2}", score, count_max, non_flag);</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            count_max = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//左下方向</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">-4</span>; j < <span class="number">5</span>; j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (chessjudge.GetChessBoardState(x + j, y - j) == state)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (count == <span class="number">0</span> && (chessjudge.GetChessBoardState(x + j - <span class="number">1</span>, y - j + <span class="number">1</span>) == non_state</span><br><span class="line">                        || chessjudge.GetChessBoardState(x + j - <span class="number">1</span>, y - j + <span class="number">1</span>) == ChessBoardState.outrange))</span><br><span class="line">                        non_flag = <span class="literal">true</span>;</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (chessjudge.GetChessBoardState(x + j, y - j) == non_state</span><br><span class="line">                        || chessjudge.GetChessBoardState(x + j, y - j) == ChessBoardState.outrange)</span><br><span class="line">                        non_flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (count > count_max)</span><br><span class="line">                    {</span><br><span class="line">                        count_max = count;</span><br><span class="line">                        now_non_flag = non_flag;</span><br><span class="line">                    }</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    non_flag = <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            score += ScoreJudge(count_max, now_non_flag);</span><br><span class="line">            <span class="comment">//Console.WriteLine("左下得分:{0}分，count_max={1},non_flag={2}", score, count_max, non_flag);</span></span><br><span class="line">            <span class="keyword">return</span> score;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//计算每个方向上的最大分数</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">ScoreJudge</span>(<span class="params"><span class="keyword">int</span> count,<span class="keyword">bool</span> flag</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="keyword">switch</span> (count)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    <span class="keyword">return</span> BE_FIVE;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    <span class="keyword">if</span> (flag == <span class="literal">false</span>)</span><br><span class="line">                        <span class="keyword">return</span> ACTIVIE_FOUR;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> NON_FOUR;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="keyword">if</span> (flag == <span class="literal">false</span>)</span><br><span class="line">                        <span class="keyword">return</span> ACTIVIE_THREE;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> NON_THREE;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">if</span> (flag == <span class="literal">false</span>)</span><br><span class="line">                        <span class="keyword">return</span> ACTIVE_TWO;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> NON_TWO;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">return</span> OTHER;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//int[,] ScoreMapMax = new int[Rule.COL, Rule.ROW];</span></span><br><span class="line">        <span class="comment">//int[,] ScoreMapMin = new int[COL, ROW];</span></span><br><span class="line">        <span class="comment">//private Point GetBestPoint(int[,] map)</span></span><br><span class="line">        <span class="comment">//{</span></span><br><span class="line">        <span class="comment">//    int iMax = 0, jMax = 0;</span></span><br><span class="line">        <span class="comment">//    for (int i = 0; i < COL; i++)</span></span><br><span class="line">        <span class="comment">//    {</span></span><br><span class="line">        <span class="comment">//        for (int j = 0; j < ROW; j++)</span></span><br><span class="line">        <span class="comment">//        {</span></span><br><span class="line">        <span class="comment">//            if (map[i, j] > map[iMax, jMax])</span></span><br><span class="line">        <span class="comment">//            {</span></span><br><span class="line">        <span class="comment">//                iMax = i;</span></span><br><span class="line">        <span class="comment">//                jMax = j;</span></span><br><span class="line">        <span class="comment">//            }</span></span><br><span class="line">        <span class="comment">//        }</span></span><br><span class="line">        <span class="comment">//    }</span></span><br><span class="line">        <span class="comment">//    return new Point(jMax, iMax);</span></span><br><span class="line">        <span class="comment">//}</span></span><br><span class="line">        <span class="comment">//private bool[,] map = new bool[COL, ROW];</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//bool result = false;</span></span><br><span class="line">        <span class="comment">//private ChessBoardState[,] Chessjudge = new ChessBoardState[COL, ROW];</span></span><br><span class="line">        <span class="comment">//int evaluate(int player)</span></span><br><span class="line">        <span class="comment">//{</span></span><br><span class="line">        <span class="comment">//    return 1;</span></span><br><span class="line">        <span class="comment">//}</span></span><br><span class="line">        <span class="comment">//设置搜索范围，减小搜索的棋子数量</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">SearchRange</span>(<span class="params"><span class="keyword">int</span> x,<span class="keyword">int</span> y,ChessBoardState state</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="keyword">if</span>(chessjudge.GetChessBoardState(x,y)==ChessBoardState.empty)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = (x - SEARCH_RANGE); i <= (x + SEARCH_RANGE); i++)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = (y - SEARCH_RANGE); j <= (y + SEARCH_RANGE); j++)</span><br><span class="line">                        <span class="keyword">if</span> (chessjudge.GetChessBoardState(i,j) == ChessBoardState.white</span><br><span class="line">                            ||chessjudge.GetChessBoardState(i,j)==ChessBoardState.black)</span><br><span class="line">                        {</span><br><span class="line">                            <span class="keyword">if</span> (i != x || j != y)</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//剪枝算法 需要区分玩家和计算机，同时玩家可以选择先走或者后走</span></span><br><span class="line">        <span class="comment">//int alpha_beta(int depth,ChessBoardState state,int alpha,int beta)</span></span><br><span class="line">        <span class="comment">//{</span></span><br><span class="line">        <span class="comment">//    if(depth==6||result==true)</span></span><br><span class="line">        <span class="comment">//    {</span></span><br><span class="line">        <span class="comment">//        if (result == true)</span></span><br><span class="line">        <span class="comment">//            return result;</span></span><br><span class="line">        <span class="comment">//        else</span></span><br><span class="line">        <span class="comment">//        {</span></span><br><span class="line">        <span class="comment">//            return evaluate(player) - evaluate(player ^ 1);</span></span><br><span class="line">        <span class="comment">//        }</span></span><br><span class="line">        <span class="comment">//    }</span></span><br><span class="line">        <span class="comment">//    ChessBoardState anti_state;</span></span><br><span class="line">        <span class="comment">//    if (state == ChessBoardState.black)</span></span><br><span class="line">        <span class="comment">//        anti_state = ChessBoardState.white;</span></span><br><span class="line">        <span class="comment">//    else</span></span><br><span class="line">        <span class="comment">//        anti_state = ChessBoardState.black;</span></span><br><span class="line">        <span class="comment">//    int i, j;</span></span><br><span class="line">        <span class="comment">//    for(i=0;i<COL;i++)</span></span><br><span class="line">        <span class="comment">//    {</span></span><br><span class="line">        <span class="comment">//        for(j=0;j<ROW;j++)</span></span><br><span class="line">        <span class="comment">//        {</span></span><br><span class="line">        <span class="comment">//            if(SearchRange(i,j,state)==true)</span></span><br><span class="line">        <span class="comment">//            {</span></span><br><span class="line">        <span class="comment">//                Chessjudge[i, j] = state;</span></span><br><span class="line">        <span class="comment">//                int ans = alpha_beta(depth + 1, anti_state, alpha, beta);</span></span><br><span class="line">        <span class="comment">//                if (ans > alpha)</span></span><br><span class="line">        <span class="comment">//                {</span></span><br><span class="line">        <span class="comment">//                    alpha = ans;</span></span><br><span class="line">        <span class="comment">//                    ansx = i;</span></span><br><span class="line">        <span class="comment">//                    ansy = j;</span></span><br><span class="line">        <span class="comment">//                }</span></span><br><span class="line">        <span class="comment">//                if(ans <beta)</span></span><br><span class="line">        <span class="comment">//                {</span></span><br><span class="line">        <span class="comment">//                    beta = ans;</span></span><br><span class="line">        <span class="comment">//                }</span></span><br><span class="line">        <span class="comment">//                if (alpha >= beta)</span></span><br><span class="line">        <span class="comment">//                {</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//                    return alpha;</span></span><br><span class="line">        <span class="comment">//                }</span></span><br><span class="line">        <span class="comment">//            }</span></span><br><span class="line">        <span class="comment">//        }</span></span><br><span class="line">        <span class="comment">//    }</span></span><br><span class="line">        <span class="comment">//}</span></span><br><span class="line">        <span class="comment">//先写一个简单的MAXmin</span></span><br><span class="line">        <span class="comment">//其实用一个数组就够了，不需要重新定义一个棋盘</span></span><br><span class="line">        <span class="keyword">private</span> Point[] tmp = <span class="keyword">new</span> Point[<span class="number">100</span>];</span><br><span class="line">        <span class="comment">//private Point tmp[200];</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Point <span class="title">NextJudge</span>(<span class="params">ChessBoardState state,<span class="keyword">out</span> <span class="keyword">int</span> max</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            ChessBoardState anti_state;</span><br><span class="line">            <span class="keyword">int</span> cnt=<span class="number">0</span>,score_tmp;</span><br><span class="line">            Point best=<span class="keyword">new</span> Point();</span><br><span class="line">            <span class="keyword">int</span>[] min = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">200</span>];</span><br><span class="line">            max = -BE_FIVE - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">200</span>;i++)</span><br><span class="line">            {</span><br><span class="line">                min[i] = BE_FIVE+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (state == ChessBoardState.black)</span><br><span class="line">                anti_state = ChessBoardState.white;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                anti_state = ChessBoardState.black;</span><br><span class="line">            <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<Rule.COL;i++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < Rule.ROW; j++)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (SearchRange(i, j, state) == <span class="literal">true</span>)</span><br><span class="line">                    {</span><br><span class="line">                        chessjudge.SetChessBoardState(i, j, state);</span><br><span class="line">                        score_tmp = GetPointScore(i, j, state);</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m<Rule.COL;m++)</span><br><span class="line">                        {</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n<Rule.ROW;n++)</span><br><span class="line">                            {</span><br><span class="line">                                <span class="keyword">if</span> (SearchRange(m, n, anti_state) == <span class="literal">true</span>)</span><br><span class="line">                                {</span><br><span class="line">                                    chessjudge.SetChessBoardState(m, n, anti_state);</span><br><span class="line">                                    score = score_tmp - GetPointScore(m, n, anti_state);</span><br><span class="line">                                    <span class="keyword">if</span>(score<min[cnt])</span><br><span class="line">                                    {</span><br><span class="line">                                        <span class="comment">//对方一定会取最小值,寻找最小值，并记录坐标</span></span><br><span class="line">                                        tmp[cnt].X = i;</span><br><span class="line">                                        tmp[cnt].Y = j;</span><br><span class="line">                                        min[cnt] = score;</span><br><span class="line">                                    }</span><br><span class="line">                                    chessjudge.SetChessBoardState(m, n, ChessBoardState.empty);</span><br><span class="line">                                }</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                        chessjudge.SetChessBoardState(i, j, ChessBoardState.empty);</span><br><span class="line">                        cnt++;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            cnt--;</span><br><span class="line">            <span class="keyword">while</span> (cnt >= <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (min[cnt] > max)</span><br><span class="line">                {</span><br><span class="line">                    max = min[cnt];</span><br><span class="line">                    best.X = tmp[cnt].X;</span><br><span class="line">                    best.Y = tmp[cnt].Y;</span><br><span class="line">                }</span><br><span class="line">                cnt--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> best;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>




</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 二维数组参数传递</title>
    <url>/2019/02/27/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-c-c-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>转载自<a href="https://www.cnblogs.com/cygalaxy/p/6963789.html" target="_blank" rel="noopener">博客</a>  </p>
</blockquote>
<blockquote>
<p>二维数组如何作为参数传递？为什么不能直接用二维指针传递？</p>
</blockquote>
<blockquote>
<p>传递动态数组推荐的方法：强制转换为一维指针，这样一维二维数组可以用同一个函数传入</p>
</blockquote>
<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p> 尝试<code>int**</code>做形参，编译错误：int(*)[10]和int**类型不符</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>** p)</span></span>{</span><br><span class="line">    ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    f(a);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="三种解决方法"><a href="#三种解决方法" class="headerlink" title="三种解决方法"></a>三种解决方法</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*传二维数组*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第1种方式：传数组,第二维必须标明</span></span><br><span class="line"><span class="comment">/*void display(int arr[][4])*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display1</span><span class="params">(<span class="keyword">int</span> arr[][<span class="number">4</span>],<span class="keyword">const</span> <span class="keyword">int</span> irows)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<irows;++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j<<span class="number">4</span>;++j)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">cout</span><<arr[i][j]<<<span class="string">" "</span>;     <span class="comment">//可以采用parr[i][j]</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">cout</span><<<span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span><<<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//第2种方式：一重指针，传数组指针,第二维必须标明</span></span><br><span class="line"><span class="comment">/*void display(int (*parr)[4])*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display2</span><span class="params">(<span class="keyword">int</span> (*parr)[<span class="number">4</span>],<span class="keyword">const</span> <span class="keyword">int</span> irows)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<irows;++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j<<span class="number">4</span>;++j)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">cout</span><<parr[i][j]<<<span class="string">" "</span>;    <span class="comment">//可以采用parr[i][j]</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">cout</span><<<span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span><<<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//注意：parr[i]等价于*(parr+i)，一维数组和二维数组都适用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第3种方式：传指针,不管是几维数组都把他看成是指针</span></span><br><span class="line"><span class="comment">/*void display3(int *arr)*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display3</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">const</span> <span class="keyword">int</span> irows,<span class="keyword">const</span> <span class="keyword">int</span> icols)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<irows;++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j<icols;++j)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">cout</span><<*(arr+i*icols+j)<<<span class="string">" "</span>;   <span class="comment">//注意:(arr+i*icols+j),不是(arr+i*irows+j)</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">cout</span><<<span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span><<<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//第2种方式：一重指针，传数组指针void display(int (*parr)[4])</span></span><br><span class="line"><span class="comment">//缺陷：需要指出第二维大小</span></span><br><span class="line"><span class="comment">typedef int parr[4];</span></span><br><span class="line"><span class="comment">void display(parr *p)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">    int *q=*p;        //q指向arr的首元素</span></span><br><span class="line"><span class="comment">    cout<<*q<<endl;   //输出0</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">typedef int (*parr1)[4];</span></span><br><span class="line"><span class="comment">void display1(parr1 p)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">    cout<<(*p)[1]<<endl;  //输出1</span></span><br><span class="line"><span class="comment">    cout<<*p[1]<<endl;    //输出4,[]运算符优先级高</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">//第3种方式：</span></span><br><span class="line"><span class="comment">void display2(int **p)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">    cout<<*p<<endl;           //输出0</span></span><br><span class="line"><span class="comment">    cout<<*((int*)p+1+1)<<endl; //输出2</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> arr[][<span class="number">4</span>]={<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>};</span><br><span class="line">    <span class="keyword">int</span> irows=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> icols=<span class="number">4</span>;</span><br><span class="line">    display1(arr,irows);</span><br><span class="line">    display2(arr,irows);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意(int*)强制转换.个人理解：相当于将a拉成了一维数组处理。</span></span><br><span class="line">    display3((<span class="keyword">int</span>*)arr,irows,icols);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 相册功能实现</title>
    <url>/2019/02/25/%E5%AD%A6%E4%B9%A0-%E5%B7%A5%E5%85%B7-hexo-hexo-%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="利用七牛网存储图片"><a href="#利用七牛网存储图片" class="headerlink" title="利用七牛网存储图片"></a>利用七牛网存储图片</h1><h1 id="缩略图和原图实现"><a href="#缩略图和原图实现" class="headerlink" title="缩略图和原图实现"></a>缩略图和原图实现</h1><p>网上很多都是在本地利用Python等语言进行压缩，繁琐且浪费空间<br>本文使用七牛网自带的图片处理功能进行缩略图的压缩<br>首先在存储空间->图片样式，新建一个图片样式，默认就行，图片瘦身可以关闭，最后得到一个处理接口，如<code>imageView2/1/w/200/h/200/q/85</code>，在图片链接后加上<code>?</code>和处理接口就行<br>例如：原图链接<code>http://pnbj1h9rr.bkt.clouddn.com/2019-02-22_1533974526388.jpg</code>，缩略图链接为<code>http://pnbj1h9rr.bkt.clouddn.com/2019-02-22_1533974526388.jpg?imageView2/1/w/200/h/200/q/85</code><br>这都是链接，不需要在本地完成，我们配置JSON文件的时候只需要读取文件名，利用Python添加对应的文件名就行</p>
<h1 id="相册页面实现"><a href="#相册页面实现" class="headerlink" title="相册页面实现"></a>相册页面实现</h1><ol>
<li>参考<a href="https://foreti.me/archives/14046165.html#album" target="_blank" rel="noopener">博客</a>的实现方法</li>
<li>修改source\lib\album\ins.js文件114行的<code>render()</code>函数中的两个变量<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minSrc = <span class="string">'http://pnbj1h9rr.bkt.clouddn.com/'</span> + data.link[i]+<span class="string">'?imageView2/1/w/200/h/200/q/85'</span>;</span><br><span class="line"><span class="keyword">var</span> src = <span class="string">'http://pnbj1h9rr.bkt.clouddn.com/'</span> + data.link[i];</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Python脚本编辑JSON"><a href="#Python脚本编辑JSON" class="headerlink" title="Python脚本编辑JSON"></a>Python脚本编辑JSON</h1>在JSON中添加</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>工具</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>强光抑制算法初步实现</title>
    <url>/2019/02/22/%E5%B7%A5%E4%BD%9C-%E7%AE%97%E6%B3%95-%E5%BC%BA%E5%85%89%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>如何实现强光场景的识别？如何自动确定对强光区域权重的最优增益？</p>
<a id="more"></a>

<h1 id="实验数据获取"><a href="#实验数据获取" class="headerlink" title="实验数据获取"></a>实验数据获取</h1><p>控制变量，尽量保持场景不变，寻找随着曝光阶的改变，过曝的场景和普通场景的区别。<br><strong>发现问题1</strong>：当曝光阶为0时，如果场景没有什么大变化的话，再去动测光权重没有效果 –>调整拍摄顺序，在背光算法中注意控制曝光阶不为0<br><strong>发现问题2</strong>：相同的增益不一定对应同一个曝光阶，增益经过调节之后，调回去曝光阶和之前不一样<br>注意修改测光权重表，门禁设备的测光权重只有中间的一小块有效；改成默认的中心权重曝光</p>
<ol>
<li>从没有一点强光到有强光场景拍十组照片，用来识别强光场景下的特点</li>
<li>从过曝的场景到不过曝的场景拍十组数据，用来选取强光场景下的最优增益</li>
</ol>
<h1 id="强光场景识别"><a href="#强光场景识别" class="headerlink" title="强光场景识别"></a>强光场景识别</h1><ol>
<li>从直方图亮度饱和的比例来看：当亮点比较小，或者欠曝的时候很难进行区分</li>
<li>从直方图的亮暗区间的区分来看，一般亮的场景会区分比较大，但是如果</li>
<li>分块数据来看</li>
</ol>
<p>识别特征：</p>
<p>1、当前对亮区测光权重的增益；如果已经比较大，说明已经识别为背光场景</p>
<p>2、静态亮区 vs 动态亮区</p>
<p>一般来说，运动的车灯是动态亮区，而路灯等是稳定不动的，我们通过调节brightness就可以控制路灯等静态亮区，而动态亮区的权重我们可以粗略的当做车灯。或者静态亮区和动态亮区给予不同的增益。</p>
<p>当检测到某个亮区的亮度相比于前一帧的相同位置有变化，将它称作动点，一个车灯的动点只有边缘区域，而中心的区域可能没有动，因此我们可以将和动点连通的亮区作为动态亮区。如何标记动点连通的亮区，我采用的是递归的方法。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search_dynamic_region</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">array</span>, <span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">-1</span>; i < <span class="number">2</span>; i++) {</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">-1</span>; j < <span class="number">2</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (x + i >= <span class="number">0</span> && x + i < row &&</span><br><span class="line">                    y + j >= <span class="number">0</span> && y + j < col &&</span><br><span class="line">                    (x || y == <span class="number">1</span>) && <span class="built_in">array</span>[(x + i)*col + y + j] == <span class="number">1</span>) {</span><br><span class="line">                <span class="built_in">array</span>[(x + i)*col + y + j] = <span class="number">2</span>;</span><br><span class="line">                search_dynamic_region(<span class="built_in">array</span>, x + i, y + j, row, col);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="强光场景最优增益"><a href="#强光场景最优增益" class="headerlink" title="强光场景最优增益"></a>强光场景最优增益</h1><ol>
<li><p>获取9组数据，第5-6组是最优组</p>
</li>
<li><p>问题：为什么曝光行差距很大，但是Bayer域的统计数据却差不多？</p>
</li>
</ol>
<h1 id="背光补偿代码bug"><a href="#背光补偿代码bug" class="headerlink" title="背光补偿代码bug"></a>背光补偿代码bug</h1><p>   发现一个背光补偿测光权重初始化的bug，如果在途中对chromatix进行了重新加载，测光表的初始值就改变了，可能会导致图片  –>通过验证，并不会发生这种问题</p>
<p>   长时间将亮区的测光权重增大，会导致图像整体变亮 ->  </p>
<ul>
<li><p>设置一个固定的权重增益，理论上说用手遮住亮区再拿开，场景不变，曝光行应该回到正常场景，但是它在增大 </p>
</li>
<li><p>就算不懂动，曝光行好像也在缓慢的增大，会不会由于第一个原因引起的？</p>
<p> 曝光行在不断的增加，说明亮区权重在降低，或者暗区权重在增加</p>
<p> 初始化的时候就会还原</p>
</li>
<li><p>实验证明，亮区的检测并没有发生改变，依旧改的是那几个区域，测光权重表是修改正确的</p>
</li>
<li><p><strong>解决方案</strong>：将测光权重完全指定 ：说明了AEC算法内部会对测光权重进行修改</p>
</li>
</ul>
<p>如果调低亮度，容易闪烁：调低亮度之后，亮区就会变少，整体亮度会提高；而提高亮度后，亮区有变多，整体亮度会变暗<br>遮挡一个亮区后，会闪烁：亮区的权重很大，亮区有轻微的改变就会影响AE，而我的视野里有一个闪动的屏幕，因此有闪烁属于正常，最后稳定阶段在进行优化</p>
<h1 id="不同平台的实现"><a href="#不同平台的实现" class="headerlink" title="不同平台的实现"></a>不同平台的实现</h1><h2 id="660平台"><a href="#660平台" class="headerlink" title="660平台"></a>660平台</h2><p>经过验证，可以实现对运动的强光进行抑制。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> v_step = q3a_bg_stats->bg_region_v_num/NUM_AEC_STATS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h_step = q3a_bg_stats->bg_region_h_num/NUM_AEC_STATS;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> bg_sum[MAX_BG_STATS_NUM]={<span class="number">0</span>};</span><br><span class="line"><span class="keyword">char</span> grid_region[MAX_BG_STATS_NUM] ={<span class="number">0</span>};</span><br><span class="line"><span class="keyword">int</span> grid_v_num, grid_h_num;</span><br><span class="line"><span class="keyword">int</span> weight_grid_count[NUM_AEC_STATS][NUM_AEC_STATS] = {<span class="number">0</span>};</span><br><span class="line"><span class="keyword">uint32_t</span> bg_count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (property_get(<span class="string">"persist.liqinxing.backlight"</span>, value, <span class="string">""</span>) > <span class="number">0</span>){</span><br><span class="line">    aec_dynamic_ratio = atoi(value)/<span class="number">1000.0</span>;</span><br><span class="line">    <span class="comment">//reduce traverse times and prevent data overflow</span></span><br><span class="line">    <span class="keyword">int</span> grid_count = q3a_bg_stats->bg_region_h_num * q3a_bg_stats->bg_region_v_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//find bright region and dynamic spot</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < grid_count; i++){</span><br><span class="line">        <span class="keyword">if</span>(q3a_bg_stats->bg_r_sum[i] > threhold_h ||</span><br><span class="line">           q3a_bg_stats->bg_gr_sum[i] > threhold_h ||</span><br><span class="line">           q3a_bg_stats->bg_b_sum[i] > threhold_h){</span><br><span class="line">                bg_count = q3a_bg_stats->bg_r_sum[i]+q3a_bg_stats->bg_gr_sum[i]+</span><br><span class="line">                q3a_bg_stats->bg_gb_sum[i]+q3a_bg_stats->bg_b_sum[i];</span><br><span class="line">                <span class="keyword">if</span>(bg_count*<span class="number">10</span>/bg_sum[i] > <span class="number">12</span>)</span><br><span class="line">                    grid_region[i] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    grid_region[i] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        bg_sum[i] = q3a_bg_stats->bg_r_sum[i]+q3a_bg_stats->bg_gr_sum[i]+</span><br><span class="line">                q3a_bg_stats->bg_gb_sum[i]+q3a_bg_stats->bg_b_sum[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//find dynamic bright region</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i < grid_count; i++){</span><br><span class="line">        <span class="keyword">if</span>(grid_region[i] == <span class="number">2</span>){</span><br><span class="line">            search_dynamic_region(grid_region, i/q3a_bg_stats->bg_region_h_num,</span><br><span class="line">                i%q3a_bg_stats->bg_region_h_num, q3a_bg_stats->bg_region_v_num,</span><br><span class="line">                q3a_bg_stats->bg_region_h_num);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert to aec weight grid table</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i<grid_count; i++){</span><br><span class="line">        <span class="keyword">if</span>(grid_region[i] != <span class="number">0</span>){</span><br><span class="line">            grid_v_num = i/q3a_bg_stats->bg_region_h_num/v_step;<span class="comment">//calculate current position v</span></span><br><span class="line">            grid_h_num = i%q3a_bg_stats->bg_region_h_num/h_step;<span class="comment">//calculate current position h</span></span><br><span class="line">            <span class="keyword">if</span>(grid_region[i] == <span class="number">2</span>)</span><br><span class="line">                weight_grid_count[grid_v_num][grid_h_num] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(weight_grid_count[grid_v_num][grid_h_num] != <span class="number">2</span>)</span><br><span class="line">                weight_grid_count[grid_v_num][grid_h_num] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_wrlock(&chromatix->lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i < NUM_AEC_STATS; i++){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j < NUM_AEC_STATS; j++){</span><br><span class="line">            <span class="keyword">if</span>(weight_grid_count[i][j] == <span class="number">2</span>){</span><br><span class="line">                chromatix->AEC.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span><br><span class="line">                    keda_exposure_weight[i][j] * aec_dynamic_ratio;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(weight_grid_count[i][j] == <span class="number">1</span>)</span><br><span class="line">                chromatix->AEC.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span><br><span class="line">                    keda_exposure_weight[i][j] * aec_static_ratio;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                chromatix->AEC.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span><br><span class="line">                    keda_exposure_weight[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    pthread_rwlock_unlock(&chromatix->lock);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (aec->aec_algo_ops.set_parameters) {</span><br><span class="line">        aec->aec_algo_ops.set_parameters(aec->handle, &backlight_set_parameter);</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">      }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="8056平台的移植"><a href="#8056平台的移植" class="headerlink" title="8056平台的移植"></a>8056平台的移植</h2><p>由于部分参数的类型不同，以及编译规则的不同，对<code>keda_backlight_algo</code>函数进行修改。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">keda_backlight_algo</span><span class="params">(<span class="keyword">aec_biz_t</span> *aec, <span class="keyword">const</span> <span class="keyword">stats_t</span>* stats)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//detect input</span></span><br><span class="line">    <span class="keyword">if</span> (!aec || !stats) {</span><br><span class="line">      AEC_ERR(<span class="string">"Invalid input: %p,%p"</span>,aec, stats);</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//define var</span></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="keyword">float</span> aec_ratio = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">float</span> aec_dynamic_ratio=<span class="number">1000</span>,aec_static_ratio=<span class="number">1</span>;</span><br><span class="line">    chromatix_3a_parms_type *chromatix;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">q3a_bg_stats_t</span>* q3a_bg_stats = stats->bayer_stats.p_q3a_bg_stats;</span><br><span class="line">    <span class="keyword">uint32_t</span> threhold_h = q3a_bg_stats->rMax * q3a_bg_stats->region_pixel_cnt * BRIGHT_REGION_RANGE /<span class="number">4</span>;</span><br><span class="line">    chromatix = (chromatix_3a_parms_type*)backlight_set_parameter.u.init_param.chromatix;</span><br><span class="line">    <span class="keyword">if</span> (!chromatix) {</span><br><span class="line">        AEC_ERR(<span class="string">"Invalid chromatix: %p"</span>, chromatix)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> v_step = q3a_bg_stats->bg_region_v_num/NUM_AEC_STATS;</span><br><span class="line">    <span class="keyword">int</span> h_step = q3a_bg_stats->bg_region_h_num/NUM_AEC_STATS;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint32_t</span> bg_sum[MAX_BG_STATS_NUM]={<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">char</span> grid_region[MAX_BG_STATS_NUM] ={<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">int</span> grid_v_num, grid_h_num;</span><br><span class="line">    <span class="keyword">int</span> weight_grid_count[NUM_AEC_STATS][NUM_AEC_STATS] = {{<span class="number">0</span>}};</span><br><span class="line">    <span class="keyword">uint32_t</span> bg_count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (property_get(<span class="string">"persist.liqinxing.backlight"</span>, value, <span class="string">""</span>) > <span class="number">0</span>){</span><br><span class="line">        aec_static_ratio = atoi(value)/<span class="number">1000.0</span>;</span><br><span class="line">        <span class="comment">//reduce traverse times and prevent data overflow</span></span><br><span class="line">        <span class="keyword">int</span> grid_count = q3a_bg_stats->bg_region_h_num * q3a_bg_stats->bg_region_v_num;</span><br><span class="line">        <span class="comment">//find the position of bright region</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for(int i = 0; i < grid_count; i++){</span></span><br><span class="line"><span class="comment">            if(q3a_bg_stats->bg_r_sum[i] > threhold_h ||</span></span><br><span class="line"><span class="comment">               q3a_bg_stats->bg_gr_sum[i] > threhold_h ||</span></span><br><span class="line"><span class="comment">               q3a_bg_stats->bg_b_sum[i] > threhold_h){</span></span><br><span class="line"><span class="comment">               //stats bright region</span></span><br><span class="line"><span class="comment">                grid_v_num = i/q3a_bg_stats->bg_region_h_num/v_step;//calculate current position v</span></span><br><span class="line"><span class="comment">                grid_h_num = i%q3a_bg_stats->bg_region_h_num/h_step;//calculate current position h</span></span><br><span class="line"><span class="comment">                weight_grid_count[grid_v_num][grid_h_num]++;</span></span><br><span class="line"><span class="comment">                bg_count = q3a_bg_stats->bg_r_sum[i]+q3a_bg_stats->bg_gr_sum[i]+</span></span><br><span class="line"><span class="comment">                    q3a_bg_stats->bg_gb_sum[i]+q3a_bg_stats->bg_b_sum[i];</span></span><br><span class="line"><span class="comment">                if(bg_count*10/bg_sum[i] > 12)</span></span><br><span class="line"><span class="comment">                    grid_region[i] = 2;</span></span><br><span class="line"><span class="comment">                else</span></span><br><span class="line"><span class="comment">                    grid_region[i] = 1;</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for(int i=0; i < NUM_AEC_STATS; i++){</span></span><br><span class="line"><span class="comment">            for(int j=0; j < NUM_AEC_STATS; j++){</span></span><br><span class="line"><span class="comment">                if(weight_grid_count[i][j] > 3){</span></span><br><span class="line"><span class="comment">                    chromatix->AEC.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span></span><br><span class="line"><span class="comment">                        keda_exposure_weight[i][j] * aec_ratio;</span></span><br><span class="line"><span class="comment">                    //LOGE("liqinxing:aec_metering[%d,%d] modify=%f",i,j,</span></span><br><span class="line"><span class="comment">                    //    chromatix->AEC.aec_metering_tables.AEC_weight_center_weighted[i][j]);</span></span><br><span class="line"><span class="comment">                    //LOGE("liqinxing:modify count=%d",weight_grid_count[i][j]);</span></span><br><span class="line"><span class="comment">                }</span></span><br><span class="line"><span class="comment">                else</span></span><br><span class="line"><span class="comment">                    chromatix->AEC.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span></span><br><span class="line"><span class="comment">                        keda_exposure_weight[i][j];</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//find bright region and dynamic spot</span></span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i < grid_count; i++){</span><br><span class="line">            <span class="keyword">if</span>(q3a_bg_stats->bg_r_sum[i] > threhold_h ||</span><br><span class="line">               q3a_bg_stats->bg_gr_sum[i] > threhold_h ||</span><br><span class="line">               q3a_bg_stats->bg_b_sum[i] > threhold_h){</span><br><span class="line">                    bg_count = q3a_bg_stats->bg_r_sum[i]+q3a_bg_stats->bg_gr_sum[i]+</span><br><span class="line">                    q3a_bg_stats->bg_gb_sum[i]+q3a_bg_stats->bg_b_sum[i];</span><br><span class="line">                    <span class="keyword">if</span>(bg_count*<span class="number">10</span>/bg_sum[i] > <span class="number">12</span>)</span><br><span class="line">                        grid_region[i] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        grid_region[i] = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            bg_sum[i] = q3a_bg_stats->bg_r_sum[i]+q3a_bg_stats->bg_gr_sum[i]+</span><br><span class="line">                    q3a_bg_stats->bg_gb_sum[i]+q3a_bg_stats->bg_b_sum[i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//find dynamic bright region</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i < grid_count; i++){</span><br><span class="line">            <span class="keyword">if</span>(grid_region[i] == <span class="number">2</span>){</span><br><span class="line">                search_dynamic_region(grid_region, i/q3a_bg_stats->bg_region_h_num,</span><br><span class="line">                    i%q3a_bg_stats->bg_region_h_num, q3a_bg_stats->bg_region_v_num,</span><br><span class="line">                    q3a_bg_stats->bg_region_h_num);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//convert to aec weight grid table</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i<grid_count; i++){</span><br><span class="line">            <span class="keyword">if</span>(grid_region[i] != <span class="number">0</span>){</span><br><span class="line">                grid_v_num = i/q3a_bg_stats->bg_region_h_num/v_step;<span class="comment">//calculate current position v</span></span><br><span class="line">                grid_h_num = i%q3a_bg_stats->bg_region_h_num/h_step;<span class="comment">//calculate current position h</span></span><br><span class="line">                <span class="keyword">if</span>(grid_region[i] == <span class="number">2</span>)</span><br><span class="line">                    weight_grid_count[grid_v_num][grid_h_num] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(weight_grid_count[grid_v_num][grid_h_num] != <span class="number">2</span>)</span><br><span class="line">                    weight_grid_count[grid_v_num][grid_h_num] = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//pthread_rwlock_wrlock(&chromatix->lock);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i < NUM_AEC_STATS; i++){</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>; j < NUM_AEC_STATS; j++){</span><br><span class="line">                <span class="keyword">if</span>(weight_grid_count[i][j] == <span class="number">2</span>){</span><br><span class="line">                    chromatix->AEC_algo_data.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span><br><span class="line">                        keda_exposure_weight[i][j] * aec_dynamic_ratio;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(weight_grid_count[i][j] == <span class="number">1</span>)</span><br><span class="line">                    chromatix->AEC_algo_data.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span><br><span class="line">                        keda_exposure_weight[i][j] * aec_static_ratio;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    chromatix->AEC_algo_data.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span><br><span class="line">                        keda_exposure_weight[i][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//pthread_rwlock_unlock(&chromatix->lock);</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (aec->aec_algo_ops.set_parameters) {</span><br><span class="line">            aec->aec_algo_ops.set_parameters(aec->handle, &backlight_set_parameter);</span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">          }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ol>
<li><code>aec_biz.c</code>中的<code>aec_biz_initialize_custom_tuning_param</code>函数，可以在chromatix初始化之后对chromatix重新改写。但是只有当init时才可以启动</li>
<li>优化静态变量<code>backlight_set_parameter</code>：可以在<code>aec_biz_init</code>时创建，在<code>aec_biz_destroy</code>时进行销毁。</li>
<li><code>void*</code>指针变量在结构体中定义，难道不需要进行内容大小的定义么？就可以直接对结构体<code>memcpy</code>了？因为指针大小是确定的，因此memcpy是没有问题的，指针的类型只是定义了指向数据的类型，也就是决定了指针运算的逻辑。</li>
<li>注意换了个镜头，要把膜撕掉！否则因为膜是棕色的，会导致白平衡异常，拍出来的是绿色的。</li>
<li>aec_biz是最接近aec模块的控制，aec_port是处理模块间的交流，相当于直接和aec_biz进行通信。</li>
<li>python注意点：<code>for i in a</code>：对i的值进行改变，不会影响a的值</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>小小的惊喜</title>
    <url>/2019/02/21/%E7%94%9F%E6%B4%BB-love-2019-02-21-love/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>围围，两个小小的惊喜让我的心跳突然提速，抑制不住的激动洋溢在脸上。  </p>
<h1 id="第一个大惊喜"><a href="#第一个大惊喜" class="headerlink" title="第一个大惊喜"></a>第一个大惊喜</h1><p>下班后郑重其事的告诉我：钦星，我走了，特地等到下班后才告诉你。<br>听到这个消息，心里空落落的，就好像泼了一盆冷水，不知道自己下班要干什么，想去学校找你，却也知道没有理由让你回来。<br>你说有一个惊喜等着我，而我却说最大的惊喜就是你呀。<br>回到家里，东西收拾的整整齐齐，没有看到你的身影，意料之中，好像是那么的自然，心里自然流露着落寞。嘴里不断说着惊喜呢，眼睛不停的四处瞄着，突然蹦出一个拥抱。<br>定睛一看，我的天，这不是我心心念念的围围么，这就是最大的惊喜啊，我的心跳瞬间提速，抑制不住的激动洋溢在脸上，好想抱你到永远永远。</p>
<h1 id="第二个小惊喜"><a href="#第二个小惊喜" class="headerlink" title="第二个小惊喜"></a>第二个小惊喜</h1><p>这一次，你真的走了，在走的时候告诉我，留给了我惊喜，全部找到才准吃饭，这是爱我的小脾气，抱歉，我承包了。<br>在宿舍，我看到了，在我的衣柜，我的床头，我的电脑面前都是你爱的痕迹。这些惊喜散布在房间的各个角落，我深深的感到自己已经被爱包裹的严严实实。<br>爱在心口难开，虽然你总是娇羞而又可爱的拒绝对我爱的表白。但你的惊喜，你的行动，总让我心潮澎湃，没事，我承包你的一切，不说无妨，我天天对你说就好了。<br>我的围，我爱你，(๑′ᴗ‵๑)Ｉ Lᵒᵛᵉᵧₒᵤ❤</p>
<div class="justified-gallery"><p><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/a3375e689f08015f33557bc1e1e37716.jpg"  alt><br><img src="/" class="lazyload" data-src="https://image.qinxing.xyz/dc373f654633a3badcfca74641c166c3.jpg"  alt></p>
          </div></body></html>]]></content>
      <categories>
        <category>生活</category>
        <category>围围</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>围围</tag>
        <tag>惊喜</tag>
      </tags>
  </entry>
  <entry>
    <title>问题：中文乱码</title>
    <url>/2019/02/20/%E5%AD%A6%E4%B9%A0-%E5%B7%A5%E5%85%B7-git-%E9%97%AE%E9%A2%98-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="认识编码及Python乱码"><a href="#认识编码及Python乱码" class="headerlink" title="认识编码及Python乱码"></a>认识编码及Python乱码</h1><p><a href="https://blog.csdn.net/joyfixing/article/details/79971667" target="_blank" rel="noopener">彻底搞懂 python 中文乱码问题</a>这篇博客讲的很透彻，以及在Python中如何进行转码</p>
<p>需要注意的是：   </p>
<p>字符串通过编码转换为字节码，字节码通过解码转换为字符串</p>
<p>str—>(encode)—>bytes，bytes—>(decode)—>str</p>
<h1 id="cmd中文乱码"><a href="#cmd中文乱码" class="headerlink" title="cmd中文乱码"></a>cmd中文乱码</h1><ol>
<li><p>在cmd中输入<code>chcp</code>，查看当前编码：如果是936则为GBK编码</p>
</li>
<li><p>在cmd中输入<code>chcp 65001</code>，切换为UTF-8编码</p>
</li>
<li><p>在菜单栏右击，属性->选项中勾选 丢弃旧的副本，重新打开一下之后再把勾去掉就好了</p>
</li>
</ol>
<h1 id="git中文乱码"><a href="#git中文乱码" class="headerlink" title="git中文乱码"></a>git中文乱码</h1><p>$ git config –global core.quotepath false</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>工具</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>中文乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ private外部访问问题</title>
    <url>/2019/02/20/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-c-c-%EF%BC%9Aprivate%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>private可以防止其他模块进行访问，但如果利用指针，是否可以在其他模块获取到private的数据？<br>下面对此进行实验：</p>
</blockquote>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A() {</span><br><span class="line">		a2 = <span class="number">3</span>;</span><br><span class="line">		a3 = <span class="number">4</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">int</span>* <span class="title">fun3</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="built_in">cout</span> << <span class="string">"a3="</span> <<a3 << <span class="built_in">endl</span>;   <span class="comment">//正确，类内访问</span></span><br><span class="line">		<span class="keyword">return</span> &a3;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">int</span>* <span class="title">fun2</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="built_in">cout</span> << <span class="string">"a2="</span> << a2 << <span class="built_in">endl</span>;   <span class="comment">//正确，类内访问</span></span><br><span class="line">		<span class="keyword">return</span> &a2;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> a2;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a3;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	A itema;</span><br><span class="line">	<span class="keyword">int</span>* mytest;</span><br><span class="line">	<span class="comment">//不能直接获取</span></span><br><span class="line">	<span class="comment">//cout << "直接获取private值a3=" << itema.a3 << endl;</span></span><br><span class="line">	mytest = itema.fun3();</span><br><span class="line">	<span class="built_in">cout</span> << <span class="string">"通过指针获取private值a3="</span><<*mytest << <span class="built_in">endl</span>;</span><br><span class="line">	*mytest = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cout</span> << <span class="string">"对private值进行修改："</span>;</span><br><span class="line">	itema.fun3();</span><br><span class="line"></span><br><span class="line">	mytest = itema.fun2();</span><br><span class="line">	<span class="built_in">cout</span> << <span class="string">"通过指针获取protected值a3="</span> << *mytest << <span class="built_in">endl</span>;</span><br><span class="line">	*mytest = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cout</span> << <span class="string">"对private值进行修改："</span>;</span><br><span class="line">	itema.fun2();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>private数据外部不能直接获取</li>
<li>private数据如果把地址传出来，可以在外部进行读取和修改</li>
<li>protected和private都可以利用指针在外部进行读取和修改</li>
</ul>
<p>因此private不是万能的，同样可以走<code>后门</code>，进行修改，用同样的方法，我们还可以引出形参指针的地址等；当我们写程序时，也要注意private也可能被外部模块修改。</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>高通代码学习与体会</title>
    <url>/2019/02/20/%E5%B7%A5%E4%BD%9C-%E7%BC%96%E7%A8%8B-%E9%AB%98%E9%80%9A%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%93%E4%BC%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>对高通代码结构以及编写技巧的学习和总结，不断更新…</p>
</blockquote>
<h2 id="数组和枚举定义的另类写法"><a href="#数组和枚举定义的另类写法" class="headerlink" title="数组和枚举定义的另类写法"></a>数组和枚举定义的另类写法</h2><p>用列表的形式去表示数组和枚举类型</p>
<p><strong>优点</strong>：  </p>
<p>方便后期添加新值，便于维护。增加一个值，不必去考虑数组或者枚举的大小，也不用去考虑位置和顺序。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//枚举类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AEC_CORE_GET_ENUM_LIST(ADD_ENTRY)                                    \</span></span><br><span class="line">  ADD_ENTRY(AEC_GET_EXPOSURE_PARAMS)            <span class="comment">/* Mask to get aec info.  */</span> \</span><br><span class="line">  ADD_ENTRY(AEC_GET_META_INFO)                  <span class="comment">/* Mask to get meta info. */</span> \</span><br><span class="line">  ADD_ENTRY(AEC_GET_REAL_GAIN_FROM_ISO)                                      \</span><br><span class="line">  ADD_ENTRY(AEC_GET_STATS_REQUIRED)    <span class="comment">/* Mask to get stats type required */</span> \</span><br><span class="line">  ADD_ENTRY(AEC_GET_UNIFIED_FLASH)                                           \</span><br><span class="line">  ADD_ENTRY(AEC_GET_RGN_SKIP_PATTERN)                                        \</span><br><span class="line">  ADD_ENTRY(AEC_GET_RELOAD_EXPOSURE_PARAMS)                                  \</span><br><span class="line">  ADD_ENTRY(AEC_GET_LED_CAL_CONFIG)                                          \</span><br><span class="line">  ADD_ENTRY(AEC_GET_MAX)  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AEC_CORE_GENERATE_ENUM(ENUM) ENUM,</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">{</span><br><span class="line">  AEC_CORE_GET_ENUM_LIST(AEC_CORE_GENERATE_ENUM)</span><br><span class="line">} aec_core_get_enum_type;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//字符串数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AEC_SET_PARAM_ENUM_LIST(ADD_ENTRY)                                    \</span></span><br><span class="line">  ADD_ENTRY(AEC_SET_PARAM_INVALID)                                            \</span><br><span class="line">  ADD_ENTRY(AEC_SET_PARAM_INIT_CHROMATIX_SENSOR)                              \</span><br><span class="line">  ADD_ENTRY(AEC_SET_PARAM_EXP_COMPENSATION)                                   \</span><br><span class="line">  ADD_ENTRY(AEC_SET_PARAM_BRIGHTNESS_LVL)                                     \</span><br><span class="line">  ADD_ENTRY(AEC_SET_PARAM_MAX)        </span><br><span class="line">  </span><br><span class="line"><span class="comment">//# 是把参数字符串化，## 是将两个参数连为一个整体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AEC_PARAM_GENERATE_STRING(STRING) #STRING,    </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *aec_biz_set_param_strings[AEC_SET_PARAM_MAX+<span class="number">1</span>] = {</span><br><span class="line">  AEC_SET_PARAM_ENUM_LIST(AEC_PARAM_GENERATE_STRING)</span><br><span class="line">};</span><br><span class="line"><span class="comment">//获取数组值(eventId的值)</span></span><br><span class="line"><span class="keyword">return</span> aec_biz_set_param_strings[eventId < AEC_SET_PARAM_MAX ?</span><br><span class="line"></span><br><span class="line">    eventId : AEC_SET_PARAM_MAX];</span><br></pre></td></tr></tbody></table></figure>

<h2 id="用union去定义接口结构体"><a href="#用union去定义接口结构体" class="headerlink" title="用union去定义接口结构体"></a>用union去定义接口结构体</h2><p><strong>优点</strong>：  </p>
<ul>
<li><p>用union只需要最大的值的空间，节省空间。</p>
</li>
<li><p>加上type，可以利用switch对不同类型的请求做处理，在union中取相应的数</p>
</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  aec_set_enum_type type; <span class="comment">/**<  */</span></span><br><span class="line">  <span class="keyword">union</span></span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">aec_set_parameter_init_t</span>      init_param;</span><br><span class="line">    <span class="keyword">aec_bracket_t</span>                 aec_bracket;</span><br><span class="line">    int32                         video_hdr;  <span class="comment">/**<  */</span></span><br><span class="line">    aec_core_hdr_type             snapshot_hdr;</span><br><span class="line">    <span class="keyword">aec_precapture_trigger_t</span>      aec_trigger;</span><br><span class="line">    <span class="keyword">boolean</span>                       est_for_af;</span><br><span class="line">    aec_algo_ramp_test_type       ramp_test;</span><br><span class="line">  } u;</span><br><span class="line">} aec_core_set_param_type;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="用函数指针实现多态"><a href="#用函数指针实现多态" class="headerlink" title="用函数指针实现多态"></a>用函数指针实现多态</h2><p><strong>优点</strong>：  </p>
<ul>
<li>扩展性：把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//c文件</span></span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">aec_biz_set_param</span><span class="params">(<span class="keyword">aec_set_parameter_t</span> *param,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">aec_output_data_t</span> *output, <span class="keyword">uint8_t</span> num_of_outputs, <span class="keyword">void</span> *aec_obj)</span></span>{ …… }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aec_biz_load_function</span><span class="params">(<span class="keyword">aec_object_t</span> *aec_object)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!aec_object) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  }</span><br><span class="line">  aec_object->set_parameters = aec_biz_set_param;</span><br><span class="line">  aec_object->get_parameters = aec_biz_get_param;</span><br><span class="line">  aec_object-><span class="built_in">process</span> = aec_biz_process;</span><br><span class="line">  aec_object->init = aec_biz_init;</span><br><span class="line">  aec_object->deinit = aec_biz_destroy;</span><br><span class="line">  aec_object->iso_to_real_gain = aec_biz_map_iso_to_real_gain;</span><br><span class="line">  aec_object->get_version = aec_biz_get_version;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">boolean</span> <span class="params">(* aec_set_parameters_func)</span><span class="params">(<span class="keyword">aec_set_parameter_t</span> *param,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">aec_output_data_t</span> *output, <span class="keyword">uint8_t</span> num_of_outputs, <span class="keyword">void</span> *aec_obj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">boolean</span> <span class="params">(* aec_get_parameters_func)</span><span class="params">(<span class="keyword">aec_get_parameter_t</span> *param,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">void</span> *aec_obj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">boolean</span> <span class="params">(* aec_process_func)</span><span class="params">(<span class="keyword">stats_t</span> *stats, <span class="keyword">void</span> *aec_obj,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">aec_output_data_t</span> *output, <span class="keyword">uint8_t</span> num_of_ouputs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(* aec_callback_func)</span><span class="params">(<span class="keyword">aec_output_data_t</span> *output, <span class="keyword">void</span> *port)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *(* aec_init_func)(<span class="keyword">void</span> *aec_lib);</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(* aec_deinit_func)</span><span class="params">(<span class="keyword">void</span> *aec)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">float</span> <span class="params">(* aec_iso_to_real_gain)</span><span class="params">(<span class="keyword">void</span> *aec_obj, <span class="keyword">uint32_t</span> iso,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">uint8_t</span> camera_id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">boolean</span> <span class="params">(* aec_get_version)</span><span class="params">(<span class="keyword">void</span> *aec_obj, Q3a_version_t *version,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">uint8_t</span> camera_id)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">aec_object</span> {</span></span><br><span class="line"> <span class="keyword">pthread_mutex_t</span> obj_lock;</span><br><span class="line"> <span class="keyword">void</span> *aec;</span><br><span class="line"> aec_set_parameters_func set_parameters;</span><br><span class="line"> aec_get_parameters_func get_parameters;</span><br><span class="line"> aec_process_func <span class="built_in">process</span>;</span><br><span class="line"> aec_init_func init;</span><br><span class="line"> aec_deinit_func deinit;</span><br><span class="line"> <span class="keyword">aec_output_data_t</span> output;</span><br><span class="line"> aec_iso_to_real_gain iso_to_real_gain;</span><br><span class="line"> <span class="keyword">q3a_custom_data_t</span> aec_custom_param;</span><br><span class="line"> aec_get_version get_version;</span><br><span class="line"> } <span class="keyword">aec_object_t</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>由于变量可能到处被定义和引用，很难找到这个变量的含义，变量值前面需要加上@，这样搜索变量的含义很快</p>
<h2 id="回调函数的注册和使用"><a href="#回调函数的注册和使用" class="headerlink" title="回调函数的注册和使用"></a>回调函数的注册和使用</h2></body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>高通</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 线程和进程</title>
    <url>/2019/02/19/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-python-Python-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>转载自<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319272686365ec7ceaeca33428c914edf8f70cca383000" target="_blank" rel="noopener">廖雪峰教程</a></p>
</blockquote>
<h1 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h1><h2 id="Unix-Linux"><a href="#Unix-Linux" class="headerlink" title="Unix/Linux"></a>Unix/Linux</h2><p>Unix/Linux操作系统提供了一个<code>fork()</code>系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是<code>fork()</code>调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p>
<p>子进程永远返回<code>0</code>，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用<code>getppid()</code>就可以拿到父进程的ID。</p>
<p>Python的<code>os</code>模块封装了常见的系统调用，其中就包括<code>fork</code>，可以在Python程序中轻松创建子进程：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># multiprocessing.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Process (%s) start...'</span> % os.getpid()</span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="keyword">if</span> pid==<span class="number">0</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'I am child process (%s) and my parent is %s.'</span> % (os.getpid(), os.getppid())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'I (%s) just created a child process (%s).'</span> % (os.getpid(), pid)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>由于Windows没有<code>fork</code>调用，上面的代码在Windows上无法运行。<code>multiprocessing</code>模块就是跨平台版本的多进程模块。<code>multiprocessing</code>模块提供了一个<code>Process</code>类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程要执行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Run child process %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line">    p = Process(target=run_proc, args=(<span class="string">'test'</span>,))</span><br><span class="line">    print(<span class="string">'Child process will start.'</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">'Child process end.'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>执行结果如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">Parent process <span class="number">928.</span></span><br><span class="line">Process will start.</span><br><span class="line">Run child process test (<span class="number">929</span>)...</span><br><span class="line">Process end.</span><br></pre></td></tr></tbody></table></figure>

<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个<code>Process</code>实例，用<code>start()</code>方法启动，这样创建进程比<code>fork()</code>还要简单。</p>
<p><code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>
<h2 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Run task %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line">    p = Pool(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p.apply_async(long_time_task, args=(i,))</span><br><span class="line">    print(<span class="string">'Waiting for all subprocesses done...'</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">'All subprocesses done.'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>对<code>Pool</code>对象调用<code>join()</code>方法会等待所有子进程执行完毕，调用<code>join()</code>之前必须先调用<code>close()</code>，调用<code>close()</code>之后就不能继续添加新的<code>Process</code>了。</p>
<p>请注意输出的结果，task <code>0</code>，<code>1</code>，<code>2</code>，<code>3</code>是立刻执行的，而task <code>4</code>要等待前面某个task完成后才执行，这是因为<code>Pool</code>的默认大小在我的电脑上是4，因此，最多同时执行4个进程。这是<code>Pool</code>有意设计的限制，并不是操作系统的限制。如果改成：<code>p = Pool(5)</code>就可以同时跑五个进程 。</p>
<p>由于<code>Pool</code>的默认大小是CPU的核数，如果你不幸拥有8核CPU，你要提交至少9个子进程才能看到上面的等待效果。</p>
<h2 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h2><p>很多时候，子进程并不是自身，而是一个外部进程。我们创建了子进程后，还需要控制子进程的输入和输出。</p>
<p><code>subprocess</code>模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。</p>
<p>下面的例子演示了如何在Python代码中运行命令<code>nslookup www.python.org</code>，这和命令行直接运行的效果是一样的：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">print(<span class="string">'$ nslookup www.python.org'</span>)</span><br><span class="line">r = subprocess.call([<span class="string">'nslookup'</span>, <span class="string">'www.python.org'</span>])</span><br><span class="line">print(<span class="string">'Exit code:'</span>, r)</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ nslookup www.python.org</span><br><span class="line">Server:        <span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span></span><br><span class="line">Address:    <span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span><span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.python.org    canonical name = python.map.fastly.net.</span><br><span class="line">Name:    python.map.fastly.net</span><br><span class="line">Address: <span class="number">199.27</span><span class="number">.79</span><span class="number">.223</span></span><br><span class="line"></span><br><span class="line">Exit code: <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果子进程还需要输入，则可以通过<code>communicate()</code>方法输入：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">print(<span class="string">'$ nslookup'</span>)</span><br><span class="line">p = subprocess.Popen([<span class="string">'nslookup'</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">output, err = p.communicate(<span class="string">b'set q=mx\npython.org\nexit\n'</span>)</span><br><span class="line">print(output.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">print(<span class="string">'Exit code:'</span>, p.returncode)</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码相当于在命令行执行命令<code>nslookup</code>，然后手动输入：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">set q=mx</span><br><span class="line">python.org</span><br><span class="line">exit</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ nslookup</span><br><span class="line">Server:        <span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span></span><br><span class="line">Address:    <span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span><span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">python.org    mail exchanger = <span class="number">50</span> mail.python.org.</span><br><span class="line"></span><br><span class="line">Authoritative answers can be found <span class="keyword">from</span>:</span><br><span class="line">mail.python.org    internet address = <span class="number">82.94</span><span class="number">.164</span><span class="number">.166</span></span><br><span class="line">mail.python.org    has AAAA address <span class="number">2001</span>:<span class="number">888</span>:<span class="number">2000</span>:d::a6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exit code: <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p><code>Process</code>之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的<code>multiprocessing</code>模块包装了底层的机制，提供了<code>Queue</code>、<code>Pipes</code>等多种方式来交换数据。</p>
<p>我们以<code>Queue</code>为例，在父进程中创建两个子进程，一个往<code>Queue</code>里写数据，一个从<code>Queue</code>里读数据：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写数据进程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">'Process to write: %s'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]:</span><br><span class="line">        print(<span class="string">'Put %s to queue...'</span> % value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读数据进程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">'Process to read: %s'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        value = q.get(<span class="literal">True</span>)</span><br><span class="line">        print(<span class="string">'Get %s from queue.'</span> % value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 父进程创建Queue，并传给各个子进程：</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line">    <span class="comment"># 启动子进程pw，写入:</span></span><br><span class="line">    pw.start()</span><br><span class="line">    <span class="comment"># 启动子进程pr，读取:</span></span><br><span class="line">    pr.start()</span><br><span class="line">    <span class="comment"># 等待pw结束:</span></span><br><span class="line">    pw.join()</span><br><span class="line">    <span class="comment"># pr进程里是死循环，无法等待其结束，只能强行终止:</span></span><br><span class="line">    pr.terminate()</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">Process to write: <span class="number">50563</span></span><br><span class="line">Put A to queue...</span><br><span class="line">Process to read: <span class="number">50564</span></span><br><span class="line">Get A <span class="keyword">from</span> queue.</span><br><span class="line">Put B to queue...</span><br><span class="line">Get B <span class="keyword">from</span> queue.</span><br><span class="line">Put C to queue...</span><br><span class="line">Get C <span class="keyword">from</span> queue.</span><br></pre></td></tr></tbody></table></figure>

<p>在Unix/Linux下，<code>multiprocessing</code>模块封装了<code>fork()</code>调用，使我们不需要关注<code>fork()</code>的细节。由于Windows没有<code>fork</code>调用，因此，<code>multiprocessing</code>需要“模拟”出<code>fork</code>的效果，父进程所有Python对象都必须通过pickle序列化再传到子进程去，所有，如果<code>multiprocessing</code>在Windows下调用失败了，要先考虑是不是pickle失败了。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>多任务可以由多进程完成，也可以由一个进程内的多线程完成。</p>
<p>我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。</p>
<p>由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。</p>
<p>Python的标准库提供了两个模块：<code>_thread</code>和<code>threading</code>，<code>_thread</code>是低级模块，<code>threading</code>是高级模块，对<code>_thread</code>进行了封装。绝大多数情况下，我们只需要使用<code>threading</code>这个高级模块。</p>
<p>启动一个线程就是把一个函数传入并创建<code>Thread</code>实例，然后调用<code>start()</code>开始执行：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新线程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n < <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        print(<span class="string">'thread %s >>> %s'</span> % (threading.current_thread().name, n))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(target=loop, name=<span class="string">'LoopThread'</span>)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</span><br></pre></td></tr></tbody></table></figure>

<p>执行结果如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">thread MainThread <span class="keyword">is</span> running...</span><br><span class="line">thread LoopThread <span class="keyword">is</span> running...</span><br><span class="line">thread LoopThread >>> <span class="number">1</span></span><br><span class="line">thread LoopThread >>> <span class="number">2</span></span><br><span class="line">thread LoopThread >>> <span class="number">3</span></span><br><span class="line">thread LoopThread >>> <span class="number">4</span></span><br><span class="line">thread LoopThread >>> <span class="number">5</span></span><br><span class="line">thread LoopThread ended.</span><br><span class="line">thread MainThread ended.</span><br></pre></td></tr></tbody></table></figure>

<p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的<code>threading</code>模块有个<code>current_thread()</code>函数，它永远返回当前线程的实例。主线程实例的名字叫<code>MainThread</code>，子线程的名字在创建时指定，我们用<code>LoopThread</code>命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为<code>Thread-1</code>，<code>Thread-2</code>……</p>
<h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><p>创建一个锁是通过<code>threading.Lock()</code>来实现：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">balance = 0</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">def run_thread(n):</span><br><span class="line">    for i in range(100000):</span><br><span class="line">        # 先要获取锁:</span><br><span class="line">        lock.acquire()</span><br><span class="line">        try:</span><br><span class="line">            # 放心地改吧:</span><br><span class="line">            change_it(n)</span><br><span class="line">        finally:</span><br><span class="line">            # 改完了一定要释放锁:</span><br><span class="line">            lock.release()</span><br></pre></td></tr></tbody></table></figure>

<p>当多个线程同时执行<code>lock.acquire()</code>时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p>
<p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用<code>try...finally</code>来确保锁一定会被释放。</p>
<p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</p>
<h2 id="多核CPU"><a href="#多核CPU" class="headerlink" title="多核CPU"></a>多核CPU</h2><p>如果你不幸拥有一个多核CPU，你肯定在想，多核应该可以同时执行多个线程。</p>
<p>如果写一个死循环的话，会出现什么情况呢？</p>
<p>打开Mac OS X的Activity Monitor，或者Windows的Task Manager，都可以监控某个进程的CPU使用率。</p>
<p>我们可以监控到一个死循环线程会100%占用一个CPU。</p>
<p>如果有两个死循环线程，在多核CPU中，可以监控到会占用200%的CPU，也就是占用两个CPU核心。</p>
<p>要想把N核CPU的核心全部跑满，就必须启动N个死循环线程。</p>
<p>试试用Python写个死循环：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import threading, multiprocessing</span><br><span class="line"></span><br><span class="line">def loop():</span><br><span class="line">    x = 0</span><br><span class="line">    while True:</span><br><span class="line">        x = x ^ 1</span><br><span class="line"></span><br><span class="line">for i in range(multiprocessing.cpu_count()):</span><br><span class="line">    t = threading.Thread(target=loop)</span><br><span class="line">    t.start()</span><br></pre></td></tr></tbody></table></figure>

<p>启动与CPU核心数量相同的N个线程，在4核CPU上可以监控到CPU占用率仅有102%，也就是仅使用了一核。</p>
<p>但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？</p>
<p>因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>
<p>GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。</p>
<p>所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。</p>
<p>不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建全局ThreadLocal对象:</span></span><br><span class="line">local_school = threading.local()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_student</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 获取当前线程关联的student:</span></span><br><span class="line">    std = local_school.student</span><br><span class="line">    print(<span class="string">'Hello, %s (in %s)'</span> % (std, threading.current_thread().name))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_thread</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="comment"># 绑定ThreadLocal的student:</span></span><br><span class="line">    local_school.student = name</span><br><span class="line">    process_student()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target= process_thread, args=(<span class="string">'Alice'</span>,), name=<span class="string">'Thread-A'</span>)</span><br><span class="line">t2 = threading.Thread(target= process_thread, args=(<span class="string">'Bob'</span>,), name=<span class="string">'Thread-B'</span>)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br></pre></td></tr></tbody></table></figure>

<p>执行结果：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">Hello, Alice (<span class="keyword">in</span> Thread-A)</span><br><span class="line">Hello, Bob (<span class="keyword">in</span> Thread-B)</span><br></pre></td></tr></tbody></table></figure>

<p>全局变量<code>local_school</code>就是一个<code>ThreadLocal</code>对象，每个<code>Thread</code>对它都可以读写<code>student</code>属性，但互不影响。你可以把<code>local_school</code>看成全局变量，但每个属性如<code>local_school.student</code>都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，<code>ThreadLocal</code>内部会处理。</p>
<p>可以理解为全局变量<code>local_school</code>是一个<code>dict</code>，不但可以用<code>local_school.student</code>，还可以绑定其他变量，如<code>local_school.teacher</code>等等。</p>
<p><code>ThreadLocal</code>最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p>
<h1 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h1><p>首先，要实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。</p>
<p>如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。</p>
<p>如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。</p>
<p>多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。</p>
<p>多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用<code>fork</code>调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。</p>
<p>多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。</p>
<p>在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。</p>
<h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><p>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？</p>
<p>我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。</p>
<p>如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型，或者批处理任务模型。</p>
<p>假设你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以幼儿园小朋友的眼光来看，你就正在同时写5科作业。</p>
<p>但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。</p>
<p>所以，多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果效率急剧下降，所有任务都做不好。</p>
<h2 id="计算密集型-vs-IO密集型"><a href="#计算密集型-vs-IO密集型" class="headerlink" title="计算密集型 vs. IO密集型"></a>计算密集型 vs. IO密集型</h2><p>是否采用多任务的第二个考虑是任务的类型。我们可以把任务分为计算密集型和IO密集型。</p>
<p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p>
<p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p>
<p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p>
<p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p>
<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。</p>
<p>现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。</p>
<p>对应到Python语言，单线程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。我们会在后面讨论如何编写协程。</p>
<h1 id="分布式进程"><a href="#分布式进程" class="headerlink" title="分布式进程"></a>分布式进程</h1><p>在Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。</p>
<p>Python的<code>multiprocessing</code>模块不但支持多进程，其中<code>managers</code>子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于<code>managers</code>模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。</p>
<p>举个例子：如果我们已经有一个通过<code>Queue</code>通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？</p>
<p>原有的<code>Queue</code>可以继续使用，但是，通过<code>managers</code>模块把<code>Queue</code>通过网络暴露出去，就可以让其他机器的进程访问<code>Queue</code>了。</p>
<p>我们先看服务进程，服务进程负责启动<code>Queue</code>，把<code>Queue</code>注册到网络上，然后往<code>Queue</code>里面写入任务：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># task_master.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random, time, queue</span><br><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送任务的队列:</span></span><br><span class="line">task_queue = queue.Queue()</span><br><span class="line"><span class="comment"># 接收结果的队列:</span></span><br><span class="line">result_queue = queue.Queue()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从BaseManager继承的QueueManager:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueManager</span><span class="params">(BaseManager)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把两个Queue都注册到网络上, callable参数关联了Queue对象:</span></span><br><span class="line">QueueManager.register(<span class="string">'get_task_queue'</span>, callable=<span class="keyword">lambda</span>: task_queue)</span><br><span class="line">QueueManager.register(<span class="string">'get_result_queue'</span>, callable=<span class="keyword">lambda</span>: result_queue)</span><br><span class="line"><span class="comment"># 绑定端口5000, 设置验证码'abc':</span></span><br><span class="line">manager = QueueManager(address=(<span class="string">''</span>, <span class="number">5000</span>), authkey=<span class="string">b'abc'</span>)</span><br><span class="line"><span class="comment"># 启动Queue:</span></span><br><span class="line">manager.start()</span><br><span class="line"><span class="comment"># 获得通过网络访问的Queue对象:</span></span><br><span class="line">task = manager.get_task_queue()</span><br><span class="line">result = manager.get_result_queue()</span><br><span class="line"><span class="comment"># 放几个任务进去:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    n = random.randint(<span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line">    print(<span class="string">'Put task %d...'</span> % n)</span><br><span class="line">    task.put(n)</span><br><span class="line"><span class="comment"># 从result队列读取结果:</span></span><br><span class="line">print(<span class="string">'Try get results...'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    r = result.get(timeout=<span class="number">10</span>)</span><br><span class="line">    print(<span class="string">'Result: %s'</span> % r)</span><br><span class="line"><span class="comment"># 关闭:</span></span><br><span class="line">manager.shutdown()</span><br><span class="line">print(<span class="string">'master exit.'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>请注意，当我们在一台机器上写多进程程序时，创建的<code>Queue</code>可以直接拿来用，但是，在分布式多进程环境下，添加任务到<code>Queue</code>不可以直接对原始的<code>task_queue</code>进行操作，那样就绕过了<code>QueueManager</code>的封装，必须通过<code>manager.get_task_queue()</code>获得的<code>Queue</code>接口添加。</p>
<p>然后，在另一台机器上启动任务进程（本机上启动也可以）：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># task_worker.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time, sys, queue</span><br><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建类似的QueueManager:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueManager</span><span class="params">(BaseManager)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:</span></span><br><span class="line">QueueManager.register(<span class="string">'get_task_queue'</span>)</span><br><span class="line">QueueManager.register(<span class="string">'get_result_queue'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到服务器，也就是运行task_master.py的机器:</span></span><br><span class="line">server_addr = <span class="string">'127.0.0.1'</span></span><br><span class="line">print(<span class="string">'Connect to server %s...'</span> % server_addr)</span><br><span class="line"><span class="comment"># 端口和验证码注意保持与task_master.py设置的完全一致:</span></span><br><span class="line">m = QueueManager(address=(server_addr, <span class="number">5000</span>), authkey=<span class="string">b'abc'</span>)</span><br><span class="line"><span class="comment"># 从网络连接:</span></span><br><span class="line">m.connect()</span><br><span class="line"><span class="comment"># 获取Queue的对象:</span></span><br><span class="line">task = m.get_task_queue()</span><br><span class="line">result = m.get_result_queue()</span><br><span class="line"><span class="comment"># 从task队列取任务,并把结果写入result队列:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = task.get(timeout=<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'run task %d * %d...'</span> % (n, n))</span><br><span class="line">        r = <span class="string">'%d * %d = %d'</span> % (n, n, n*n)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        result.put(r)</span><br><span class="line">    <span class="keyword">except</span> Queue.Empty:</span><br><span class="line">        print(<span class="string">'task queue is empty.'</span>)</span><br><span class="line"><span class="comment"># 处理结束:</span></span><br><span class="line">print(<span class="string">'worker exit.'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>任务进程要通过网络连接到服务进程，所以要指定服务进程的IP。</p>
<p>现在，可以试试分布式进程的工作效果了。先启动<code>task_master.py</code>服务进程：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ python3 task_master.py </span><br><span class="line">Put task <span class="number">3411.</span>..</span><br><span class="line">Put task <span class="number">1605.</span>..</span><br><span class="line">Put task <span class="number">1398.</span>..</span><br><span class="line">Put task <span class="number">4729.</span>..</span><br><span class="line">Put task <span class="number">5300.</span>..</span><br><span class="line">Put task <span class="number">7471.</span>..</span><br><span class="line">Put task <span class="number">68.</span>..</span><br><span class="line">Put task <span class="number">4219.</span>..</span><br><span class="line">Put task <span class="number">339.</span>..</span><br><span class="line">Put task <span class="number">7866.</span>..</span><br><span class="line">Try get results...</span><br></pre></td></tr></tbody></table></figure>

<p><code>task_master.py</code>进程发送完任务后，开始等待<code>result</code>队列的结果。现在启动<code>task_worker.py</code>进程：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ python3 task_worker.py</span><br><span class="line">Connect to server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>...</span><br><span class="line">run task <span class="number">3411</span> * <span class="number">3411.</span>..</span><br><span class="line">run task <span class="number">1605</span> * <span class="number">1605.</span>..</span><br><span class="line">run task <span class="number">1398</span> * <span class="number">1398.</span>..</span><br><span class="line">run task <span class="number">4729</span> * <span class="number">4729.</span>..</span><br><span class="line">run task <span class="number">5300</span> * <span class="number">5300.</span>..</span><br><span class="line">run task <span class="number">7471</span> * <span class="number">7471.</span>..</span><br><span class="line">run task <span class="number">68</span> * <span class="number">68.</span>..</span><br><span class="line">run task <span class="number">4219</span> * <span class="number">4219.</span>..</span><br><span class="line">run task <span class="number">339</span> * <span class="number">339.</span>..</span><br><span class="line">run task <span class="number">7866</span> * <span class="number">7866.</span>..</span><br><span class="line">worker exit.</span><br></pre></td></tr></tbody></table></figure>

<p><code>task_worker.py</code>进程结束，在<code>task_master.py</code>进程中会继续打印出结果：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">Result: <span class="number">3411</span> * <span class="number">3411</span> = <span class="number">11634921</span></span><br><span class="line">Result: <span class="number">1605</span> * <span class="number">1605</span> = <span class="number">2576025</span></span><br><span class="line">Result: <span class="number">1398</span> * <span class="number">1398</span> = <span class="number">1954404</span></span><br><span class="line">Result: <span class="number">4729</span> * <span class="number">4729</span> = <span class="number">22363441</span></span><br><span class="line">Result: <span class="number">5300</span> * <span class="number">5300</span> = <span class="number">28090000</span></span><br><span class="line">Result: <span class="number">7471</span> * <span class="number">7471</span> = <span class="number">55815841</span></span><br><span class="line">Result: <span class="number">68</span> * <span class="number">68</span> = <span class="number">4624</span></span><br><span class="line">Result: <span class="number">4219</span> * <span class="number">4219</span> = <span class="number">17799961</span></span><br><span class="line">Result: <span class="number">339</span> * <span class="number">339</span> = <span class="number">114921</span></span><br><span class="line">Result: <span class="number">7866</span> * <span class="number">7866</span> = <span class="number">61873956</span></span><br></pre></td></tr></tbody></table></figure>

<p>这个简单的Master/Worker模型有什么用？其实这就是一个简单但真正的分布式计算，把代码稍加改造，启动多个worker，就可以把任务分布到几台甚至几十台机器上，比如把计算<code>n*n</code>的代码换成发送邮件，就实现了邮件队列的异步发送。</p>
<p>Queue对象存储在哪？注意到<code>task_worker.py</code>中根本没有创建Queue的代码，所以，Queue对象存储在<code>task_master.py</code>进程中：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">                                             │</span><br><span class="line">┌─────────────────────────────────────────┐     ┌──────────────────────────────────────┐</span><br><span class="line">│task_master.py                           │  │  │task_worker.py                        │</span><br><span class="line">│                                         │     │                                      │</span><br><span class="line">│  task = manager.get_task_queue()        │  │  │  task = manager.get_task_queue()     │</span><br><span class="line">│  result = manager.get_result_queue()    │     │  result = manager.get_result_queue() │</span><br><span class="line">│              │                          │  │  │              │                       │</span><br><span class="line">│              │                          │     │              │                       │</span><br><span class="line">│              ▼                          │  │  │              │                       │</span><br><span class="line">│  ┌─────────────────────────────────┐    │     │              │                       │</span><br><span class="line">│  │QueueManager                     │    │  │  │              │                       │</span><br><span class="line">│  │ ┌────────────┐ ┌──────────────┐ │    │     │              │                       │</span><br><span class="line">│  │ │ task_queue │ │ result_queue │ │<───┼──┼──┼──────────────┘                       │</span><br><span class="line">│  │ └────────────┘ └──────────────┘ │    │     │                                      │</span><br><span class="line">│  └─────────────────────────────────┘    │  │  │                                      │</span><br><span class="line">└─────────────────────────────────────────┘     └──────────────────────────────────────┘</span><br><span class="line">                                             │</span><br><span class="line"></span><br><span class="line">                                          Network</span><br></pre></td></tr></tbody></table></figure>

<p>而<code>Queue</code>之所以能通过网络访问，就是通过<code>QueueManager</code>实现的。由于<code>QueueManager</code>管理的不止一个<code>Queue</code>，所以，要给每个<code>Queue</code>的网络调用接口起个名字，比如<code>get_task_queue</code>。</p>
<p><code>authkey</code>有什么用？这是为了保证两台机器正常通信，不被其他机器恶意干扰。如果<code>task_worker.py</code>的<code>authkey</code>和<code>task_master.py</code>的<code>authkey</code>不一致，肯定连接不上。</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>线程</tag>
        <tag>进程</tag>
        <tag>分布式进程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程进程总结</title>
    <url>/2019/02/19/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-c-%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>线程和进程是什么？为什么需要使用多线程？有什么可能存在的问题？如何使用线程？</p>
<a id="more"></a>

<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>线程，有时被称为轻量进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304" target="_blank" rel="noopener">指针</a>(PC），<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8/187682" target="_blank" rel="noopener">寄存器</a>集合和<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88/1682032" target="_blank" rel="noopener">堆栈</a>组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程<strong>共享进程所拥有的全部资源</strong>。一个线程可以<strong>创建和撤消另一个线程</strong>，同一进程中的多个线程之间可以并发执行。</p>
<p>线程有<a href="https://baike.baidu.com/item/%E5%B0%B1%E7%BB%AA/10932509" target="_blank" rel="noopener">就绪</a>、<a href="https://baike.baidu.com/item/%E9%98%BB%E5%A1%9E/9032404" target="_blank" rel="noopener">阻塞</a>和<a href="https://baike.baidu.com/item/%E8%BF%90%E8%A1%8C/5480697" target="_blank" rel="noopener">运行</a>三种基本状态。就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；运行状态是指线程占有处理机正在运行；阻塞状态是指线程在等待一个事件（如某个信号量），逻辑上不可执行。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。</p>
<p>线程是程序中一个单一的顺序控制流程。进程内有一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指令<a href="https://baike.baidu.com/item/%E8%BF%90%E8%A1%8C" target="_blank" rel="noopener">运行</a>时的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为<a href="https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404" target="_blank" rel="noopener">多线程</a>。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><strong>1）轻型实体</strong></p>
<p>线程中的实体基本上不拥有<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90" target="_blank" rel="noopener">系统资源</a>，只是有一点必不可少的、能保证独立<a href="https://baike.baidu.com/item/%E8%BF%90%E8%A1%8C" target="_blank" rel="noopener">运行</a>的资源。</p>
<p>线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。TCB包括以下信息：</p>
<p>（1）线程状态。</p>
<p>（2）当线程不运行时，被保存的现场资源。</p>
<p>（3）一组执行堆栈。</p>
<p>（4）存放每个线程的局部变量主存区。</p>
<p>（5）访问同一个进程中的主存和其它资源。</p>
<p>用于指示被执行指令序列的<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8" target="_blank" rel="noopener">程序计数器</a>、保留<a href="https://baike.baidu.com/item/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">局部变量</a>、少数状态参数和<a href="https://baike.baidu.com/item/%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">返回地址</a>等的一组<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8" target="_blank" rel="noopener">寄存器</a>和<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88" target="_blank" rel="noopener">堆栈</a>。</p>
<p><strong>2）独立调度和分派的基本单位。</strong></p>
<p>在多线程OS中，线程是能独立<a href="https://baike.baidu.com/item/%E8%BF%90%E8%A1%8C" target="_blank" rel="noopener">运行</a>的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>中的）。</p>
<p><strong>3）可并发执行。</strong></p>
<p>在一个<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA" target="_blank" rel="noopener">处理机</a>与外围设备并行工作的能力。</p>
<p><strong>4）共享</strong><a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>资源。</p>
<p><a href="https://baike.baidu.com/pic/%E7%BA%BF%E7%A8%8B/103101/0/a583631edbe8bbb41ad57610?fr=lemma&ct=single" target="_blank" rel="noopener" title="线程"><img src="/" class="lazyload" data-src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=ae1c7b5b9d16fdfadc6cc1ec848e8cea/c8177f3e6709c93d793c8e879f3df8dcd00054f7.jpg"  alt="线程"></a>线程</p>
<p>在同一<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的<a href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4" target="_blank" rel="noopener">地址空间</a>（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">文件</a>、定时器、<a href="https://baike.baidu.com/item/%E4%BF%A1%E5%8F%B7%E9%87%8F" target="_blank" rel="noopener">信号量</a>机构等。由于同一个<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>内的线程<a href="https://baike.baidu.com/item/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98" target="_blank" rel="noopener">共享内存</a>和<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">文件</a>，所以线程之间互相通信不必调用<a href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8" target="_blank" rel="noopener">内核</a>。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。</p>
<p>广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192" target="_blank" rel="noopener">操作系统</a>动态执行的<a href="https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83" target="_blank" rel="noopener">基本单元</a>，在传统的<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">操作系统</a>中，进程既是基本的<a href="https://baike.baidu.com/item/%E5%88%86%E9%85%8D%E5%8D%95%E5%85%83" target="_blank" rel="noopener">分配单元</a>，也是基本的执行单元。</p>
<p>进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括<a href="https://baike.baidu.com/item/%E6%96%87%E6%9C%AC" target="_blank" rel="noopener">文本</a>区域（text region）、数据区域（data region）和<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88" target="_blank" rel="noopener">堆栈</a>（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86" target="_blank" rel="noopener">处理</a>器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>。</p>
<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p><strong>动态性</strong>：进程的实质是程序在<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">多道程序系统</a>中的一次执行过程，进程是动态产生，动态消亡的。</p>
<p><strong>并发性</strong>：任何进程都可以同其他进程一起并发执行</p>
<p><strong>独立性</strong>：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的<strong>独立</strong>单位；</p>
<p><strong>异步性</strong>：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进</p>
<p><strong>结构特征</strong>：进程由程序、数据和<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97" target="_blank" rel="noopener">进程控制块</a>三部分组成。</p>
<p>多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果；但是执行过程中，程序不能发生改变。</p>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1></body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>void*指针疑问和总结</title>
    <url>/2019/02/18/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-c-void%E6%8C%87%E9%92%88%E7%96%91%E9%97%AE%E5%92%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>对void用法和注意事项进行总结，以及提出几个问题：</p>
<ul>
<li><p>void*进行赋值后，可以直接使用memcpy么</p>
</li>
<li><p>void*并不知道空间大小，放在结构体中如何确定结构体的空间</p>
</li>
</ul>
<a id="more"></a>

<h1 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h1><p>void即“无类型”，void *则为“无类型指针”，能够指向不论什么数据类型。  </p>
<h1 id="void指针总结"><a href="#void指针总结" class="headerlink" title="void指针总结"></a>void指针总结</h1><blockquote>
<p>指针有两个属性:指向变量/对象的地址和长度 </p>
<p>但是指针只存储地址,长度则取决于指针的类型</p>
</blockquote>
<p>首先我们要了解指针是什么，指针只存储地址的值，长度取决于指针的类型，也就是说指针的运算才和类型有关，因此可以进行memcpy只是需要定义一下指针的类型。也就解决了<strong>第二个问题</strong>，void*存储的是变量/对象地址，地址是一个4位或者8位的变量，根据系统位数而定，因此结构体的空间也就是固定的。</p>
<blockquote>
<p>任何指针都可以赋值给void指针 </p>
</blockquote>
<p>void指针能够指向随意类型的数据，亦就可以用随意数据类型的指针对void指针赋值。其中可以不进行转换，只需要获取变量、对象的地址而不获取大小。<strong>第一个问题</strong>也就解决了，void*指针是可以直接<code>memcpy</code>的，但是如果要进行指针运算，就需要转换，具体原因看下面。</p>
<blockquote>
<p>void指针赋值给其他类型的指针时都要进行转换</p>
<p>void指针不能参与指针运算,除非进行转换 </p>
</blockquote>
<p>但是值得注意的是，void指针赋值给其他类型的指针都要进行转换，因为指针不仅要知道指向变量/对象的地址，还需要知道指向对象的长度。也因此参与指针运算，同样需要类型转换。</p>
<p>在ANSIC标准中，不同意对void指针进行算术运算如pvoid++或pvoid+=1等，而在GNU中则同意，由于在缺省情况下，GNU觉得void <em>与char *一样。sizeof(</em>pvoid )== sizeof( char)。不同的标准对指针运算的标准不一样，但是严格起见，我们都应该对指针类型进行赋值才能开始运算。</p>
<blockquote>
<p>在函数的返回值中, void 是没有任何返回值, 而 void * 是返回任意类型的值的指针.</p>
</blockquote>
<p>注意函数的返回值是void*的时候是返回任意类型的值。</p>
<h1 id="void-指针的作用"><a href="#void-指针的作用" class="headerlink" title="void*指针的作用"></a>void*指针的作用</h1><p>由于void指针能够指向随意类型的数据，亦就可以用随意数据类型的指针对void指针赋值，因此还能够用void指针来作为函数形參，这样函数就能够接受随意数据类型的指针作为參数。比如： </p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memcpy</span><span class="params">( <span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> len )</span></span>; </span><br><span class="line">void * memset( void * buffer, int c, size_t num)；</span><br></pre></td></tr></tbody></table></figure>

<p>相比于void发挥的作用在于：</p>
<ul>
<li>对函数返回的限定；</li>
<li>对函数參数的限定。</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>背光算法代码实现</title>
    <url>/2019/02/14/%E5%B7%A5%E4%BD%9C-%E7%BC%96%E7%A8%8B-%E8%83%8C%E5%85%89%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>如何实现强光下自由降低曝光阶？修改stats数据是否有效？如何动态修改曝光权重？</p>
<a id="more"></a>

<h1 id="修改stats数据"><a href="#修改stats数据" class="headerlink" title="修改stats数据"></a>修改stats数据</h1><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>为了注重强光，需要降低亮度，如果增加亮区的亮度，原来可能已经饱和了，现在如果继续增加，就没有效果了。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>如果调整stats数据中RGB的最大值，防止超出最大值，是否有用。</p>
<p>实验发现调整rbg_max大小是没有用的，ISP输出数据深度，超过这个深度之后无效，因此增大亮区的统计亮度基本没有效果；如果改成增大暗区的统计亮度来降低曝光，就失去了背光补偿的意义</p>
<h1 id="修改曝光权重"><a href="#修改曝光权重" class="headerlink" title="修改曝光权重"></a>修改曝光权重</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>曝光权重是从chromatix直接导入的，流经stats模块，进入了aec_port，我们可以在stats模块中截取进行修改；也可以再aec模块传入的地方进行修改。</p>
<h2 id="STATS模块尝试"><a href="#STATS模块尝试" class="headerlink" title="STATS模块尝试"></a>STATS模块尝试</h2><p>如果在stats模块传递到的位置进行修改，因为先要由统计数据去调整曝光权重，而程序是先执行调整曝光权重再去判断统计数据的话，理论上曝光调整会延迟一帧进行。因此最好在stats模块中能获取到stats和曝光权重的时候一并修改。但是可能存在一个问题，在stats模块修改了chromatix中的数据，aec模块可能不会重新加载。</p>
<p>在<code>stats_port_event</code>函数中的<code>IPC_KEDA_AE_CONTROL</code>下方对private中的chromatix参数进行修改</p>
<p>首先确认这是否是每帧都会运行的地方，加打印，看打印时间相隔多少，如果是33ms就是每帧都会打印；却发现没有打印，因此需要重新找到将stats数据和测光权重传递给aec的事件</p>
<p>从名称中定位到可能的事件，并查看处理方法：<code>MCT_EVENT_CONTROL_SET_PARM</code> （不是每帧都执行）<code>MCT_EVENT_MODULE_ISP_STATS_INFO</code>(用来debug的，排除) <code>MCT_EVENT_CONTROL_PARM_STREAM_BUF</code> (stats模块控制，排除)<code>MCT_EVENT_CONTROL_SOF</code>(控制帧开头，用来插入JPEG信息，排除) <code>MCT_EVENT_MODULE_STATS_DATA</code>（平均20ms执行一次是不是有点过快了）</p>
<h2 id="AEC模块尝试"><a href="#AEC模块尝试" class="headerlink" title="AEC模块尝试"></a>AEC模块尝试</h2><p>由于stats模块在aec模块的上游，因此我们在aec模块中进行修改，可以更简单快捷的控制AEC模块的输入。</p>
<h3 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h3><ol>
<li><p>我们要找到chromatix导入的位置：<code>aec_biz_map_init_chromatix_sensor</code>函数</p>
</li>
<li><p>可以看到chromatix数据是从<code>chromatix_3a_parms_wrapper</code>导入到<code>aec_set_parameter_init_t</code>结构体中，<code>chromatix_3a_parms_wrapper</code>在stats模块中也可以进行修改，但是为了防止修改了chromatix参数，如果仅在初始化时进行修改，那么不会生效</p>
</li>
<li><p>接下来找到<code>aec_biz_map_init_chromatix_sensor</code>函数调用位置：<code>aec_biz_set_param</code>，仅有在<code>param->type == AEC_SET_PARAM_INIT_CHROMATIX_SENSOR</code>时，才会进行调用。因此我们之前可能不生效的猜测是正确的，只有在初始化的时候才会加载。</p>
</li>
<li><p>两个解决方案：一是我们在最后必须经过的地方，对chromatix中的值进行修改；二是增加一个自定义的<code>param->type</code>类型。 相比较来说，肯定是第二种方法比较好，在一帧里不会重复的对chromatix中的值进行修改。</p>
</li>
<li><p>还有一个问题值得注意：<code>aec_biz_set_param</code>函数也不是每帧都会执行的，只有当设置参数的时候才会执行。经过打印实验，相比于set_params，函数<code>aec_biz_process</code>是会每帧执行的。我们的背光补偿算法以及对测光权重的处理需要放在一个一直执行的地方。</p>
</li>
<li><p>很遗憾的是<code>aec_biz_map_init_chromatix_sensor</code>是对数据<code>set_param</code>进行操作的，而<code>set_param</code>只能由函数<code>set_parameters</code>进行设置，不能在函数<code>aec_biz_process</code>中进行处理。</p>
</li>
<li><p>下面有三种解决方案：</p>
<ul>
<li><p>一种是在process中调用<code>set_parameters</code>函数(但是不知道形参)</p>
</li>
<li><p>一种是在set_parameters中增加自定义的处理</p>
</li>
<li><p>最后一种是定义一个全局变量<code>backlight_set_parameter</code>指向aec_set_parameter_t的地址，当运行<code>aec_biz_set_param</code>时更新全局变量，然后在process中处理。</p>
</li>
<li><p>但是这个时候第二种方法就不如第三种方法来的简单，第二种方法会导致开启背光补偿后每帧都需要执行<code>aec_biz_set_param</code>函数，第三种方法更加简单，但是相当于给set_param和process之间开了一个后门，可能会有安全隐患？</p>
</li>
</ul>
</li>
<li><p>为了可以修改送入AEC算法的stats数据，以及需要在aec算法之前操作，我们将背光补偿算法放在函数<code>aec_biz_process</code>中，位于函数<code>aec_biz_stats_map</code>和<code>aec_algo_ops.process</code>之前。</p>
</li>
<li><p>但是发现函数process不能使用<code>aec_set_parameter_t</code>这个数据，一个方法是定义一个全局变量<code>backlight_set_parameter</code>指向aec_set_parameter_t的地址，当运行<code>aec_biz_set_param</code>时更新全局变量，然后在process中处理。这样相当于开了一个后门</p>
</li>
<li><p>由于aec_core_set_param_type是<code>union</code>类型，因此需要在一个合适的时候讲</p>
</li>
<li><p>定义一个static的变量，将设置的值保存起来</p>
</li>
</ol>
<p>发现问题：</p>
<ol>
<li><p>死机，摄像头加载不了  </p>
<p>解决方法：将指针改成了结构体变量，防止由于set_param变量的变化而变化</p>
</li>
<li><p>打印修改的测光权重，发现不对应  </p>
<p>解决方法：调整stats分块数据和测光权重表的对应关系</p>
</li>
<li><p>想要更新AEC的参数，只能通过set_param函数进行修改，传入的值是一个union类型加一个type，也就是说每次传入的参数是跟type有关系的。而aec模块的输入是封闭的，需要你有对应的set_param类型，通过命名很明显的发现没有</p>
<p>解决方法只能是init_chromatix的方法对测光权重进行修改</p>
</li>
<li><p>难道说这里的aec_algo_ops一直指的是aec_biz，而不是aec的算法，也就是说它会经常调用自身，那我之前的推导岂不是全部乱掉了</p>
<p>解决方法：重新对结构体进行了分析 ，param->type 的枚举值里有PARAM，而set_param里面没有，按照set_param的函数的执行顺序，是将类型<code>aec_set_parameter_t</code>转换成了<code>aec_core_set_param_type</code>的类型，发现之前的推论没有问题。</p>
</li>
<li><ul>
<li><p>写入chromatix文件无效，尝试读取权重表，自己计算current luma，将两者的current luma进行对比，确实将曝光权重进行了修改，但是参数不生效。</p>
</li>
<li><p>无论写入什么值或者不写入值，图像曝光都不够，cur_luma一直很低：是否是chromatix参数传递有问题？将chromatix打印出来没有问题啊。是否可能是因为调用memcpy函数之前没有对目标指针进行初始化？</p>
</li>
<li><p>时间一长设备会挂掉，是否因为哪个地方内存泄露？或者越界访问了？</p>
</li>
<li><p>解决方法：将设置参数类型改为<code>AEC_SET_COPY_CHROMATIX_SENSOR</code>,，参数生效，但是好像过一段时间会再次不生效</p>
<p>AE容易闪烁</p>
</li>
</ul>
</li>
</ol>
<p>解决方法：因为增大了亮区的权重，会对亮的地方很敏感，我测试的场景下有个会动的显示屏，所以出现闪烁的情况也是正常现象。</p>
<ol start="11">
<li>如果用ADRC的方法实现，由于set_param只有enable这个选项，也需要进行chromatix参数的改写。也可以利用这个方法对chromatix参数进行改写。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>在aec_biz.c中进行修改</p>
<ol>
<li>首先定义局部静态变量，储存chromatix数据以及初始化时的测光权重数据。</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> aec_core_set_param_type backlight_set_parameter;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">float</span> keda_exposure_weight[NUM_AEC_STATS][NUM_AEC_STATS]={<span class="number">0</span>};</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>在初始化时读取chromatix数据，并存储测光权重表</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//放在代码pthread_rwlock_rdlock(&chromatix->lock)之后</span></span><br><span class="line"><span class="comment">//在对读写锁进行读操作之后</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> IPC_BACKLIGHT_CONTROL</span></span><br><span class="line"> backlight_set_parameter.type = AEC_SET_COPY_CHROMATIX_SENSOR;</span><br><span class="line">  STATS_MEMCPY(&backlight_set_parameter.u.init_param, <span class="keyword">sizeof</span>(<span class="keyword">aec_set_parameter_init_t</span>),</span><br><span class="line">    &param->u.init_param, <span class="keyword">sizeof</span>(<span class="keyword">aec_set_parameter_init_t</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i < NUM_AEC_STATS; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j < NUM_AEC_STATS; j++)</span><br><span class="line">        keda_exposure_weight[i][j] =</span><br><span class="line">        chromatix->AEC.aec_metering_tables.AEC_weight_center_weighted[i][j];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>在aec_biz_process函数之前定义处理自定义处理函数</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">keda_backlight_algo</span><span class="params">(<span class="keyword">aec_biz_t</span> *aec, <span class="keyword">const</span> <span class="keyword">stats_t</span>* stats)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!aec || !stats) {</span><br><span class="line">      AEC_ERR(<span class="string">"Invalid input: %p,%p"</span>,aec, stats);</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="keyword">float</span> aec_ratio = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    chromatix_3a_parms_wrapper *chromatix;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">q3a_bg_stats_t</span>* q3a_bg_stats = stats->bayer_stats.p_q3a_bg_stats;</span><br><span class="line">    <span class="keyword">uint32_t</span> threhold_h = q3a_bg_stats->rMax * q3a_bg_stats->region_pixel_cnt * <span class="number">0.6</span> /<span class="number">4</span>;</span><br><span class="line">    chromatix = (chromatix_3a_parms_wrapper*)</span><br><span class="line">        backlight_set_parameter.u.init_param.chromatix;</span><br><span class="line">    <span class="keyword">if</span> (!chromatix) {</span><br><span class="line">        AEC_ERR(<span class="string">"Invalid chromatix: %p"</span>, chromatix)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> v_step = q3a_bg_stats->bg_region_v_num/NUM_AEC_STATS;</span><br><span class="line">    <span class="keyword">int</span> h_step = q3a_bg_stats->bg_region_h_num/NUM_AEC_STATS;</span><br><span class="line">    <span class="keyword">int</span> grid_v_num, grid_h_num;</span><br><span class="line">    <span class="keyword">int</span> weight_grid_count[NUM_AEC_STATS][NUM_AEC_STATS] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">if</span> (property_get(<span class="string">"persist.liqinxing.backlight"</span>, value, <span class="string">""</span>) > <span class="number">0</span>){</span><br><span class="line">        aec_ratio = atoi(value)/<span class="number">1000.0</span>;</span><br><span class="line">        <span class="comment">//reduce traverse times and prevent data overflow</span></span><br><span class="line">        <span class="keyword">int</span> grid_count = q3a_bg_stats->bg_region_h_num * q3a_bg_stats->bg_region_v_num;</span><br><span class="line">        <span class="comment">//find the position of bright region</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < grid_count; i++){</span><br><span class="line">            <span class="keyword">if</span>(q3a_bg_stats->bg_r_sum[i] > threhold_h ||</span><br><span class="line">               q3a_bg_stats->bg_gr_sum[i] > threhold_h ||</span><br><span class="line">               q3a_bg_stats->bg_b_sum[i] > threhold_h){</span><br><span class="line">                grid_v_num = i/q3a_bg_stats->bg_region_h_num/v_step;<span class="comment">//calculate current position v</span></span><br><span class="line">                grid_h_num = i%q3a_bg_stats->bg_region_h_num/h_step;<span class="comment">//calculate current position h</span></span><br><span class="line">                weight_grid_count[grid_v_num][grid_h_num]++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//adjust metering ratio in the bright region</span></span><br><span class="line">        pthread_rwlock_wrlock(&chromatix->lock);</span><br><span class="line">        backlight_set_parameter.type = AEC_SET_COPY_CHROMATIX_SENSOR;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i < NUM_AEC_STATS; i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j < NUM_AEC_STATS; j++){</span><br><span class="line">                <span class="keyword">if</span>(weight_grid_count[i][j] > <span class="number">3</span>){</span><br><span class="line">                    chromatix->AEC.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span><br><span class="line">                        keda_exposure_weight[i][j] * aec_ratio;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        pthread_rwlock_unlock(&chromatix->lock);</span><br><span class="line">        <span class="keyword">if</span> (aec->aec_algo_ops.set_parameters) {</span><br><span class="line"></span><br><span class="line">            aec->aec_algo_ops.set_parameters(aec->handle, &backlight_set_parameter);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">return</span> TRUE;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li>在aec_biz_process函数中的<code>ret = aec_biz_stats_map(aec, stats);</code>上方调用我们的函数：<code>keda_backlight_algo(aec,stats);</code></li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>代码实现</tag>
      </tags>
  </entry>
  <entry>
    <title>写给初恋的第一首歌</title>
    <url>/2019/02/14/%E7%94%9F%E6%B4%BB-love-2019-02-14-love/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>你甜甜的笑靥</p>
<p>已闯入我的心扉</p>
<p>我痴痴地望着</p>
<p>为何只有你喜欢</p>
<p>你望着我傻笑</p>
<p>我看你傻笑而傻笑</p>
<p>围围</p>
<p>你太可爱</p>
<p>我不知怎么办</p>
<p>感谢你</p>
<p>让我如痴如醉的甜蜜</p>
<p>喜欢你</p>
<p>让我生活撒上阳光</p>
<p>原谅我</p>
<p>不解细腻的少女心</p>
<p>感谢你</p>
<p>出现在这里</p>
<br>

<p>你动情的歌声</p>
<p>总萦绕我的耳畔</p>
<p>我轻盈的思绪</p>
<p>却缠上你的发梢</p>
<p>我念你的心跳</p>
<p>我因你心跳而心跳</p>
<p>围围</p>
<p>你太可爱</p>
<p>我已知怎么办</p>
<p>我喜欢你的甜</p>
<p>有你那就是晴天</p>
<p>我许你一世</p>
<p>期待着每天的你</p>
<p>你就是那未来</p>
<p>我憧憬未来和未来</p>
<p>围围</p>
<p>你太可爱</p>
<p>我不会放开</p>
<p>喜欢你</p>
<p>那样沁人心脾的爱恋</p>
<p>感谢你</p>
<p>让我人生重新起航</p>
<p>原谅我</p>
<p>有点笨拙的小脾气</p>
<p>感谢你</p>
<p>一直在那里</p>
<br>

<p>有一个</p>
<p>早已被你猜到的秘密</p>
<p>请允许</p>
<p>我把你放进我的心</p>
<p>红蜡烛</p>
<p>融入爱恋燃烧着自己</p>
<p>不知你</p>
<p>能否会忘记</p>
<p>相信我</p>
<p>予你幸福的一辈子</p>
</body></html>]]></content>
      <categories>
        <category>生活</category>
        <category>围围</category>
        <category>诗歌</category>
      </categories>
      <tags>
        <tag>围围</tag>
        <tag>情书</tag>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>疯人愿</title>
    <url>/2019/02/02/%E7%94%9F%E6%B4%BB-%E5%9B%B4-2019-02-02-weiyi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>不是疯子<br>不是傻子<br>是疯子<br>亦是傻子<br>不是歌<br>那就谱成歌<br>不能唱<br>那就喊<br>不能喊<br>那就默<br>疯子有愿望<br>傻子也有<br>我也有<br>还有梦想<br>只要愿意追求梦想<br>疯何如<br>傻又何如     </p>
</body></html>]]></content>
      <categories>
        <category>生活</category>
        <category>围围</category>
        <category>围的礼物</category>
      </categories>
      <tags>
        <tag>围围</tag>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>惊蛰</title>
    <url>/2019/02/01/%E7%94%9F%E6%B4%BB-%E5%9B%B4-2019-02-01-weiyi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><div align="center">
元月惊蛰惊醒春，<br>     
虽春犹寒衣不退。<br>      
洁面玉兰清香逸，<br>      
河清影面霓虹缀。<br>   
</div>

</body></html>]]></content>
      <categories>
        <category>生活</category>
        <category>围围</category>
        <category>围的礼物</category>
      </categories>
      <tags>
        <tag>围围</tag>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>夜雨</title>
    <url>/2019/01/30/%E7%94%9F%E6%B4%BB-%E5%9B%B4-2019-01-30-weiyi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>夜还没深<br>家人已经入睡<br>只我还独坐帘前<br>听着这夜雨<br>听着这歌声<br>灵魂神游在过去与未来  </p>
<a id="more"></a>

<p><strong>木栏杆子金黄</strong><br><strong>调皮的风啊</strong><br><strong>把雨吹到栏前的玻璃板面上</strong><br><strong>留下星星点点的雨水印</strong><br>在对面昏黄路灯的照耀下<br>闪闪发亮<br>潺潺流水在屋檐上滑落<br>密密麻麻的雨滴打在蓝瓦灰砖上<br>发出声响<br>远处的霓虹灯在闪烁着<br>我甚至不知道<br>是它自己在闪烁<br>还是雨滴的划落而产生的错觉<br>这寂静的夜<br>沉寂得让人心生寒意<br>幸炉子的温暖将寒冷抵御<br>镜映明灯镜子荧<br>心照恒星心意定<br>向着这夜雨和明镜<br>许下所爱之人安好的愿  </p>
<div align="right">
——冯围
 二零一九年一月三十日晚
 农历贰零壹捌年腊月廿五
</div>
</body></html>]]></content>
      <categories>
        <category>生活</category>
        <category>围围</category>
        <category>围的礼物</category>
      </categories>
      <tags>
        <tag>围围</tag>
        <tag>宝藏</tag>
      </tags>
  </entry>
  <entry>
    <title>车辆人员监控调试注意点</title>
    <url>/2019/01/30/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-%E8%BD%A6%E8%BE%86%E4%BA%BA%E5%91%98%E7%9B%91%E6%8E%A7%E8%B0%83%E8%AF%95%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>讨论车辆人员卡口的注意点，对以后可能遇到的问题进行指导</p>
</blockquote>
<a id="more"></a>



<h1 id="产品类型"><a href="#产品类型" class="headerlink" title="产品类型"></a>产品类型</h1><ul>
<li><p>4N   ==人脸</p>
</li>
<li><p>7N   ==车辆+人（小比例，能检测到人就行；同<code>结构化</code>）</p>
</li>
<li><p>8N   ==车辆</p>
</li>
<li><p>PID是产品号；HID是硬件型号，HID可能一样</p>
</li>
</ul>
<h1 id="车辆卡口"><a href="#车辆卡口" class="headerlink" title="车辆卡口"></a>车辆卡口</h1><h2 id="架设要求"><a href="#架设要求" class="headerlink" title="架设要求"></a>架设要求</h2><ol>
<li><p>根据摄像头的像素去决定拍几车道  </p>
<p>车牌要150个像素点以上，一般200万的就拍双车道</p>
</li>
<li><p>视角大小  </p>
</li>
</ol>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol>
<li><p>颜色容易偏色</p>
</li>
<li><p>补光容易过曝  </p>
<p> 尽量用外置不用内置，打到地面上通过漫发射照亮车牌</p>
</li>
<li><p>对比度第一点</p>
</li>
<li><p>镜头不好，可能会产生光斑</p>
</li>
</ol>
<h2 id="电警卡口"><a href="#电警卡口" class="headerlink" title="电警卡口"></a>电警卡口</h2><p>由于爆闪灯，需要比较精确控制AEC和AWB的时序，爆闪灯来会有一个中断</p>
<p>快门一般设置为1/400</p>
<p>白平衡容易出错 </p>
<p><strong>解决方法</strong>：预先设置好，并将白平衡的优先级调高</p>
<p>FPGA直接控制sensor</p>
<h1 id="人员卡口"><a href="#人员卡口" class="headerlink" title="人员卡口"></a>人员卡口</h1><ul>
<li><p>让人脸大的时候再抓拍 ==视场角</p>
</li>
<li><p>逆光场景 ==由于PK时只看人脸效果，也只会存人脸效果，无论视频效果怎么样，能看清人脸就行</p>
</li>
<li><p>景深  ==AF  </p>
</li>
</ul>
<ol>
<li><p>纵深场景时，AF容易聚到后面，而在前面的话人脸效果更好，可以限制焦点的距离</p>
</li>
<li><p>环境比较光滑时，如瓷砖地板，容易聚在纹理清楚的地方，聚不到人脸上</p>
</li>
<li><p>日夜切换容易跑焦</p>
</li>
</ol>
<ul>
<li>一定要看所有的时间段，最好隔15分钟拍一张照片，查看一下每个时候的照片效果</li>
</ul>
<p>逆光 –>红斑</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像效果调试</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>海思camera</tag>
      </tags>
  </entry>
  <entry>
    <title>chromatix 重载代码实现</title>
    <url>/2019/01/29/%E5%B7%A5%E4%BD%9C-%E7%BC%96%E7%A8%8B-chromatix%E9%87%8D%E8%BD%BD%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>在高通自带的reload函数中，每次reload的时候都要先查找hash值以及lru，也就是内存中是否存在，如果存在就不会重新重新读取动态库数据。因此本文的方法是在读取hash值的位置加一个函数，不进行hash值和lru count的读取，删除之前的hash和lru，重新进行读取。</p>
<a id="more"></a>

<h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><ol>
<li>在<code>port_sensor.c</code>文件中的<code>port_sensor_handle_upstream_module_event</code>函数判断传入参数非空之后增加对自定义perisist的处理:当persist从0变为1，重载chromatix头文件</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> chromatix_reload = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (property_get(<span class="string">"persist.chromatix.reload"</span>, value, <span class="string">""</span>) > <span class="number">0</span>){</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"0"</span>, value) == <span class="number">0</span>)</span><br><span class="line">          chromatix_reload = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span>{</span><br><span class="line">          <span class="keyword">if</span>(chromatix_reload){</span><br><span class="line">              chromatix_reload = <span class="number">0</span>; </span><br><span class="line">              <span class="keyword">if</span>(keda_reload_chromatix_ptr(<span class="keyword">module</span>,event,</span><br><span class="line"> bundle_info->s_bundle) == TRUE)</span><br><span class="line">               SERR(<span class="string">"chromatix reload sucess"</span>);</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               SERR(<span class="string">"chromatix reload failed"</span>);                                                                                              </span><br><span class="line">           }</span><br><span class="line">      }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>在<code>port_sensor_handle_upstream_module_event</code>函数上方加入<code>keda_reload_chromatix_ptr</code>的定义，在8056平台中要删除<code>CAMERA_CHROMATIX_MODULE_ALL</code>参数    </li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">keda_reload_chromatix_ptr</span><span class="params">(<span class="keyword">mct_module_t</span> *<span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">mct_event_t</span> *event, <span class="keyword">module_sensor_bundle_info_t</span>* s_bundle)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">      <span class="keyword">sensor_chromatix_params_t</span> chromatix_params;</span><br><span class="line">      <span class="keyword">int32_t</span>                   rc = SENSOR_FAILURE;</span><br><span class="line">      <span class="built_in">memset</span>(&chromatix_params, <span class="number">0</span>, <span class="keyword">sizeof</span>(chromatix_params));</span><br><span class="line">      RETURN_ON_NULL(s_bundle);</span><br><span class="line">      RETURN_ON_NULL(event);</span><br><span class="line">      RETURN_ON_NULL(<span class="keyword">module</span>);</span><br><span class="line"></span><br><span class="line">      SHIGH(<span class="string">"load chromatix for sensor %s"</span>,</span><br><span class="line">       s_bundle->sensor_lib_params->sensor_lib_ptr->sensor_slave_info.sensor_name);</span><br><span class="line"></span><br><span class="line">      SENSOR_SUB_MODULE_PROCESS_EVENT(s_bundle, SUB_MODULE_SENSOR,</span><br><span class="line">            SENSOR_GET_CUR_CHROMATIX_NAME, &chromatix_params, rc);</span><br><span class="line">      RETURN_FALSE_IF(rc < <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      SENSOR_SUB_MODULE_PROCESS_EVENT(s_bundle, SUB_MODULE_CHROMATIX,</span><br><span class="line">            CHROMATIX_KEDA_RELOAD, &chromatix_params, rc);</span><br><span class="line">      RETURN_FALSE_IF(rc < <span class="number">0</span>);</span><br><span class="line">      RETURN_ON_FALSE(sensor_util_validate_chromatix_params(&chromatix_params));</span><br><span class="line"></span><br><span class="line">      RETURN_ON_FALSE(sensor_util_post_chromatix_event_downstream(</span><br><span class="line">          <span class="keyword">module</span>, s_bundle, event->identity, &chromatix_params,</span><br><span class="line">          CAMERA_CHROMATIX_MODULE_ALL));</span><br><span class="line">      <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>在<code>sensor_common.h</code>中增加<code>CHROMATIX_KEDA_RELOAD</code>的枚举定义</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">CHROMATIX_ENUM_MIN, <span class="comment">/* start of chromatix enums */</span></span><br><span class="line"><span class="comment">/* Get enums */</span></span><br><span class="line">CHROMATIX_GET_PTR, <span class="comment">/* sensor_chromatix_params_t * */</span></span><br><span class="line">CHROMATIX_GET_CACHED_PTR,</span><br><span class="line"><span class="comment">/* Set enums */</span></span><br><span class="line">CHROMATIX_SET_CM,</span><br><span class="line">CHROMATIX_RESET_NAME,</span><br><span class="line">CHROMATIX_KEDA_RELOAD,</span><br><span class="line">CHROMATIX_ENUM_MAX, <span class="comment">/* End of Chromatix enums*/</span></span><br><span class="line"><span class="comment">/* End of Actuator enums*/</span></span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li>在<code>chromatix_sub_module.c</code>中的<code>chromatix_process</code>函数添加对<code>CHROMATIX_KEDA_RELOAD</code>的处理</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (event) {</span><br><span class="line"><span class="keyword">case</span> CHROMATIX_SET_CM:</span><br><span class="line">  ctrl->cm = (chromatix_manager_type *)data;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CHROMATIX_GET_PTR:</span><br><span class="line">  chromatix_get_ptr(ctrl, data);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CHROMATIX_GET_CACHED_PTR:</span><br><span class="line">  chromatix_get_cached_ptr(ctrl, data);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CHROMATIX_RESET_NAME:</span><br><span class="line">  chromatix_reset_name(ctrl);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CHROMATIX_KEDA_RELOAD:</span><br><span class="line">  chromatix_reload_get_ptr(ctrl, data);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  SERR(<span class="string">"invalid event %d"</span>, event);</span><br><span class="line">  rc = SENSOR_FAILURE;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="5">
<li>模仿<code>chromatix_get_ptr</code>函数，在<code>chromatix_process</code>函数上方加入<code>chromatix_reload_get_ptr</code>的定义</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int32_t</span> <span class="title">chromatix_reload_get_ptr</span><span class="params">(<span class="keyword">chromatix_data_t</span> *ctrl, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">int32_t</span> i;</span><br><span class="line">    <span class="keyword">sensor_chromatix_params_t</span> *params;</span><br><span class="line">    SLOW(<span class="string">"Enter"</span>);</span><br><span class="line"></span><br><span class="line">    RETURN_ERROR_ON_NULL(ctrl);</span><br><span class="line">    RETURN_ERROR_ON_NULL(data);</span><br><span class="line"></span><br><span class="line">    params = (<span class="keyword">sensor_chromatix_params_t</span> *)data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i < SENSOR_CHROMATIX_MAX; i++) {</span><br><span class="line">      SLOW(<span class="string">"type[%d]:[%s]"</span>, i, params->chromatix_lib_name[i]);</span><br><span class="line">      <span class="keyword">if</span> (params->chromatix_lib_name[i] == ctrl->chromatix_name[i])</span><br><span class="line">        params->chromatix_reloaded[i] = FALSE;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        params->chromatix_reloaded[i] = TRUE;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (i == SENSOR_CHROMATIX_EXTERNAL) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!params->chromatix_lib_name[i]) {</span><br><span class="line">        params->chromatix_ptr[i] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      ctrl->chromatix_ptr[i] =</span><br><span class="line">        reload_getChromatix(ctrl->cm, params->chromatix_lib_name[i],</span><br><span class="line">        pick_calibration_type[i]);</span><br><span class="line">      <span class="keyword">if</span> (!ctrl->chromatix_ptr[i]) {</span><br><span class="line">        SERR(<span class="string">"Can't get chromatix pointer : %s"</span>, </span><br><span class="line">        params->chromatix_lib_name[i]);</span><br><span class="line">        <span class="keyword">return</span> SENSOR_FAILURE;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      params->chromatix_ptr[i] = ctrl->chromatix_ptr[i];</span><br><span class="line"></span><br><span class="line">      SLOW(<span class="string">"chromatix version: 0x%x"</span>,</span><br><span class="line">        ((chromatix_parms_type*)ctrl->chromatix_ptr[i])</span><br><span class="line">        ->chromatix_version_info.chromatix_version);</span><br><span class="line">      ctrl->chromatix_name[i] = params->chromatix_lib_name[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    SLOW(<span class="string">"Exit"</span>);</span><br><span class="line">    <span class="keyword">return</span> SENSOR_SUCCESS;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<ol start="6">
<li>在<code>chromatix_manager.c</code>中模仿<code>cm_getChromatix</code>函数重新定义一个<code>reload_getChromatix</code>,并进行修改，删除对哈希值和页面置换算法时间的判断</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//660平台</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">reload_getChromatix</span><span class="params">(chromatix_manager_type* cm, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">uint32_t</span> calibration_type)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">void</span>    *data_sym = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">void</span>    *data_hdl = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">char</span>    *key      = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> cIndex;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!cm || !name) {</span><br><span class="line">    SERR(<span class="string">"NULL pointer detected"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  SLOW(<span class="string">"%s"</span>, name);</span><br><span class="line">  PTHREAD_MUTEX_LOCK(&cm->mutex);</span><br><span class="line">  SERR(<span class="string">"delete least used file from cache, and add"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* get the least used chromatix file info */</span></span><br><span class="line">  lru_getLeastRecent(&cm->lru, &key, &cIndex);</span><br><span class="line">  <span class="comment">/* delete has node and unload the library */</span></span><br><span class="line">  hash_delete(&cm->hash, key, &data_hdl, &data_sym);</span><br><span class="line">  unload_chromatix(data_hdl, data_sym);</span><br><span class="line"></span><br><span class="line">  data_sym = addLib_getSymbol(cm, name, calibration_type);</span><br><span class="line">  <span class="keyword">if</span> (data_sym == <span class="literal">NULL</span>)</span><br><span class="line">    SERR(<span class="string">"failed : addLib2"</span>);</span><br><span class="line"></span><br><span class="line">  lru_traverse(&cm->lru);</span><br><span class="line">  PTHREAD_MUTEX_UNLOCK(&cm->mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> data_sym;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//8056平台</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">reload_getChromatix</span><span class="params">(chromatix_manager_type* cm, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">uint32_t</span> calibration_type)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> <span class="keyword">void</span> *data_sym = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">void</span> *data_hdl = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">char</span> *key = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">uint32_t</span> cIndex;</span><br><span class="line"> <span class="keyword">if</span> (!cm || !name) {</span><br><span class="line"> SERR(<span class="string">"NULL pointer detected"</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"> }</span><br><span class="line"> SLOW(<span class="string">"%s"</span>, name);</span><br><span class="line"> PTHREAD_MUTEX_LOCK(&cm->mutex);</span><br><span class="line"> SERR(<span class="string">"delete least used file from cache, and add"</span>);</span><br><span class="line"> <span class="comment">/* get the least used chromatix file info */</span></span><br><span class="line"></span><br><span class="line"> lru_getLeastRecent(&cm->lru, &key, &cIndex);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* delete has node and unload the library */</span></span><br><span class="line"></span><br><span class="line"> hash_delete(&cm->hash, key, &data_hdl);</span><br><span class="line"></span><br><span class="line"> chromatix_unload_library(data_hdl);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> data_sym = addLib_getSymbol(cm, name, calibration_type);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (data_sym == <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">     SERR(<span class="string">"failed : addLib2"</span>);</span><br><span class="line"> lru_traverse(&cm->lru);</span><br><span class="line"> PTHREAD_MUTEX_UNLOCK(&cm->mutex);</span><br><span class="line"> <span class="keyword">return</span> data_sym;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//在chromatix_manager.h中添加reload_getChromatix的定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">reload_getChromatix</span><span class="params">(chromatix_manager_type* cm, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> calibration_type)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<h1 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h1><ol>
<li><p>在线或者本地编译好chromatix头文件后，将编译生成的动态库push进设备相应的地址</p>
</li>
<li><p>手动输入或者运行脚本</p>
</li>
</ol>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">adb shell setprop persist.chromatix.reload 0</span><br><span class="line">adb shell setprop persist.chromatix.reload 1</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>可以查看关键词<code>chromatix reload</code>，如果显示成功，则重载成功</li>
</ol>
<p>BUG：</p>
<ol>
<li>发现部分动态库加载不正确</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>功能实现</tag>
      </tags>
  </entry>
  <entry>
    <title>君在否</title>
    <url>/2019/01/24/%E7%94%9F%E6%B4%BB-%E5%9B%B4-2019-01-24-weiyi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>寅时五更天<br>梦初醒<br>听闻声声鸡鸣<br>枕间还萦绕着梦里的场景  </p>
<a id="more"></a>

<p>再入睡<br>醒来城市的喧嚣已被唤醒<br>围坐炉前<br>遥望窗外浓雾中的叠山<br>依依情丝浮现<br>那悠悠的相思愁啊<br>不胜那奔涌的海浪波涛<br>更不比那万马奔腾踏过千山<br>仅轻柔的清风<br>扶着窗前帘<br>拂着碧水面<br>飞跃蜜甜的白云<br>飘摇在广阔的天边<br>拨动着那琴弦在心间<br>君在否?<br>只闻那鸟雀几句啼鸣<br>君在否?<br>只见那山间朦雾皱眉愁<br>你听<br>耳边的风儿是我的呢喃<br>你瞧<br>夜空的星儿是你的眉眼<br>千山万水归期遥<br>红笺小字<br>诉不尽的离别绪<br>道不完的苦思忧<br>待到相见时<br>方消万缕愁  </p>
<div align="right">
——冯围  
 二零一九年一月二十四日晨于家中
 农历贰零壹捌年腊月十九
</div>

<p><img src="/" class="lazyload" data-src="https://i.loli.net/2019/01/24/5c495b81aa35d.jpg"  alt></p>
</body></html>]]></content>
      <categories>
        <category>生活</category>
        <category>围围</category>
        <category>围的礼物</category>
      </categories>
      <tags>
        <tag>围围</tag>
        <tag>宝藏</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：室内灯光闪烁</title>
    <url>/2019/01/22/%E5%B7%A5%E4%BD%9C-BUG-BUG-%E5%AE%A4%E5%86%85%E7%81%AF%E5%85%89%E9%97%AA%E7%83%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>较亮的室内灯光会闪烁</p>
<a id="more"></a>
<p><strong>问题描述</strong>：在较亮的室内，对着灯会闪烁，查看曝光时间会小于10ms</p>
<p><strong>原因</strong>：抗闪烁会让曝光时间锁定在10ms整数倍，但是如果增益为1，曝光时间是10ms的时候依旧大于目标亮度，会当做室外场景，继续降低曝光时间。</p>
<p><strong>解决方法</strong>：  </p>
<ol>
<li>增加目标亮度，就可以增大曝光行。直接调节亮度，可以增大所有的目标亮度，但是会影响夜晚时候的效果。因此在头文件中增加亮区的目标亮度，使其他场景下影响最小。  </li>
<li>减小光圈，可以增大曝光行，使之大于10ms。</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>BUG</tag>
        <tag>高通camera</tag>
        <tag>闪烁</tag>
      </tags>
  </entry>
  <entry>
    <title>原有背光补偿算法实现</title>
    <url>/2019/01/21/%E5%B7%A5%E4%BD%9C-%E7%BC%96%E7%A8%8B-%E5%8E%9F%E6%9C%89%E8%83%8C%E5%85%89%E8%A1%A5%E5%81%BF%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><ol>
<li><p>获取分块亮度统计数据  </p>
<p>– 用的memcp，是否可以直接用指针获取，用const保护；</p>
</li>
<li><p>计算分块亮度  </p>
<p>–用RGGB的平均亮度代替一个块的亮度</p>
</li>
<li><p>进行排序  </p>
<p>–是否会出现totalblockNum比总数大的问题</p>
</li>
<li><p>求平均亮度</p>
</li>
<li><p>设置亮度阈值  </p>
<p>–根据level获取相应百分比的块的亮度和序号</p>
</li>
<li><p>如果检测到当前亮度大于亮度阈值，CurFrameAvgLuma加上该分块的亮度</p>
</li>
<li><p>求亮区的平均亮度</p>
</li>
<li><p>将分块亮度统计数据乘以（亮区亮度和平均亮度的比值）</p>
</li>
</ol>
<h1 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h1><p>原有的背光补偿等级仅仅调节的是亮区的范围，而亮区的程度并不能调节。<br>而且如果没有强光，也会对普通场景的亮度降低。为了不影响普通场景的亮度，可以采用对强光进行识别的算法。</p>
<p>首先用执法仪对强光和普通场景的直方图进行分析，场景1-3是普通场景，场景4-6是强光场景。发现强光场景的共同点是256的值很大，而255或者254却很小。同时要对RGB都进行分析，有的时候可能有一种光很亮，会误判成强光场景。<br><strong>注意</strong>：可能不能直接用比例的方式去减小曝光时间，可能会出现不收敛的情况，导致上下波动。<br><img src="/" class="lazyload" data-src="/2019/01/21/%E5%B7%A5%E4%BD%9C-%E7%BC%96%E7%A8%8B-%E5%8E%9F%E6%9C%89%E8%83%8C%E5%85%89%E8%A1%A5%E5%81%BF%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/1.jpg"  alt="强光和普通场景直方图"></p>
<p>由于AE统计信息是将图像分块统计，也相当于一个缩小的直方图数据。<br>如果分块数据的话，强光场景下应该是强光区域有不少，同时暗光很多，由于成对数关系，因此区分应该很明显。<br>亮度在最大值亮度的50%-90%区间内，比例很少。<br>同时可以判断亮区的边界，如果边界大于一定的范围，则进行调整。</p>
<p>获取分块数据</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> aec_get_status = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> histo_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (property_get(<span class="string">"persist.liqinxing.aec_stats.get"</span>, value, <span class="string">""</span>) > <span class="number">0</span>){</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"0"</span>, value) == <span class="number">0</span>){</span><br><span class="line">        aec_get_status = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">if</span>(aec_get_status){</span><br><span class="line">            aec_get_status = <span class="number">0</span>;</span><br><span class="line">        FILE *fp;</span><br><span class="line">        fp = fopen(<span class="string">"/data/aec_stats.txt"</span>,<span class="string">"a"</span>);</span><br><span class="line">        <span class="keyword">if</span>(fp == <span class="literal">NULL</span>){</span><br><span class="line">            LOGE(<span class="string">"cannot open file aec_stats.txt,please create it"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"No.%d sence h_num:%d v_num:%d"</span>,</span><br><span class="line">        histo_count++, aec_stats->bayer_stats.p_q3a_bg_stats->bg_region_h_num,</span><br><span class="line">        aec_stats->bayer_stats.p_q3a_bg_stats->bg_region_v_num);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp,<span class="string">"channel-r:\n"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">3888</span>; i++)</span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">"%d  "</span>, aec_stats->bayer_stats.p_q3a_bg_stats->bg_r_sum[i]);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp,<span class="string">"\n"</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp,<span class="string">"channel-gr:\n"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">3888</span>; i++)</span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">"%d  "</span>, aec_stats->bayer_stats.p_q3a_bg_stats->bg_gr_sum[i]);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp,<span class="string">"\n"</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp,<span class="string">"channel-gb:\n"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">3888</span>; i++)</span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">"%d  "</span>, aec_stats->bayer_stats.p_q3a_bg_stats->bg_gb_sum[i]);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp,<span class="string">"\n"</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp,<span class="string">"channel-b:\n"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">3888</span>; i++)</span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">"%d  "</span>, aec_stats->bayer_stats.p_q3a_bg_stats->bg_b_sum[i]);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp,<span class="string">"\n"</span>);</span><br><span class="line">        <span class="comment">//free point p</span></span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">if</span>(fp!=<span class="literal">NULL</span>)</span><br><span class="line">            fp=<span class="literal">NULL</span>;</span><br><span class="line">       }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是出现问题，没有将数据打印出来<br>发现没有进入这个mask中，函数没有执行<br>因此放在aec_biz_stats_map中，这里是将stats数据map进aec算法模块的地方。<br>先用matlab进行处理；本文用的python处理<br><img src="/" class="lazyload" data-src="/2019/01/21/%E5%B7%A5%E4%BD%9C-%E7%BC%96%E7%A8%8B-%E5%8E%9F%E6%9C%89%E8%83%8C%E5%85%89%E8%A1%A5%E5%81%BF%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/2.jpg"  alt></p>
<h2 id="强光场景识别"><a href="#强光场景识别" class="headerlink" title="强光场景识别"></a>强光场景识别</h2><ol>
<li>计算相比于最强光强的比例  </li>
</ol>
<p>分为三个区间，暗区，中间区间，亮区，阈值为30%和80%</p>
<p><img src="/" class="lazyload" data-src="/2019/01/21/%E5%B7%A5%E4%BD%9C-%E7%BC%96%E7%A8%8B-%E5%8E%9F%E6%9C%89%E8%83%8C%E5%85%89%E8%A1%A5%E5%81%BF%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/3.jpg"  alt></p>
<p>可以看到强光场景下暗区比例很大，中间区间较小，亮区类似</p>
<p>中位数</p>
<ol start="2">
<li><p>打印stats其他参数，了解参数的意义</p>
<ol>
<li><p>rmax,grmax,gbmax,bmax是一样的16383，是一个像素上最大亮度（14位）</p>
</li>
<li><p>region_pixel_cnt=bg_region_height*bg_region_width 660=22*30 </p>
<p>1920/64=30 1080/48=22 因此总共的最大亮度为1e7 单体最大亮度为2703195，这符合实验得出的结论</p>
</li>
<li><p><img src="/" class="lazyload" data-src="https://i.loli.net/2019/01/24/5c493fc5e0c0b.jpg"  alt></p>
</li>
<li><p>直方图数据长度不一致，原来是4096，后来变成了256</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (CAM_HISTOGRAM_STATS_SIZE == bhist_stats->num_bins) {</span><br><span class="line">  <span class="built_in">memcpy</span>(hist_data->hist_buf, stats_ptr,</span><br><span class="line">  <span class="keyword">sizeof</span>(hist->bayer_stats.r_stats.hist_buf));</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (bhist_stats->num_bins > CAM_HISTOGRAM_STATS_SIZE &&</span><br><span class="line">          bhist_stats->num_bins % CAM_HISTOGRAM_STATS_SIZE == <span class="number">0</span>) {</span><br><span class="line">  <span class="comment">/* Stats from HW have more bins and is a multiple of output bin size */</span></span><br><span class="line">  <span class="comment">/* scale bins by collapsing */</span></span><br><span class="line">  <span class="keyword">uint32_t</span> factor = bhist_stats->num_bins / CAM_HISTOGRAM_STATS_SIZE;</span><br><span class="line">  <span class="keyword">uint32_t</span> i, j;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < CAM_HISTOGRAM_STATS_SIZE; i++) {</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j < factor; j++) {</span><br><span class="line">     hist_data->hist_buf[i] +=</span><br><span class="line">       stats_ptr[i * factor + j];</span><br><span class="line">     }</span><br><span class="line">  }</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  ISP_ERR(<span class="string">"CHANNEL_Y Size mismatch error bhist_stats->num_bins %d"</span>,</span><br><span class="line">  bhist_stats->num_bins);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
</li>
</ol>
<p>num_bins是实际直方图数据的长度，由于这个长度是256的倍数，aec模块中的统计数据其实是将num_bins的直方图数据进行了压缩</p>
<p>这里用goto语句防止打开文件错误，没有执行下面原有的程序</p>
<p>通过控制增益的方式来控制图像的过曝和正常情况，对两种情况进行对比。</p>
<p>从过曝到正常，中位数降低很明显</p>
<p>可以看梯度–直方图或者分块亮度数据的梯度</p>
<p><strong>注意</strong>：写入txt数据的时候不要连续写入两个<code>\n</code>，如果这样readlines的时候第一个字符会为空</p>
<p>可以以梯度来衡量</p>
<p>我只要找到强光的特点就行了，  </p>
<p>首先有值很大的，直方图中255的值很大，而254的值很小  </p>
<p>直方图后面160-254之间几乎是平的  </p>
<p>检测到如果大于一定的值如80%的最大值，则进行权重的增大或者，或者直接对AE进行调整  </p>
<p>原来的方法不行，因为亮的区域亮度已经满了，再增大也改变不了多少AE的效果，可以修改测光表的权重  </p>
<p>框架式构图 –人手搭框架、框架拍景物</p>
<p>搜查AEC chromatix数据的调用位置</p>
<p>prase</p>
<p>自动调节可以算最高点80%和40%面积的比值作为他们的梯度</p>
<p>如果是sink端口，则不需要查看事件，取而代之的，只需转发事件并让下游模块处理它们并采取相应的行动</p>
<p>MCT_EVENT_DOWNSTREAM是接受上游的数据，向下游传递</p>
<p>chromatix数据是在stats模块进行最先一步的加载，分发给下游进行处理</p>
<p><strong>PROBLEM</strong>：究竟什么算是下游模块？</p>
<p>动态修改权重：两种方案，去修改chromatix文件，让它重新加载一次；在chromatix数据向下发的时候修改它的值；由于第一种方法存在一个数据大量赋值的过程，可能会降低速度，甚至导致一大堆赋值问题，因此采用第二种方案。</p>
<p><strong>想法</strong>：修改reload应该就可以让chromatix文件重载，这样不就不需要重启设备调参数了么</p>
<p><code>sensor_util_post_chromatix_event_downstream</code></p>
<p>cached</p>
<p><code>macro</code>:宏指令</p>
<p><strong>PROBLEM</strong>：只搜索到了<code>event_module->module_event_data</code>给其他模块赋值，没有搜索到谁赋值给它的？void*难道就是这么神奇？难道是在framework层进行赋值的？</p>
<p>func_tbl有三个方法：open/process/close 可以对chromatix进行操作</p>
<p>process中可以选择</p>
<p><code>SENSOR_SUB_MODULE_PROCESS_EVENT</code>对sensor的每个子模块进行处理，chromatix也是在其中 如果要搜索子模块的处理函数可以搜索process的类型，如<code>CHROMATIX_GET_PTR</code></p>
<p>第二个参数是对那个模块生效</p>
<p><strong>PROBLEM</strong>：为什么加载chromatix的时候还要加载一堆模块</p>
<p>lru页面置换算法（Least Recently Used）</p>
<p>关于操作系统的内存管理，如何节省利用容量不大的内存为最多的进程提供资源，一直是研究的重要方向。而内存的虚拟存储管理，是现在最通用，最成功的方式—— 在内存有限的情况下，扩展一部分外存作为<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/101812" target="_blank" rel="noopener">虚拟内存</a>，真正的内存只存储当前运行时所用得到信息。这无疑极大地扩充了内存的功能，极大地提高了计算机的并发度。虚拟页式存储管理，则是将进程所需空间划分为多个页面，内存中只存放当前所需页面，其余页面放入外存的管理方式。  </p>
<p>然而，有利就有弊，虚拟页式存储管理增加了进程所需的内存空间，却也带来了运行时间变长这一缺点：进程运行过程中，不可避免地要把在外存中存放的一些信息和内存中已有的进行交换，由于外存的低速，这一步骤所花费的时间不可忽略。因而，采取尽量好的算法以减少读取外存的次数，也是相当有意义的事情。</p>
<p><strong>我的理解</strong>：这个算法就是去决定哪些数据该放在内存里，哪些数据该放在外存里。</p>
<p><strong>PROBLEM</strong>：为什么替换了动态库文件，chromatix数据依旧没有生效</p>
<p><strong>ANSWER</strong>:  so文件是位于外存之中，而程序运行会先检测所需的数据内存中是否存在，如果存在就加载内存中的数据，如果不存在再去加载位于外存的数据。虚拟内存可以虚拟的扩大程序的内存空间，但是会出现一个问题，</p>
<p><strong>BIZ</strong>:business model ，实际上就是控制层（业务逻辑层）。<br><strong>解释</strong>：控制层的主要作用就是协调model层和view层直接的调用和转换。能够有效的避免请求直接进行数据库内容调用，而忽略了逻辑处理的部分。<br>实际上biz就起到了一个server服务的角色，很好的沟通了上层和下层直接的转换，避免在model层进行业务处理（代码太混乱，不利于维护）</p>
<p>由于每次reload的时候都要先查找hash值以及lru，不会重新重新读取动态库数据，因此在读取hash值的位置加一个函数，不进行hash值的读取</p>
<p><strong>PROBLEM</strong>：为何直接用eztune中的代码可以生效</p>
<p>方法一：由于在reload chromatix文件的时候，会首先查找是否存在hash值以及lru；当程序运行时会将so文件中的数据加载到内存中，因此我们要删去原来的hash值和lru，重新load chromatix。</p>
<p>方法二：移植extune的代码</p>
<p><strong>PROBLEM</strong>：没有对指针进行malloc，可以进行赋值么</p>
<p>由于测光权重表和bg_stats(grid)不是一一对应的关系，</p>
<p>还可以判断是否是运动光源</p>
<p>如果想要降低AE，有下面几种方法：</p>
<ol>
<li>提升cur_luma：</li>
</ol>
<ul>
<li><p>增加测光权重：但是不知道在哪一帧生效</p>
</li>
<li><p>增大输入的stats   —— aec使用bg_stats和直方图数据进行统计</p>
</li>
</ul>
<ol start="2">
<li><p>减少target_luma</p>
</li>
<li><p>直接对写入寄存器的值进行操作</p>
</li>
</ol>
<ul>
<li>对index进行操作</li>
</ul>
<p>对光晕的检测；如果正常曝光，应该不会存在过大的光晕</p>
<p>设置两个阈值，饱和亮度和较亮的亮度。用饱和亮度的块数除较亮的亮度的块数得到ratio，可以得出光晕的比例。ratio越大，光晕越小。</p>
<p>但是实际上发现，普通场景较亮亮度色块很多，而很亮的很少；强光场景中，ratio反而大——解释：由于强光场景亮度区分的很大，较亮的色块就比较少，因此ratio值就比较大</p>
<p>难道说ratio值越小越正常？理论上如果光晕少的话，应该是较亮的区域很少，饱和的区域很多，理论上数字很大呀</p>
<p>直方图更加精确一点，为何不用直方图呢 –转用直方图</p>
<p>发现直方图更逼近想象中的曲线，光晕越小，ratio越大，但是不太好判断</p>
<p>整理照片</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>算法实现</tag>
      </tags>
  </entry>
  <entry>
    <title>送行</title>
    <url>/2019/01/21/%E7%94%9F%E6%B4%BB-love-2019-01-21-love/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>又是一个明媚的清晨<br>天气真好<br>你就是我的太阳<br>在我的身边<br>总让我抑制不住<br>内心的燥热</p>
<a id="more"></a>

<p>你的笑容<br>我想用亲吻去守护<br>你的娇躯<br>我想用拥抱去挽留<br>多么不想你走呀  </p>
<p>想狠狠的吻下去<br>吮吸每一处<br>属于你的芳香<br>品尝每一处<br>属于你的香甜<br>摩挲每一处<br>属于你的细腻  </p>
<p>运气很好<br>路过的每一地方都是那么顺利<br>刚到站台就来公交<br>刚到地铁就来列车<br>刚出电梯就是出口<br>好像一切都是安排好的<br>这么凑巧<br>运气爆棚<br>却又好像是老天<br>让我快快度过这个<br>离别的时刻  </p>
<p>高铁上<br>让你坐在我的腿上<br>俏皮可爱的脸上<br>泛起了娇羞的红晕<br>我轻轻一个拥抱<br>一个娇小的身体<br>贴在我的腿上<br>身心好像找到了依偎<br>不是你坐在我身上<br>而是我<br>坐在你的身边<br>看着窗外的风景<br>还有你温柔的脸庞<br>真的好美</p>
<p>美好的时光<br>总是如此短暂<br>这趟列车<br>自顾自的的走着<br>丝毫不顾及<br>我的不舍<br>不顾及我的腿<br>还留有你的体温</p>
<p>你<br>一个人走了<br>去见你的弟妹<br>而我<br>只能像捉迷藏一样<br>躲着你们<br>紧张刺激地<br>玩一局<br>跟踪游戏<br>内心有一丝的落寞<br>却在你回头的一瞬<br>又露出激动的笑容<br>这就是矛盾的我呀</p>
<p>车站里<br>依依不舍<br>想躲掉你的眼神<br>怕一不留心<br>掉下一颗眼泪<br>因为<br>现在的我<br>异常脆弱  </p>
<p>小憩一会儿<br>眼角居然湿润<br>刚刚一定是做了一个<br>思念的梦吧<br>睁眼醒来<br>すきだよ<br>映入眼帘<br>竟在我内心没有掀起<br>滔天巨浪<br>千万句表白<br>换来你的一句表白<br>我却只是微笑着回答<br>我也喜欢你，围围  </p>
<p>傻瓜<br>那是因为<br>在你的眉宇间<br>在你的言语中<br>在你的轻抚下<br>我早已找到了自己想要的<br>表白<br>这可能就是心照不宣吧  </p>
<p>悲伤是今天的旋律<br>一不留神<br>便沉浸其中<br>却时不时蹦出欢快的笑声<br>暂时的打断<br>我沉闷的演奏<br>让我呼吸急促<br>忘却一切的烦恼</p>
<p>想打电话<br>听你的呢喃细语<br>听你的开怀大笑<br>想你的莞尔一笑<br>想你的痴情相望<br>我是傻瓜么<br>这才多久呀<br>接下来的一个月<br>怕是该以泪洗面了<br>两情若是长久时<br>又岂在朝朝暮暮<br>这何尝不是<br>安慰自己呢  </p>
<p>站起身<br>伸伸懒腰<br>深呼一口气<br>迷上了你<br>那是我的荣幸<br>我可不能迷失自我<br>我还要记录下<br>这爱的点点滴滴呢</p>
<div class="justified-gallery"><p><img src="/" class="lazyload" data-src="/2019/01/21/%E7%94%9F%E6%B4%BB-love-2019-01-21-love/5.jpg"  alt></p><p><img src="/" class="lazyload" data-src="/2019/01/21/%E7%94%9F%E6%B4%BB-love-2019-01-21-love/1.jpg"  alt></p><p><img src="/" class="lazyload" data-src="/2019/01/21/%E7%94%9F%E6%B4%BB-love-2019-01-21-love/2.jpg"  alt></p><p><img src="/" class="lazyload" data-src="/2019/01/21/%E7%94%9F%E6%B4%BB-love-2019-01-21-love/3.jpg"  alt></p><p><img src="/" class="lazyload" data-src="/2019/01/21/%E7%94%9F%E6%B4%BB-love-2019-01-21-love/4.jpg"  alt></p>
          </div>

</body></html>]]></content>
      <categories>
        <category>生活</category>
        <category>围围</category>
        <category>诗歌</category>
      </categories>
      <tags>
        <tag>围围</tag>
        <tag>情书</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2019/01/21/%E5%AD%A6%E4%B9%A0-%E5%B7%A5%E5%85%B7-git-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="远程仓库相关命令"><a href="#远程仓库相关命令" class="headerlink" title="远程仓库相关命令"></a>远程仓库相关命令</h1><ul>
<li>检出仓库：$ git clone git://github.com/jquery/jquery.git  </li>
<li>查看远程仓库：$ git remote -v  </li>
<li>添加远程仓库：$ git remote add [name] [url]  </li>
<li>删除远程仓库：$ git remote rm [name]  </li>
<li>修改远程仓库：$ git remote set-url –push[name][newUrl]  </li>
<li>拉取远程仓库：$ git pull [remoteName] [localBranchName]  </li>
<li>推送远程仓库：$ git push [remoteName] [localBranchName]  </li>
</ul>
<h1 id="分支操作相关命令"><a href="#分支操作相关命令" class="headerlink" title="分支操作相关命令"></a>分支操作相关命令</h1><ul>
<li>查看本地分支：$ git branch  </li>
<li>查看远程分支：$ git branch -r  </li>
<li>创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支  </li>
<li>切换分支：$ git checkout [name]  </li>
<li>创建新分支并立即切换到新分支：$ git checkout -b [name]  </li>
<li>删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项  </li>
<li>合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并  </li>
<li>创建远程分支(本地分支push到远程)：$ git push origin [name]  </li>
<li>删除远程分支：$ git push origin :heads/[name]  </li>
</ul>
<p>我从master分支创建了一个issue5560分支，做了一些修改后，使用git push origin master提交，但是显示的结果却是’Everything up-to-date’，发生问题的原因是git push origin master 在没有track远程分支的本地分支中默认提交的master分支，因为master分支默认指向了origin master 分支，这里要使用git push origin issue5560：master 就可以把issue5560推送到远程的master分支了。</p>
<ul>
<li><p>如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，那么可以这么做。<br>$ git push origin test:master         // 提交本地test分支作为远程的master分支 //好像只写这一句，远程的github就会自动创建一个test分支<br>$ git push origin test:test              // 提交本地test分支作为远程的test分支</p>
</li>
<li><p>如果想删除远程的分支呢？类似于上面，如果:左边的分支为空，那么将删除:右边的远程的分支。<br>$ git push origin :test              // 刚提交到远程的test将被删除，但是本地还会保存的，不用担心</p>
</li>
</ul>
<h1 id="版本-tag-操作相关命令"><a href="#版本-tag-操作相关命令" class="headerlink" title="版本(tag)操作相关命令"></a>版本(tag)操作相关命令</h1><ul>
<li>查看版本：$ git tag</li>
<li>创建版本：$ git tag [name]</li>
<li>删除版本：$ git tag -d [name]</li>
<li>查看远程版本：$ git tag -r</li>
<li>创建远程版本(本地版本push到远程)：$ git push origin [name]</li>
<li>删除远程版本：$ git push origin :refs/tags/[name]</li>
</ul>
<h1 id="子模块-submodule-相关操作命令"><a href="#子模块-submodule-相关操作命令" class="headerlink" title="子模块(submodule)相关操作命令"></a>子模块(submodule)相关操作命令</h1><ul>
<li>添加子模块：$ git submodule add [url] [path]  </li>
</ul>
<p>如：$ git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs  </p>
<ul>
<li>初始化子模块：$ git submodule init —-只在首次检出仓库时运行一次就行</li>
<li>更新子模块：$ git submodule update —-每次更新或切换分支后都需要运行一下</li>
<li>删除子模块：<ul>
<li>$ git rm –cached [path]</li>
<li>编辑“.gitmodules”文件，将子模块的相关配置节点删除掉</li>
<li>编辑“.git/config”文件，将子模块的相关配置节点删除掉</li>
<li>手动删除子模块残留的目录</li>
</ul>
</li>
</ul>
<h1 id="忽略一些文件、文件夹不提交"><a href="#忽略一些文件、文件夹不提交" class="headerlink" title="忽略一些文件、文件夹不提交"></a>忽略一些文件、文件夹不提交</h1><p>在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如<br>target<br>bin<br>*.db  </p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>工具</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 多终端同步</title>
    <url>/2019/01/21/%E5%AD%A6%E4%B9%A0-%E5%B7%A5%E5%85%B7-hexo-hexo-%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>#准备条件#<br>安装了Node.js,Git,Hexo环境<br>完成Github与本地Hexo的对接<br>这部分可以参考<a href="https://xuanwo.org/2015/03/26/hexo-intor/" target="_blank" rel="noopener">最详细的Hexo博客搭建图文教程</a></p>
<h1 id="push本地文件"><a href="#push本地文件" class="headerlink" title="push本地文件"></a>push本地文件</h1><p>在其中一个终端操作，push本地文件夹Hexo中的必要文件到yourname.github.io的hexo分支上（这里分支名称我使用的develop）</p>
<p>在利用Github+Hexo搭建自己的博客时，新建了一个Hexo的文件夹，并进行相关的配置，这部分主要是将这些配置的文件托管到Github项目的分支上，其中只托管部分用于多终端的同步的文件，如完成的效果图所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git init  //初始化本地仓库</span><br><span class="line">git add source //将必要的文件依次添加，有些文件夹如npm install产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件，如下图所示</span><br><span class="line">git commit -m "Blog Source Hexo"</span><br><span class="line">git branch hexo  //新建hexo分支</span><br><span class="line">git checkout hexo  //切换到hexo分支上</span><br><span class="line">git remote add origin git@github.com:yourname/yourname.github.io.git  //将本地与Github项目对接</span><br><span class="line">git push origin hexo  //push到Github项目的hexo分支上</span><br></pre></td></tr></tbody></table></figure>

<p>这样你的github项目中就会多出一个Hexo分支，这个就是用于多终端同步关键的部分。</p>
<h1 id="clone和push更新文件"><a href="#clone和push更新文件" class="headerlink" title="clone和push更新文件"></a>clone和push更新文件</h1><p>此时在另一终端更新博客，只需要将Github的hexo分支clone下来，进行初次的相关配置</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git clone -b hexo git@github.com:yourname/yourname.github.io.git  //将Github中hexo分支clone到本地</span><br><span class="line">cd  yourname.github.io  //切换到刚刚clone的文件夹内</span><br><span class="line">npm install    //注意，这里一定要切换到刚刚clone的文件夹内执行，安装必要的所需组件，不用再init</span><br><span class="line">hexo new post "new blog name"   //新建一个.md文件，并编辑完成自己的博客内容</span><br><span class="line">git add source  //经测试每次只要更新sorcerer中的文件到Github中即可，因为只是新建了一篇新博客</span><br><span class="line">git commit -m "XX"</span><br><span class="line">git push origin hexo  //更新分支</span><br><span class="line">hexo d -g   //push更新完分支之后将自己写的博客对接到自己搭的博客网站上，同时同步了Github中的master</span><br></pre></td></tr></tbody></table></figure>
<h1 id="不同终端间配置"><a href="#不同终端间配置" class="headerlink" title="不同终端间配置"></a>不同终端间配置</h1><p>在不同的终端已经做完配置，就可以分享自己更新的博客<br>进入自己相应的文件夹</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git pull origin hexo  //先pull完成本地与远端的融合</span><br><span class="line">hexo new post " new blog name"</span><br><span class="line">git add source</span><br><span class="line">git commit -m "XX"</span><br><span class="line">git push origin hexo</span><br><span class="line">hexo d -g</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>工具</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>python stats数据绘图</title>
    <url>/2019/01/21/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-python-python-stats%E6%95%B0%E6%8D%AE%E7%BB%98%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="（一）绘图"><a href="#（一）绘图" class="headerlink" title="（一）绘图"></a>（一）绘图</h2><h3 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#导入模块  </span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="comment">#创建新图</span></span><br><span class="line">fig = plt.figure()  <span class="comment"># an empty figure with no axes</span></span><br><span class="line">fig.suptitle(<span class="string">'No axes on this figure'</span>)  <span class="comment"># Add a title so we know which it is</span></span><br><span class="line"></span><br><span class="line">fig, ax_lst = plt.subplots(<span class="number">2</span>, <span class="number">2</span>)  <span class="comment"># a figure with a 2x2 grid of Axes</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="输入及图表属性"><a href="#输入及图表属性" class="headerlink" title="输入及图表属性"></a>输入及图表属性</h3><p><img src="/" class="lazyload" data-src="/2019/01/21/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-python-python-stats%E6%95%B0%E6%8D%AE%E7%BB%98%E5%9B%BE/1.jpg"  alt><br>所有绘图功能都期望np.array或np.ma.masked_array作为输入,类似“数组”的类.例如pandas数据对象，np.matrix可能会或可能不会按预期工作。最好用np.array在绘图之前将这些转换为对象。<br>例如，转换一个 pandas.DataFrame</p>
<p>a = pandas.DataFrame(np.random.rand(4,5), columns = list(‘abcde’))<br>a_asndarray = a.values<br>和隐蔽的 np.matrix</p>
<p>b = np.matrix([[1,2],[3,4]])<br>b_asarray = np.asarray(b)</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><strong>例子1</strong>：同一张图画多根曲线    </p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x, x, label=<span class="string">'linear'</span>)</span><br><span class="line">plt.plot(x, x**<span class="number">2</span>, label=<span class="string">'quadratic'</span>)</span><br><span class="line">plt.plot(x, x**<span class="number">3</span>, label=<span class="string">'cubic'</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">'x label'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y label'</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">"Simple Plot"</span>)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/" class="lazyload" data-src="/2019/01/21/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-python-python-stats%E6%95%B0%E6%8D%AE%E7%BB%98%E5%9B%BE/2.jpg"  alt><br><strong>例子2</strong>：重复画图  </p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_plotter</span><span class="params">(ax, data1, data2, param_dict)</span>:</span></span><br><span class="line">    out = ax.plot(data1, data2, **param_dict)</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">data1, data2, data3, data4 = np.random.randn(<span class="number">4</span>, <span class="number">100</span>)</span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">my_plotter(ax, data1, data2, {<span class="string">'marker'</span>: <span class="string">'x'</span>})</span><br><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">my_plotter(ax1, data1, data2, {<span class="string">'marker'</span>: <span class="string">'x'</span>})</span><br><span class="line">my_plotter(ax2, data3, data4, {<span class="string">'marker'</span>: <span class="string">'o'</span>})</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/" class="lazyload" data-src="/2019/01/21/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-python-python-stats%E6%95%B0%E6%8D%AE%E7%BB%98%E5%9B%BE/3.jpg"  alt></p>
<h2 id="（二）numpy"><a href="#（二）numpy" class="headerlink" title="（二）numpy"></a>（二）numpy</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><p>ndarray.ndim  </p>
<p>数组的轴数（尺寸）。  </p>
</li>
<li><p>ndarray.shape  </p>
<p>数组的大小。这是一个整数元组，表示每个维度中数组的大小。对于具有n行和m列的矩阵，shape将是(n,m)。shape因此，元组的长度 是轴的数量ndim。  </p>
</li>
<li><p>ndarray.size  </p>
<p>数组的元素总数。这等于元素的乘积shape。  </p>
</li>
<li><p>ndarray.dtype  </p>
<p>描述数组中元素类型的对象。可以使用标准Python类型创建或指定dtype。此外，NumPy还提供自己的类型。numpy.int32，numpy.int16和numpy.float64就是一些例子。  </p>
</li>
<li><p>ndarray.itemsize  </p>
<p>数组中每个元素的大小（以字节为单位）。例如，类型的元素数组float64有itemsize8（= 64/8），而其中一个类型complex32有itemsize4（= 32/8）。它相当于ndarray.dtype.itemsize。  </p>
</li>
<li><p>ndarray.data  </p>
<p>包含数组实际元素的缓冲区。通常，我们不需要使用此属性，因为我们将使用索引工具访问数组中的元素。 </p>
</li>
</ul>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><ul>
<li><p>从常规Python列表或元组创建数组:np.array()  </p>
</li>
<li><p>创建全零数组：np.zeros( (3,4) )  </p>
</li>
<li><p>创建数字序列：np.arange( 10, 30, 5 ) （接受float参数）  </p>
<p>第三个参数是步进长度</p>
</li>
<li><p>当arange与浮点参数一起使用时，由于有限的浮点精度，通常不可能预测所获得的元素的数量。出于这个原因，通常最好使用linspace作为参数接收我们想要的元素数量的函数 </p>
<p>np.linspace( 0, 2, 9 )  第三个参数是总数</p>
</li>
</ul>
<h3 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h3><ul>
<li><p>a[0:2]：  –a[0] a[1]  </p>
<p><strong>注意</strong>：留左不留右</p>
</li>
<li><p>resharp(,)： 转换数组的大小</p>
</li>
</ul>
<h2 id="（三）读写文件"><a href="#（三）读写文件" class="headerlink" title="（三）读写文件"></a>（三）读写文件</h2><p>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></tbody></table></figure>

<p>或者用</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br></pre></td></tr></tbody></table></figure>

<h2 id="（四）读函数"><a href="#（四）读函数" class="headerlink" title="（四）读函数"></a>（四）读函数</h2><p>python文件对象提供了三个“读”方法： read()、readline() 和 readlines()。每种方法可以接受一个变量以限制每次读取的数据量。</p>
<p>read() 每次读取整个文件，它通常用于将文件内容放到一个字符串变量中。如果文件大于可用内存，为了保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。<br>readlines() 之间的差异是后者一次读取整个文件，象 .read() 一样。.readlines() 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for … in … 结构进行处理。<br>readline() 每次只读取一行，通常比readlines() 慢得多。仅当没有足够内存可以一次读取整个文件时，才应该使用 readline()。<br><strong>注意</strong>：这三种方法是把每行末尾的’\n’也读进来了，它并不会默认的把’\n’去掉，需要我们手动去掉。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">In[<span class="number">4</span>]: <span class="keyword">with</span> open(<span class="string">'test1.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    list1 = f1.readlines()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(list1)):</span><br><span class="line">    list1[i] = list1[i].rstrip(<span class="string">'\n'</span>)</span><br><span class="line">In[<span class="number">5</span>]: list1</span><br><span class="line">Out[<span class="number">5</span>]: [<span class="string">'111'</span>, <span class="string">'222'</span>, <span class="string">'333'</span>, <span class="string">'444'</span>, <span class="string">'555'</span>, <span class="string">'666'</span>]</span><br></pre></td></tr></tbody></table></figure>

<h1 id="绘图脚本编写"><a href="#绘图脚本编写" class="headerlink" title="绘图脚本编写"></a>绘图脚本编写</h1><h2 id="待解决问题"><a href="#待解决问题" class="headerlink" title="待解决问题"></a>待解决问题</h2><ol>
<li><p>Spyder中其他路径的文件读取不到  </p>
<p>添加文件路径</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">"Z:\liqinxing\test_photo\sdm660_ipc"</span>)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>字符串如何批量转数字 ——map函数   </p>
</li>
<li><p>一行字符串如何转数组 ——split函数  </p>
</li>
<li><p>一维数组如何转二维数组  ——resharp   </p>
</li>
<li><p>三维数组如何画图  ——引入mpl_toolkits.mplot3d</p>
</li>
</ol>
<h2 id="脚本如下"><a href="#脚本如下" class="headerlink" title="脚本如下"></a>脚本如下</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">line=<span class="number">1</span></span><br><span class="line">sence=<span class="number">1</span></span><br><span class="line">stats_data=np.zeros((<span class="number">48</span>,<span class="number">64</span>))</span><br><span class="line"><span class="comment">#添加文件路径并打开</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'Z:\\liqinxing\\test_photo\\sdm660_ipc\\aec_stats.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    list1 = f1.readlines()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(list1)):</span><br><span class="line">    <span class="comment">#去掉每行的\n</span></span><br><span class="line">    list1[i] = list1[i].rstrip(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="comment">#判断每一行的第一个字符</span></span><br><span class="line">    <span class="keyword">if</span> list1[i][<span class="number">1</span>].isdigit() == <span class="literal">True</span>:</span><br><span class="line">        <span class="comment">#split将字符串切分成数组 </span></span><br><span class="line">        <span class="comment">#map函数将函数依次作用到list上的每个元素</span></span><br><span class="line">        data=list(map(int,list1[i].split())) </span><br><span class="line">        print(<span class="string">'line='</span>+str(line))</span><br><span class="line">        line += <span class="number">1</span></span><br><span class="line">        <span class="comment">#将数组转换成np数组</span></span><br><span class="line">        data_tmp=np.array(data)</span><br><span class="line">        <span class="comment">#将一维数组切块，留左不留右，并转换成二维数组</span></span><br><span class="line">        stats_subdata = data_tmp[<span class="number">0</span>:<span class="number">64</span>*<span class="number">48</span>].reshape(<span class="number">48</span>,<span class="number">64</span>)</span><br><span class="line">        <span class="comment">#对RGGB四个通道的值进行相加</span></span><br><span class="line">        stats_data += stats_subdata</span><br><span class="line">        <span class="keyword">if</span> line%<span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="comment">#建立一个figure</span></span><br><span class="line">            figure = plt.figure()</span><br><span class="line">            <span class="comment">#3D绘图</span></span><br><span class="line">            ax = Axes3D(figure)</span><br><span class="line">            <span class="comment">#定义XY轴</span></span><br><span class="line">            X = np.arange(<span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">            Y = np.arange(<span class="number">0</span>, <span class="number">48</span>)</span><br><span class="line">            X, Y = np.meshgrid(X, Y)</span><br><span class="line">            <span class="comment">#设置标题</span></span><br><span class="line">            ax.set_title(<span class="string">'sence'</span>+str(sence))</span><br><span class="line">            <span class="comment">#绘图</span></span><br><span class="line">            ax.plot_surface(X,Y,stats_data,</span><br><span class="line">                rstride=<span class="number">1</span>, cstride=<span class="number">1</span>, cmap=<span class="string">'rainbow'</span>)</span><br><span class="line">            stats_data=np.zeros((<span class="number">48</span>,<span class="number">64</span>))</span><br><span class="line">            sence += <span class="number">1</span></span><br><span class="line"><span class="comment">#plt.show是将所有的图画出来，而且是阻塞性的</span></span><br><span class="line"><span class="comment">#如果想画多个图，一定要在最后结束的时候用</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>诗意的年华</title>
    <url>/2019/01/18/%E7%94%9F%E6%B4%BB-love-2019-01-18-love/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>在你诗意的年华没有遇见你，或许是我的遗憾；<br>但是今后的日子里，让我们一起走向那神往的诗意生活；<br>做一个有趣的人，你我都是对方的诗和远方。</p>
<a id="more"></a>

<div class="justified-gallery"><p><img src="/" class="lazyload" data-src="/2019/01/18/%E7%94%9F%E6%B4%BB-love-2019-01-18-love/2.jpg"  alt></p><p><img src="/" class="lazyload" data-src="/2019/01/18/%E7%94%9F%E6%B4%BB-love-2019-01-18-love/3.jpg"  alt></p><p><img src="/" class="lazyload" data-src="/2019/01/18/%E7%94%9F%E6%B4%BB-love-2019-01-18-love/4.jpg"  alt></p><p><img src="/" class="lazyload" data-src="/2019/01/18/%E7%94%9F%E6%B4%BB-love-2019-01-18-love/5.jpg"  alt></p><p><img src="/" class="lazyload" data-src="/2019/01/18/%E7%94%9F%E6%B4%BB-love-2019-01-18-love/1.jpg"  alt></p>
          </div></body></html>]]></content>
      <categories>
        <category>生活</category>
        <category>围围</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>围围</tag>
        <tag>情书</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：手动增益过大时闪烁</title>
    <url>/2019/01/17/%E5%B7%A5%E4%BD%9C-BUG-BUG-%E6%89%8B%E5%8A%A8%E5%A2%9E%E7%9B%8A%E8%BF%87%E5%A4%A7%E6%97%B6%E9%97%AA%E7%83%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>当手动增益调节到90多时，图像会有闪烁<br>当调到100时，增益突然变低，图像突然变好</p>
<h2 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h2><ol>
<li>增益太高，导致曝光行一行跨度太大，达不到目标亮度</li>
<li>虽然增益很高，我们是在AE模块的输出截取修改，其实AE会把这个场景当做很亮的场景，曝光行在很小的地方波动，那个时候的曝光行不够平滑</li>
<li>是否可能增益到100时候超过了IMX327的最大数字增益</li>
</ol>
<h2 id="排查经过"><a href="#排查经过" class="headerlink" title="排查经过"></a>排查经过</h2><ul>
<li>1/17/2019 13:28:49</li>
</ul>
<p>烧写最新版本启动不了  –烧写1.4版本<br>搭好环境，更新代码</p>
<ul>
<li>2019/1/17 13:43:27  </li>
</ul>
<p>曝光行一直在变化，增益也在变化。  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( output->stats_update.aec_update.sensor_gain > aec->aec_exp_limit.gain_max){</span><br><span class="line">  <span class="keyword">if</span>((output->stats_update.aec_update.linecount < (<span class="keyword">uint32_t</span>)output->stats_update.aec_update.preview_linesPerFrame/<span class="number">10</span>)</span><br><span class="line">&& (aec->aec_exp_limit.shutter_max_line != aec->aec_exp_limit.shutter_min_line))</span><br><span class="line">    output->stats_update.aec_update.sensor_gain *= aec->aec_exp_limit.gain_max;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    output->stats_update.aec_update.sensor_gain= aec->aec_exp_limit.gain_max;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( output->stats_update.aec_update.sensor_gain < aec->aec_exp_limit.gain_min){</span><br><span class="line">  <span class="keyword">if</span>((output->stats_update.aec_update.linecount < (<span class="keyword">uint32_t</span>)output->stats_update.aec_update.preview_linesPerFrame/<span class="number">10</span>) \</span><br><span class="line">&& (aec->aec_exp_limit.shutter_max_line != aec->aec_exp_limit.shutter_min_line))</span><br><span class="line">    output->stats_update.aec_update.sensor_gain *= aec->aec_exp_limit.gain_min;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    output->stats_update.aec_update.sensor_gain = aec->aec_exp_limit.gain_min;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    aec->aec_exp_limit.cur_lux_index = core_output->lux_idx;</span><br></pre></td></tr></tbody></table></figure>


<p><strong>问题</strong>：调节手动增益为什么不是直接设置固定值？  </p>
<p><strong>解释</strong>：可能是由于增益比较大，如果想要达到目标亮度，曝光行可能会来回跳动，因此需要将手动增益乘以一个较小的数，也就是原始的输出增益。这里就相当于在原来的AEC基础上加上了一个固定的倍数。</p>
<ul>
<li>2019/1/17 14:38:34  </li>
</ul>
<p>可能是在之前乘以的倍数比较大？超过了最大值？ –可以到达600多倍</p>
<p><img src="/" class="lazyload" data-src="/2019/01/17/%E5%B7%A5%E4%BD%9C-BUG-BUG-%E6%89%8B%E5%8A%A8%E5%A2%9E%E7%9B%8A%E8%BF%87%E5%A4%A7%E6%97%B6%E9%97%AA%E7%83%81/bug1-1583661012571.jpg"  alt></p>
<ul>
<li>2019/1/17 15:38:45 </li>
</ul>
<p>lib中设置了最大增益上限为252，是否是因为超过了最大上限？ –在sensor.c中的<code>sensor_set_aec_update</code>函数用persist强制设置  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> prop[PROPERTY_VALUE_MAX];</span><br><span class="line"><span class="keyword">uint32_t</span> Debug_flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> real_gain = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">uint32_t</span> linecount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">property_get(<span class="string">"persist.camera.debug.flag"</span>, prop, <span class="string">"0"</span>);</span><br><span class="line">Debug_flag = atoi(prop);</span><br><span class="line">   </span><br><span class="line">property_get(<span class="string">"persist.camera.debug.real_gain"</span>, prop, <span class="string">"0"</span>);</span><br><span class="line">real_gain = atof(prop);</span><br><span class="line">    </span><br><span class="line">property_get(<span class="string">"persist.camera.debug.linecount"</span>, prop, <span class="string">"0"</span>);</span><br><span class="line">linecount = atoi(prop);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (Debug_flag == <span class="number">1</span>) {</span><br><span class="line">  exposure.real_gain = real_gain;</span><br><span class="line">  exposure.linecount = linecount;</span><br><span class="line">  SERR(<span class="string">"liqinxing: manual_set real_gain: %f,</span></span><br><span class="line"><span class="string">    linecnt = %d"</span>, real_gain,linecount);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sensor_set_exposure(sctrl, exposure);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>2019/1/18 10:40:06 </li>
</ul>
<p>排查99和100效果不同的原因：<br>注意一个问题：100ms更新一次数据 –理论上不是两帧更新一次么，也就是66ms;由于不是每次都打印，可能会出现这个问题</p>
<p>设置的手动增益是正常的，一直在增大；难道说是超出阈值了<br>保持图片的当前亮度稳定，那么曝光行和增益的乘积是固定的，也就是当增益增大，固定增益增大，曝光阶会会减小，但是到了100就不对了；为什么之前不会出现这个问题呢？</p>
<ul>
<li>2019/1/18 13:37:03  </li>
</ul>
<p>尝试修改lib.h文件中的IMX327_MAX_GAIN为1000<br>发现增益等级设置的手动增益范围也变成了1-1000，当为80时，手动增益为252倍，之后和100相同的情况，而在70-80之间依旧闪烁</p>
<ul>
<li>2019/1/18 14:10:49 </li>
</ul>
<p>为什么增益到了252就会出问题呢？这个增益恰好是lib中设置的最大增益</p>
<ul>
<li>2019/1/18 15:00:40 </li>
</ul>
<p>尝试将IMX327_MAX_GAIN改小，发现不再闪烁了，但是并不能解释根本原因</p>
<h2 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h2><p>写入寄存器是字节型写入的，需要将float型转换成十六进制，它是通过一个查找表<code>reg_value_lookup_table</code>去设置对应的倍数的。但是有个问题，超过查找表的最大值就没有进行赋值。而查找表的最大值只有251倍，我们设置的最大倍数有252倍，所以会出现问题。我们只需要将查找表加长，让每个倍数有对应的写入寄存器的值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>与camera相关参数的设置，注意是以字节形式写入，有时需要进入底层去查看原因。</li>
<li>aec_port中的real_gain并不是最终写入寄存器的值，需要经过sensor模块（可能会经过截取等简单操作），还有最后转换成字节型。</li>
</ul>
<h2 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h2><ul>
<li>imx327数字增益范围是0.3-42dB；换算一下最大数字增益是125.89；最大增益为71.4dB</li>
<li>imx327_lib.h文件中最大增益是252，也就是24dB</li>
<li>增益和倍数的换算是20lg(倍数)=dB</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>bug</tag>
        <tag>闪烁</tag>
      </tags>
  </entry>
  <entry>
    <title>ADRC</title>
    <url>/2019/01/15/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-ADRC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>用来提高整体亮度并抑制过曝，混合使用GTM和LTM。用直方图AEC设置更低的目标亮度，用更高的数字增益来增大暗处的亮度，会带来噪声的增加，尤其是户外的场景。</p>
<a id="more"></a> 

<h2 id="（一）ADRC初始化设置"><a href="#（一）ADRC初始化设置" class="headerlink" title="（一）ADRC初始化设置"></a>（一）ADRC初始化设置</h2><ul>
<li>使能直方图和ADRC: <code>Histogram Metering</code></li>
<li>为每个区间设置最大ADRC增益 <code>Max ADRC Gain</code></li>
<li>设置每个区间GTM/LTM的比例 <code>LTM/GTM Percentage</code> </li>
<li>在直方图保留部分使能DRC增益标志位 <code>ltm/gtm_enable</code>，如果没有GTM的平台，使能gamma和ltm</li>
<li>使能LTM<code>Local Tone Mapping</code></li>
<li>在<strong>isp头文件</strong>里不要使能<strong>GTM</strong></li>
</ul>
<h2 id="（二）判断是否设置成功"><a href="#（二）判断是否设置成功" class="headerlink" title="（二）判断是否设置成功"></a>（二）判断是否设置成功</h2><p>3A信息：<code>AEC Debug Info ->Histogram Adjustment</code> 中<code>ADRC target gain</code></p>
<h2 id="（三）基础调试"><a href="#（三）基础调试" class="headerlink" title="（三）基础调试"></a>（三）基础调试</h2><h3 id="微调直方图AEC获得恰当的整体亮度和DRC增益"><a href="#微调直方图AEC获得恰当的整体亮度和DRC增益" class="headerlink" title="微调直方图AEC获得恰当的整体亮度和DRC增益"></a>微调直方图AEC获得恰当的整体亮度和DRC增益</h3><p>ADRC工作范围：ideal_luma_target < legacy_luma_target * Min_Target_Adj_Ratio<br>在ADRC的情况下，亮度由final_luma_target * drc_gain决定</p>
<p><img src="/" class="lazyload" data-src="/2019/01/15/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-ADRC/adrc_brightness.jpg"  alt="adrc_brightness"></p>
<table>
<thead>
<tr>
<th align="center">ITEM</th>
<th align="left">AEC模块</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">luma_target (legacy_luma_target)</td>
<td align="left">luma targets</td>
<td>整体亮度越强，值越大</td>
</tr>
<tr>
<td align="center">ideal_luma_target</td>
<td align="left">Histogram Metering</td>
<td>ADRC越强，值越小。可以调节sat_low_ref,sat_high_ref,dark_low_ref,dark_high_ref,hist sat range,hist darc range。<code>sat</code>参数是调节ADRC的关键</td>
</tr>
<tr>
<td align="center">Min Target Adj Ratio</td>
<td align="left">Histogram Metering</td>
<td>整体亮度越亮，ADRC越强，值越大</td>
</tr>
<tr>
<td align="center">max_drc_gain</td>
<td align="left">Histogram Metering</td>
<td>限制ADRC的最大增益，ADRC越强，值越大；一开始调试不要超过2，谨慎增大这个值</td>
</tr>
<tr>
<td align="center">### 调试ADRC比例</td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="center">如果用了LTM，会提升对比度。不应该期望有明显的改进，也不应该过度使用LTM，因为他可能导致几种问题。</td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="center">一般来说，LTM比GTM/gamma对对比度和强光抑制更好，但是它可能产生一些副作用。对于对比度改善，高光抑制你也可以细调遗留的目标亮度和gamma</td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="center"><strong>建议</strong>：第一次调LTM不要超过0.5，留下的给gamma/gtm</td>
<td align="left"></td>
<td></td>
</tr>
</tbody></table>
<h2 id="（四）高级ADRC调试"><a href="#（四）高级ADRC调试" class="headerlink" title="（四）高级ADRC调试"></a>（四）高级ADRC调试</h2><h3 id="LTM调试"><a href="#LTM调试" class="headerlink" title="LTM调试"></a>LTM调试</h3><pre><code>我们可以调试`Global Tone Contrast`(修改对比度)和`Fixed content low`(修改暗区亮度)</code></pre><h3 id="抗闪烁优先还是ADRC"><a href="#抗闪烁优先还是ADRC" class="headerlink" title="抗闪烁优先还是ADRC"></a>抗闪烁优先还是ADRC</h3><pre><code>由于启用了ADRC，曝光时间可能小于10Ms，因此`可能出现闪烁问题`</code></pre><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/* 3A头文件 Histogram Metering 最后*/</span><br><span class="line">1.000000f,/* adrc_antibanding_priority_enable */</span><br><span class="line">170.000000f,/* atb_cutoff_idx_50hz */</span><br><span class="line">160.000000f,/* atb_cutoff_idx_60hz */</span><br><span class="line">200.000000f,/* atb_trigger.start */</span><br><span class="line">230.000000f,/* atb_trigger.end */</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果lux_idx <atb_trigger.end(非常非常明亮的情况下)，我们认为这是一个明确的亮度户外情况下，没有闪烁。所以，什么都不会发生。</li>
<li>当lux_idx >atb_trigger.end(可能在door中)，如果检测到条带，ADRC算法使曝光指数小于cutoff_idx，则该特性将把曝光指数限制在cutoff_idx，并降低drc idx(更小的drc gain)来调节亮度。</li>
<li>如果lux_idx在start和endzhi之间。调整比例将从0.0到1.0插值，使调整平滑。</li>
</ul>
<p><strong>闪烁问题和建议</strong>：</p>
<ul>
<li>也可能有曝光表的设计和模块的灵敏度有关</li>
<li>一开始关闭这个功能，除非你发现ADRC会引起闪烁问题</li>
<li>减少触发点可以对抗闪烁更有帮助</li>
<li>设置cutoff index比理论值略大一点</li>
</ul>
<h3 id="ADRC-WNR调整"><a href="#ADRC-WNR调整" class="headerlink" title="ADRC WNR调整"></a>ADRC WNR调整</h3><p>我们有机会调整CPP头中WNR的权重，DRC 增益是触发。<code>ADRC WNR Adjustment feature</code>，这个值可以大于或者小于1，最后WNR的设置会乘上ADRC WNR adjustment value。<br><strong>注意</strong>：<br>我们总是为WNR设置增益触发，而WNR的触发中也包含ADRC增益。gain(wnr-trigger) = gain * drc_gain</p>
<h3 id="ADRC-ACE调整"><a href="#ADRC-ACE调整" class="headerlink" title="ADRC ACE调整"></a>ADRC ACE调整</h3><p>我们可以在isp头中设置颜色调整，<code>DRC Sat Adj Factor</code>将会在color conversion模块中乘上a_m,a_p,c_m,c_p，可以对饱和度进行增强或者减少<br><strong>建议</strong>：不是必须的，一开始不需要打开</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像效果调试</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>直方图AEC</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo markdown常用语法</title>
    <url>/2019/01/14/%E5%AD%A6%E4%B9%A0-%E5%B7%A5%E5%85%B7-hexo-markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h1><ul>
<li><p>添加目录：<code>[TOC]</code></p>
</li>
<li><p>分段 <code>两个回车</code></p>
</li>
<li><p>换行 <code>两个空格</code> + <code>回车</code></p>
</li>
<li><p>标题 <code>#</code> ~ <code>######</code>，<code>#</code>号的个数表示几级标题，即表示一级标题到六级标题</p>
</li>
<li><p>强调 <code>**文字**</code>，<code>__文字__</code> ， <code>_文字_</code> ， <code>*文字*</code> ， <code>~~文字~~</code></p>
</li>
<li><p>引用 <code>></code> 注意后面紧跟个空格；两个空格结束引用。</p>
</li>
<li><p>代码块 <code>四个空格</code> 开头或， 使用```</p>
</li>
<li><p>链接 <code>[文字] (链接地址)</code></p>
</li>
<li><p>图片 <code>![图片说明] (图片地址)</code> ，地址可以是本地路劲，也可以是网络地址</p>
</li>
<li><p>列表 <code>*</code> ， <code>+</code>， <code>-</code>， <code>1.</code> ，选其中之一，注意后面紧跟个空格，如果是二级列表就在前面加一个空格</p>
</li>
<li><p>表格 - 和 | 分割行和列 ， 用<code>:</code>控制对其方式</p>
<p><strong>注</strong>：一般对合并单元格，以及其他特殊格式表格，markdown 是无能为力的<br>所以常规的做法是使用HTML标签，但是这样的编写效率极低。<br>但是有了这款工具的话，所有问题都迎刃而解。</p>
<p>在线生成HTML代码 <a href="http://www.tablesgenerator.com/" target="_blank" rel="noopener">Tables Generator</a> (国外的站)</p>
</li>
</ul>
<h1 id="首页概述"><a href="#首页概述" class="headerlink" title="首页概述"></a>首页概述</h1><ul>
<li>首页显示正文内容 <code><!-- more --></code></li>
<li>如果想空着：在layout设置部分用<code>description: <br></code></li>
<li>如果想要和正文不一样，用<code>description:</code>加上文字</li>
<li>如果想要概述中换行，用<br></li>
<li>如果md文件编写概述中换行，不能直接换行，需要加上<code>-</code>，但是注意不同的行直接会自动多一个<code>,</code></li>
</ul>
<h1 id="常用html格式"><a href="#常用html格式" class="headerlink" title="常用html格式"></a>常用html格式</h1><p>用div去指定特殊格式 </p>
<ul>
<li>古诗  <figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-family:cursive; font-style:normal; line-height:100%; font-size:250%; font-weight:bold; color:#FC8500; text-align:center;"</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br></pre></td></tr></tbody></table></figure></li>
<li>诗歌  <figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-family:cursive; font-style:normal; line-height:150%; font-size:200%; font-weight:bold; color:#FC8500; text-align:left; padding-left:10%"</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>工具</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>见</title>
    <url>/2019/01/11/%E7%94%9F%E6%B4%BB-%E5%9B%B4-2019-01-11-weiyi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>尊师桥河岸边的树倾慕幽幽碧水的容颜，倾身俯下诉说着爱意，四季如此，任由流年去。春，她抽出了新芽。夏，她披上了茂叶。秋，她用金黄的落叶为他歌舞，装点他的落寞。冬来了，那树啊，也终是俯身飘摇飘摇，随着他终老。  </p>
<p>东吴门前的那条路上，忍受不了寒冬的侵蚀的绿叶，终是离开了树枝。枯秃的枝桠依旧树枝茂密，伸展在天空中像网一样托住了霞光。<br>天还没完全黑下来的篮球场，已经没有了往常那番热闹。只看见被雨冲刷地发亮的地面，和雨滴落在黄泥浅塘面的声响。雨水一颗颗地滴落，给大地一个又一个的拥抱，在地面散开来一朵又一朵雨伞般的水花朵儿。<br>就这样，我走过东吴桥，途经尊师轩，路过东吴门，怀揣着这颗迫切的心，去见你。就这样，我不顾自己考完试留下的满面油光，去见你。就这样，我不在乎这寒风这雨，还是找了理由，说不想见你却已经迫不及待地，想见你。</p>
<div align="right">
——冯围
二零一九年一月十一日晚
农历贰零壹捌年腊月初六
</div>
</body></html>]]></content>
      <categories>
        <category>生活</category>
        <category>围围</category>
        <category>围的礼物</category>
      </categories>
      <tags>
        <tag>围围</tag>
        <tag>宝藏</tag>
      </tags>
  </entry>
  <entry>
    <title>背光补偿和强光抑制算法实现</title>
    <url>/2019/01/11/%E5%B7%A5%E4%BD%9C-%E7%BC%96%E7%A8%8B-%E8%83%8C%E5%85%89%E8%A1%A5%E5%81%BF%E5%92%8C%E5%BC%BA%E5%85%89%E6%8A%91%E5%88%B6%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p><strong>背光补偿</strong>是忽略强光，将暗处提亮，提高整体亮度<br><strong>强光抑制</strong>是重视强光，将亮处抑制，降低整体亮度</p>
<p>这两者的本质都是对曝光进行操作，再对图像进行gamma映射等轻微的调整。<br>本文用三种方案对问题进行讨论和实现</p>
<a id="more"></a> 
<hr>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li>强光抑制太注重亮区，当车辆快速驶来，车灯的影响可能会很大，暗区看不清，甚至导致<code>AE不稳定</code></li>
<li>强光抑制可能会导致噪声比较大，是否可以通过增大降噪触发点去自动增大<code>降噪等级</code></li>
<li>注意<code>ABF</code>可能会对亮区进行降噪，是否可以对ABF增加一个亮区参数</li>
<li>通过调节<code>锐化和降噪的LNR</code>对亮区进行锐化，对暗区进行进一步的降噪</li>
</ul>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="方案一：对测光权重进行调整"><a href="#方案一：对测光权重进行调整" class="headerlink" title="方案一：对测光权重进行调整"></a>方案一：对测光权重进行调整</h3><h4 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h4><ul>
<li><strong>自动模式</strong>：修改亮区的权重</li>
<li><strong>手动模式</strong>：修改相应区域的权重</li>
</ul>
<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><h3 id="方案二：对高通GTM-LTM进行调整"><a href="#方案二：对高通GTM-LTM进行调整" class="headerlink" title="方案二：对高通GTM/LTM进行调整"></a>方案二：对高通GTM/LTM进行调整</h3><h4 id="实现方案-1"><a href="#实现方案-1" class="headerlink" title="实现方案"></a>实现方案</h4><p>查看高通直方图AEC以及GTM/LTM的调节</p>
<ul>
<li><strong>自动模式</strong>：修改GTM/LTM的等级</li>
</ul>
<h3 id="方案三：对Bayer域和YUV域的直方图数据进行处理"><a href="#方案三：对Bayer域和YUV域的直方图数据进行处理" class="headerlink" title="方案三：对Bayer域和YUV域的直方图数据进行处理"></a>方案三：对Bayer域和YUV域的直方图数据进行处理</h3><h4 id="实现方案-2"><a href="#实现方案-2" class="headerlink" title="实现方案"></a>实现方案</h4><ul>
<li>通过Bayer域直方图统计数据得到亮区的区间，或者修改目标亮度</li>
<li>在yuv域直方图对gamma进行细微调整，可以通过调整LTM，也可以直接对亮区的gamma曲线进行抑制</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>算法实现</tag>
      </tags>
  </entry>
  <entry>
    <title>伞下的晴天</title>
    <url>/2019/01/11/%E7%94%9F%E6%B4%BB-love-2019-01-11-love/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>今夜，又是一个雨天<br>好似我们和雨有缘<br>我们的相遇<br>总是或多或少的下着小雨</p>
<a id="more"></a> 

<p>上天是这么的眷顾<br>让我又可以帮你撑着伞<br>两个人就这样静静的走着<br>即使周围是喧闹的观前街  </p>
<p>而我的眼眸里，<br>独有你一个人，<br>就像这周围的世界<br>只是一面单调的绿色，<br>而你是那一抹粉红。</p>
<p>与你面对面吃着饭<br>已经忘记<br>自己是在吃饭<br>还是在看你<br>不知道<br>自己吃了什么<br>就想狠狠地<br>记住你的每一点美  </p>
<p>我任性的沾着辣酱<br>想要一个小小的逞强<br>却被你一把夺过<br>放进了你那小嘴中<br>嗔怪着我的任性<br>却不知你的心疼<br>早已在我心里<br>注入了一股股暖流</p>
<p>回去的路上<br>低头看着你<br>发现自己是多么的幸福<br>你的频频回头<br>你的盈盈笑靥<br>你的软惜娇羞<br>总会让我抑制不住<br>想亲的冲动</p>
<p>柔软的脸庞<br>带着少女的清香<br>我已经醉倒在你的身边<br>那条幽静的小路<br>多么希望一直走不到头<br>这样<br>我可以<br>一直一直的<br>把你搂在怀里  </p>
<p>踮起脚尖<br>东张西望<br>立在人流之中<br>等你<br>只为第一个看见你<br>好像只翘首等待的鹅呀</p>
<p>哈哈，说真的<br>我还是第一次站在人海中<br>等着我的心上人<br>那样的迫不及待<br>又带丝羞涩<br>刚拿起手机安慰一下<br>自己期待又兴奋的内心<br>却没想到你就已经<br>悄然来到了我的身边<br>傻乎乎的看着我<br>我想<br>这冬日<br>有你就够了<br>足以给我暖阳般的温暖 </p>
<p>最后<br>塞下一瓶牛奶<br>既然喜爱你的美<br>那就要一直美下去<br>我要好好守护你的这份美<br>你可以生活不精致<br>但是我要学会照顾你的一切<br>从此以后<br>呵护你就是我的责任了！</p>
</body></html>]]></content>
      <categories>
        <category>生活</category>
        <category>围围</category>
        <category>诗歌</category>
      </categories>
      <tags>
        <tag>围围</tag>
        <tag>情书</tag>
      </tags>
  </entry>
  <entry>
    <title>ADB指令小结</title>
    <url>/2019/01/10/%E5%B7%A5%E4%BD%9C-%E7%BC%96%E7%A8%8B-ADB%E6%8C%87%E4%BB%A4%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>ADB，即 Android Debug Bridge。利用ADB指令可以对安卓设备进行命令行操作。<br>下面总结一些常用的ADB指令方便设备的开发与调试。</p>
<a id="more"></a> 

<h2 id="（一）推库不用重启的方法："><a href="#（一）推库不用重启的方法：" class="headerlink" title="（一）推库不用重启的方法："></a>（一）推库不用重启的方法：</h2><p>可以节省大量时间，需要重启启动程序，和第二条搭配使用<br>另外还可以方便的查看开camera初始化时的一些打印<br>注意：需要有APK，部分IPC上不能使用</p>
<h3 id="660-8998平台"><a href="#660-8998平台" class="headerlink" title="660/8998平台:"></a>660/8998平台:</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">adb shell stop cameraserver</span><br><span class="line">adb shell start cameraserver</span><br><span class="line">adb shell sync</span><br></pre></td></tr></tbody></table></figure>

<h3 id="老平台："><a href="#老平台：" class="headerlink" title="老平台："></a>老平台：</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">adb shell stop media</span><br><span class="line">adb shell start media</span><br><span class="line">adb shell stop qcamerasvr</span><br><span class="line">adb shell start qcamerasvr</span><br><span class="line">adb shell sync</span><br></pre></td></tr></tbody></table></figure>

<h2 id="（二）adb启动和关闭程序的方法"><a href="#（二）adb启动和关闭程序的方法" class="headerlink" title="（二）adb启动和关闭程序的方法"></a>（二）adb启动和关闭程序的方法</h2><h3 id="先找到当前窗口的程序名，拿骁龙相机举例"><a href="#先找到当前窗口的程序名，拿骁龙相机举例" class="headerlink" title="先找到当前窗口的程序名，拿骁龙相机举例"></a>先找到当前窗口的程序名，拿骁龙相机举例</h3><p>输入：adb shell dumpsys window windows | findstr Current<br>输出：mCurrentFocus=Window{59a08b7 u0 org.codeaurora.snapcam/com.android.camera.CameraLauncher}<br>后面一长串的字母就是程序名</p>
<h3 id="先找到当前窗口的程序名，拿骁龙相机举例启动程序，adb-shell-am-start-–n-程序名"><a href="#先找到当前窗口的程序名，拿骁龙相机举例启动程序，adb-shell-am-start-–n-程序名" class="headerlink" title="先找到当前窗口的程序名，拿骁龙相机举例启动程序，adb shell am start –n + 程序名"></a>先找到当前窗口的程序名，拿骁龙相机举例启动程序，adb shell am start –n + 程序名</h3><p>adb shell am start -n org.codeaurora.snapcam/com.android.camera.CameraLauncher</p>
<h3 id="先找到当前窗口的程序名，拿骁龙相机举例关闭程序"><a href="#先找到当前窗口的程序名，拿骁龙相机举例关闭程序" class="headerlink" title="先找到当前窗口的程序名，拿骁龙相机举例关闭程序"></a>先找到当前窗口的程序名，拿骁龙相机举例关闭程序</h3><p>adb shell pkill snapcam(缩写就够了)</p>
<h2 id="（三）拍照：用模拟抓拍键的方式抓拍"><a href="#（三）拍照：用模拟抓拍键的方式抓拍" class="headerlink" title="（三）拍照：用模拟抓拍键的方式抓拍"></a>（三）拍照：用模拟抓拍键的方式抓拍</h2><p>adb shell input keyevent 27<br>如果写成脚本，速度较快，有的时候图片不能立即pull出来，建议加个延时，具体延时长度自己试验<br>延时：ping /n 2 127.1>nul<br>此处的2代表延时2秒</p>
<h2 id="（四）抓raw图的方法：不一定要骁龙相机，方便拍raw图以及平时的分析（660平台）"><a href="#（四）抓raw图的方法：不一定要骁龙相机，方便拍raw图以及平时的分析（660平台）" class="headerlink" title="（四）抓raw图的方法：不一定要骁龙相机，方便拍raw图以及平时的分析（660平台）"></a>（四）抓raw图的方法：不一定要骁龙相机，方便拍raw图以及平时的分析（660平台）</h2><h3 id="先找到当前窗口的程序名，拿骁龙相机举例先修改文件夹权限"><a href="#先找到当前窗口的程序名，拿骁龙相机举例先修改文件夹权限" class="headerlink" title="先找到当前窗口的程序名，拿骁龙相机举例先修改文件夹权限"></a>先找到当前窗口的程序名，拿骁龙相机举例先修改文件夹权限</h3><p>adb shell chmod 777 /data/misc/camera</p>
<h3 id="先找到当前窗口的程序名，拿骁龙相机举例抓取一帧RAW"><a href="#先找到当前窗口的程序名，拿骁龙相机举例抓取一帧RAW" class="headerlink" title="先找到当前窗口的程序名，拿骁龙相机举例抓取一帧RAW"></a>先找到当前窗口的程序名，拿骁龙相机举例抓取一帧RAW</h3><p>可以在QCamera2HWICallbacks.cpp的dumpFrameToFile函数查看具体实现过程。可能会出现抓拍到不止1张raw图的情况。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">adb shell setprop persist.camera.raw_yuv 1</span><br><span class="line">adb shell setprop persist.camera.preview_raw 1</span><br><span class="line">adb shell setprop persist.camera.dumpimg 0</span><br><span class="line">adb shell setprop persist.camera.dumpimg 131088</span><br></pre></td></tr></tbody></table></figure>
<h3 id="先找到当前窗口的程序名，拿骁龙相机举例导入chromatix时，用骁龙相机抓出来的raw图是MIPI格式"><a href="#先找到当前窗口的程序名，拿骁龙相机举例导入chromatix时，用骁龙相机抓出来的raw图是MIPI格式" class="headerlink" title="先找到当前窗口的程序名，拿骁龙相机举例导入chromatix时，用骁龙相机抓出来的raw图是MIPI格式"></a>先找到当前窗口的程序名，拿骁龙相机举例导入chromatix时，用骁龙相机抓出来的raw图是MIPI格式</h3><p>而这里格式要改成packed，图片的名称中有图片的大小<br>注意：第一次抓取raw图，设置好要重启camera<br>由于persist.camera.raw_yuv只有在给channel添加通道的时候才会读取，因此设置之后需要重启camera，可以重启设备或者重启应用程序。</p>
<h2 id="（五）抓YUV图的方法（660平台）："><a href="#（五）抓YUV图的方法（660平台）：" class="headerlink" title="（五）抓YUV图的方法（660平台）："></a>（五）抓YUV图的方法（660平台）：</h2><h3 id="VFE输出"><a href="#VFE输出" class="headerlink" title="VFE输出"></a>VFE输出</h3><p>和上面一个类似，先改权限</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">adb shell setprop persist.camera.isp.dump_cnt 1</span><br><span class="line">adb shell setprop persist.camera.isp.dump 0</span><br><span class="line">adb shell setprop persist.camera.isp.dump 2</span><br></pre></td></tr></tbody></table></figure>
<p>实现函数：iface_util.c中的 iface_util_dump_frame</p>
<h3 id="CPP输出（方法和抓raw图差不多）"><a href="#CPP输出（方法和抓raw图差不多）" class="headerlink" title="CPP输出（方法和抓raw图差不多）"></a>CPP输出（方法和抓raw图差不多）</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">adb shell setprop persist.camera.dumpimg 0</span><br><span class="line">adb shell setprop persist.camera.dumpimg 131073</span><br></pre></td></tr></tbody></table></figure>

<h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p>persist.camera.isp.dump 0到12位的意义：<br>CAM_STREAM_TYPE_PREVIEW – 0x2<br>CAM_STREAM_TYPE_SNAPSHOT – 0x8<br>CAM_STREAM_TYPE_VIDEO – 0x10<br>persist.camera.dumpimg<br>16到23位表示dump多少帧，但如果是0，就是10帧<br>8-15位表示跳过多少帧，默认不跳过.<br>0到7位：<br>QCAMERA_DUMP_FRM_PREVIEW –0x1<br>QCAMERA_DUMP_FRM_VIDEO –0x2<br>QCAMERA_DUMP_FRM_SNAPSHOT –0x4<br>QCAMERA_DUMP_FRM_THUMBNAIL –0x8<br>QCAMERA_DUMP_FRM_RAW –0x10<br>QCAMERA_DUMP_FRM_JPEG –0x20</p>
<h2 id="（六）查看HAL层和客户端设置的参数值"><a href="#（六）查看HAL层和客户端设置的参数值" class="headerlink" title="（六）查看HAL层和客户端设置的参数值"></a>（六）查看HAL层和客户端设置的参数值</h2><p>adb shell dumpsys media.camera</p>
<h2 id="（七）log打印"><a href="#（七）log打印" class="headerlink" title="（七）log打印"></a>（七）log打印</h2><p>logcat|grep xxx –搜索包含xxx的log<br>logcat|grep xxx > /data/log.log –将包含xxx的log存到/data/log.log中<br>setprop persist.camera.stats.aec.debug 5 –stats中的AEC模块等级小于等于5的都打印出来</p>
<h3 id="关键词："><a href="#关键词：" class="headerlink" title="关键词："></a>关键词：</h3><p>查看曝光信：target_luma<br>查看灰点信息：simple-grey-world<br>查看决策点：final_awb_decision<br>查看HAL层帧率：PROFILE_PREVIEW_FRAMES_PER_SECOND<br>查看camera层模块帧率：fps</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">{</span><br><span class="line">  Q3A_AWB_AGW_D65 = <span class="number">0</span>,                                <span class="comment">/* D65*/</span></span><br><span class="line">  Q3A_AWB_AGW_D75,                                    <span class="comment">/* D75*/</span></span><br><span class="line">  Q3A_AWB_AGW_A,                                      <span class="comment">/* A*/</span></span><br><span class="line">  Q3A_AWB_AGW_WARM_FLO,                               <span class="comment">/* TL84*/</span></span><br><span class="line">  Q3A_AWB_AGW_COLD_FLO,                               <span class="comment">/* CW*/</span></span><br><span class="line">  Q3A_AWB_AGW_HORIZON,                                <span class="comment">/* H*/</span></span><br><span class="line">  Q3A_AWB_AGW_D50,                                    <span class="comment">/* D50*/</span></span><br><span class="line">  Q3A_AWB_AGW_CUSTOM_FLO,                             <span class="comment">/* CustFlo*/</span></span><br><span class="line">  Q3A_AWB_AGW_NOON,                                   <span class="comment">/* Noon*/</span></span><br><span class="line">  Q3A_AWB_AGW_CUSTOM_DAYLIGHT,</span><br><span class="line">  Q3A_AWB_AGW_CUSTOM_A,</span><br><span class="line">  Q3A_AWB_AGW_U30,</span><br><span class="line">  Q3A_AWB_AGW_CUSTOM_DAYLIGHT1,</span><br><span class="line">  Q3A_AWB_AGW_CUSTOM_DAYLIGHT2,</span><br><span class="line">  Q3A_AWB_AGW_CUSTOM_FLO1,</span><br><span class="line">  Q3A_AWB_AGW_CUSTOM_FLO2,</span><br><span class="line">  Q3A_AWB_AGW_MAX_LIGHT,</span><br><span class="line">  Q3A_AWB_AGW_INVALID_LIGHT = Q3A_AWB_AGW_MAX_LIGHT,</span><br><span class="line">  Q3A_AWB_DAY_LINE_1 = Q3A_AWB_AGW_MAX_LIGHT,</span><br><span class="line">  Q3A_AWB_DAY_LINE_2,</span><br><span class="line">  Q3A_AWB_FLINE,</span><br><span class="line">  Q3A_AWB_A_LINE_1,</span><br><span class="line">  Q3A_AWB_A_LINE_2,</span><br><span class="line">  <span class="comment">/* Daylight, only used for algorithm, not data*/</span></span><br><span class="line">  Q3A_AWB_AGW_HYBRID,    </span><br><span class="line">  <span class="comment">/* Don't count the hybrid*/</span></span><br><span class="line">  Q3A_AWB_AGW_MAX_ALL_LIGHT = Q3A_AWB_AGW_HYBRID,   </span><br><span class="line">  Q3A_AWB_AGW_INVALID_ALL_LIGHT = Q3A_AWB_AGW_MAX_ALL_LIGHT</span><br><span class="line">} chromatix_awb_all_light_adapter;</span><br></pre></td></tr></tbody></table></figure>


<h3 id="推库技巧："><a href="#推库技巧：" class="headerlink" title="推库技巧："></a>推库技巧：</h3><p>如果一次生成的so文件比较多，可以放在一个文件夹内，把文件夹的内容推入设备。<br>adb push C:\ROM. System/vendor/lib      注意.不能少</p>
<h2 id="（八）参考脚本："><a href="#（八）参考脚本：" class="headerlink" title="（八）参考脚本："></a>（八）参考脚本：</h2><h3 id="push-bat（推动态库）"><a href="#push-bat（推动态库）" class="headerlink" title="push.bat（推动态库）"></a>push.bat（推动态库）</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">REM 在推库之前关闭应用程序，不然可能会卡死在应用程序的界面</span><br><span class="line">REM IPC上建议不要关掉程序，重启会很慢，直接推库会卡一会儿，然后就可以正常使用</span><br><span class="line">adb shell pkill ptt</span><br><span class="line">REM HAL层动态库</span><br><span class="line">adb push adb push Z:\liqinxing\sdm660\sdm660_ipw300\out\target\product\u2p\obj_arm\lib\camera.sdm660.so system/lib/hw</span><br><span class="line">REM camera层动态库</span><br><span class="line">adb push Z:\liqinxing\sdm660\sdm660_ipw300\out\target\product\u2p\obj_arm\lib\libchromatix_imx290_default_preview_3a.so system/vendor/lib</span><br><span class="line">adb push Z:\liqinxing\sdm660\sdm660_ipw300\out\target\product\u2p\obj_arm\lib\libchromatix_imx290_cpp_preview.so system/vendor/lib</span><br><span class="line">adb push Z:\liqinxing\sdm660\sdm660_ipw300\out\target\product\u2p\obj_arm\lib\libchromatix_imx290_preview.so system/vendor/lib</span><br><span class="line">adb push Z:\liqinxing\sdm660\sdm660_ipw300\out\target\product\u2p\obj_arm\lib\libchromatix_imx290_common.so system/vendor/lib</span><br><span class="line">REM 重启cameraserver（8998/sdm660平台）</span><br><span class="line">adb shell stop cameraserver</span><br><span class="line">adb shell start cameraserver</span><br><span class="line">adb shell sync</span><br><span class="line">REM 启动应用程序</span><br><span class="line">adb shell am start -n com.kedacom.ptt/com.kedacom.kdmipw300.activity.IPW300MainActivity</span><br><span class="line">ping /n 3 127.1>nul</span><br><span class="line">REM 确认是否打开</span><br><span class="line">adb shell dumpsys window windows | findstr Current</span><br></pre></td></tr></tbody></table></figure>

<h3 id="capture-bat（拍照）"><a href="#capture-bat（拍照）" class="headerlink" title="capture.bat（拍照）"></a>capture.bat（拍照）</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">REM 先清空原来的图片</span><br><span class="line">adb shell rm -r /sdcard/DCIM/Camera/*</span><br><span class="line">adb shell rm -r /storage/extdisk/ipw300/image/chn0_0/*</span><br><span class="line">REM 拍照</span><br><span class="line">adb shell input keyevent 27</span><br><span class="line">ping /n 3 127.1>nul</span><br><span class="line">REM 导出照片</span><br><span class="line">adb pull /storage/extdisk/ipw300/image/chn0_0 Z:\liqinxing\test_photo\sixth_tunning</span><br><span class="line">adb pull /sdcard/DCIM/Camera Z:\liqinxing\test_photo\sixth_tunning</span><br></pre></td></tr></tbody></table></figure>

<h3 id="sdm660-root-bat"><a href="#sdm660-root-bat" class="headerlink" title="sdm660_root.bat"></a>sdm660_root.bat</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell setprop service.user.test 1</span><br><span class="line">ping -n 5 127.1 > nul</span><br><span class="line">adb shell setenforce 0</span><br><span class="line">ping -n 1 127.1 > nul</span><br><span class="line">adb remount</span><br></pre></td></tr></tbody></table></figure>

<h3 id="captureraw-bat"><a href="#captureraw-bat" class="headerlink" title="captureraw.bat"></a>captureraw.bat</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">adb shell chmod 777 /data/misc/camera</span><br><span class="line">adb shell rm  /data/misc/camera/*</span><br><span class="line">adb shell setprop persist.camera.raw_yuv 1</span><br><span class="line">adb shell setprop persist.camera.preview_raw 1</span><br><span class="line">adb shell setprop persist.camera.dumpimg 0</span><br><span class="line">adb shell setprop persist.camera.dumpimg 131088</span><br><span class="line">adb pull /data/misc/camera Z:\liqinxing\test_photo\raw</span><br></pre></td></tr></tbody></table></figure>

<h3 id="captureyuv-bat"><a href="#captureyuv-bat" class="headerlink" title="captureyuv.bat"></a>captureyuv.bat</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">adb shell chmod 777 /data/misc/camera</span><br><span class="line">adb shell rm  /data/misc/camera/*</span><br><span class="line">adb shell setprop persist.camera.isp.dump_cnt 1</span><br><span class="line">adb shell setprop persist.camera.isp.dump 0</span><br><span class="line">adb shell setprop persist.camera.isp.dump 2 </span><br><span class="line">adb pull /data/misc/camera Z:\liqinxing\test_photo\raw</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
      </tags>
  </entry>
  <entry>
    <title>偶然，又或是必然</title>
    <url>/2019/01/09/%E7%94%9F%E6%B4%BB-love-2019-01-09-love/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>那个时候没有察觉到，最重要的东西其实就在眼前，才了解到，那些数不清的偶然，就是爱上你的必然，那些所有都是最珍贵的宝物，现在的我已经明白，我的最爱，不管多少次轮回，还是想要遇见你。<br>—— because of my love</p>
</blockquote>
<a id="more"></a> 

<p>一个偶然，让我听到围围歌单中的第一首歌《because of my love》，感觉是上天送给我的礼物，不偏不倚让我遇到。回忆起来，我的喜欢可能是从之前的点点滴滴积累起来，到这一步可能都是顺其自然。</p>
<p>而那这些点点滴滴又是如今最美好的回忆，那么我有必要记录下我心动的每个瞬间，保持这份喜欢到永远。</p>
<p>感谢围围给了我一次爱你的机会，我会珍惜和守护你的一切。请相信我！</p>
</body></html>]]></content>
      <categories>
        <category>生活</category>
        <category>围围</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>围围</tag>
        <tag>情书</tag>
      </tags>
  </entry>
  <entry>
    <title>sdm660 ISP效果调试总结</title>
    <url>/2019/01/09/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-sdm660-ISP%E6%95%88%E6%9E%9C%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>经过一轮的调试，发现660相比于上一代，在降噪和锐化方面有所提升，具体体现在在同一张图的亮区和暗区，中心和边缘可以用不同的降噪锐化参数。这样可以在保留亮区细节的同时，可以降低暗区的噪声，也减小rolloff带来的噪声。</p>
<a id="more"></a>

<h2 id="1-黑电平"><a href="#1-黑电平" class="headerlink" title="1. 黑电平"></a>1. 黑电平</h2><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>如图1、由于采用的是14位，相比于之前的12位，平均值会出现比以前大4倍的情况。右边的平均值和左边的不等，是因为开启了BLSS，这个功能是指一部分不进行ABF，可以减少噪声的偏移，让黑色区域更纯粹，建议开启。</p>
<p><img src="/" class="lazyload" data-src="/2019/01/09/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-sdm660-ISP%E6%95%88%E6%9E%9C%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/1.1.jpg"  alt="1.1"></p>
<h3 id="BLSS介绍"><a href="#BLSS介绍" class="headerlink" title="BLSS介绍"></a>BLSS介绍</h3><p>图二中介绍：ABF会带来噪声的偏移，在图三中左边是开启了BLSS，右边是关闭了BLSS，从直方图可以看出开启了BLSS可以减少噪声偏移。当出现在极弱光条件下，暗色调为微红/紫色，而中色调和亮色调为灰色情况，考虑是否关闭了BLSS。</p>
<p><img src="/" class="lazyload" data-src="/2019/01/09/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-sdm660-ISP%E6%95%88%E6%9E%9C%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/1.2.jpg"  alt="1.2"></p>
<p><img src="/" class="lazyload" data-src="/2019/01/09/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-sdm660-ISP%E6%95%88%E6%9E%9C%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/1.3.jpg"  alt="1.3"></p>
<h3 id="代码位置介绍"><a href="#代码位置介绍" class="headerlink" title="代码位置介绍"></a>代码位置介绍</h3><p><img src="/" class="lazyload" data-src="/2019/01/09/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-sdm660-ISP%E6%95%88%E6%9E%9C%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/1.4.jpg"  alt="1.4"></p>
<p>在注释中说明线性化的第一个数就是黑电平</p>
<p><img src="/" class="lazyload" data-src="/2019/01/09/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-sdm660-ISP%E6%95%88%E6%9E%9C%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/1.5.jpg"  alt="1.5"></p>
<p>BLSS offset位置</p>
<h2 id="2-ABF"><a href="#2-ABF" class="headerlink" title="2. ABF"></a>2. ABF</h2><h3 id="操作简介"><a href="#操作简介" class="headerlink" title="操作简介"></a>操作简介</h3><p>在每个降噪和锐化模块之前都有一个radial table，是指在不同的半径范围内用不同的降噪锐化参数。由于进行rolloff校正，边缘的增益较大，会带来很多的噪声。如果镜头本身shading较小，RNR参数可以较小或者忽略。在base table中可以调节不同半径运用的降噪参数的比例。</p>
<p>如图2.4，在filter strength中可以根据每个像素点的亮度去调节不同的降噪强度，值越小，降噪越大。我一般使用工具测出哪些亮度的噪声较大，再去选择强度范围，这里强度是10位的，而我们是8位的，根据最后图像中的RGB值乘以4，可以大致得出暗区范围。由于暗区gamma抬升的较严重，这对于降低暗区的噪声很有效。在很亮的情况下，甚至可以将strength调到1，提升细节。Edge softness是调节噪声的检测区域，值越大，进行降噪的噪声范围越大。</p>
<p><img src="/" class="lazyload" data-src="/2019/01/09/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-sdm660-ISP%E6%95%88%E6%9E%9C%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/2.1.jpg"  alt="2.1"></p>
<p><img src="/" class="lazyload" data-src="/2019/01/09/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-sdm660-ISP%E6%95%88%E6%9E%9C%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/2.2.jpg"  alt="2.2"></p>
<p><img src="/" class="lazyload" data-src="/2019/01/09/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-sdm660-ISP%E6%95%88%E6%9E%9C%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/2.3.jpg"  alt="2.3"></p>
<p><img src="/" class="lazyload" data-src="/2019/01/09/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-sdm660-ISP%E6%95%88%E6%9E%9C%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/2.4.jpg"  alt="2.4"></p>
<h3 id="代码位置"><a href="#代码位置" class="headerlink" title="代码位置"></a>代码位置</h3><p>1、 前两行代表strength的强度，两列分别代表RG和GRGB通道的强度。</p>
<p>2、 Lo代表暗区范围的边界对应上图的127，Hi代表亮区的边界</p>
<p>3、 Edge softness不必说，base table就是图2.3的代码形式</p>
<p><img src="/" class="lazyload" data-src="/2019/01/09/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-sdm660-ISP%E6%95%88%E6%9E%9C%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/2.5.jpg"  alt="2.5"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ABF是在gamma之前进行的降噪，暗区经过gamma抬升之后引入了更多的噪声，在此之前进行一波简单的降噪，尤其是对暗区颗粒感的噪声有较好的效果。亮区如果ABF较强会抹掉细节，因此需要确定好暗区的亮区的范围。如果启用LTM，ABF也可以有效降低暗区的噪声。</p>
<h2 id="3-LTM"><a href="#3-LTM" class="headerlink" title="3. LTM"></a>3. LTM</h2><h3 id="操作简介-1"><a href="#操作简介-1" class="headerlink" title="操作简介"></a>操作简介</h3><p><img src="/" class="lazyload" data-src="/2019/01/09/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-sdm660-ISP%E6%95%88%E6%9E%9C%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/3.1.jpg"  alt="3.1"></p>
<p>这是LTM界面，比较简单，三个滑块可以修改，strength代表LTM的强度，右边两个滑块是暗区的增强程度和亮区的抑制程度，亮区的抑制可以调到4.0，而暗区的提升区域和LTM要随着增益的降低而降低，否则会带来很多的噪声，可以通过调节ABF来减小他们。也可以减小暗区的饱和度来减小噪声。</p>
<p>右上角的图片可以右键点击，添加拐点，进行曲线的调整，要降低已提升区域的饱和度，饱和度曲线必须呈现右侧下凹并且左侧上凸的状态。</p>
<h2 id="4-WNR"><a href="#4-WNR" class="headerlink" title="4. WNR"></a>4. WNR</h2><h3 id="操作简介-2"><a href="#操作简介-2" class="headerlink" title="操作简介"></a>操作简介</h3><p>RNR的操作类似，一开始进行base table的半径大小的选择，在调试时候的RNR可以进行不同区域scale和softness的缩放。</p>
<p>原始的LNR如图4.1，横坐标是intensity，指的是像素点的强度，值越大代表越亮的区域。纵坐标代表的是对降噪阈值和权重的缩放比例。比如说亮度区域，我们想要看到他的细节，就要减小scale的缩放比例。暗区想要降噪比较强，可以增大scale的比例，这个地方需要根据具体的情况判断缩放比例。因此不一定按照原来的曲线，根据自己的目标进行调整。</p>
<p>第五层和第六层参数过大，会减少图片的饱和度和以及出现渗色的情况，低照度的情况下使用，数值不能太大。</p>
<h3 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h3><p>1、 拍raw图时记下当前的增益值，以便生成该增益下的噪声模板</p>
<p>2、 调整的WNR的时候可以先将ASF关闭，避免由于锐化造成的噪声。</p>
<p>3、 先观察中间中等亮度的区域，避免因为LNR和RNR的影响。</p>
<p>4、 由于scale是滤波的程度，而softness是对噪声和边缘的选择，我们可以先将scale调至很大，权重也调成0，通过想要放出的细节去确定softness，然后通过调整scale，调整滤波的程度，调整到能够去除噪声的最小值。最后调整权重，调整权重会放出部分噪声和细节。</p>
<p>5、 最后进行LNR和RNR进行细微的调整，比如增强暗亮区的细节。</p>
<p><img src="/" class="lazyload" data-src="/2019/01/09/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-sdm660-ISP%E6%95%88%E6%9E%9C%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/4.1.jpg"  alt="4.1"></p>
<p><img src="/" class="lazyload" data-src="/2019/01/09/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-sdm660-ISP%E6%95%88%E6%9E%9C%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/4.2.jpg"  alt="4.2"></p>
<h3 id="代码位置-1"><a href="#代码位置-1" class="headerlink" title="代码位置"></a>代码位置</h3><p>代码中的WNR有两处，下面的那组参数是low power模式下的参数。先确认用的是哪一组参数。其他的参数和上一代类似，只是增加了第五层和第六层。RNR和LNR可以用chromatix工具生成。</p>
<h2 id="5-ASF"><a href="#5-ASF" class="headerlink" title="5. ASF"></a>5. ASF</h2><h3 id="操作简介-3"><a href="#操作简介-3" class="headerlink" title="操作简介"></a>操作简介</h3><p>一开始同样是RNR的调整。</p>
<p>接下来是边缘检测模板等配置。</p>
<p><img src="/" class="lazyload" data-src="/2019/01/09/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-sdm660-ISP%E6%95%88%E6%9E%9C%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/5.1.jpg"  alt="5.1"></p>
<p>这里不需要我们改值，但是后面可以选择我们用薄的还是厚的，在增益较小的情况下，顾及细节用thin kernels，增益较大，比较模糊的情况可以选择用mid或者thick kernels，顾及噪声。</p>
<p>接下来是几条锐化曲线：</p>
<p><img src="/" class="lazyload" data-src="/2019/01/09/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-sdm660-ISP%E6%95%88%E6%9E%9C%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/5.2.jpg"  alt="5.2"></p>
<p>第一条曲线是activity normalization factor曲线。横坐标是局部亮度，纵坐标是代表了活动归一化因子的缩放，这幅图代表越暗的区域，降低偏暗像素缩放因子，可以降低暗区的噪声，但也会带来对比度较低的问题。当然降低缩放因子，并不能直接导致锐化程度的降低，而是通过第三条曲线降低gain weight来降低锐化，甚至有滤波的效果。</p>
<p><img src="/" class="lazyload" data-src="/2019/01/09/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-sdm660-ISP%E6%95%88%E6%9E%9C%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/5.3.jpg"  alt="5.3"></p>
<p>这条gain lut曲线是最主要的一条曲线，第一个滑块是代表平坦区域的锐化程度，第二个代表对暗处的锐化的提升效果，最后一个是对亮处锐化的提升。可以增强阴影部分和高亮部分的细节，如果暗处噪声较多，可以降低暗区的提升效果，甚至变成负值，代表对暗处锐化的抑制。</p>
<p><img src="/" class="lazyload" data-src="/2019/01/09/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-sdm660-ISP%E6%95%88%E6%9E%9C%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/5.4.jpg"  alt="5.4"></p>
<p>这条gain weight曲线横坐标是归一化活动，我理解的是边缘的程度，值越大，就越是边缘，值越小，代表越平坦。Gain weight如果是0，就完全用9x9的低通滤波器，如果是1，就完全是经过锐化的数值，如果在两者之间，这是用的两者的比例之和。</p>
<p>上面的滑块会让曲线向右移动，可以让噪声不被锐化出来，增益较大的情况下进行右移。左边的滑块就是调整平坦区域的锐化和滤波的比例。</p>
<p>联系第一条曲线，如果暗区的缩放因子设置的比较小，归一化活动缩小了，相当于在原来的基础上横坐标的值减小了，那么它的锐化程度会更小，滤波会更多，可以降低噪声，也会抹掉细节，因此需要适当注意。</p>
<p><img src="/" class="lazyload" data-src="/2019/01/09/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-sdm660-ISP%E6%95%88%E6%9E%9C%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/5.5.jpg"  alt="5.5"></p>
<p>这条曲线是gain negative lut，只需要用滑块调整和gain lut的比例。锐化出来是有两个边的，一个是黑边，一个是白边，上一条gain lut指的是白边，这个是黑边，为了减少白边，我一般将gain lut调的较小，gain negative lut调的较大。同时还有钳位可以调整。代码中的Clamp UL 是白边的阈值，可以小一点。Clamp LL 是黑边的阈值。当然，这样会降低细节，如果细节不够，我们可以增加gain lut去增加细节的锐化，同时用clamp UL去减小白边。</p>
<p><img src="/" class="lazyload" data-src="/2019/01/09/%E5%B7%A5%E4%BD%9C-%E5%9B%BE%E5%83%8F-sdm660-ISP%E6%95%88%E6%9E%9C%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/5.6.jpg"  alt="5.6"></p>
<p>最后是RNR的调整，由于之前的ABF和WNR，边缘的滤波可能更加严重，这里可以对边缘增强一些，但也可能带来更多的噪声，因此适当增强或者不增强。</p>
<p>在other的选项中勾选median filter blend，在锐化之前用中值滤波器，可以减小尖峰噪声，同时对细节影响不大，建议勾选。</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像效果调试</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>效果调试</tag>
      </tags>
  </entry>
  <entry>
    <title>linux服务器的基本操作</title>
    <url>/2019/01/03/%E5%AD%A6%E4%B9%A0-%E7%BC%96%E7%A8%8B-web-linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="linux更换国内源"><a href="#linux更换国内源" class="headerlink" title="linux更换国内源"></a>linux更换国内源</h2><ol>
<li><p>备份原来的源<br>sudo cp /etc/apt/sources.list /etc/apt/sources_init.list<br>将以前的源备份一下，以防以后可以用的。</p>
</li>
<li><p>更换源<br>sudo gedit /etc/apt/sources.list<br>使用gedit打开文档，将下边的阿里源复制进去，然后点击保存关闭。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 阿里源</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>更新<br>更新源<br><code>sudo apt-get update</code><br>复损坏的软件包，尝试卸载出错的包，重新安装正确版本的。<br><code>sudo apt-get -f install</code><br>更新软件<br><code>sudo apt-get upgrade</code></p>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>有一个人</title>
    <url>/2019/01/02/%E7%94%9F%E6%B4%BB-%E5%9B%B4-2019-01-02-weiyi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>有一个人<br>他是阳光，正好温暖在我心上  </p>
<p>有一个人<br>他有双美丽的手，会敲代码  会焊电路  会弹琴  </p>
<p>有一个人<br>他陪我奔跑在护城河岸  阡陌石路  柳荫桥头  </p>
<p>有一个人<br>他会在寒冷的傍晚不远千里送来温热奶茶  </p>
<p>有一个人<br>他每天都对我说着好喜欢好喜欢你  </p>
<p>有一个人<br>他邀我漫步在民国风情道  七里山塘桥  </p>
<p>有一个人<br>他为牵到我的手而欢欣雀跃  </p>
<p>有一个人<br>他总是喜欢呆呆地看着我  目不转睛  </p>
<p>有一个人<br>他会迫不及待地来见我  带着他的心意  </p>
<p>有一个人<br>他时常用相机来记下我的笑靥  为之着迷  </p>
<p>有一个人<br>他想尽办法让我开心  讲笑话分享欣喜  </p>
<p>有一个人<br>他会为了与我分享苹果而义无反顾奔跑着  </p>
<p>有一个人<br>他自己做东西来给我惊喜   </p>
<p>有一个人<br>他给我过生日傻乎乎地买了个大蛋糕  </p>
<p>有一个人<br>他会不辞辛劳来到我身边只为见我一面  </p>
<p>有一个人<br>他给我以我从未乞求过的爱意  </p>
<p>有一个人<br>他就这样来到我的心里<br><br><br></p>
<p>他应该是一杯温热的奶茶  </p>
<p>捧在手心是温暖  </p>
<p>喝在嘴里是香甜  </p>
<p>他应该是一杯醇厚的美酒  </p>
<p>这杯酒啊  </p>
<p>让我未喝先醉  </p>
<p>可这杯酒  </p>
<p>让我想喝不敢饮  </p>
<p>我害怕  </p>
<p>害怕拿起这杯酒后还是要放下  </p>
<p>害怕沉醉后必须要醒来的钻心<br><br><br></p>
<p>我多想更勇敢一点  </p>
<p>可我不舍  </p>
<p>不舍心中的这份倾心  </p>
<p>不舍心中的那个梦想  </p>
<p>我知道  </p>
<p>知道这两个美好的事情  </p>
<p>我只能抉其一   </p>
<p>啊  </p>
<p>人生总是这么不尽人意  </p>
<p>我等待着  </p>
<p>等待着那个让我欢欣的奇迹  </p>
<div align="right">
——冯围
2019年1月2日晚于博远楼落笔
农历贰零壹捌年拾壹月廿七日
</div>
 </body></html>]]></content>
      <categories>
        <category>生活</category>
        <category>围围</category>
        <category>围的礼物</category>
      </categories>
      <tags>
        <tag>围围</tag>
        <tag>宝藏</tag>
      </tags>
  </entry>
  <entry>
    <title>平安夜</title>
    <url>/2018/12/25/%E7%94%9F%E6%B4%BB-%E5%9B%B4-2018-12-25-weiyi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>这个平安夜有惊喜</p>
<p>惊喜是看见你为见我而奔跑的气喘吁吁</p>
<p>惊喜是你赠予的明信片诉着倾心</p>
<p>惊喜是红红的大苹果一人一半里藏着的蜜甜</p>
<p>惊喜是什么呢？</p>
<p>最大的惊喜不过是见到了你</p>
<p>——智障障障小钦星</p>
<div align="right">
——冯围   
2018年12月25日   
</div>

</body></html>]]></content>
      <categories>
        <category>生活</category>
        <category>围围</category>
        <category>围的礼物</category>
      </categories>
      <tags>
        <tag>围围</tag>
        <tag>宝藏</tag>
      </tags>
  </entry>
  <entry>
    <title>十七里</title>
    <url>/2018/12/24/%E7%94%9F%E6%B4%BB-%E5%9B%B4-2018-12-24-weiyi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>青竹书签，醉眼迷离</p>
<p>我更不知道这是巧合</p>
<p>还是缘分的推进</p>
<p>抑或是冲动的情感飘然于心</p>
<p>十里有多远我不知晓  </p>
<p>七里有多长我不知道</p>
<p>我只知道这十几里路</p>
<p>让两个人靠得越来越近</p>
<p>青竹书签，醉眼迷离</p>
<p>我更不知道这是巧合</p>
<p>还是缘分的推进</p>
<p>抑或是冲动的情感飘然于心</p>
<p>确让人心生欢喜</p>
<div align="right">
——冯围   
2018年12月25日   
</div>

</body></html>]]></content>
      <categories>
        <category>生活</category>
        <category>围围</category>
        <category>围的礼物</category>
      </categories>
      <tags>
        <tag>围围</tag>
        <tag>宝藏</tag>
      </tags>
  </entry>
</search>
