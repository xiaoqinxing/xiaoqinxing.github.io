<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>高速PCB设计注意点</title>
    <url>/posts/cf39b128/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>参考<a href="https://www.bilibili.com/video/BV1hi4y1j7zX?from=search&seid=15918437188388155646" target="_blank" rel="noopener">b站视频</a>和<a href="https://zhuanlan.zhihu.com/p/34061689" target="_blank" rel="noopener">知乎</a></p>
</blockquote>
<h2 id="（一）差分线"><a href="#（一）差分线" class="headerlink" title="（一）差分线"></a>（一）差分线</h2><p>由于高频信号容易受到串扰，电线的输出不能完美的等于输出，总会耦合进去一些噪声。而现在高速PCB中，高低电平阈值越来越低，当噪声超过高电平的阈值，信号就会出错。因此再加一根线，组成差分线，两根距离很近，可以认为两个线上面的噪声是相同的，两者相减就可以得到除掉噪声的信号，同时还会对信号有一定的放大。这是高速PCB经常涉及到的。</p>
<p><img src="https://image.qinxing.xyz/20201026200637.png" alt="单线的信号传输"></p>
<p>如图，这是单线的信号传输，输入是个完美的方波，但是输出会耦合各种各样的噪声ΔV，当噪声超过0和1的阈值时，就会造成误判</p>
<p><img src="https://image.qinxing.xyz/20201026201159.png" alt="差分线的信号传输"></p>
<p>如图，这是差分线的信号传输，一个传输原始信号，另外一根线传递倒相的信号，接收到了也会受到干扰，由于距离比较近，可以认为这两个线上的噪声都是ΔV。接收后，将两个信号相减，就除去了噪声，完美的还原了原始信号</p>
<h2 id="（二）等长线"><a href="#（二）等长线" class="headerlink" title="（二）等长线"></a>（二）等长线</h2><p>电信号在电线中的传递是有一定的时延的。对时序要求比较高的时候，就需要考虑到这个时延，所以会用到蛇形线。高速PCB很多时候会用差分线进行信号的传递，差分线就需要两个信号相位相同，如果相位不同，信号会出错。</p>
<p><img src="https://image.qinxing.xyz/20201026202136.png" alt="等长差分线的波形图"></p>
<p>这是等长线的波形图，上面两个波形是差分线上的两个信号，可以看到是反向的。经过相减之后，可以完美的还原波形。</p>
<p><img src="https://image.qinxing.xyz/20201026202140.png" alt="非等长差分线的波形图"></p>
<p>这是不等长的两根线的波形图，上面两个波形是差分线上的两个信号，经过长一些的线，信号会有一些延迟，导致两者相位对不上。相减之后的波形就出现了明显的失真。</p>
<h2 id="（三）阻抗匹配"><a href="#（三）阻抗匹配" class="headerlink" title="（三）阻抗匹配"></a>（三）阻抗匹配</h2><p>阻抗匹配是指信号源或者传输线跟负载之间达到一种适合的搭配。阻抗匹配主要有两点作用，调整负载功率和抑制信号反射。在高速PCB设计中，阻抗的匹配与否关系到信号的质量优劣。</p>
<h3 id="一-、什么是阻抗"><a href="#一-、什么是阻抗" class="headerlink" title="一 、什么是阻抗"></a>一 、什么是阻抗</h3><p>在电学中，常把对电路中电流所起的阻碍作用叫做阻抗。阻抗单位为欧姆，常用Z表示，是一个复数Z= R+i( ωL–1/（ωC）)。具体说来阻抗可分为两个部分，电阻（实部）和电抗（虚部）。其中电抗又包括容抗和感抗，由电容引起的电流阻碍称为容抗，由电感引起的电流阻碍称为感抗。</p>
<p><img src="https://image.qinxing.xyz/20201026212850.jpg" alt="阻抗"></p>
<h3 id="二、PCB走线什么时候需要做阻抗匹配？"><a href="#二、PCB走线什么时候需要做阻抗匹配？" class="headerlink" title="二、PCB走线什么时候需要做阻抗匹配？"></a>二、PCB走线什么时候需要做阻抗匹配？</h3><p>不主要看频率，而关键是看信号的边沿陡峭程度，即信号的上升/下降时间，一般认为如果信号的上升/下降时间（按10%～90%计）小于6倍导线延时，就是高速信号，必须注意阻抗匹配的问题。导线延时一般取值为150ps/inch。</p>
<h3 id="三、阻抗匹配的作用"><a href="#三、阻抗匹配的作用" class="headerlink" title="三、阻抗匹配的作用"></a>三、阻抗匹配的作用</h3><p>● 调整负载功率</p>
<p>假定激励源已定，那么负载的功率由两者的阻抗匹配度决定。对于一个理想化的纯电阻电路或者低频电路，由电感、电容引起的电抗值基本可以忽略，此时电路的阻抗来源主要为电阻。如图2所示，电路中电流I=U/(r+R)，负载功率P=I<em>I</em>R。由以上两个方程可得当R=r时P取得最大值，Pmax=U<em>U/(4</em>r)。</p>
<p>如果我们需要输出电流大，则选择小的负载R;如果我们需要输出电压大，则选择大的负载R;如果我们需要输出功率最大，则选择跟信号源内阻匹配的电阻R。</p>
<p><img src="https://image.qinxing.xyz/20201026203823.jpg" alt="负载功率调整"></p>
<p>● 抑制信号反射</p>
<p>当一束光从空气射向水中时会发生反射，这是因为光和水的光导特性不同。同样，当信号传输中如果传输线上发生特性阻抗突变也会发生反射。波长与频率成反比，低频信号的波长远远大于传输线的长度，因此一般不用考虑反射问题。高频领域，当信号的波长与传输线长出于相同量级时反射的信号易与原信号混叠，影响信号质量。通过阻抗匹配可有效减少、消除高频信号反射。</p>
<p><img src="https://image.qinxing.xyz/20201026203141.jpg" alt="正常信号"></p>
<p><img src="https://image.qinxing.xyz/20201026203157.jpg" alt="异常信号（反射引起超调）"></p>
<h3 id="四、阻抗匹配的方法"><a href="#四、阻抗匹配的方法" class="headerlink" title="四、阻抗匹配的方法"></a>四、阻抗匹配的方法</h3><p>阻抗匹配的方法主要有两个，一是改变组抗力，二是调整传输线。</p>
<p>改变阻抗力就是通过电容、电感与负载的串并联调整负载阻抗值，以达到源和负载阻抗匹配。</p>
<p>调整传输线是加长源和负载间的距离，配合电容和电感把阻抗力调整为零。此时信号不会发生发射，能量都能被负载吸收。高速PCB布线中，一般把数字信号的走线阻抗设计为50欧姆。一般规定同轴电缆基带50欧姆，频带75欧姆，对绞线（差分）为85-100欧姆。</p>
<h3 id="五、阻抗匹配的应用"><a href="#五、阻抗匹配的应用" class="headerlink" title="五、阻抗匹配的应用"></a>五、阻抗匹配的应用</h3><p>● 功放与音箱</p>
<p>无论是定阻抗式还是定电压式输出的功放，只有喇叭的总功率和功放的总功率相等时才能得到最佳的工作状态。音箱系统若要完全达到匹配是非常困难的，它的音频成分总是在不停的变化，好在音箱系统对阻抗匹配度要求并不高。最常见到的喇叭阻抗的标示值是8欧姆，它表示当输入1KHz的正弦波信号，它呈现的阻抗值是八欧姆；或者是在喇叭的工作频率响应范围内，平均阻抗为8欧姆。</p>
<p>● PCB走线</p>
<p>高频领域中，信号频率对PCB走线的阻抗值影响非常大。一般来说当数字信号边沿时间小于1ns或者模拟信号频率超过300M时就要考虑阻抗问题。PCB走线阻抗主要来自寄生的电容、电阻、电感系数，主要因素有材料介电常数、线宽、线厚乃至焊盘的厚度等。PCB 阻抗的范围是 25 至120 欧姆，USB、 LVDS、 HDMI、 SATA等一般要做85-100欧姆阻抗控制。</p>
<p><img src="https://image.qinxing.xyz/20201026220455.jpg" alt="走线匹配阻抗"></p>
<p>● 天线设计</p>
<p>研究天线阻抗的主要目的是为实现天线和馈线间的匹配。发射信号时应使发射天线与馈线的特性阻抗相等，以获得最好的信号增益。接收信号时天线与负载应做共轭匹配，接收机（负载）阻抗一般认为只有实数部分，因此需要用匹配网络来除去天线的电抗部分并使它们的电阻部分相等。图7为天线阻抗匹配时常用的π型网络，使用网络分析仪测量阻抗以确定 C1、C2、C3 的取值，完成阻抗匹配。</p>
<p><img src="https://image.qinxing.xyz/20201026215622.jpg" alt="π型电路"></p>
<p>● 终端匹配电阻</p>
<p>在设计CAN总线、485总线时常需要在差分线两端加终端电阻（匹配电阻），以减少由特性阻抗突变造成的信号反射。如下图CAN总线网络，双绞线特性阻抗为120欧姆，若不加终端电阻两端直接悬空，空气的特性阻抗为无穷大。此时，极易出现图4所示的信号反射。</p>
<p><img src="https://image.qinxing.xyz/20201026220441.jpg" alt="CAN总线网络"></p>
<p>对于CAN总线来说，由于收发器对信号电平判断的采样点位置普遍靠后，因此信号反射一般不会影响通信错误率。反射会影响产品的EMI特性，最直接的表现就是眼图实验效果差，存在两个异常凸起。</p>
<p><img src="https://image.qinxing.xyz/20201026220437.jpg" alt="CAN总线眼图"></p>
<h3 id="六、实际试验"><a href="#六、实际试验" class="headerlink" title="六、实际试验"></a>六、实际试验</h3><p>原始信号：</p>
<p><img src="https://image.qinxing.xyz/20201026220434.png" alt="原始信号"></p>
<p>负载为空时的波形：</p>
<p>反射波，会导致进入的信号有个余波，对信号产生干扰。</p>
<p>可以通过两个脉冲的时间差去测线缆的长度（甚至是光纤的长度）</p>
<p><img src="https://image.qinxing.xyz/20201026220431.png" alt="负载为空时的波形"></p>
<p>下图是负载短接的波形图，原因暂时还不清楚</p>
<p><img src="https://image.qinxing.xyz/20201026220331.png" alt="短接负载时的波形"></p>
<p>下图是进行阻抗匹配后的波形图</p>
<p><img src="https://image.qinxing.xyz/20201026220325.png" alt="进行阻抗匹配后的波形"></p>
<h3 id="七、疑问：是什么时候都需要阻抗匹配么？阻抗匹配会损失效率的吧？"><a href="#七、疑问：是什么时候都需要阻抗匹配么？阻抗匹配会损失效率的吧？" class="headerlink" title="七、疑问：是什么时候都需要阻抗匹配么？阻抗匹配会损失效率的吧？"></a>七、疑问：是什么时候都需要阻抗匹配么？阻抗匹配会损失效率的吧？</h3><p>不同场合的“匹配”要求不一样</p>
<p>如果要求电源使用效率高，此处的关键要求是耗电所做出的功，因此阻抗应该尽量小。</p>
<p>如果要求发出功率高，此处的关键是负载获得功率要尽量大。</p>
<p>如果是高频传输线，此处的关键目标是不能有或尽量减少反射，则线路阻抗(阻性)和终端阻抗相等(阻性)。</p>
<p>如果是放大器，往往要求不影响源，此时特别要求低输入电流(输入阻抗尽量大)</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>电子</category>
      </categories>
      <tags>
        <tag>电子电路</tag>
        <tag>高速PCB</tag>
        <tag>阻抗匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>相机成像原理之sensor篇</title>
    <url>/posts/e6f0524a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="（一）sensor的硬件结构"><a href="#（一）sensor的硬件结构" class="headerlink" title="（一）sensor的硬件结构"></a>（一）sensor的硬件结构</h2><h3 id="1-每个像素的结构"><a href="#1-每个像素的结构" class="headerlink" title="1. 每个像素的结构"></a>1. 每个像素的结构</h3><p>每个像素点的最上方有个微透镜，增加透光量。有镜头就有CRA的问题，超出一定角度的光线无法被收集，需要和镜头进行匹配。</p>
<p><img src="https://image.qinxing.xyz/20200325171710.png" alt="像素的结构"></p>
<h3 id="2-sensor的纵向结构"><a href="#2-sensor的纵向结构" class="headerlink" title="2. sensor的纵向结构"></a>2. sensor的纵向结构</h3><p>光透过电路会发生反射，造成每个像素点之间的干扰。背照式的结构（感光层在电路的上方）不会受到电路的影响。</p>
<p><img src="https://image.qinxing.xyz/20200325171743.png" alt="sensor的纵向结构 "></p>
<h3 id="3-CFA-color-filter-array"><a href="#3-CFA-color-filter-array" class="headerlink" title="3. CFA(color filter array)"></a>3. CFA(color filter array)</h3><p>每个像素点上覆盖有一种颜色的滤光片，从而去感知每种颜色的亮度。</p>
<p><img src="https://image.qinxing.xyz/20200325171811.png" alt="滤光片CFA"></p>
<p>Bayer格式：绿色分量为总像素数的一半，红色蓝色为总像素的四分之一。</p>
<h4 id="3-1-MONO-sensor"><a href="#3-1-MONO-sensor" class="headerlink" title="3.1 MONO sensor"></a>3.1 MONO sensor</h4><p>由于滤光会带来亮度上的损失，有种MONO sensor，没有滤光片的处理，亮度会大大提高（有文章说可以提高四倍），但是这就感知不到颜色了，所以又叫黑白sensor。</p>
<h4 id="3-2-光谱响应曲线"><a href="#3-2-光谱响应曲线" class="headerlink" title="3.2 光谱响应曲线"></a>3.2 光谱响应曲线</h4><p>下图是IMX290每个红绿蓝滤光片的光谱响应曲线。</p>
<p><img src="https://image.qinxing.xyz/20200325171849.png" alt="IMX290光谱响应曲线"></p>
<p>这是人眼视锥细胞对光谱的响应曲线</p>
<p><img src="https://image.qinxing.xyz/20200325171930.png" alt="人眼视锥细胞对光谱的响应曲线"></p>
<p>由于人眼和sensor对光谱的感应曲线不同，同一个物体感知到的颜色不同。因此颜色需要一个转换关系。ISP中的CCM（色彩校正矩阵）就此诞生，利用一个3x3的矩阵，将sensor感知到的RGB颜色，校准成我们看到的RGB颜色。</p>
<h4 id="3-3-红绿灯变色问题"><a href="#3-3-红绿灯变色问题" class="headerlink" title="3.3 红绿灯变色问题"></a>3.3 红绿灯变色问题</h4><p>这里穿插一个监控摄像头常遇到的问题，拍红灯的时候，经常会拍成黄灯和白灯，这是为什么呢？</p>
<p>因为红灯的光谱在780~620nm之间，从光谱响应曲线中可以看到，红像素最敏感，然后是绿像素，最后是蓝色像素。</p>
<p>当感光度比较小的时候，红色像素的亮度远远大于绿色和蓝色，肯定是呈现出红色。感光度比较大时，绿色像素也能有很高的亮度，而红色像素早已经饱和了，不在增加，这个时候呈现的颜色就是红色+绿色=黄色。感光度很大的时候，RGB都饱和了，红绿蓝加在一起就是白色。<br><strong>解决方法：</strong></p>
<ol>
<li>降低曝光</li>
<li>换用蓝玻璃IRCUT：在650nm以上的红光，绿像素的感应也很强。换用蓝玻璃IR可以有效减少绿像素的干扰。同时它也可以比较彻底的滤除630nm以上波长的红光，减少过曝的问题。</li>
</ol>
<h4 id="3-4-去马赛克"><a href="#3-4-去马赛克" class="headerlink" title="3.4 去马赛克"></a>3.4 去马赛克</h4><p>由于sensor每个像素点只能感知到一种颜色，因此想要得到每个像素点的RGB值，需要进行插值，这个过程就是去马赛克(Demosiac)。<br><img src="https://image.qinxing.xyz/20200327202901.png" alt="demosiac"></p>
<h3 id="4-IR-CUT"><a href="#4-IR-CUT" class="headerlink" title="4. IR-CUT"></a>4. IR-CUT</h3><p>大家都知道，摄像头有个IR-CUT，那为什么要加IR-CUT filter 呢？IR-CUT是红外滤光片，可以滤除红外光。</p>
<p>从IMX290的光谱敏感性曲线可以看到sensor到了1000的波长还能进行光电转换，而人眼只能到700nm，也就是可以说sensor 的“可见光”和人眼的不一样，而且范围远远比人眼的要大。</p>
<p>那么就会导致什么问题呢，最大的问题就是颜色不一样，因为人眼是感受到的是在可见光在可见光范围内的响应，而sensor感受到的却是在400-1000范围内的响应。因此我们需要加上一个IR-cut 使sensor感受的波段和人眼一样。</p>
<p>还有一个原因：当光线进入镜头，由于折射率不同，可见光和红外光会在靶面的不同位置成像，IR-CUT可以减少红外光产生的伪像。</p>
<h4 id="4-1-拓展：RGB-IR-sensor"><a href="#4-1-拓展：RGB-IR-sensor" class="headerlink" title="4.1 拓展：RGB-IR sensor"></a>4.1 拓展：RGB-IR sensor</h4><p>补充一种sensor，这种sensor不用IR-CUT，除了有RGB三种CFA，还增加了一种专门只通过红外光的CFA。由光谱图我们可以知道，普通sensor中的绿像素不仅仅能感知绿色，还能感知到红外波段的光，实际上是绿色+IR（红外光）。RGB-IR的sensor有个IR像素只感知红外光，两者相减就可以得到可见光的绿色。</p>
<p><img src="https://image.qinxing.xyz/20200328184305.png" alt="RGB-IR format"></p>
<p>这样就用数字滤光代替了IR-CUT。我觉得更有应用场景的地方在于，夜间场景下开红外灯，不仅可以感知到红外，还能感知到颜色，是一种待开发的黑光技术。</p>
<h3 id="5-黑电平"><a href="#5-黑电平" class="headerlink" title="5. 黑电平"></a>5. 黑电平</h3><p>黑电平（Black Level Correction）也就是黑色的最低点，以8bit数据来说，指在经过一定校准的显示装置上，没有一行光亮输出的视频信号电平。定义图像数据为0时对应的信号电平。</p>
<p>黑电平产生的原因：</p>
<ol>
<li>CMOS传感器采集的信息经过一系列转换生成原始RAW格式数据。以8bit数据为例，单个pixel的有效值是0-255，但是实际AD芯片（模数转换芯片）的精度可能无法将电压值很小的一部分转换出来，因此，sensor厂家一般会在AD的输入之前加上一个固定的偏移量，使输出的pixel       value在5（非固定）-255之间，目的是为了让暗部的细节完全保留，当然同时也会损失一些亮部细节，由于对于图像来说，我们的关注度更倾向于暗部区域，ISP后面会有很多增益模块（LSC、AWB、Gamma等），因此亮区的一点点损失是可以接受的。</li>
<li>sensor的电路本身会存在暗电流，导致在没有光线照射的时候，像素单位也有一定的输出电压，暗电流这个东西跟曝光时间和gain都有关系，不同的位置也是不一样的。因此在gain增大的时候，电路的增益增大，暗电流也会增强，因此很多ISP会选择在不同gain下减去不同的黑电平的值。</li>
</ol>
<p>ISP pipeline中的黑电平校正（Black Level Correction） ：</p>
<p>拍几张不同增益下的全黑图像，算出每个增益下对应的黑电平值。isp会在raw图之后减去这个黑电平值。这一般是ISP的第一步。</p>
<h3 id="6-坏点"><a href="#6-坏点" class="headerlink" title="6. 坏点"></a>6. 坏点</h3><p>传感器芯片由于工艺的原因产生一些有缺陷的像素点，这些像素点可能比邻近的像素点更暗或者更亮。</p>
<p>  ISP pipeline中的的坏点校正：</p>
<p>  在判定某像素为坏点后，会根据邻近像素点的值计算得到一个值以替代该坏点。</p>
<h2 id="（二）sensor的曝光"><a href="#（二）sensor的曝光" class="headerlink" title="（二）sensor的曝光"></a>（二）sensor的曝光</h2><p>sensor的曝光时间和快门时间是一个概念，都是sensor的感光时间。曝光（快门）时间越长，图像就越亮。</p>
<p>当控制快门时间，仍然达不到期望的亮度，就需要调节sensor的感光度（ISO）。CMOS sensor的感光度就是它的增益。增益是用模拟或数字的方法进行放大，不可避免的会放大噪声，因此拍摄时一般快门优先。</p>
<p>当拍摄高速运动的物体或者手抖的时候，容易产生运动模糊，就需要降低快门时间。</p>
<p>sensor的曝光方式有两种，卷帘曝光和全局曝光。</p>
<h3 id="1-卷帘曝光（rolling-shutter）"><a href="#1-卷帘曝光（rolling-shutter）" class="headerlink" title="1. 卷帘曝光（rolling shutter）"></a>1. 卷帘曝光（rolling shutter）</h3><ol>
<li><p>sensor曝光是每一行依次开始曝光的，所以图像中每一行的起始曝光时间是不一致的，目前大部分sensor属于这种。下图是卷帘曝光拍摄高速运动的物体的现象。</p>
<p><img src="https://image.qinxing.xyz/20200722144307.png" alt="卷帘曝光失真"></p>
</li>
<li><p>这是IMX290的sensor曝光与输出示意图<br> <img src="https://image.qinxing.xyz/20200722144302.png" alt="IMX290 曝光序列"></p>
<p> 黄色区域是sensor处于感光的时间，蓝色区域是sensor每一行数据的输出时间，红色是曝光开始的时间。XHS是进行每个操作的最小时间单位。</p>
<p> 从时间先后来看，一幅图像是从第一行开始曝光，一个XHS之后，再从第二行开始曝光，依次类推。图像的第一行曝光结束后，进行输出，输出数据的时间是一个XHS，依此类推。</p>
</li>
<li><p>卷帘曝光带来的问题</p>
<ol>
<li><p>日光灯下有横条纹</p>
<p>日光灯属于频闪灯，跟当地的供电频率有关，如果当地的供电是50Hz的正弦波（国内），日光灯就会以100Hz的频率闪烁。sensor每行的起始曝光时间是不同的，这就导致了每一行曝光时的亮度不同。因此会出现横条纹</p>
<p> <strong>解决方法：</strong></p>
<ul>
<li>控制曝光时间是1/100的整数倍，这样每行的曝光时间都是一个周期的整数倍，亮度就保持一致了。</li>
<li>控制帧率为25/50帧，不能解决横条纹的问题，但是可以让每帧图像中的横条纹固定在相同的位置。1/25是1/100的整数倍，可以使不同图像中每一行曝光的开始时间都相差四个周期。保证了每张图像中同一行的亮度是一致的。</li>
</ul>
</li>
<li><p>拍摄快速运动的物体会有失真</p>
<p>  因为每一行曝光开始的时间不同，当物体快速运动时，每行抓拍下来的物体位置都不同，造成了物体的变形。</p>
<p>  <strong>解决方法：</strong></p>
<ul>
<li>加大图像输出的速度（提高帧率也可行，本质上改变的就是输出速度）</li>
<li>调整抓拍的时间和角度，比如远处的车辆每帧移动的像素点较少，可以去抓拍稍远处的车辆</li>
<li>使用全局曝光的sensor</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="2-全局曝光（global-shutter）"><a href="#2-全局曝光（global-shutter）" class="headerlink" title="2. 全局曝光（global shutter）"></a>2. 全局曝光（global shutter）</h3><p>每一行的起始曝光和终止曝光的时间一致，目前只有电警设备上用到，价格昂贵。因为电警设备有爆闪灯，爆闪灯亮的时间很短。如果使用卷帘曝光的sensor，一幅图像才曝光几行灯就熄灭了，所以必须要用全局曝光的传感器。</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>ISP</tag>
      </tags>
  </entry>
  <entry>
    <title>python加速库numba的使用</title>
    <url>/posts/7529006a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>最近写ISP算法的时候，发现Python运行循环特别的慢，终于在网上找到了可以加速Python循环的方法。速度实测下来提升有一百倍以上。</p>
<h2 id="numba简介"><a href="#numba简介" class="headerlink" title="numba简介"></a>numba简介</h2><p>Numba 是 Python 的实时编译器，它特别适合使用 NumPy 数组和函数以及循环的代码。</p>
<p>Numba 会读取修饰函数的 Python 字节码，并结合有关函数输入参数类型的信息。它分析和优化您的代码，最后使用 LLVM 编译器库生成函数的机器代码版本，根据您的 CPU 功能进行定制。然后每次调用函数时都会使用此编译版本。</p>
<p>Numba 必须编译函数在执行函数的机器代码版本之前给出的参数类型，这需要时间。但是，一旦编译完成，Numba 将缓存函数的机器代码版本，用于提供的特定类型的参数。如果再次调用具有相同类型的 ，它可以重用缓存的版本，而不必再次编译。（第一次执行会比较慢）</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>在函数前面加上 <code>@jit</code><br>编译选项：</p>
<ul>
<li>nopython：Numba有两种编译模式：非python模式和对象模式。前者生成更快的代码，但有限制。<code>@jit(nopython=True)</code></li>
<li>cache：为了避免每次调用 Python 程序时编译时间，可以指示 Numba 将函数编译的结果写入基于文件的缓存中。<code>@jit(cache=True)</code></li>
<li>parallel：为已知具有并行语义的函数中的这些操作启用自动并行化（和相关优化）<code>@jit(nopython=True, parallel=True)</code></li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">100</span>).reshape(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@jit(nopython=True) # Set "nopython" mode for best performance, equivalent to @njit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">go_fast</span><span class="params">(a)</span>:</span> <span class="comment"># Function is compiled to machine code when called the first time</span></span><br><span class="line">    trace = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(a.shape[<span class="number">0</span>]):   <span class="comment"># Numba likes loops</span></span><br><span class="line">        trace += np.tanh(a[i, i]) <span class="comment"># Numba likes NumPy functions</span></span><br><span class="line">    <span class="keyword">return</span> a + trace              <span class="comment"># Numba likes NumPy broadcasting</span></span><br><span class="line"></span><br><span class="line">print(go_fast(x))</span><br></pre></td></tr></tbody></table></figure>

<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>比如说坏点校正的算法，会对每个像素点都进行一个判断，关键的循环部位利用numba进行加速。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bad_pixel_correction</span><span class="params">(raw: RawImageInfo, params: RawImageParams)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    function: bad_pixel_correction</span></span><br><span class="line"><span class="string">    correct for the bad (dead, stuck, or hot) pixels</span></span><br><span class="line"><span class="string">    input: raw:RawImageInfo() params:RawImageParams()</span></span><br><span class="line"><span class="string">    卷积核neighborhood_size * neighborhood_size，当这个值大于卷积核内最大的值或者小于最小的值，会将这个值替代掉</span></span><br><span class="line"><span class="string">    这个算法应该会损失不少分辨率</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    neighborhood_size = params.get_size_for_bad_pixel_correction()</span><br><span class="line">    <span class="keyword">if</span> ((neighborhood_size % <span class="number">2</span>) == <span class="number">0</span>):</span><br><span class="line">        print(<span class="string">"neighborhood_size shoud be odd number, recommended value 3"</span>)</span><br><span class="line">        <span class="keyword">return</span> raw</span><br><span class="line"></span><br><span class="line">    raw_data = raw.get_raw_data()</span><br><span class="line">    raw_channel_data = list()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (raw.get_color_space() == <span class="string">"raw"</span>):</span><br><span class="line">        ret_img = RawImageInfo()</span><br><span class="line">        ret_img.create_image(<span class="string">'after bad pixel correction'</span>, raw_data.shape)</span><br><span class="line">        <span class="comment"># Separate out the quarter resolution images</span></span><br><span class="line">        D = split_raw_data(raw_data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># number of pixels to be padded at the borders</span></span><br><span class="line">        <span class="comment">#no_of_pixel_pad = math.floor(neighborhood_size / 2.)</span></span><br><span class="line">        no_of_pixel_pad = neighborhood_size // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">0</span>, len(D)):  <span class="comment"># perform same operation for each quarter</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># display progress</span></span><br><span class="line">            print(<span class="string">"bad pixel correction: Quarter "</span> + str(idx+<span class="number">1</span>) + <span class="string">" of 4"</span>)</span><br><span class="line"></span><br><span class="line">            img = D[idx]</span><br><span class="line">            width, height = img.shape[<span class="number">1</span>], img.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># pad pixels at the borders, 扩充边缘</span></span><br><span class="line">            img = np.pad(img,</span><br><span class="line">                            (no_of_pixel_pad, no_of_pixel_pad),</span><br><span class="line">                            <span class="string">'reflect'</span>)  <span class="comment"># reflect would not repeat the border value</span></span><br><span class="line">            </span><br><span class="line">            raw_channel_data.append(bad_pixel_correction_subfunc(img, no_of_pixel_pad,width,height))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Regrouping the data</span></span><br><span class="line">        ret_img.data[::<span class="number">2</span>, ::<span class="number">2</span>] = raw_channel_data[<span class="number">0</span>]</span><br><span class="line">        ret_img.data[::<span class="number">2</span>, <span class="number">1</span>::<span class="number">2</span>] = raw_channel_data[<span class="number">1</span>]</span><br><span class="line">        ret_img.data[<span class="number">1</span>::<span class="number">2</span>, ::<span class="number">2</span>] = raw_channel_data[<span class="number">2</span>]</span><br><span class="line">        ret_img.data[<span class="number">1</span>::<span class="number">2</span>, <span class="number">1</span>::<span class="number">2</span>] = raw_channel_data[<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">return</span> ret_img</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        params.set_error_str(<span class="string">"bad pixel correction need RAW data"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@jit(nopython=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bad_pixel_correction_subfunc</span><span class="params">(img, no_of_pixel_pad, width, height)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(no_of_pixel_pad, height + no_of_pixel_pad):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(no_of_pixel_pad, width + no_of_pixel_pad):</span><br><span class="line">            <span class="comment"># save the middle pixel value</span></span><br><span class="line">            mid_pixel_val = img[i, j]</span><br><span class="line">            <span class="comment"># extract the neighborhood</span></span><br><span class="line">            neighborhood = img[i - no_of_pixel_pad: i + no_of_pixel_pad+<span class="number">1</span>,</span><br><span class="line">                                j - no_of_pixel_pad: j + no_of_pixel_pad+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># set the center pixels value same as the left pixel</span></span><br><span class="line">            <span class="comment"># Does not matter replace with right or left pixel</span></span><br><span class="line">            <span class="comment"># is used to replace the center pixels value</span></span><br><span class="line">            neighborhood[no_of_pixel_pad,</span><br><span class="line">                            no_of_pixel_pad] = neighborhood[no_of_pixel_pad, no_of_pixel_pad<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">            min_neighborhood = np.min(neighborhood)</span><br><span class="line">            max_neighborhood = np.max(neighborhood)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mid_pixel_val < min_neighborhood):</span><br><span class="line">                img[i, j] = min_neighborhood</span><br><span class="line">            <span class="keyword">elif</span> (mid_pixel_val > max_neighborhood):</span><br><span class="line">                img[i, j] = max_neighborhood</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                img[i, j] = mid_pixel_val</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Put the corrected image to the dictionary</span></span><br><span class="line">    <span class="keyword">return</span> img[no_of_pixel_pad: height + no_of_pixel_pad, no_of_pixel_pad: width + no_of_pixel_pad]</span><br></pre></td></tr></tbody></table></figure>



</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numba</tag>
      </tags>
  </entry>
  <entry>
    <title>gamma之我见</title>
    <url>/posts/445bb88c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>我对gamma的理解是，根据人眼的特性，对真实世界的动态范围进行压缩的一种方法</p>
<h2 id="以前对gamma的理解"><a href="#以前对gamma的理解" class="headerlink" title="以前对gamma的理解"></a>以前对gamma的理解</h2><p>以前我对gamma的理解就是，sensor对光线的感知是线性的，而人眼对gamma的感知是非线性的，因此需要一个映射。</p>
<p>camera拍出来的raw图，如果直接看，大部分区域都特别的暗，和现实世界完全不一样，因此需要通过gamma将暗处提亮<br>这个其实只是站在ISP调试的角度去理解ISP的。</p>
<p>这就带来了很多的问题，现实世界是线性的，为什么图片就要转成非线性？</p>
<p>raw图应该就是现实世界的还原，为什么我看raw图特别的暗呢？那我们平时通过显示屏看图片的时候，图片经过了一系列的非线性转换，为什么还和真实世界相同的效果呢？难道真实世界是指数的？</p>
<h2 id="gamma理解的更新"><a href="#gamma理解的更新" class="headerlink" title="gamma理解的更新"></a>gamma理解的更新</h2><p>了解了显示屏的gamma，终于打通了摄像头从拍照到显示的这个回路，理解了为什么要用gamma</p>
<p>首先摄像头是线性感光的，现实世界的光线强度就是线性的，这个动态范围是很大的，通常摄像机拍出来的raw图都是12比特的，也就是说动态范围可以到10^12。即可以测量的最亮亮度是最暗亮度的4096倍，转换成db，就是72dB。当然即使是这样的动态范围，还是不足以完美的描述现实世界，因此搞了一系列的高动态范围的操作，可以让动态范围进一步的扩大。</p>
<p>但是拍出来的照片需要考虑存储，如果线性存储的话，这个存储量是很惊人的。有没有方法把现实世界12比特以上的数据压缩到8比特呢？通过移位肯定是不行的，会造成精度损失。因此聪明的科学家根据人眼对亮度的感受是成指数的原理，对数据进行非线性压缩，这个gamma曲线是经过实验得出的。亮处压缩的多，暗处压缩的少</p>
<p>最后一步就是对照片的还原。显示屏，和现实世界以及camera拍出来的raw图一样，都是一个线性的世界，而存储的图片亮度是个非线性域。图片怎么压缩的，就来一个反变换函数进行解析（解码）。<br>微软联合惠普和爱普生提出了sRGB标准，推荐显示器的gamma值为2.2。display P3的标准gamma值为2.6，由于这个gamma值更大一点，所以P3的照片用普通的显示器看应该更亮一点，sRGB的照片用p3显示器看应该更暗一点，还可能会让亮度的差异变得更加明显，不够平滑，导致大面积色块的问题。</p>
<h2 id="和渲染之间的联系"><a href="#和渲染之间的联系" class="headerlink" title="和渲染之间的联系"></a>和渲染之间的联系</h2><p>游戏界也长期忽略了显示器的gamma问题，导致渲染的画面偏暗，错了几十年。游戏渲染的其实是个线性世界，如果直接输出显示，由于显示器自带一个2.2的gamma，会导致渲染出来的画面总是暗沉沉的。因此游戏渲染在输出前需要先用gamma进行gamma矫正，再送去显示。</p>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>既然显示屏是按照2.2次方的gamma对图片进行还原，理论上isp应该让照片更加符合现实场景，那么为什么不直接在raw图上用1/2.2次方的gamma处理呢？</p>
<p><strong>我的思考</strong>：可能是由于镜头的影响，sensor感知到世界和现实世界有一定的差距，同时很多时候都需要对图片进行一个对比度等效果的增强，如果在这个基础上再去乘以一个增益，会带来更多的精度损失，还不如用一条自定义的gamma一步到位。</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像</category>
      </categories>
      <tags>
        <tag>ISP</tag>
        <tag>gamma</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake 指南</title>
    <url>/posts/83169df8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="1-基础语法"><a href="#1-基础语法" class="headerlink" title="1. 基础语法"></a>1. 基础语法</h2><h2 id="（一）-基础语法"><a href="#（一）-基础语法" class="headerlink" title="（一） 基础语法"></a>（一） 基础语法</h2><h3 id="1-指定cmake最低版本"><a href="#1-指定cmake最低版本" class="headerlink" title="1. 指定cmake最低版本"></a>1. 指定cmake最低版本</h3><p><code>cmake_minimum_required (VERSION 2.6)</code></p>
<h3 id="2-设置项目名称"><a href="#2-设置项目名称" class="headerlink" title="2. 设置项目名称"></a>2. 设置项目名称</h3><p><code>project (LearnCMake)</code></p>
<h3 id="3-创建可执行程序"><a href="#3-创建可执行程序" class="headerlink" title="3.创建可执行程序"></a>3.创建可执行程序</h3><p> add_executable函数用于创建一个可执行程序工程。</p>
<p>  add_executable(<name> [WIN32] [MACOSX_BUNDLE]</name></p>
<p>​        [EXCLUDE_FROM_ALL]</p>
<p>​        source1 [source2 …])</p>
<p>  如下所示：</p>
<p><code>add_executable(FirstExecutable hello_world.cpp)</code></p>
<p>  也可以添加多个源文件到工程中，如下：</p>
<p><code>add_executable(FirstExecutable main.cpp app_util.h app_util.cpp)</code></p>
<h3 id="4-创建库文件工程（a-so-lib-dll"><a href="#4-创建库文件工程（a-so-lib-dll" class="headerlink" title="4. 创建库文件工程（a/so/lib/dll)"></a>4. 创建库文件工程（a/so/lib/dll)</h3><p>add_library函数用于创建一个库文件工程。</p>
<p>  add_library(<name> [STATIC | SHARED | MODULE]</name></p>
<p>​        [EXCLUDE_FROM_ALL]</p>
<p>​        source1 [source2 …])</p>
<p>  如下所示：</p>
<p>  <code>add_library(SecondLibrary second_library.cpp)</code></p>
<p>  和add_executable一样，也可以添加多个源文件。</p>
<p><code>add_library(SecondLibrary test.cpp app_util.h app_util.cpp)</code></p>
<p>  默认的是静态库，也可以显式的设置库是否为静态库、动态库或者是模块。另外BUILD_SHARED_LIBS也可控制编译成哪种库。</p>
<p><code>add_library(SecondLibrary SHARED second_library.cpp)</code></p>
<h3 id="5、set设置变量"><a href="#5、set设置变量" class="headerlink" title="5、set设置变量"></a>5、<strong>set设置变量</strong></h3><p>  前面的add_library和add_executable可以添加多个源文件，但是文件多了之后可能会一行占用很长，因此我们可以使用set函数来进行变量赋值，然后在调用add_library和add_executable生成项目。</p>
<p>  如下所示，效果和前面的示例一样。</p>
<figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(SOURCES </span><br><span class="line">    <span class="variable">${PROJECT_SOURCE_DIR}</span>/src/datastruct_test.c</span><br><span class="line">    <span class="variable">${PROJECT_SOURCE_DIR}</span>/src/app.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">set</span>(HEADER</span><br><span class="line">    <span class="variable">${PROJECT_SOURCE_DIR}</span>/inc</span><br><span class="line">)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">${PROJECT_NAME}</span> <span class="variable">${HEADER}</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">${PROJECT_NAME}</span> <span class="variable">${SOURCES}</span>)</span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">${PROJECT_NAME}</span> <span class="variable">${SOURCES}</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>  使用set函数，还可以对变量值进行累加，如下AppUtilSrcs就代表3个文件了</p>
<figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(AppUtilSrcs app_util.h app_util.cpp)</span><br><span class="line"><span class="keyword">set</span>(AppUtilSrcs <span class="variable">${AppUtilSrcs}</span> b.cpp)</span><br></pre></td></tr></tbody></table></figure>

<p>  除了文件名定义，set还用于变量定义</p>
<figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(CMAKE_BUILD_TYPE <span class="string">"Debug"</span>)  </span><br><span class="line"><span class="keyword">SET</span>(CMAKE_CXX_FLAGS_DEBUG <span class="string">"$ENV{CXXFLAGS} -O0 -Wall -g2 -ggdb -lpthread"</span>)  </span><br><span class="line"><span class="keyword">SET</span>(CMAKE_CXX_FLAGS_RELEASE <span class="string">"$ENV{CXXFLAGS} -O3 -Wall -lpthread"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="6、代码控制"><a href="#6、代码控制" class="headerlink" title="6、代码控制"></a>6、<strong>代码控制</strong></h3><p>  如果一个项目太大，文件成千上万，那么一个一个文件的添加太过于麻烦了，因此cmake使用aux_source_directory函数来添加目录到工程中。</p>
<p>  如下所示，将目录下所有文件赋值给第一个变量，然后将这个变量加到工程中。</p>
<figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># find all source file in src</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">${PROJECT_SOURCE_DIR}</span>/src SOURCES)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"SRC FILES: "</span> <span class="variable">${SOURCES}</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">${PROJECT_NAME}</span> <span class="variable">${SOURCES}</span>)</span><br></pre></td></tr></tbody></table></figure>



<p>除了添加文件目录外，我们经常还需要包含第三方库（头文件、库文件）等需求，添加头文件目录功能如下：</p>
<ul>
<li><p>include_directories函数用于添加头文件包含目录。</p>
</li>
<li><p>link_directories函数用于添加需要链接文件的库目录。</p>
</li>
<li><p>link_libraries函数用于添加需要连接的库文件。</p>
</li>
</ul>
<figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="variable">${PROJECT_NAME}</span> <span class="variable">${PROJECT_SOURCE_DIR}</span>/inc)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="string">"../thirdparty/googletest/googletest/lib"</span>) </span><br><span class="line"><span class="keyword">link_libraries</span>(<span class="string">"protobuf.so"</span>)</span><br></pre></td></tr></tbody></table></figure>



<p>链接目标文件和的库文件，使用target_link_libraries函数，这里的目标文件是指通过add_executable()和add_library()指令生成已经创建的目标文件。所以target_link_libraries是在add_executable之后，而link_libraries是在add_executable之前。</p>
<figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">${PROJECT_NAME}</span> PRIVATE <span class="variable">${OpenCV_INCLUDE_DIRS}</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">${PROJECT_NAME}</span> <span class="variable">${OpenCV_LIBS}</span>)</span><br></pre></td></tr></tbody></table></figure>



<p>从编译文件列表中排除文件，可以使用cmake提供的list的REMOVE_ITEM功能来实现。</p>
<figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(src lua_src)</span><br><span class="line"><span class="keyword">list</span>(REMOVE_ITEM lua_src <span class="string">"src/lua.c"</span>, <span class="string">"src/luac.c"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7、添加编译选项"><a href="#7、添加编译选项" class="headerlink" title="7、添加编译选项"></a>7、<strong>添加编译选项</strong></h3><p>​    cmake使用add_compile_options函数来添加编译选项，用add_definitions函数来为源文件的编译添加由-D定义的标志，示例如下：</p>
<figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">add_compile_options</span>(-std=gnu99)</span><br><span class="line"><span class="keyword">add_definitions</span>(-O3 -g -W -Wall</span><br><span class="line">  -Wno-deprecated -Woverloaded-virtual -Wwrite-strings</span><br><span class="line">  -D__WUR= -D_REENTRANT -D_FILE_OFFSET_BITS=<span class="number">64</span> -DTIXML_USE_STL</span><br><span class="line"> )</span><br></pre></td></tr></tbody></table></figure>

<p>也可以通过设置变量添加编译选项</p>
<figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># specify the C++ standard</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb debug</span></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_BUILD_TYPE <span class="string">"Debug"</span>)  </span><br><span class="line"><span class="keyword">SET</span>(CMAKE_CXX_FLAGS_DEBUG <span class="string">"$ENV{CXXFLAGS} -O0 -Wall -g2 -ggdb -lpthread"</span>)  </span><br><span class="line"><span class="keyword">SET</span>(CMAKE_CXX_FLAGS_RELEASE <span class="string">"$ENV{CXXFLAGS} -O3 -Wall -lpthread"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>注意，<strong>这两个选项都是针对所有平台、编译器</strong>，因此需要慎重使用，最好使用if来进行流程处理。</p>
<h3 id="8、添加其他的CMakeLists-txt"><a href="#8、添加其他的CMakeLists-txt" class="headerlink" title="8、添加其他的CMakeLists.txt"></a>8、<strong>添加其他的CMakeLists.txt</strong></h3><p>  一个CMakeLists.txt里面的target如果要链接其他CMakeLists.txt中的target，可以使用add_subdirectory函数，如下所示：</p>
<figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(debug)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(common)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="9、find-package"><a href="#9、find-package" class="headerlink" title="9、find_package"></a>9、<strong>find_package</strong></h3><p>  find_package 为外部工程加载设置。</p>
<p>  find_package(<package> [version] [EXACT] [QUIET]</package></p>
<p>​       [[REQUIRED|COMPONENTS] [components…]]<br>​        [NO_POLICY_SCOPE])</p>
<p>  QUIET选项将会禁掉包没有被发现时的警告信息。REQUIRED选项表示如果报没有找到的话，cmake的过程会终止，并输出警告信息。</p>
<p>  find_package可以根据cmake内置的.cmake的脚本去找相应的库的模块，调用了find_package成功之后，会有相应的变量“生成”有效。</p>
<p>  比如调用了find_package(Qt5Widgets)，返回之后就会有变量Qt5Widgets_FOUND，Qt5Widgets_INCLUDE_DIRS相应的变量生效。 然后就可以在CMakeLists.txt里面使用上述的变量了。  </p>
<figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>( OpenCV REQUIRED )</span><br><span class="line"><span class="keyword">if</span>(OpenCV_FOUND)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">"OpenCV library has found"</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">"OpenCV_INCLUDE_DIR: "</span> <span class="variable">${OpenCV_INCLUDE_DIRS}</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">"OpenCV_LIBRARY: "</span> <span class="variable">${OpenCV_LIBS}</span>)</span><br><span class="line">    <span class="keyword">target_include_directories</span>(<span class="variable">${PROJECT_NAME}</span> PRIVATE <span class="variable">${OpenCV_INCLUDE_DIRS}</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">${PROJECT_NAME}</span> <span class="variable">${OpenCV_LIBS}</span>)</span><br><span class="line"><span class="keyword">else</span>(OpenCV_FOUND)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">"OpenCV library not found"</span>)</span><br><span class="line"><span class="keyword">endif</span>(OpenCV_FOUND)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="10、条件、循环控制"><a href="#10、条件、循环控制" class="headerlink" title="10、条件、循环控制"></a>10、<strong>条件、循环控制</strong></h3><ul>
<li><p>If else结构</p>
<figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)</span><br><span class="line">    <span class="keyword">elseif</span>(condition)</span><br><span class="line">    <span class="keyword">else</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>for循环</p>
<figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(loop_var arg1 arg2 ...)</span><br><span class="line">	COMMAND1(ARGS ...)</span><br><span class="line">	COMMAND2(ARGS ...)</span><br><span class="line">	 ...</span><br><span class="line"><span class="keyword">endforeach</span>(loop_var)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>while循环</p>
  <figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endwhile</span>(condition)</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<h3 id="11、Install指令"><a href="#11、Install指令" class="headerlink" title="11、Install指令"></a>11、<strong>Install指令</strong></h3><p>Install指令用于定义安装规则，安装的内容可以包括目标二进制、动态库、静态库以及文件、目录、脚本等。</p>
<p>参数中的TARGETS后面跟的就是我们通过ADD_EXECUTABLE或者ADD_LIBRARY定义的目标文件，可能是可执行二进制、动态库、静态库。</p>
<p>目标类型也就相对应的有三种，ARCHIVE特指静态库，LIBRARY特指动态库，RUNTIME特指可执行目标二进制。</p>
<p>  INSTALL(TARGETS targets…</p>
<p>​      [[ARCHIVE|LIBRARY|RUNTIME]</p>
<p>​         [DESTINATION </p><dir>]<p></p>
<p>​         [PERMISSIONS permissions…]</p>
<p>​          [CONFIGURATIONS</p>
<p>​      [Debug|Release|…]]</p>
<p>​          [COMPONENT <component>]</component></p>
<p>​          [OPTIONAL]</p>
<p>​         ] […])</p>
<p>  示例如下：</p>
<figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="keyword">INSTALL</span>(TARGETS myrun mylib mystaticlib</span><br><span class="line">    RUNTIME DESTINATION bin</span><br><span class="line">    LIBRARY DESTINATION lib</span><br><span class="line">    ARCHIVE DESTINATION libstatic</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<p>  可执行二进制myrun安装到${CMAKE_INSTALL_PREFIX}/bin目录</p>
<p>  动态库libmylib安装到${CMAKE_INSTALL_PREFIX}/lib目录</p>
<p>  静态库libmystaticlib安装到${CMAKE_INSTALL_PREFIX}/libstatic目录</p>
<p>  特别注意的是你不需要关心TARGETS具体生成的路径，只需要写上TARGETS名称就可以了。</p>
<h2 id="（二）使用cmake流程"><a href="#（二）使用cmake流程" class="headerlink" title="（二）使用cmake流程"></a>（二）使用cmake流程</h2><h3 id="1-linux下使用"><a href="#1-linux下使用" class="headerlink" title="1. linux下使用"></a>1. linux下使用</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install cmake</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> code <span class="built_in">source</span> direction</span></span><br><span class="line">cd ~/code</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">rm -r *</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Debug ..</span><br><span class="line">cmake --build . #可以使用make -j16，支持并行编译</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-windows下使用"><a href="#2-windows下使用" class="headerlink" title="2. windows下使用"></a>2. windows下使用</h3><ol>
<li>安装mingw</li>
<li>安装mingw安装package中的mingw32-gcc-g++-bin（用来编译），mingw32-gdb-bin(用来调试)</li>
<li>添加环境变量</li>
<li>最后运行<ol>
<li><strong>每次cmake之前删除build里的缓存</strong></li>
<li><code>cd build</code></li>
<li><code>cmake -G "Unix Makefiles" ../</code> <strong>(非常重要)</strong></li>
</ol>
</li>
</ol>
<h2 id="（三）自动生成版本信息"><a href="#（三）自动生成版本信息" class="headerlink" title="（三）自动生成版本信息"></a>（三）自动生成版本信息</h2><h2 id="1-获取git信息：commit号和分支信息"><a href="#1-获取git信息：commit号和分支信息" class="headerlink" title="1. 获取git信息：commit号和分支信息"></a>1. 获取git信息：commit号和分支信息</h2><p>通过git log -1 –pretty=format:%H获取commit号</p>
<p>通过git symbolic-ref –short -q HEAD获取分支信息</p>
<p>示例如下：</p>
<figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># get git version</span></span><br><span class="line"><span class="keyword">set</span>(COMMIT_HASH <span class="string">""</span>)</span><br><span class="line"><span class="keyword">set</span>(BRANCH_NAME <span class="string">""</span>)</span><br><span class="line"><span class="keyword">find_package</span>(Git QUIET)</span><br><span class="line"><span class="keyword">if</span>(GIT_FOUND)</span><br><span class="line"><span class="keyword">execute_process</span>(</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">${GIT_EXECUTABLE}</span> log -<span class="number">1</span> --pretty=format:%H</span><br><span class="line">    OUTPUT_VARIABLE COMMIT_HASH</span><br><span class="line">    OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">    ERROR_QUIET</span><br><span class="line">    WORKING_DIRECTORY <span class="variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">execute_process</span>(</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">${GIT_EXECUTABLE}</span> symbolic-ref --short -q HEAD</span><br><span class="line">    OUTPUT_VARIABLE BRANCH_NAME</span><br><span class="line">    OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">    ERROR_QUIET</span><br><span class="line">    WORKING_DIRECTORY <span class="variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">string</span>(SUBSTRING <span class="variable">${COMMIT_HASH}</span> <span class="number">0</span> <span class="number">8</span> COMMIT_HASH)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"Git version is ${BRANCH_NAME}:${COMMIT_HASH}"</span>)</span><br><span class="line"><span class="keyword">add_definitions</span>(-DCOMMIT_HASH=\<span class="string">"${COMMIT_HASH}\")</span></span><br><span class="line"><span class="string">add_definitions(-DBRANCH_NAME=\"${BRANCH_NAME}\")</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="（四）opencv的集成"><a href="#（四）opencv的集成" class="headerlink" title="（四）opencv的集成"></a>（四）opencv的集成</h2><h3 id="1-linux下集成opencv"><a href="#1-linux下集成opencv" class="headerlink" title="1. linux下集成opencv:"></a>1. linux下集成opencv:</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libopencv-dev</span><br></pre></td></tr></tbody></table></figure>

<p>直接就可以编译了</p>
<h3 id="2-windows下集成opencv"><a href="#2-windows下集成opencv" class="headerlink" title="2. windows下集成opencv"></a>2. windows下集成opencv</h3><p>去官网下载opencv windows安装包，运行就生成一个文件夹。里面有两个目录，build和source，build放的是预编译好的库，source里面放的是源码。</p>
<p>把build\x64\vc15\lib加入到环境变量中，看下代码运行是否正确。</p>
<h4 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h4><p>正常来说会报mutux找不到定义的错误。</p>
<p>那是因为mingw多线程的库有问题，必须要特定64位版本的才能够安装</p>
<p>下载安装：<a href="https://sourceforge.net/projects/mingwbuilds/files/host-windows/releases/4.8.1/64-bit/threads-posix/seh/x64-4.8.1-release-posix-seh-rev5.7z/download" target="_blank" rel="noopener">MinGW-x64-4.8.1-release-posix-seh-rev5</a></p>
<p>并把mingw的bin文件加到环境变量中去，就可以运行了。</p>
<h4 id="问题2："><a href="#问题2：" class="headerlink" title="问题2："></a>问题2：</h4><p>确认自己的cmake把opencv的库加进去的情况下，还是找不到imread等常用函数路径。那很可能是预编译没有编译出适合你电脑系统的库，需要自己编译opencv库</p>
<p>在source文件夹下新建一个build目录。编译的时候用mingw32-make -j16多线程编译会比cmake –build .更快一点</p>
<figure class="highlight powershell"><table><tbody><tr><td class="code"><pre><span class="line">cmake <span class="literal">-DCMAKE_BUILD_TYPE</span>=Release <span class="literal">-DCMAKE_EXPORT_COMPILE_COMMANDS</span>=ON .. <span class="literal">-G</span> <span class="string">"MinGW Makefiles"</span></span><br><span class="line">mingw32<span class="literal">-make</span> <span class="literal">-j16</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="问题3："><a href="#问题3：" class="headerlink" title="问题3："></a>问题3：</h4><p>windows下编译的时候会出现这个问题：</p>
<p>gcc: error: long: No such file or directory</p>
<p>解决方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cmake -DOPENCV_ENABLE_ALLOCATOR_STATS=OFF -DCMAKE_BUILD_TYPE=Release -DCMAKE_EXPORT_COMPILE_COMMANDS=ON .. -G "MinGW Makefiles"</span><br></pre></td></tr></tbody></table></figure>

<h4 id="问题4："><a href="#问题4：" class="headerlink" title="问题4："></a>问题4：</h4><p>编译完成后，用cmake编译opencv的样例的时候发现，cmake打印出来的include路径不对。</p>
<p>需要编译之后安装！</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cmake --install .</span><br></pre></td></tr></tbody></table></figure>

<p>接着把生成的库绝对路径：sources\build\install\x64\mingw\lib加入环境变量，注意这个要看编译器，不同的编译器和系统产生的库路径不一样</p>
<h4 id="问题5："><a href="#问题5：" class="headerlink" title="问题5："></a>问题5：</h4><p>在本地电脑上运行样例程序，提示缺少dll库</p>
<p>需要把source/build/bin加入环境变量</p>
<h3 id="cmake-模板"><a href="#cmake-模板" class="headerlink" title="cmake 模板"></a>cmake 模板</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># TODO: Set the project name</span><br><span class="line">project(opencv_sample)</span><br><span class="line">message("====================================================")</span><br><span class="line">message(STATUS "build app: " ${PROJECT_NAME})</span><br><span class="line"> </span><br><span class="line"># TODO: set source file (c/cpp)</span><br><span class="line">set(SOURCES </span><br><span class="line">    ${PROJECT_SOURCE_DIR}/src/opencv_sample.cpp</span><br><span class="line">)</span><br><span class="line">message(STATUS "SRC FILES: " ${SOURCES})</span><br><span class="line"></span><br><span class="line"># set output file path</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR})</span><br><span class="line">message(STATUS "BUILD EXE: " ${EXECUTABLE_OUTPUT_PATH} "/" ${PROJECT_NAME})</span><br><span class="line"></span><br><span class="line"># Add an executable</span><br><span class="line">add_executable(${PROJECT_NAME} ${SOURCES})</span><br><span class="line"></span><br><span class="line"># find opencv package</span><br><span class="line">find_package( OpenCV REQUIRED )</span><br><span class="line">if(OpenCV_FOUND)</span><br><span class="line">    message(STATUS "OpenCV library has found")</span><br><span class="line">    message(STATUS "OpenCV_INCLUDE_DIR: " ${OpenCV_INCLUDE_DIRS})</span><br><span class="line">    message(STATUS "OpenCV_LIBRARY: " ${OpenCV_LIBS})</span><br><span class="line">    target_include_directories(${PROJECT_NAME} PRIVATE ${OpenCV_INCLUDE_DIRS})</span><br><span class="line">    target_link_libraries(${PROJECT_NAME} ${OpenCV_LIBS})</span><br><span class="line">else(OpenCV_FOUND)</span><br><span class="line">    message(FATAL_ERROR "OpenCV library not found")</span><br><span class="line">endif(OpenCV_FOUND)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="（五）-QT的集成"><a href="#（五）-QT的集成" class="headerlink" title="（五） QT的集成"></a>（五） QT的集成</h2><p>类似opencv，但是不需要自己编译了</p>
<p>在官网下载安装包：<a href="https://download.qt.io/official_releases/" target="_blank" rel="noopener">https://download.qt.io/official_releases/</a></p>
<p>选择QT版本，不需要全部勾选，比如我是mingw64编译器，那就选择mingw64版本的</p>
<p>然后把安装路径的Qt\5.15.0\mingw81_64\lib\cmake和C:\Qt\5.15.0\mingw81_64\bin加入环境变量，QT的安装就算完成了</p>
<p>cmake模版：</p>
<figure class="highlight cmake"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(ImageTools LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_INCLUDE_CURRENT_DIR <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOUIC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOMOC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTORCC <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># find all source file in src</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">${PROJECT_SOURCE_DIR}</span> SOURCES)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"SRC FILES: "</span> <span class="variable">${SOURCES}</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">${PROJECT_NAME}</span> <span class="variable">${PROJECT_SOURCE_DIR}</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找当前文件夹中所有的ui文件</span></span><br><span class="line"><span class="keyword">set</span>(UI_FILES</span><br><span class="line">    mainwindow.ui</span><br><span class="line">    imageeditor.ui</span><br><span class="line">    staticsview.ui</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加资源文件</span></span><br><span class="line"><span class="keyword">set</span>( QRCS resource.qrc )</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Qt5 COMPONENTS Widgets Core Gui REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ANDROID)</span><br><span class="line">  <span class="keyword">add_library</span>( <span class="variable">${PROJECT_NAME}</span> <span class="variable">${SOURCES}</span> <span class="variable">${UI_FILES}</span> <span class="variable">${QRCS}</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">add_executable</span>( <span class="variable">${PROJECT_NAME}</span> <span class="variable">${SOURCES}</span> <span class="variable">${UI_FILES}</span> <span class="variable">${QRCS}</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(ImageTools PRIVATE Qt5::Widgets Qt5::Core Qt5::Gui)</span><br></pre></td></tr></tbody></table></figure>
</dir></body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>编译</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>高通老平台 camera 驱动指南</title>
    <url>/posts/7e4fe84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="摄像头驱动指南"><a href="#摄像头驱动指南" class="headerlink" title="摄像头驱动指南"></a>摄像头驱动指南</h2><h3 id="（一）内核驱动"><a href="#（一）内核驱动" class="headerlink" title="（一）内核驱动"></a>（一）内核驱动</h3><h4 id="1-GPIO"><a href="#1-GPIO" class="headerlink" title="1. GPIO"></a>1. GPIO</h4><p>kernel/Documentation/devicetree/bindings/media/video/ </p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">gpios = <&msmgpio 15 0>, </span><br><span class="line">             <&msmgpio 90 0>, </span><br><span class="line">             <&msmgpio 89 0>; </span><br><span class="line">qcom,gpio-reset = <1>; </span><br><span class="line">qcom,gpio-standby = <2>;</span><br><span class="line"></span><br><span class="line">qcom,gpio-req-tbl-num = <0 1 2>; </span><br><span class="line">qcom,gpio-req-tbl-flags = <1 0 0>; </span><br><span class="line">qcom,gpio-req-tbl-label = "CAMIF_MCLK", </span><br><span class="line">                                          "CAM_RESET1", </span><br><span class="line">                                           "CAM_STANDBY"; </span><br><span class="line">qcom,gpio-set-tbl-num = <1 1>; </span><br><span class="line">qcom,gpio-set-tbl-flags = <0 2>; </span><br><span class="line">qcom,gpio-set-tbl-delay = <1000 30000>;</span><br></pre></td></tr></tbody></table></figure>

<p>实现I2C的功能</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">gpios = <&msm_gpio 29 0>, </span><br><span class="line">             <&msm_gpio 30 0>; </span><br><span class="line">qcom,gpio-tbl-num = <0 1>; </span><br><span class="line">qcom,gpio-tbl-flags = <1 1>; </span><br><span class="line">qcom,gpio-tbl-label = "CCI_I2C_DATA0", </span><br><span class="line">                                     "CCI_I2C_CLK0";</span><br></pre></td></tr></tbody></table></figure>



<h4 id="2-时钟"><a href="#2-时钟" class="headerlink" title="2. 时钟"></a>2. 时钟</h4><p>设置时钟源</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">clocks = <&clock_gcc clk_mclk0_clk_src>, </span><br><span class="line">               <&clock_gcc clk_gcc_camss_mclk0_clk>; </span><br><span class="line">clock-names = "cam_src_clk", "cam_clk";</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-供电"><a href="#3-供电" class="headerlink" title="3. 供电"></a>3. 供电</h4><p>PMIC供电</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cam_vdig-supply = <&pm8916_s4>; </span><br><span class="line"> cam_vana-supply = <&pm8916_l17>; </span><br><span class="line"> cam_vio-supply = <&pm8916_l6>; </span><br><span class="line"> cam_vaf-supply = <&pm8916_l10>;</span><br></pre></td></tr></tbody></table></figure>

<p>CAM_VANA – Supply voltage (模拟)<br>CAM_VDIG – Supply voltage (数字)<br>CAM_VAF – Supply voltage (Actuator 电压)<br>CAM_VIO – Input/output voltage (IO数字)</p>
<p>也可以通过GPIO控制外部的LDO供电</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">gpios = <&msm_gpio 27 0>, </span><br><span class="line">             <&msm_gpio 28 0>, </span><br><span class="line">             <&msm_gpio 33 0>, </span><br><span class="line">             <&msm_gpio 114 0>, </span><br><span class="line">             <&msm_gpio 110 0>; </span><br><span class="line">qcom,gpio-reset = <1>; </span><br><span class="line">qcom,gpio-standby = <2>; </span><br><span class="line">qcom,gpio-vdig = <3>; </span><br><span class="line">qcom,gpio-vana = <4>; </span><br><span class="line">qcom,gpio-req-tbl-num = <0 1 2 3 4>; </span><br><span class="line">qcom,gpio-req-tbl-flags = <1 0 0 0 0>; </span><br><span class="line">qcom,gpio-req-tbl-label = "CAMIF_MCLK", </span><br><span class="line">                                "CAM_RESET", </span><br><span class="line">                                "CAM_STANDBY", </span><br><span class="line">                                "CAM_VDIG", </span><br><span class="line">                                "CAM_VANA";</span><br></pre></td></tr></tbody></table></figure>

<h4 id="4-YUV-I2C-地址配置-bayer的配置在用户空间中"><a href="#4-YUV-I2C-地址配置-bayer的配置在用户空间中" class="headerlink" title="4. YUV I2C 地址配置(bayer的配置在用户空间中)"></a>4. YUV I2C 地址配置(bayer的配置在用户空间中)</h4><h3 id="（二）用户空间驱动"><a href="#（二）用户空间驱动" class="headerlink" title="（二）用户空间驱动"></a>（二）用户空间驱动</h3><h4 id="1-sensor初始化参数"><a href="#1-sensor初始化参数" class="headerlink" title="1. sensor初始化参数"></a>1. sensor初始化参数</h4><p>包括支持模式，安装位置和安装角度</p>
<h4 id="2-sensor输出配置"><a href="#2-sensor输出配置" class="headerlink" title="2. sensor输出配置"></a>2. sensor输出配置</h4><p>bayer或者YUV</p>
<p>连接模式MIPI或者parallel</p>
<p>输出的sensor尺寸会有要求，具体需要看sensor手册，比如说长宽需要是多少的倍数，起始点的横纵坐标是多少的倍数</p>
<p><img src="https://image.qinxing.xyz/20201015163802.png" alt="sensor尺寸的要求"></p>
<h4 id="3-bayer-slave配置"><a href="#3-bayer-slave配置" class="headerlink" title="3. bayer slave配置"></a>3. bayer slave配置</h4><ol>
<li><p>I2C slave地址以及地址类型</p>
</li>
<li><p>sensor id寄存器地址，写入sensor_id_info数据结构</p>
</li>
<li><p>上下电设置，写入mm_sensor_power_setting结构体</p>
</li>
</ol>
<h4 id="4-输出尺寸表"><a href="#4-输出尺寸表" class="headerlink" title="4. 输出尺寸表"></a>4. 输出尺寸表</h4><p>vt_pixel_clk = line_length_pclk * frame_length * frame rate</p>
<p>用于曝光时间的计算，可以用来AEC算法的antibanding校正</p>
<p>op_pixel_clk VFE时钟</p>
<p>op_pixel_clk  = （sensor 输出实际比特率）/bits-per-pixel</p>
<p>如果MIPI DDR时钟值（MIPI lane的频率)为300Mhz，同时sensor使用4个lane传输数据，每个lane的数据率为300 * 2 = 600Mhz，因此总数据率为600* 4 = 2400Mhz，对于10bit的bayer sensor,op_pixel_clk  的值可设置为2400 / 10 = 240Mhz。实际测试下来，这个时钟值可以大不能小</p>
<h4 id="5-chromatix参数"><a href="#5-chromatix参数" class="headerlink" title="5. chromatix参数"></a>5. chromatix参数</h4><h4 id="6-sensor寄存器地址"><a href="#6-sensor寄存器地址" class="headerlink" title="6. sensor寄存器地址"></a>6. sensor寄存器地址</h4><ol>
<li>曝光寄存器</li>
</ol>
<p>vert_offset - 曝光行数上限的边界值，曝光行数任何情况下都应该小于frame_length_lines减去vert_offset</p>
<ol start="2">
<li>输出控制寄存器地址</li>
</ol>
<h4 id="7-MIPI接收器配置"><a href="#7-MIPI接收器配置" class="headerlink" title="7. MIPI接收器配置"></a>7. MIPI接收器配置</h4><ol>
<li>CSI-PHY config 设置lane参数</li>
<li>csi_lane_assign对sensor和MSM的lan进行映射，调整顺序</li>
<li>CSI-D配置 这个没太懂，一般应该都是CSI_RAW10</li>
</ol>
<h4 id="8-寄存器设定"><a href="#8-寄存器设定" class="headerlink" title="8. 寄存器设定"></a>8. 寄存器设定</h4><p>通过I2C来配置</p>
<ol>
<li><p>初始化设定</p>
</li>
<li><p>grouphold on设定</p>
<p>sensor工作时更新曝光设定需要操作很多寄存器（曝光时间，每帧行数，增益），他们必须要在同一帧内完成，这些寄存器都有双buffer，并具有按组更新的功能。表现为所有相关寄存器一起完成更新。当设定grouped parameter hold为1时，写入的寄存器数据被暂存到buffer寄存器中。</p>
</li>
<li><p>grouphold off设定</p>
<p>当设定group parameter hold为0时，曝光寄存器的值会被同时更新，参数的变化会在同一帧生效，相当于一个触发器。</p>
</li>
<li><p>分辨率设定</p>
</li>
<li><p>曝光设定 主要编写real_to_register_gain和register_to_real_gain()函数</p>
</li>
<li><p>启动输出设定</p>
<p>MIPI数据包必须在start of transmission 和 end of transmission之间发送</p>
<p>这个地方相当于启动camera</p>
</li>
<li><p>停止输出设定</p>
<p>应该要把clock和data lane置为LP11的状态，如果没有正确执行会导致相机和高通平台同步问题</p>
</li>
</ol>
<h3 id="（三）可能出现的问题"><a href="#（三）可能出现的问题" class="headerlink" title="（三）可能出现的问题"></a>（三）可能出现的问题</h3><p>当相邻两证的时间戳相差较远，会出现SOF IRQ 超时的问题，这个地方高通出现过fd泄露的问题</p>
<p>当VFE时钟的设置小于sensor的MIPI时钟，会出现VFE overflow</p>
<p>当声明的传感器输出尺寸和传感器输出尺寸不匹配时，会发生CAMIF错误。</p>
<p>为了排除CSID故障，必须启用所有CSID IRQ以检查CSID是否收到mipi数据或错误位IRQ。</p>
<p>为了对DPHY进行故障排除，必须启用DPHY调试日志以检查硬件寄存器CAMSS_A_CSI_PHY_X_MIPI_CSIPHY_INTERRUPT_STATUSY是否收到任何IRQ错误。</p>
<h3 id="（四）注意点"><a href="#（四）注意点" class="headerlink" title="（四）注意点"></a>（四）注意点</h3><ol>
<li><p>VI/ISP 的工作时钟 。 如上图中的 VI 最大工作时钟是 6 00MHz ，模式 3 840 * 2160 * 60fps 的像素时钟是 4 98MHz ，还是能够支持的；如果是模式 3 840 * 2160 * 100fps ， 那么像素时钟需要 8 30Mhz ， 超出了芯片的处理能力 。 VI 时钟 通过 vi_p0_cksel(pipe0) 寄存器来控制 ， 高分辨率高帧率下如果出现 mipi 解析数据无异常 ， 但出现 vi 中断不对的情况 ， 可以确认下这 组 寄存器的配置 。</p>
</li>
<li><p>通信数据速率。上述 sensor 端的帧率和位宽方面已提过，一般来说新的 soc 平台不会因为 mipi 或 lvds 的接受速率受限而无法对接，但是对于大分辨率较高帧率的 sensor ，还是存在这方面的风险。</p>
</li>
<li><p>输入时钟。 Sensor 依赖于外部时钟驱动，输入时钟区分为芯片平台提供和晶振提供，需要与硬件确认。如果是芯片平台提供的时钟，需要查找《 SoC 用户指南》的时钟复位配置寄存器，配置为需要的频率；如果是晶振提供，那与硬件确认晶振提供的时钟频率是什么，是否合乎需求。</p>
</li>
<li><p>注意主从模式，主要区别是sensor的行列同步信号，是有sensor内部产生还是外部产生来达到控制帧率的目的，主从模式在硬件设计以及软件配置方面有差别。</p>
</li>
</ol>
<p>如果需要详细了解，请参考《<a href="https://files.qinxing.xyz/Camera%20Sensor%20Driver%20Development%20and%20Troubleshooting.pdf" target="_blank" rel="noopener">Camera Sensor Driver Development and Troubleshooting</a>》</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
      </tags>
  </entry>
  <entry>
    <title>CHI metadata的设置与获取</title>
    <url>/posts/2d45f7e3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>HAL3对camera的控制是通过metadata进行控制的。在相机初始化的时候会获取一个默认设置，然后在请求每一帧的时候，把需要设置的参数在metadata中更新，再参数也下发下去。<br>那么带来了两个问题：</p>
<ol>
<li><p>如何对接上层，告诉它我有相应的接口，如果你想要实现某个功能，就设置metadata就行了。<br>其次如何在CHI节点中又获取到上层设置的接口呢？</p>
</li>
<li><p>CHI之间的3A，人脸识别等统计信息也是通过metadata传递的，在CHI之间如何获取呢？</p>
</li>
</ol>
<p>本文从这两个方面去解答。</p>
<h2 id="设置和获取上层的metadata"><a href="#设置和获取上层的metadata" class="headerlink" title="设置和获取上层的metadata"></a>设置和获取上层的metadata</h2><p>元数据标签可以是预定义的Android标签，也可以是定制的供应商标签。供应商标签在HAL中定义，以支持Camx和Chi所需的附加元数据。供应商标签信息有三种类型:hwVendorTagInfo、componentVendorTagsInfo和coreVendorTagInfo。我们需要添加相应的vendor标签。</p>
<p>hwVendorTagInfo: 在camxtitan17xcontext.cpp中定义，被Core、HWL、SWL等使用。这些厂商标签大多不属于HWL，它们是HW独立的。</p>
<p>componentVendorTagsInfo：这些厂商标签依赖于CHI节点，并在每个CHI组件中相应地定义。</p>
<p>coreVendorTagInfo：在核心层(camxvendortag .cpp)中定义，并由核心层或其他层使用。</p>
<p>接下来详细讲解操作步骤：</p>
<ol>
<li><p>在hwVendorTagInfo增加厂商标签信息</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//Path: vendor/qcom/proprietary/camx/src/hwl/titan17x/camxtitan17xcontext.cpp </span></span><br><span class="line"><span class="keyword">static</span> VendorTagData g_VendorTagSectionDemo[] = </span><br><span class="line">{ </span><br><span class="line">    { <span class="string">"demoTag"</span>,  VendorTagType::Byte,  <span class="number">1</span> }, </span><br><span class="line">};</span><br><span class="line"><span class="keyword">static</span> VendorTagSectionData g_HwVendorTagSections[] = </span><br><span class="line">{ </span><br><span class="line">......</span><br><span class="line"> </span><br><span class="line">    { </span><br><span class="line">        <span class="string">"org.quic.camera.DemoSection"</span>, <span class="number">0</span>, </span><br><span class="line">        CAMX_ARRAY_SIZE(g_VendorTagSectionDemo), g_VendorTagSectionDemo, </span><br><span class="line">        TagSectionVisibility::TagSectionVisibleToAll </span><br><span class="line">    },  </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>在骁龙相机中设置metadata标签</p>
<p>路径：packages/apps/SnapdragonCamera/src/com/android/camera/CaptureModule.java </p>
<ol>
<li><p>定义key</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CaptureRequest.Key<Byte> demoKey = </span><br><span class="line">            <span class="keyword">new</span> CaptureRequest.Key<>(<span class="string">"org.quic.camera.DemoSection.demoTag"</span>, <span class="keyword">byte</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>定义默认值</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mDemoKeyValue = <span class="keyword">true</span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyDemoKey</span><span class="params">(CaptureRequest.Builder request)</span> </span>{ </span><br><span class="line">        <span class="keyword">try</span> { </span><br><span class="line">            request.set(CaptureModule.demoKey, (<span class="keyword">byte</span>) (mDemoKeyValue? <span class="number">0xFF</span> : <span class="number">0x00</span>)); </span><br><span class="line">        } <span class="keyword">catch</span> (IllegalArgumentException e) { </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>应用key到每帧请求</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyCommonSettings</span><span class="params">(CaptureRequest.Builder builder, <span class="keyword">int</span> id)</span> </span>{ </span><br><span class="line">…… </span><br><span class="line">        applyDemoKey(builder); </span><br><span class="line">…… </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
</li>
<li><p>获取metadata</p>
<ol>
<li><p>camx session</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//Path: vendor/qcom/proprietary/camx/src/core/camxsession.cpp </span></span><br><span class="line">CamxResult Session::ProcessCaptureRequest( </span><br><span class="line">    <span class="keyword">const</span> ChiPipelineRequest* pPipelineRequests) </span><br><span class="line">{ </span><br><span class="line">…….. </span><br><span class="line">MetadataSlot* pMetadataSlot = </span><br><span class="line">         pPerFrameInputPool->GetSlot(m_requestBatchId[pipelinIndex]); </span><br><span class="line"><span class="keyword">if</span> (pMetadataSlot != NULL) { </span><br><span class="line">        UINT32 metaTag = <span class="number">0</span>; </span><br><span class="line">        result = VendorTagManager::QueryVendorTagLocation(<span class="string">"org.quic.camera.DemoSection"</span>, <span class="string">"demoTag"</span>, &metaTag); </span><br><span class="line">        <span class="keyword">if</span> (CamxResultSuccess == result) </span><br><span class="line">       { </span><br><span class="line">             UINT8* demoData = static_cast<UINT8*>(pMetadataSlot->GetMetadataByTag(metaTag)); </span><br><span class="line">       } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>camx pipeline</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//Path: vendor/qcom/proprietary/camx/src/core/camxpipeline.cpp</span></span><br><span class="line"><span class="function">CamxResult <span class="title">Pipeline::ProcessRequest</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    PipelineProcessRequestData* pPipelineRequestData)</span> </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">…… </span><br><span class="line">    UINT32 metaTag = <span class="number">0</span>; </span><br><span class="line">    result = VendorTagManager::QueryVendorTagLocation(<span class="string">"org.quic.camera.DemoSection"</span>, <span class="string">"demoTag"</span>, &metaTag); </span><br><span class="line">    <span class="keyword">if</span> (CamxResultSuccess == result) </span><br><span class="line">   { </span><br><span class="line">        UINT8* demoData = <span class="keyword">static_cast</span><UINT8*>(pInputSlot->GetMetadataByTag(metaTag)); </span><br><span class="line">   } </span><br><span class="line">……</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>SWL/HWL</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//Path: vendor/qcom/proprietary/camx/src/swl/sensor/camxsensornode.cpp</span></span><br><span class="line">CamxResult SensorNode::ExecuteProcessRequest( </span><br><span class="line">    ExecuteProcessRequestData* pExecuteProcessRequestData) </span><br><span class="line">{ </span><br><span class="line">…… </span><br><span class="line">    UINT32      metaTag[<span class="number">1</span>]            = { <span class="number">0</span> }; </span><br><span class="line">    UINT8*      demoData[<span class="number">1</span>]         = { <span class="number">0</span> }; </span><br><span class="line">    UINT           length                     = CAMX_ARRAY_SIZE(metaTag); </span><br><span class="line">    UINT64       configDataOffset[<span class="number">1</span>] = { <span class="number">0</span> }; </span><br><span class="line"> </span><br><span class="line">    result = VendorTagManager::QueryVendorTagLocation(<span class="string">"org.quic.camera.DemoSection"</span>, <span class="string">"demoTag"</span>, &metaTag[<span class="number">0</span>]); </span><br><span class="line">    metaTag[<span class="number">0</span>] |= InputMetadataSectionMask; </span><br><span class="line">    GetDataList(metaTag, reinterpret_cast<VOID **>(demoData), configDataOffset, length); </span><br><span class="line">……</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>CHI 节点</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//Path: vendor/qcom/proprietary/chi-cdk/vendor/node/memcpy/camxchinodememcpy.cpp </span></span><br><span class="line">CDKResult ChiMemCpyNode::ProcessRequest( </span><br><span class="line">    CHINODEPROCESSREQUESTINFO* pProcessRequestInfo) </span><br><span class="line">{  </span><br><span class="line">…… </span><br><span class="line">    CHIVENDORTAGBASEINFO vendorTagBase  = {<span class="number">0</span>}; </span><br><span class="line">    vendorTagBase.size = sizeof(CHIVENDORTAGBASEINFO); </span><br><span class="line">    vendorTagBase.pComponentName = <span class="string">"org.quic.camera.DemoSection"</span>; </span><br><span class="line">    vendorTagBase.pTagName = <span class="string">"demoTag"</span>; </span><br><span class="line"> </span><br><span class="line">    g_ChiNodeInterface.pGetVendorTagBase(&vendorTagBase); </span><br><span class="line">UINT8* demoData = static_cast<UINT8*>(ChiNodeUtils::GetMetaData( </span><br><span class="line">pProcessRequestInfo->frameNum, vendorTagBase.vendorTagBase  </span><br><span class="line">|InputMetadataSectionMask, ChiMetadataDynamic, &g_ChiNodeInterface, </span><br><span class="line">m_hChiSession));  </span><br><span class="line">……</span><br></pre></td></tr></tbody></table></figure>



</li>
</ol>
</li>
</ol>
<h2 id="CHI节点之间获取metadata"><a href="#CHI节点之间获取metadata" class="headerlink" title="CHI节点之间获取metadata"></a>CHI节点之间获取metadata</h2><p>我们在CHI节点之间需要获取metadata，那么如何获取呢，就以获取人脸检测配置为例</p>
<ol>
<li><p>找到你需要获取的vendor tag</p>
<p>vendor\qcom\proprietary\chi-cdk\cdk\fd\chifdproperty.h </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> CHAR* VendorTagSectionOEMFDConfig  = <span class="string">"org.quic.camera2.oemfdconfig"</span>; <span class="comment">///< OEM FD config vendor tag section</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> CHAR* VendorTagNameOEMFDConfig     = <span class="string">"OEMFDConfig"</span>;                  <span class="comment">///< OEM FD config vendor tag name</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>找到相关的数据结构体</p>
<p>vendor\qcom\proprietary\chi-cdk\cdk\common\chistatspropertydefines.h </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/// @brief Structure describing the rectangle coordinates</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    UINT32    left;      <span class="comment">///< x coordinate of the ROI</span></span><br><span class="line">    UINT32    top;       <span class="comment">///< y coordinate of the ROI</span></span><br><span class="line">    UINT32    <span class="built_in">width</span>;     <span class="comment">///< Width of the ROI</span></span><br><span class="line">    UINT32    <span class="built_in">height</span>;    <span class="comment">///< Height of the ROI</span></span><br><span class="line">} RectangleCoordinate;</span><br><span class="line"><span class="comment">/// @brief Describes Face ROI</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    UINT32                 id;           <span class="comment">///< Id used to track a face in the scene</span></span><br><span class="line">    UINT32                 confidence;   <span class="comment">///< Confidence of this face</span></span><br><span class="line">    RectangleCoordinate    faceRect;     <span class="comment">///< Detected Face rectangle</span></span><br><span class="line">} FaceROIData;</span><br><span class="line"><span class="comment">/// @brief Structure describing Face ROI data</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    UINT64         requestId;                       <span class="comment">///< Request ID corresponding to this results</span></span><br><span class="line">    UINT32         ROICount;                        <span class="comment">///< Number of ROIs</span></span><br><span class="line">    FaceROIData    unstabilizedROI[MaxFaceROIs];    <span class="comment">///< Unstabilized Face ROI data</span></span><br><span class="line">    FaceROIData    stabilizedROI[MaxFaceROIs];      <span class="comment">///< Stabilized Face ROI data</span></span><br><span class="line">} FaceROIInformation;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>检查需要读取的供应商标记的依赖。如果尚未发布，则增加依赖项计数。</p>
<p>如果Chi节点的处理依赖于其他标签并且标签尚未发布，则Chi节点可以在pProcessRequestInfo中设置依赖关系并立即返回。 一旦满足依赖关系，框架将再次调用ExecuteProcessRequest。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">+       <span class="comment">// Check OEMFDResults dependency </span></span><br><span class="line">+       CHIVENDORTAGBASEINFO vendorTagBase  = {<span class="number">0</span>}; </span><br><span class="line">+    vendorTagBase.<span class="built_in">size</span>                  = <span class="keyword">sizeof</span>(CHIVENDORTAGBASEINFO); </span><br><span class="line">+    vendorTagBase.pComponentName        = VendorTagSectionOEMFDResults; </span><br><span class="line">+    vendorTagBase.pTagName              = VendorTagNameOEMFDResults; </span><br><span class="line">+    g_ChiNodeInterface.pGetVendorTagBase(&vendorTagBase); </span><br><span class="line">+ </span><br><span class="line">+       tag = vendorTagBase.vendorTagBase; </span><br><span class="line">+ </span><br><span class="line">+       pData = ChiNodeUtils::GetMetaData(pProcessRequestInfo->frameNum, tag, </span><br><span class="line">ChiMetadataDynamic, </span><br><span class="line">+                                      &g_ChiNodeInterface, m_hChiSession); </span><br><span class="line">+       <span class="keyword">if</span> (<span class="literal">NULL</span> == pData) </span><br><span class="line">+    { </span><br><span class="line">+        pDependencyInfo->properties[dependencyCount]    = tag; </span><br><span class="line">+        pDependencyInfo->offsets[dependencyCount]       = <span class="number">0</span>; </span><br><span class="line">+        dependencyCount++; </span><br><span class="line">+    } </span><br><span class="line">+ </span><br><span class="line">     <span class="keyword">if</span> (dependencyCount > <span class="number">0</span>) </span><br><span class="line">     { </span><br><span class="line">         pDependencyInfo->count        = dependencyCount;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>在处理请求的函数中获取厂商标签</p>
 <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">+<span class="function">VOID <span class="title">ChiMemCpyNode::GetFDResults</span><span class="params">(UINT64 requestId)</span> </span></span><br><span class="line">+{ </span><br><span class="line">+       VOID* pData = <span class="literal">NULL</span>; </span><br><span class="line">+       UINT32 tag; </span><br><span class="line">+       CHIVENDORTAGBASEINFO vendorTagBase      = {<span class="number">0</span>}; </span><br><span class="line">+       vendorTagBase.<span class="built_in">size</span>                                      = <span class="keyword">sizeof</span>(CHIVENDORTAGBASEINFO); </span><br><span class="line">+       vendorTagBase.pComponentName            = VendorTagSectionOEMFDResults; </span><br><span class="line">+       vendorTagBase.pTagName                          = VendorTagNameOEMFDResults; </span><br><span class="line">+       g_ChiNodeInterface.pGetVendorTagBase(&vendorTagBase); </span><br><span class="line">+ </span><br><span class="line">+       tag = vendorTagBase.vendorTagBase; </span><br><span class="line">+ </span><br><span class="line">+       pData = ChiNodeUtils::GetMetaData(requestId, tag, ChiMetadataDynamic, </span><br><span class="line">+               &g_ChiNodeInterface, m_hChiSession); </span><br><span class="line">+       <span class="keyword">if</span>(pData){ </span><br><span class="line">+               LOG_ERROR(CamxLogGroupChi, <span class="string">"pData %p tag 0x%x"</span>,pData,tag); </span><br><span class="line">+               FaceROIInformation*  pFaceROIInfo = (FaceROIInformation *)pData; </span><br><span class="line">+               LOG_ERROR(CamxLogGroupChi, <span class="string">"ROICount %d"</span>, pFaceROIInfo->ROICount); </span><br><span class="line">+               <span class="keyword">for</span> (UINT32 i = <span class="number">0</span>; i < pFaceROIInfo->ROICount; i++){ </span><br><span class="line">+                       LOG_ERROR(CamxLogGroupChi,<span class="string">"faceID=%d, confidence=%d, top-left(%d, %d), width=%d, height=%d"</span>, </span><br><span class="line">+                               pFaceROIInfo->unstabilizedROI[i].id,                      pFaceROIInfo->unstabilizedROI[i].confidence, </span><br><span class="line">+                               pFaceROIInfo->unstabilizedROI[i].faceRect.left,  pFaceROIInfo->unstabilizedROI[i].faceRect.top, </span><br><span class="line">+                               pFaceROIInfo->unstabilizedROI[i].faceRect.<span class="built_in">width</span>, pFaceROIInfo->unstabilizedROI[i].faceRect.<span class="built_in">height</span>); </span><br><span class="line">+               } </span><br><span class="line">+               <span class="keyword">for</span> (UINT32 i = <span class="number">0</span>; i < pFaceROIInfo->ROICount; i++){ </span><br><span class="line">+                       LOG_ERROR(CamxLogGroupChi,<span class="string">"faceID=%d, confidence=%d, top-left(%d, %d), width=%d, height=%d"</span>, </span><br><span class="line">+                               pFaceROIInfo->stabilizedROI[i].id,                        pFaceROIInfo->stabilizedROI[i].confidence, </span><br><span class="line">+                               pFaceROIInfo->stabilizedROI[i].faceRect.left,  pFaceROIInfo->stabilizedROI[i].faceRect.top, </span><br><span class="line">+                               pFaceROIInfo->stabilizedROI[i].faceRect.<span class="built_in">width</span>, pFaceROIInfo->stabilizedROI[i].faceRect.<span class="built_in">height</span>); </span><br><span class="line">+               } </span><br><span class="line">+       }<span class="keyword">else</span>{ </span><br><span class="line">+               LOG_ERROR(CamxLogGroupChi, <span class="string">"OEMFDResults pData is NULL!"</span>); </span><br><span class="line">+       } </span><br><span class="line">+} </span><br><span class="line">+ </span><br><span class="line"> <span class="comment">//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// </span></span><br><span class="line"> <span class="comment">/// ChiMemCpyNode::ProcessRequest </span></span><br><span class="line"> <span class="comment">//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// </span></span><br><span class="line">@@ <span class="number">-550</span>,<span class="number">6</span> +<span class="number">603</span>,<span class="number">7</span> @@ <span class="function">CDKResult <span class="title">ChiMemCpyNode::ProcessRequest</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">if</span> (TRUE == satisfied) </span></span></span><br><span class="line"><span class="function"><span class="params">     { </span></span></span><br><span class="line"><span class="function"><span class="params">+       GetFDResults(pProcessRequestInfo->frameNum); </span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">for</span> (UINT32 i = <span class="number">0</span>; i < pProcessRequestInfo->outputNum; i++) </span></span></span><br><span class="line"><span class="function"><span class="params">         { </span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="comment">// This is memcpy dummy RTB node</span></span></span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>最后打开人脸检测的打印进行检查</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">adb root  </span><br><span class="line">adb remount  </span><br><span class="line">adb shell "echo logVerboseMask=0x100000 >> /vendor/etc/camera/camxoverridesettings.txt"  </span><br><span class="line">adb reboot</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>HAL3</tag>
      </tags>
  </entry>
  <entry>
    <title>Camera HAL3 分析</title>
    <url>/posts/1e916c1d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>Android Camera硬件抽象层（HAL，Hardware Abstraction Layer）主要用于把底层硬件驱动和位于android.hardware中的framework APIs连接起来。Camera子系统(mm-camera)主要包含了camera pipeline components 的各种实现，而camera HAL提供了这些组件的使用接口。<br>起着承上启下的作用。<br>在camera HAL层实现中，芯片厂商一般将camera HAL层的实现分为两层：interface层和OEM层(这个应该就是我们说的mm-camera)。OEM层为下层，它用于屏蔽不同的camera硬件。不同的camera硬件必须支持OEM层提供的对外接口。Interface层为上层，它调用OEM层的对外接口来实现camera HAL所定义的接口。对于Interface层，它并不知道底层camera硬件到底是哪一个版本。同时，interface层完成了屏蔽camera HAL版本的作用。对于OEM层，它也不知道上层是哪一个camera HAL版本，及android版本。两层分离架构，可以很容易地实现不同芯片支持同一个android版本和同一款芯片支持不同android版本(前提条件是该款芯片能够支持这些android版本的各个需求)。</p>
</blockquote>
<h2 id="（一）相机系统架构"><a href="#（一）相机系统架构" class="headerlink" title="（一）相机系统架构"></a>（一）相机系统架构</h2><p><img src="https://image.qinxing.xyz/20200428172940.png" alt="Camera System Architecture"><br>主要包含如下几个重要组成部分：</p>
<h3 id="Application-Framework"><a href="#Application-Framework" class="headerlink" title="Application Framework"></a>Application Framework</h3><p>Application framework层主要是应用代码（app’s code），这个代码主要利用android.hardware.Camera API与Camera硬件进行交互。这些代码调用相关的JNI类来访问与Camera进行交互的原生代码（native code）。API有1和2两个版本。</p>
<h3 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h3><p>与android.hardware.Camera有关的JNI代码主要frameworks/base/core/jni/ android_hardware_Camera.cpp。这些代码调用下一层的原生代码以获得物理camera的访问权，然后返回用于在framework层创建android.hardware.Camera对象的数据。</p>
<h3 id="Native-framework"><a href="#Native-framework" class="headerlink" title="Native framework"></a>Native framework</h3><p>Native framework的定义位于 frameworks/av/camera/Camera.cpp中，它提供了android.hardware.Camera类在本地的实现。这些类调用IPC binder来获得camera service。</p>
<h3 id="Binder-IPC-proxies"><a href="#Binder-IPC-proxies" class="headerlink" title="Binder IPC proxies"></a>Binder IPC proxies</h3><p>IPC binder代理可以现实进程间通信。在frameworks/av/camera目录下有三个camera binder类的定义。ICameraService是cameraservice的接口，ICamera是被打开的camera设备的接口，ICameraClient是camera设备返回给application framework层的接口。</p>
<h3 id="Camera-Service"><a href="#Camera-Service" class="headerlink" title="Camera Service"></a>Camera Service</h3><p>Camera service位于frameworks/av/services/camera/libcameraservice/CameraService.cpp，它是与HAL直接进行交互的真正代码。</p>
<h3 id="HAL"><a href="#HAL" class="headerlink" title="HAL"></a>HAL</h3><p>硬件抽象层定义了一套标准接口，你必须实现这些接口，以保证你的APP能够与你的Camera硬件正确的协调工作，从而使保证你的Camera的所有功能能够正常进行工作。</p>
<h3 id="Kernel-Driver"><a href="#Kernel-Driver" class="headerlink" title="Kernel Driver"></a>Kernel Driver</h3><p>Camera驱动向下与真实的camera硬件进行交互，向上与HAL实现进行交互。Camera硬件和驱动必须能够提供YV12和NV21格式的图像数据，以支持camera图像数据在显示屏上的预览和视频录制。<br>高通老平台（670以下）在HAL和kernel之间还有一个mm-camera，kernel负责操作硬件，提供图像数据，mm-camera负责对ISP pipeline的控制以及各个功能（如快门时间）的实现。</p>
<h3 id="HAL1的camera-open的流程"><a href="#HAL1的camera-open的流程" class="headerlink" title="HAL1的camera open的流程"></a>HAL1的camera open的流程</h3><p><img src="https://image.qinxing.xyz/20200407150157.png" alt="camera open的流程"></p>
<h2 id="（二）HAL层概述"><a href="#（二）HAL层概述" class="headerlink" title="（二）HAL层概述"></a>（二）HAL层概述</h2><p>Android硬件抽象层（Hardware Abstraction Layer，HAL）向上连接camera framework 层APIs，向下连接底层Camera驱动和硬件。最新版的Android引进了一种全新的camera stack底层实现方案。如果你有之前开发的适用于老版本Android的camera HAL module和驱动，那么注意了，因为新版本与老版本在camera pipeline的实现上面有非常大的改动。</p>
<p>由于很多设备仍然依赖于老版本的camera HAL，因此，未来的Android发布版本依然会支持第一版的camera HAL。Android camera service也支持同时实现两种HAL，这种设计有一定的好处，比如你想使用HAL v1支持一个能力比较有限的前置camera，同时使用HAL v3支持一个具有强大功能的后置camera，此时这种设计就有了用武之地。HAL v2是v1向v3的一个过渡版本，将不在支持。</p>
<p>系统中只会有一个camera HAL module（这个module拥有自己的版本号，当前是1、2或2.1），该module可以维护多个独立的camera device，每个device都会有自己的版本号。Camera module v2或更新版本的module会支持device v2及更新的版本，这个 camera module可以支持多个不同版本的camera device。这也就是我们为什么说Android支持两个HAL的实现。</p>
<h3 id="不用HAL1的原因"><a href="#不用HAL1的原因" class="headerlink" title="不用HAL1的原因"></a>不用HAL1的原因</h3><p>第1版的camera subsystem被设计成由顶层控制黑箱结构。简单的说，老的camera子系统有3种操作模式：</p>
<ul>
<li>预览</li>
<li>视频录制</li>
<li>继续拍照</li>
</ul>
<p><img src="https://image.qinxing.xyz/20200428105702.png" alt="HAL相机组件"><br>每种模式都有所不同，也有一定的功能重叠。这使得很以后在功能扩展方面变得比较困难，比如说burst mode，它属于上面三种中的两种。</p>
<h3 id="HAL3的改进"><a href="#HAL3的改进" class="headerlink" title="HAL3的改进"></a>HAL3的改进</h3><p>重新设计 Android Camera API 的目的在于大幅提高应用对于 Android 设备上的相机子系统的控制能力，同时重新组织 API，提高其效率和可维护性。借助额外的控制能力，您可以更轻松地在 Android 设备上构建高品质的相机应用，这些应用可在多种产品上稳定运行，同时仍会尽可能使用设备专用算法来最大限度地提升质量和性能。</p>
<p>版本 3 相机子系统将多个运行模式整合为一个统一的视图，您可以使用这种视图实现之前的任何模式以及一些其他模式，例如连拍模式。这样一来，便可以提高用户对聚焦、曝光以及更多后期处理（例如降噪、对比度和锐化）效果的控制能力。此外，这种简化的视图还能够使应用开发者更轻松地使用相机的各种功能。</p>
<p>API 将相机子系统塑造为一个管道，该管道可按照 1:1 的基准将传入的帧捕获请求转化为帧。这些请求包含有关帧的捕获和处理的所有配置信息，其中包括分辨率和像素格式；手动传感器、镜头和闪光灯控件；3A 操作模式；RAW 到 YUV 处理控件；统计信息生成等等。</p>
<p>简单来说，应用框架从相机子系统请求帧，然后相机子系统将结果返回到输出流。此外，系统还会针对每组结果生成包含色彩空间和镜头遮蔽等信息的元数据。您可以将相机版本 3 看作相机版本 1 的单向流管道。它会将每个捕获请求转化为传感器捕获的一张图像，这张图像将被处理成：</p>
<p>包含有关捕获的元数据的 Result 对象。<br>图像数据的 1 到 N 个缓冲区，每个缓冲区会进入自己的目标 Surface。<br>可能的输出 Surface 组经过预配置：</p>
<p>每个 Surface 都是一个固定分辨率的图像缓冲区流的目标位置。<br>一次只能将少量 Surface 配置为输出（约 3 个）。<br>一个请求中包含所需的全部捕获设置，以及要针对该请求将图像缓冲区（从总配置组）推送到其中的输出 Surface 的列表。请求可以只发生一次（使用 capture()），也可以无限重复（使用 setRepeatingRequest()）。捕获的优先级高于重复请求的优先级。<br><img src="https://image.qinxing.xyz/20200428105614.png" alt="相机核心操作模型"><br><img src="https://image.qinxing.xyz/20200428150810.png" alt></p>
<h2 id="（三）HAL3的使用"><a href="#（三）HAL3的使用" class="headerlink" title="（三）HAL3的使用"></a>（三）HAL3的使用</h2><p>google范例：<a href="https://github.com/android/camera-samples" target="_blank" rel="noopener">https://github.com/android/camera-samples</a> 这里面有API2的使用范例，通过调用API2来实现HDR预览。</p>
<p>由于我们更偏向底层，需要了解如何对HAL层直接控制。高通有HAL3的使用范例，在<code>hardware/qcom/camera/QCamera2/HAL3/test</code>。如果想要看HAL1的使用范例，在对应的HAL目录下。</p>
<p>从main函数看起，一开始创建了一个对象MainTestContext，用来菜单的控制和显示。</p>
<p>然后创建了CameraHAL3Base类的实例，这个类是camera的操作函数，包括摄像头的打开，能力集的获取，预览录像拍照的初始化。</p>
<h3 id="加载HAL摄像头"><a href="#加载HAL摄像头" class="headerlink" title="加载HAL摄像头"></a>加载HAL摄像头</h3><ol>
<li>通过hal3appTestLoad解析动态库，获取HAL层的接口。操作函数都在<code>camera_module_t</code>结构体中。</li>
<li><code>get_number_of_cameras</code>获取camera的数量。</li>
<li><code>get_vendor_tag_ops</code>获取厂商标签（vendor tag），然后设置下去</li>
<li>通过<code>set_callbacks</code>注册两个回调函数，<code>torch_mode_status_change</code>和<code>camera_device_status_change</code></li>
<li>通过<code>get_camera_info</code>获取camera的静态信息</li>
</ol>
<h3 id="初始化摄像头"><a href="#初始化摄像头" class="headerlink" title="初始化摄像头"></a>初始化摄像头</h3><p>通过camera_module_t.common.methods-><code>open</code>打开摄像头，输入一个camera id，返回一个<code>camera3_device_t</code>（通过hw_device_t指针中转）。</p>
<p>通过camera3_device_t.ops-><code>initialize</code>初始化camera的两个回调函数：<code>Notify</code>和<code>ProcessCaptureResult</code>。</p>
<h3 id="配置流"><a href="#配置流" class="headerlink" title="配置流"></a>配置流</h3><p>这里分为预览，录像，普通抓拍，RAW拍照，红外模式等等，其实流程都是一样的，拿预览说事。</p>
<ol>
<li>初始化一个数据流<code>camera3_stream_t</code>，定义这个数据流的输入输出，图像大小与格式</li>
<li>初始化数据流配置<code>camera3_stream_configuration</code>，放入所有需要的数据流</li>
<li>通过camera3_device_t.ops-><code>configure_streams</code>配置数据流</li>
<li>通过camera3_device_t.ops-><code>construct_default_request_settings</code>获取预览和拍照的默认配置（metadata的形式）</li>
</ol>
<h3 id="开启流"><a href="#开启流" class="headerlink" title="开启流"></a>开启流</h3><ol>
<li>创建一个请求线程，专门负责发送请求<code>process_capture_request</code></li>
<li>通过回调函数<code>ProcessCaptureResult</code>对图像数据进行处理，然后发送信号量，让请求线程发送下一帧的请求</li>
<li>如果有参数发生改变，比如开启红外，只需要更新元数据metadata，继续发送请求即可。camera_metadata_t.<code>update</code>更新元数据，<code>release</code>发布元数据。</li>
</ol>
<h2 id="（四）HAL层的实现"><a href="#（四）HAL层的实现" class="headerlink" title="（四）HAL层的实现"></a>（四）HAL层的实现</h2><h3 id="对外接口"><a href="#对外接口" class="headerlink" title="对外接口"></a>对外接口</h3><p>HAL层位于camera驱动和上层Android framework层之间，它定义了一些标准接口，你必须正确地实现这些接口，以保证你的APP能够正确的操作你的camera硬件进行正常工作。HAL接口定义位于hardware/libhardware/include/hardware/camera.h 和hardware/libhardware/include/hardware/camera_common.h头文件中。如果是HAL3，接口是camera3.h。</p>
<p>camera_common.h文件主要定义了两个结构体。camera_info是camera的硬件信息，如朝向,版本信息等等。camera_module是camera的操作方法，如获取camera信息，设置回调等等。</p>
<p>Camera.h则包含了与android.hardware.Camera相关的代码。该头文件声明了camera_device结构体，camera_device结构体包含一个camera_device_ops结构体，camera_device_ops结构体包含了指向HAL接口实现函数的函数指针。可以查看frameworks/av/include/camera/CameraParameters.h 文件以了解更多不同类型的camera参数的相关文档。这些参数都通过HAL中的 int (*set_parameters)(struct camera_device *, const char *parms) 函数指针进行设置。</p>
<p>camera3.h包含了camera3_device结构体，里面包含了hw_device和camera3_device_opts结构体。每个设备数据结构必须以hw_device_t开头，后跟模块特定的公共方法和属性。其中opts是camera的操作函数，初始化的时候注册了两个重要的函数，一个是处理数据流的捕获结果，这里面包含了metadate信息以及图像数据，另外一个是事件通知，主要通知camera的时间戳和错误信息。configure_streams是用来重置camera处理流程，设置一个新的输入输出流。process_capture_request是构建一个捕获请求。process_capture_result是处理完成的捕获。</p>
<h3 id="代码位置"><a href="#代码位置" class="headerlink" title="代码位置"></a>代码位置</h3><ol>
<li>老平台的HAL<br>位置在hardware/qcom/camera.QCamera2路径下，分为HAL和HAL3两个版本。具体的实现在vendor/qcom/proprietary/mm-camera路径下。</li>
<li>新平台的HAL<br>位置在vendor/qcom/proprietary/camx/src/core/hal路径下，camxhal3.h就是对应了HAL3的接口。判断到底用哪个地方的代码，需要查看编译脚本。</li>
</ol>
<h3 id="CAMX代码流程"><a href="#CAMX代码流程" class="headerlink" title="CAMX代码流程"></a>CAMX代码流程</h3><p>camera service 调用camera.provider的HAL接口，在结构体camera3_device_ops中。这个接口映射到了vendor/qcom/proprietary/camx/src/core/hal/camxhal3entry.cpp中的camera3_device_ops。</p>
<p>而这个camera3_device_ops调用的是g_jumpTableHAL3 的接口。g_jumpTableHAL3的定义在camxhal3.cpp中，通过调用HALDevice的操作函数实现。</p>
<p>这个地方有个<strong>疑问</strong>，为什么要用复杂的dispatch类进行重定向，并原子性的加载操作函数。原子意味着不可分的，同一时刻只能有一个线程对它进行操作。</p>
<p>接下来HALDevice里面的各个函数又会调用camxhal3module.cpp中GetCHIAppCallbacks()里面的函数实现，通过funcCHIHALOverrideEntry映射到chi_hal_override_entry，而这个函数接口又来自于chioverride.h，这里是CHI框架的对外接口，是HAL和chi交接的地方。</p>
<p>代码流程如下图：</p>
<div class="mermaid">sequenceDiagram
	participant camera_service as camera service
	participant camxhal3entry as camxhal3entry.cpp
	participant camxhal3 as camxhal3.cpp
	participant camxhal3module as camxhal3module.cpp
	participant chioverride as chioverride.h
	camera_service->>camxhal3entry: camera3_device_ops
	note left of camxhal3entry: HAL3对外接口
	camxhal3entry->>camxhal3: g_jumpTableHAL3
	camxhal3->>camxhal3module: GetCHIAppCallbacks
	camxhal3module->>chioverride: chi_hal_callback_ops_t
	note left of chioverride: CHI对外接口</div>



<p>这就到了chxextensioninterface.cpp</p>
<p>InitializeOverrideSession函数在初始化的时候，通过CreateUsecaseObject创建了一个用例</p>
<p>然后进入到对应用例的cpp中，比如说chxadvancedcamerausecase.cpp</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">	participant chioverride as chioverride.h</span><br><span class="line">	participant chiextensioninterface as extensioninterface</span><br><span class="line">	chioverride-->chiextensioninterface: chi_hal_callback_ops</span><br></pre></td></tr></tbody></table></figure>



<p><img src="https://image.qinxing.xyz/20200529194323.png" alt="camx 代码流程图"></p>
<p>metadata：</p>
<p>通过ConstructDefaultRequestSettings获取默认配置</p>
<p>这里会从HAL层和CHI获取两次metadata，然后将这两者的metadata进行融合</p>
<p>未完待续。。。</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>HAL</tag>
      </tags>
  </entry>
  <entry>
    <title>3D降噪算法实现</title>
    <url>/posts/8da2c999/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>2D降噪是对单个图像进行空域降噪，3D降噪是对时域中的多张图像进行降噪，利用了历史信息。这里介绍一种比较好实现的3D降噪算法——ViBe算法。</p>
<h2 id="ViBe算法"><a href="#ViBe算法" class="headerlink" title="ViBe算法"></a>ViBe算法</h2><p>ViBe是一种像素级视频背景建模或前景检测的算法，效果优于所熟知的几种算法，对硬件内存占用也少。ViBe是一种像素级的背景建模、前景检测算法，该算法主要不同之处是背景模型的更新策略，随机选择需要替换的像素的样本，随机选择邻域像素进行更新。在无法确定像素变化的模型时，随机的更新策略，在一定程度上可以模拟像素变化的不确定性。</p>
<p>该算法实质是找出运动的前景和静止的背景，对前景和背景采用不同的降噪参数，背景的降噪强，前景的降噪弱。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://image.qinxing.xyz/image-20200516232509117.png" alt="流程图"></p>
<p>ViBe算法处理的是灰度图像，图像以一个与图像尺寸（M×N）大小相同的矩阵来表示，主要的计算发生在一个数量为<strong>NumSample</strong>（一般为20）个的背景样本（20个与图像尺寸大小相同的矩阵）与当前帧之间，背景样本会随着帧的变化而不断地更新。</p>
<h2 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h2><ol>
<li><p><strong>初始化：</strong>将20个背景样本的值全设为0（20个M×N的元素全为0的矩阵）；</p>
</li>
<li><p><strong>根据第一帧得到初始样本：</strong>对于某个样本，当前坐标（x，y）处的值将随机取第一帧同样位置（x，y）处附近的8个值中的一个，构成初始背景样本，见下图。因为每次都是随机选取的，所以20个样本矩阵是不相同的。</p>
</li>
</ol>
<p><img src="https://image.qinxing.xyz/clip_image001.png" alt="初始样本选取"></p>
<ol start="3">
<li><p><strong>比较（第二帧）当前像素与样本：</strong>从第二帧开始后面的每一帧都会与样本做像素差的计算，以此来判断当前帧各个像素点是前景还是背景，并且在这个过程中不断更新样本。</p>
<p>假设当前处理的像素位于（x，y），像素差为当前帧在这个位置的像素值（p）与某个样本在这个位置的值（q）的差，p-q。若这个值小于阈值（程序中是最后一排参数<strong>ArrayMatchThresh</strong>，根据增益不同取值不同，取值0代表0，取值1代表255），则计数加1，20个样本会从第一个一直计算到最后一个，倘若中途小于阈值的次数超过了<strong>MatchNum</strong>，则会停止计算，将（x，y）处的像素作为当作背景，若20个样本计算结束小于阈值的次数都没有超过<strong>MatchNum，</strong>则将（x，y）处的像素作为当作前景。在这里<strong>ArrayMatchThresh</strong>越大，<strong>MatchNum</strong>越小，越容易将当前像素判成背景，在这种情况下缓慢移动的物体会很难检测出，因此可以适当降低<strong>ArrayMatchThresh</strong>，增大<strong>MatchNum</strong>。</p>
</li>
<li><p><strong>更新样本当前像素所在坐标的值：</strong>当（x，y）处的像素被作为背景像素点时，将以1/<strong>UpdateFactor</strong>的概率更新20个样本中的一个样本，更新的方式是随机选择20个样本中的一个，将该样本在（x，y）处的值更换为当前帧在（x，y）处的值。<strong>UpdateFactor</strong>越大，更新样本的可能性越小，经过多次测验发现适当减小<strong>UpdateFactor</strong>的值，可以减小拖影现象，因为这样可以保证样本随着视频不断更新，更好地区分前景和背景。</p>
</li>
<li><p><strong>更新样本当前像素所在坐标邻近坐标的值：</strong>除了上面更新（x，y）处的值以外，算法还会随机选择（x，y）处周围的8个点中的一个，将它的值更换为当前帧在（x，y）处的像素值，更新的概率也是1/<strong>UpdateFactor</strong>，也是更新20个样本中的一个。</p>
</li>
<li><p><strong>以当前像素更新样本：</strong>当（x，y）处的像素被视为前景像素点的时候，会判断经过多个帧的处理之后是否很长时间里都把该点的像素视为前景点，如果很多个帧（也就是很长时间）该点都被当作前景点，那么可能是判断出错，会以1/<strong>UpdateFactor</strong>的概率将20个样本中的一个在（x，y）处的值更换为当前帧在（x，y）处的值。</p>
</li>
<li><p>区分了前景与背景，接下来将进行3D降噪处理，每一帧的处理都会参考前一帧的降噪结果，前景和背景会分离开分别进行降噪处理，它们参考前一帧的强度分别是<strong>ForegroundAlphaThresh</strong>和<strong>BackgroundAlphaThresh</strong>这两个参数，也是根据增益的不同而划分成6个参数，为了减少拖影现象，这两个参数可以是党的降低，但降低之后会影响降噪的效果。</p>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>降噪</tag>
      </tags>
  </entry>
  <entry>
    <title>CHI模块指南</title>
    <url>/posts/8b80089f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="（一）简介"><a href="#（一）简介" class="headerlink" title="（一）简介"></a>（一）简介</h2><h3 id="为什么要用CHI模块？"><a href="#为什么要用CHI模块？" class="headerlink" title="为什么要用CHI模块？"></a>为什么要用CHI模块？</h3><p>android开发了相机硬件接口，使OEM可以为用户生产高质量的相机解决方案，camera2 API和HAL3接口的结合提供了足够的灵活性，可以支持大多数的使用案例。</p>
<p>但是当java层负责控制执行流程是，在其他引擎（GPU,CPU,DSP)上的延迟或潜在的低效率处理可能是不可接受的，OEM可以通过绕过HAL3接口并直接修改摄像头驱动程序来更有效的实现自定义的功能。</p>
<p>CHI API是建立在HAL3接口的基础上，HAL3是谷歌围绕camera pipeline精确的每个请求设计的，为了给用户提供一个完整的图像处理控制，但是这个请求是有限的。而CHI旨在提供更加精细的控制，以及可以访问ISP中的处理引擎。这个接口可以让照相和通用的图像处理APP提供低延时的软硬件处理。</p>
<h3 id="什么时候要用到CHI模块？"><a href="#什么时候要用到CHI模块？" class="headerlink" title="什么时候要用到CHI模块？"></a>什么时候要用到CHI模块？</h3><p>当camera2/HAL3 接口有如下限制的时候：</p>
<ol>
<li>没有接口可以访问ISP里面各个固定功能的引擎，ISP不是固定一块的，是由各个硬件和软件模块组成的，我利用CHI可以调用ISP里面的单独的一个模块</li>
<li>没有接口可以精确地请求一个处理流程，利用CHI可以控制图像处理的每个节点，从而控制图像的每个处理流程</li>
<li>用例的定义比较松散，预期的处理可能和想像中不同</li>
<li>管道深度是基于预期的用例调试的，为了实现一个复杂的处理流程，对于大多数的HAL3相机驱动来说，特别的请求数量太多了。</li>
<li>需要最少的处理和最小的延迟</li>
</ol>
<h3 id="CHI模块是什么？"><a href="#CHI模块是什么？" class="headerlink" title="CHI模块是什么？"></a>CHI模块是什么？</h3><p>CHI 是为了分离Camera2/HAL3接口，并提供一个完整灵活的图像处理驱动。它可以作为独立的实体进行访问。它能够使用来自sensor或者内存的图像数据（这个惊呆了，不仅仅可以处理来自camera数据，也可以处理来自应用的数据）。</p>
<p>为了让高通的spectra能够和现有的camera2/HAL3接口保持向后兼容，将HAL3驱动转换成了恰当的CHI调用。也就是说HAL3的所有实现，都是通过调用CHI接口实现的。（这一点是和老平台的mm-camera是一样的吧）</p>
<p>CHI提供了一个overrides的接口，允许OEM修改高通默认的camera用例实现（HAL3的实现），不仅仅可以正常的使用Camera2/HAL3的应用程序，同时还可以同时获得CHI提供的灵活性。这些代替的操作(overrides)可以让OEM在任何可获得的引擎上实现各种各样的图像处理，具有低延时，不需要在多个引擎之间协调同步的特点。</p>
<h3 id="CHI的五个关键自定义组件"><a href="#CHI的五个关键自定义组件" class="headerlink" title="CHI的五个关键自定义组件"></a>CHI的五个关键自定义组件</h3><ol>
<li><strong>CHI override</strong>：可以对HAL3接口进行补充，为任何一个兼容HAL3的APP提供精细的图像处理流程，精确的引擎选择，以及多帧图像的控制。</li>
<li><strong>CHI pipeline</strong> ：可以自定义ISP pipeline来处理图像，pipeline由固定功能的ISP功能块（FF-ISP)和拓展的节点（node)组成，这部分可以由xml文件进行配置。当然了直接调用CHI也可以以编程的方式生成pipeline（不过谁会这么傻呢）。</li>
<li><strong>CHI node extensions</strong>：它是图像的处理节点，可以进行扩展，提供了方便的hooks来简化CPU，GPU(openCL, openGL ES或Vulkan)或者DSP(OpenDSP,，Qualcomm® Computer Vision SDK, 或自定义编程)</li>
<li><strong>CHI stats overrides</strong>：允许重写高通默认的统计算法（包括3A），而无需更改驱动程序。外部统计算法可以存储私有的数据，自定义的节点也可以访问这些数据。</li>
<li><strong>CHI sensor XML</strong>：通过xml配置不同的硬件，包括图像传感器，马达，EEPROM，闪光灯等组件。</li>
</ol>
<h3 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h3><ol>
<li><p><strong>Use case</strong>：用例，是camera pipeline的特定配置，为某个特定的场景使用。比如说2K的预览的同时可以20MP的抓拍，这就是一个use case。同一个用例可以有多条camera pipeline。在底层硬件的限制类指定任何可能的用例，上层不需要修改驱动程序就可以适应各种场景。</p>
</li>
<li><p><strong>topology</strong>：拓扑图，由一系列处理节点和一组链接组成。</p>
</li>
<li><p><strong>Engine</strong>：引擎，可用于处理数据的硬件。 如Spectra ISP，Snapdragon CPU，Adreno和DSP。</p>
</li>
<li><p><strong>Node</strong>：节点，是camera pipeline的逻辑功能块，运行在单个引擎上。节点连起来就是拓扑图。</p>
</li>
<li><p><strong>Pipeline</strong>：管道， 包含了一个拓扑图。驱动程序利用pipeline来了解说用到的引擎，以及输出处理的流程。</p>
</li>
<li><p><strong>session</strong>：会话，具有1-n个管道。会话管理所有的硬件资源，以及连接到它的所有管道中的未决请求。支持多个并行，每个会话在多个请求中都保持自己的状态，不受其他会话的影响。停用会话，才释放分配给它的所有资源。</p>
</li>
<li><p><strong>request</strong>：请求，触发管道处理数据的动作。 这可以是处理从图像传感器提取的数据帧或处理来自内存的数据的请求。 驱动程序必须为每个请求返回结果。HAL3和CHI请求是分开管理的。（这两个请求是不一样的）</p>
</li>
<li><p><strong>sub-request</strong>: 子请求，将单个HAL3请求分解为多个CHI请求的操作。子请求的结构不会在驱动程序(CHI)外部反馈，而是将它们合并成一个结果，该结果与原始请求像对应。子请求用于启用 Camera2功能，如HDR，请求多个不同曝光时间的图像，最终产生单个图像。再比如多帧图像后处理，将多个图像合并以创建单个图像输出。子请求是用例管理的一部分，可以在CHI override模块使用。</p>
</li>
<li><p><strong>Stream</strong>：流，具有相同大小和格式的缓冲区序列，用于处理图像数据。可以将多个不同类型的流指定为camera pipeline的输入和输出。这组流是定义Camera2 / HAL3用例的关键组件。</p>
</li>
<li><p><strong>Per-session settings</strong>：单个会话设置，在会话生存期内影响处理管道的设置。会话开始后就无法更改这些设置。例如，允许图像防抖。</p>
</li>
<li><p><strong>Per-request settings</strong>：单个请求的设置。例如，手动曝光值。</p>
</li>
<li><p><strong>Statistics</strong>： 包括3A在内的算法。这些领域特定的算法被视为CHI API的专用部分。</p>
</li>
<li><p><strong>Live or realtime stream</strong>：配置来自图像传感器的数据处理，不能够修改之前请求的数据。当处理速率跟不上sensor的输出速率，应该放到离线流中。</p>
</li>
<li><p><strong>Offline stream</strong>：处理不从图像传感器接受的数据。</p>
</li>
</ol>
<h2 id="（二）CHI-拓扑图的XML配置"><a href="#（二）CHI-拓扑图的XML配置" class="headerlink" title="（二）CHI 拓扑图的XML配置"></a>（二）CHI 拓扑图的XML配置</h2><p>硬件和软件的图像处理节点（node）产生所需的输出，这些节点之间的连接确定数据将如何流过相机子系统。 这组节点和连接称为拓扑。</p>
<p>用例由一组要处理的目标和一组会话设置定义，这些设置进一步定义了应如何处理数据。 每个用例都由拓扑图表示，拓扑图是传递到HAL3 API的信息与如何处理数据的具体定义之间的联系。</p>
<p>所有用例及其对应拓扑的列表都编码在XML文件中。 一个用例是在<strong>configure_streams</strong>的时候被选择的，基于XML的两个部分：< Targets >和< SystemwideSettings >。</p>
<p>提供了一个XSD模式，该模式定义了XML的结构（这句话没太懂）。 提供了一些工具来将XML文件打包为二进制文件，以供CHI驱动程序使用。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>节点是拓扑图中的硬件或软件处理组件。 节点的定义包括了高通默认的节点和自定义的节点。一个节点有一组输入和输出，被称作输入和输出端口。</p>
<p>输出到HAL3 图像buffer的输出端口，被称作sinkbuffer 输出端口。还有一些节点的输出端口不输出到任何图像缓冲区，用于指示节点正在使用中。这些叫SinkNoBuffer。</p>
<p>通过将一个节点的输入端口连接到另一个节点的输出端口来形成拓扑图中的DAG，或者在存在反馈环路的情况下，一个节点的输出端口可以连接到其自己的输入端口。输入端口和输出端口之间的连接称为链接（link），链接还包含有关节点之间使用的必要缓冲区的信息。</p>
<p><img src="https://image.qinxing.xyz/20200513192028.png" alt="节点，端口，链接的关系"></p>
<h3 id="XML的组成"><a href="#XML的组成" class="headerlink" title="XML的组成"></a>XML的组成</h3><ol>
<li><p>UsecaseDef是根标记，在此标记中定义了各个用例Usecase。</p>
</li>
<li><p>Usecase是用例标记，它包括了匹配用例的关键，以及拓补图。里面有UsecaseName、Targets、streamconfigmode、systemwidesetting、pipeline</p>
</li>
<li><p>Targets是流的列表，包括用例执行的格式和大小范围，此处列出的流与传递到HAL3 configure_streams API的流相对应.</p>
<p>Target是单个流或目标的描述，会将本节的各个标记值（target和systemwideSettings）与传递到configure_streams中的流配置进行比较，以找到匹配的Usecase。</p>
<ol>
<li>range，缓冲区的分辨率和configure_streams（）中缓冲区的传入分辨率必须在此范围内，以便Usecase被选择为输入流配置的匹配用例</li>
<li>systemwideSettings，单个会话的设置组，定义此用例的key，这些设置对应安卓的property。</li>
<li>TargetDirection: 流的方向，可以是输入或输出，也可以是双向</li>
<li>Formats：流的数据格式</li>
</ol>
</li>
<li><p>pipeline是这个用例的pipeline，有一组节点和链接组成。pipelineName是这个pipeline的名字。</p>
<ol>
<li><p>nodesList是节点的列表。node是单个节点，告诉驱动程序如何处理一个请求。</p>
<ol>
<li><p>NodeProperty，可选的，允许安卓的几个property属性。</p>
</li>
<li><p>NodeName，节点名字</p>
</li>
<li><p>NodeId，驱动程序通过解释nodeId以了解节点类型，自定义的节点，Id都是255，这个值与NodeProperty一起通知驱动程序，确切的自定义节点类型。</p>
</li>
<li><p>NodeInstance，节点实例</p>
</li>
<li><p>NodeInstanceId ，用于表示节点的唯一实例ID，这些id用于将节点的端口彼此连接起来</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag"><<span class="name">Node</span>></span> </span><br><span class="line">    <span class="tag"><<span class="name">NodeProperty</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">NodePropertyName</span>></span>CustomNodeLibrary<span class="tag"></<span class="name">NodePropertyName</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">NodePropertyId</span>></span>1<span class="tag"></<span class="name">NodePropertyId</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">NodePropertyDataType</span>></span>STRING<span class="tag"></<span class="name">NodePropertyDataType</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">NodePropertyValue</span>></span>com.oem.node.libname<span class="tag"></<span class="name">NodePropertyValue</span>></span>  </span><br><span class="line">    <span class="tag"></<span class="name">NodeProperty</span>></span> </span><br><span class="line">    <span class="tag"><<span class="name">NodeName</span>></span>CustomNode<span class="tag"></<span class="name">NodeName</span>></span> </span><br><span class="line">    <span class="tag"><<span class="name">NodeId</span>></span>255<span class="tag"></<span class="name">NodeId</span>></span> </span><br><span class="line">    <span class="tag"><<span class="name">NodeInstance</span>></span>CustomNodeInstanceName0<span class="tag"></<span class="name">NodeInstance</span>></span> </span><br><span class="line">    <span class="tag"><<span class="name">NodeInstanceId</span>></span>0<span class="tag"></<span class="name">NodeInstanceId</span>></span> </span><br><span class="line"><span class="tag"></<span class="name">Node</span>></span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
</li>
<li><p>portlinkages，节点间的链接列表。link，是节点间的单个链接，可以一对多</p>
<ol>
<li>srcPort是节点的输出端口，主要通过端口以及节点的名字和id来确定。</li>
<li>dstPort是节点的输入端口</li>
<li>bufferProperties描述了缓冲区的属性，主要有格式（BufferFormat），大小，初始分配的缓冲区数量（BufferImmediateAllocCount），最大缓冲区深度（BufferQueueDepth），从堆中分配分配缓冲区（bufferHeap），用于允许分配在摄像机ISP外部可见以及缓冲区的使用信息（BufferFlags）</li>
<li>linkProperties就只有BatchMode，是否需要批处理，通常只有在HFR模式才需要这样做，以允许ISP在单个硬件提交中处理多个帧。它只适用于无法脱机操作的链接。</li>
</ol>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag"><<span class="name">Link</span>></span> </span><br><span class="line">    <span class="tag"><<span class="name">SrcPort</span>></span> </span><br><span class="line">     <span class="tag"><<span class="name">PortName</span>></span>IFEOutputPortFull<span class="tag"></<span class="name">PortName</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">PortId</span>></span>0<span class="tag"></<span class="name">PortId</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">NodeName</span>></span>IFE<span class="tag"></<span class="name">NodeName</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">NodeId</span>></span>65536<span class="tag"></<span class="name">NodeId</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">NodeInstance</span>></span>IFEInstanceName0<span class="tag"></<span class="name">NodeInstance</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">NodeInstanceId</span>></span>0<span class="tag"></<span class="name">NodeInstanceId</span>></span> </span><br><span class="line">    <span class="tag"></<span class="name">SrcPort</span>></span> </span><br><span class="line">    <span class="tag"><<span class="name">DstPort</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">PortName</span>></span>IPEInputPortFull<span class="tag"></<span class="name">PortName</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">PortId</span>></span>0<span class="tag"></<span class="name">PortId</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">NodeName</span>></span>IPE<span class="tag"></<span class="name">NodeName</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">NodeId</span>></span>65538<span class="tag"></<span class="name">NodeId</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">NodeInstance</span>></span>IPEInstanceName0<span class="tag"></<span class="name">NodeInstance</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">NodeInstanceId</span>></span>0<span class="tag"></<span class="name">NodeInstanceId</span>></span> </span><br><span class="line">    <span class="tag"></<span class="name">DstPort</span>></span> </span><br><span class="line">    <span class="tag"><<span class="name">BufferProperties</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">BufferFormat</span>></span>ChiFormatYUV420NV12<span class="tag"></<span class="name">BufferFormat</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">BufferImmediateAllocCount</span>></span>8<span class="tag"></<span class="name">BufferImmediateAllocCount</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">BufferQueueDepth</span>></span>8<span class="tag"></<span class="name">BufferQueueDepth</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">BufferHeap</span>></span>Ion<span class="tag"></<span class="name">BufferHeap</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">BufferFlags</span>></span>BufferMemFlagHw<span class="tag"></<span class="name">BufferFlags</span>></span> </span><br><span class="line">    <span class="tag"></<span class="name">BufferProperties</span>></span> </span><br><span class="line"><span class="tag"></<span class="name">Link</span>></span></span><br></pre></td></tr></tbody></table></figure>




</li>
</ol>
</li>
</ol>
<h2 id="（三）CHI-架构模型"><a href="#（三）CHI-架构模型" class="headerlink" title="（三）CHI 架构模型"></a>（三）CHI 架构模型</h2><h3 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h3><p><img src="https://image.qinxing.xyz/20200515101014.png" alt="CHI框架"></p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="https://image.qinxing.xyz/20200514190636.png" alt="初始化"></p>
<p>JAVA层通过open的函数获得了CHI的所有操作函数，这是通过chi_hal_override_entry()方法获取的。</p>
<p>接着用configure_stream配置流，CHI框架在其中的操作是初始化了会话session，找到配置对应的pipeline，并返回了一个pipeline的句柄。（框架为自定义会话和后处理预留了接口，返回NULL是用高通默认的pipeline）</p>
<p><img src="https://image.qinxing.xyz/20200514190631.png" alt="请求与返回流程"></p>
<p>用process_capture_request去请求图像数据（包括抓拍，录像和预览），这个请求会提交到pipeline中，接着pipeline中的各个节点都会得到请求的通知，进行对应的执行。当然这一步也可以重写请求，比如说为多帧特性创建额外的请求。</p>
<p>每个管道都会异步执行，来自任何管道的结果，包括实时流和离线流，都会通知CHI层。如果CHI为JAVA层的请求生成了多个子请求，那么需要等到所有结果都触发之后再调用chi_override_process_pipeline_result，把结果转发到HAL，最终转发给camera框架中的process_capture_result。 高通框架支持重写结果通知部分。</p>
<p><img src="https://image.qinxing.xyz/20200515094211.png" alt="close 流程"></p>
<p>当HAL收到camera框架的close调用时，它调用chi_teardown_override_session，然后必须清理所有的自定义管道和会话。</p>
<h3 id="元数据metadata"><a href="#元数据metadata" class="headerlink" title="元数据metadata"></a>元数据metadata</h3><p>CHI中的沟通渠道分为以下几个：</p>
<ul>
<li><p>传给APP的数据</p>
</li>
<li><p>传给后处理pipeline的数据</p>
</li>
<li><p>使用发布和订阅机制的节点通信（这是很有名的一种设计模式）</p>
<ul>
<li>原生节点之间用android tags/chiVendorTags</li>
<li>原生节点和自定义节点，以及自定义节点之间用android tags/chiVendorTags/ExtCompVendorTags </li>
</ul>
</li>
</ul>
<p>元数据标签可以是预定义的Android标签，也可以是定制的厂商标签。元数据标签使内部和外部的组件可以相互通信，也可以与面向应用程序的摄像头API通信。在CHI中，Android元数据标签是预定义的，只接收不可变的值。厂商标记不能静态地与固定的绝对值关联。根据目标上扩展组件的数量和类型，CHI使用厂商标记的动态索引(base  + offset)使组件能够相互通信。</p>
<p>元数据标记ID是一个32位的值，它被限制在一个特定的部分中。每个部分的起始偏移量为0x1_0000。标记空间的范围从0x0000_0000到0x8000_0000是为Android元数据标记保留的。供应商部分应该在0x8000_0000之后开始。</p>
<p>在初始化时，当CHI扫描目标系统中的可用组件时，它为每个发布自定义厂商标记的组件分配一个厂商部分的开始位置。组件需要枚举标记为Base + Offset,  Base由CHI分配</p>
<p><img src="https://image.qinxing.xyz/20200515110540.png" alt="metadata 存储位置"></p>
<p>节点可以通过设置初始化时枚举过的标记来发布元数据。CHI会根据特定标记的依赖关系，通知所有其他提交的节点。这个机制对于Android标签、ChiVendorTags或其他ExtCompVendorTags都是一样的。</p>
<p><img src="https://image.qinxing.xyz/20200515110543.png" alt="节点间通信流程图"></p>
<h2 id="（四）代码细节"><a href="#（四）代码细节" class="headerlink" title="（四）代码细节"></a>（四）代码细节</h2><h3 id="1-加载外部二进制库"><a href="#1-加载外部二进制库" class="headerlink" title="1. 加载外部二进制库"></a>1. 加载外部二进制库</h3><p>每个节点都必须在一起单独的动态库里面，按照com.< cendor >, < category >, < algorithm > .so的方式命名。</p>
<p>< vendor >：公司名</p>
<p>< category >：模块的类型，可以是node或者stats</p>
<p>< algorithm > ： 算法独特的名字，如果说节点，名字必须和xml指定的名称匹配。如果是stats，只能是af, aec, awb, asd, afd里面的一个。</p>
<p>所有的动态库都放在 <code>/sys/data/camx/components/</code></p>
<p>相机服务的初始化，发生在设备启动的时候，加载HAL3模块的CHI实现。在CHI HAL3的启动过程中，驱动城市查询并加载位于这个路径下的所有动态库。</p>
<h3 id="2-CHI-接口"><a href="#2-CHI-接口" class="headerlink" title="2. CHI 接口"></a>2. CHI 接口</h3><p>CHI向HAL3接口添加了一些关键元素，以支持更细粒度的控制，以下函数用于访问CHI驱动程序，他们对Camera2/HAL3没有任何依赖。</p>
<p>ChiEntry()是CHI驱动程序的主要入口点，所有CHI功能都需要。</p>
<p>其中使用了ChiContextOps 结构体指向所有的CHI函数。客户端需要使用有效的CHIIHandle句柄来调用这些函数，这个结构体永远不会缩小，现有字段也不会在结构更改时重新排序或者重新使用。所有字段默认值是0，0代表了这个特性不可用。</p>
<p>CHI 接口的函数中比较重要的是pOpenContext。通过这个函数打开CHI的上下文，并将句柄返回给CHI。这个函数必须在任何其他CHI函数之前调用。</p>
<p>这个函数是用来创建chicontext的唯一实例，chicontext是会话中所有状态都保留的地方，预计每个进程中将会有一个Chicontext，当然，一个进程中有多个chicontext也是支持的。在chicontext之间没有交互信息的机制，会话和pipeline只能被创建它的chicontext使用。</p>
<h3 id="3-HAL3到CHI-重写接口（override）"><a href="#3-HAL3到CHI-重写接口（override）" class="headerlink" title="3. HAL3到CHI 重写接口（override）"></a>3. HAL3到CHI 重写接口（override）</h3><p>如果CHI功能用于HAL3相机应用程序，这些功能必须在OEM重写代码中实现。这些函数必须被编译到一个名为com.< vendor > .chi.override.so的文件中。</p>
<p>chi_hal_override_entry()</p>
<p>由驱动程序调用来初始化HAL重写模块的入口点。为了让驱动程序初始化override接口，com.< vendor > .chi.override.so必须导出这个函数。该函数在相机服务器初始化期间调用，初始化发生在设备引导期间。</p>
<h3 id="4-CHI-节点接口"><a href="#4-CHI-节点接口" class="headerlink" title="4. CHI 节点接口"></a>4. CHI 节点接口</h3><p>ChiNodeEntry() ：由CHI驱动程序调用来初始化自定义节点的入口点。</p>
<p>ChiNodeCallbacks结构体：</p>
<table>
<thead>
<tr>
<th>size</th>
<th>结构的大小，这个值框架会自己计算的</th>
</tr>
</thead>
<tbody><tr>
<td>majorVersion/minorVersion</td>
<td>版本号</td>
</tr>
<tr>
<td>pGetCapabilities</td>
<td>必填，能力集，mask列表在chinode.h中查找</td>
</tr>
<tr>
<td>pQueryVendorTag</td>
<td>如果节点需要到处vendor标记才填充它</td>
</tr>
<tr>
<td>pCreate</td>
<td>必填，当拓扑图创建时创建节点实例</td>
</tr>
<tr>
<td>pDestory</td>
<td>必填，当拓扑图销毁是销毁节点实例</td>
</tr>
<tr>
<td>pQueryBufferInfo</td>
<td>必填，CHI调用这个函数从节点查询特定输出格式的输入缓冲区格式(分辨率和类型)</td>
</tr>
<tr>
<td>pSetBufferInfo</td>
<td>必填，CHI设置缓冲区格式</td>
</tr>
<tr>
<td>pProcessRequest</td>
<td>必填，执行请求处理。</td>
</tr>
<tr>
<td>pChiNodeSetNodeInterface</td>
<td>必填，设置节点中的预定义CHI接口</td>
</tr>
<tr>
<td>pPipelineCreated</td>
<td>可选，CHI通知节点创建了一个特定的pipeline</td>
</tr>
<tr>
<td>pPostPipelineCreate</td>
<td>后管道创建的通知</td>
</tr>
<tr>
<td>pPrepareStreamOn/pOnStreamOn/pOnStreamOff</td>
<td>事件通知</td>
</tr>
<tr>
<td>pQueryMetadataPublishList</td>
<td>必须调用此函数来查询节点发布的元数据列表。</td>
</tr>
<tr>
<td>pFlushRequest</td>
<td>释放为请求分配的节点资源。</td>
</tr>
<tr>
<td>pGetFlushResponse</td>
<td>获取刷新调用的最坏情况响应时间</td>
</tr>
<tr>
<td>pFillHwdata</td>
<td>填充每个请求的硬件数据</td>
</tr>
</tbody></table>
<h3 id="5-CHI-stats-重写"><a href="#5-CHI-stats-重写" class="headerlink" title="5. CHI stats 重写"></a>5. CHI stats 重写</h3><p>有AE, AWB, AF, HAF(混合自动对焦)，PDAF，Auto Flicker Detection（水波纹检测），Auto Scene Detection（场景识别），Tracker （对象触摸跟踪）算法的接口，可以自己实现（高通的算法还是很复杂和高级的，正常人不会修改）</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>高通</tag>
        <tag>camx</tag>
      </tags>
  </entry>
  <entry>
    <title>chromatix调试问题汇总</title>
    <url>/posts/19376693/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="问题1：sensor-info"><a href="#问题1：sensor-info" class="headerlink" title="问题1：sensor info"></a>问题1：sensor info</h2><h3 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h3><p>Sensor info.txt如何制作，不同sensor不一样，具体从哪个文件中找到相应的配置</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p><strong>Sensor info.txt模板如下：</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">30.000000f, /* Max FPS */</span><br><span class="line">1, /* min line ct */</span><br><span class="line">2196, /* maximum line count in max fps */</span><br><span class="line">2196, /* maximum line count */</span><br><span class="line">1, /* minimum gain */</span><br><span class="line">251, /* max gain fix fps */</span><br><span class="line">251, /* max gain after linear afr */</span><br><span class="line">3072, /* raw image width */</span><br><span class="line">2048, /* raw image height */</span><br><span class="line">RGGB, /* bayer pattern */</span><br><span class="line">10, //bits per pixel</span><br><span class="line">1, //packed or not, packed=1, unpacked=0</span><br><span class="line">0, /* crop top after camif */</span><br><span class="line">0, /* crop bottom after camif */</span><br><span class="line">0, /* crop left after camif */</span><br><span class="line">0, /* crop right after camif */</span><br><span class="line">240, //black level in 12-bit value based on spec</span><br><span class="line">240, //black level under low light</span><br><span class="line">240, //black level under bright light</span><br></pre></td></tr></tbody></table></figure>
<p><strong>来源：</strong><br>可以从sensor_lib.h中获取到</p>
<ol>
<li><strong>FPS</strong>：sensor最大输出帧率，对应out_info 的max_fps</li>
<li><strong>Min/max line</strong>: 从sensor手册中获取到</li>
<li><strong>Min/max gain</strong>: 最大增益由自己定，一般不会太大，不会超过256</li>
<li><strong>Raw image width/height</strong>：raw尺寸，对应out_info里面的x_output/y_output</li>
<li><strong>Bayer pattern</strong>: RAW 滤光片排列格式，对应sensor_output的filter_arrangement，一般是RGGB</li>
<li><strong>Bit per pixel</strong>：sensor一般支持10bit和12bit，看寄存器配成多少bit，对应sensor_output的raw_output</li>
<li><strong>Packed or not</strong>：RAW的两种格式</li>
<li><strong>Crop</strong>：上下左右的裁剪，对应crop_params</li>
<li><strong>Black level</strong>: 来自手册或者自己的测量，注意10bit要转成12bit，比如raw测出来的黑电平是60，转成12bit，就是多加两位，乘以四，最后就是240</li>
</ol>
<p><strong>建议：</strong></p>
<ol>
<li>建议先抓一张raw图，把raw图导入chromatix工具，多测试几种格式，确定了RAW图的格式再把sensor info.txt定下来</li>
<li>像黑电平，曝光行等在chromatix工具调试的过程中可以修改，并不是说写了多少就是多少。</li>
</ol>
<h2 id="问题2：调试文件目录"><a href="#问题2：调试文件目录" class="headerlink" title="问题2：调试文件目录"></a>问题2：调试文件目录</h2><h3 id="详细-1"><a href="#详细-1" class="headerlink" title="详细"></a>详细</h3><p><img src="https://image.qinxing.xyz/20200508093600.png" alt><br>这几个调试文件夹分别对应isp pipe中的哪些功能。<br>比如说我想改ae是不是只需要改3A文件夹下的相关变量内容。</p>
<h3 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h3><ol>
<li><strong>3A</strong> 对应的是3A模块:AE,AWB,AF</li>
<li><strong>Common</strong> 对应的是RAW域最前端的基础处理模块：黑电平（线性化），rolloff。</li>
<li><strong>CPP</strong> 对应的是ISP中的CPP模块，主要是yuv域的降噪WNR和锐化ASF。</li>
<li><strong>Isp</strong> 对应的是VFE模块，包括PDAF,ABF,绿平衡，坏点校正，去马赛克，gamma，color conversion,宽动态调节（LTM（注意有两个版本，都是有效的）/GTM/ADRC），肤色去噪，CAC,色度抑制，肤色增强,统计数据配置，video HDR(只支持隔行扫描HDR sensor)，人脸检测等模块。<br>最常用到的就是ABF，gamma，color conversion，宽动态调节。</li>
<li><strong>Postproc</strong> 对应的是RNR降噪参数，CAC等不常用的参数，一般不会调，用默认的。</li>
</ol>
<p>chromatix工具最终是生成头文件的，我们当然可以跳过工具，直接去修改头文件。两者是一样的效果。</p>
<h2 id="问题3：抓RAW图"><a href="#问题3：抓RAW图" class="headerlink" title="问题3：抓RAW图"></a>问题3：抓RAW图</h2><h3 id="详细-2"><a href="#详细-2" class="headerlink" title="详细"></a>详细</h3><p>手机/ipc设备拍摄raw图的方法。</p>
<h3 id="回答-1"><a href="#回答-1" class="headerlink" title="回答"></a>回答</h3><h4 id="手机抓raw图的方法（传统）"><a href="#手机抓raw图的方法（传统）" class="headerlink" title="手机抓raw图的方法（传统）"></a>手机抓raw图的方法（传统）</h4><ol>
<li>安装骁龙相机</li>
<li>连续点击五次设置里面的红眼消除，进入高级设置</li>
<li>关闭零秒快拍（ZSL）选项，关闭pdaf功能</li>
<li>选择图片格式 RAW</li>
<li>按下拍照就是抓取RAW图了，图片保存在/sdcard/DCIM/Camera或者/data/misc/camera路径下</li>
</ol>
<h4 id="Ipc抓取raw图的方法："><a href="#Ipc抓取raw图的方法：" class="headerlink" title="Ipc抓取raw图的方法："></a>Ipc抓取raw图的方法：</h4><ol>
<li>连接usb线</li>
<li>安装total control</li>
<li>安装骁龙相机</li>
<li>用手机抓raw图的方法抓取</li>
</ol>
<h4 id="Adb抓取raw图（仅适用于660以上平台）"><a href="#Adb抓取raw图（仅适用于660以上平台）" class="headerlink" title="Adb抓取raw图（仅适用于660以上平台）"></a>Adb抓取raw图（仅适用于660以上平台）</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">adb shell chmod 777 /data/misc/camera</span><br><span class="line">adb shell setprop persist.camera.raw_yuv 1</span><br><span class="line">adb shell setprop persist.camera.preview_raw 1</span><br><span class="line">adb shell setprop persist.camera.dumpimg 0</span><br><span class="line">adb shell setprop persist.camera.dumpimg 131088</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Tips</strong></p>
<ol>
<li>可以在QCamera2HWICallbacks.cpp的dumpFrameToFile函数查看具体实现过程。可能会出现抓拍到不止1张raw图的情况。</li>
<li>用骁龙相机抓出来的raw图是MIPI格式，而这里格式要改成packed，图片的名称中带有图片的大小。</li>
<li>第一次抓取raw图，设置好要重启camera或者重启应用程序。由于persist.camera.raw_yuv只有在给channel添加通道的时候才会读取，因此设置之后需要重启camera，可以重启设备或者重启应用程序。</li>
<li>图片路径在<code>/data/misc/camera</code></li>
</ol>
<h2 id="问题4：头文件对应关系"><a href="#问题4：头文件对应关系" class="headerlink" title="问题4：头文件对应关系"></a>问题4：头文件对应关系</h2><h3 id="详细-3"><a href="#详细-3" class="headerlink" title="详细"></a>详细</h3><p>不同的sensor有不同的chromatix头文件，同一个sensor在不同数据流（预览，抓拍，录像）下也有不同的头文件，如何确定到底哪个生效呢？</p>
<h3 id="回答-2"><a href="#回答-2" class="headerlink" title="回答"></a>回答</h3><p>拿660平台举例，在<code>/vendor/qcom/proprietary/mm-camera/media-controller/modules/sensors/configs</code>路径下的xml里进行了配置。</p>
<p>这个位置有很多的xml配置文件，先找到这个设备的xml，比如说sdm660_camera.xml</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag"><<span class="name">CameraModuleConfig</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">CameraId</span>></span>0<span class="tag"></<span class="name">CameraId</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">SensorName</span>></span>imx290<span class="tag"></<span class="name">SensorName</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">ChromatixName</span>></span>imx290_chromatix<span class="tag"></<span class="name">ChromatixName</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">ModesSupported</span>></span>1<span class="tag"></<span class="name">ModesSupported</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">Position</span>></span>BACK<span class="tag"></<span class="name">Position</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">MountAngle</span>></span>90<span class="tag"></<span class="name">MountAngle</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">CSIInfo</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">CSIDCore</span>></span>2<span class="tag"></<span class="name">CSIDCore</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">LaneMask</span>></span>0x1F<span class="tag"></<span class="name">LaneMask</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">LaneAssign</span>></span>0x4320<span class="tag"></<span class="name">LaneAssign</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">ComboMode</span>></span>0<span class="tag"></<span class="name">ComboMode</span>></span></span><br><span class="line">  <span class="tag"></<span class="name">CSIInfo</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">LensInfo</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">FocalLength</span>></span>2.8<span class="tag"></<span class="name">FocalLength</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">FNumber</span>></span>2.8<span class="tag"></<span class="name">FNumber</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">TotalFocusDistance</span>></span>1.97<span class="tag"></<span class="name">TotalFocusDistance</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">HorizontalViewAngle</span>></span>54.8<span class="tag"></<span class="name">HorizontalViewAngle</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">VerticalViewAngle</span>></span>42.5<span class="tag"></<span class="name">VerticalViewAngle</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">MinFocusDistance</span>></span>0.1<span class="tag"></<span class="name">MinFocusDistance</span>></span></span><br><span class="line">  <span class="tag"></<span class="name">LensInfo</span>></span></span><br><span class="line"><span class="tag"></<span class="name">CameraModuleConfig</span>></span></span><br></pre></td></tr></tbody></table></figure>
<p>这个文件配置了cameraid，sensor的名称（一般通过sensor名称来选择到底用哪套配置），位置等等信息。<br>里面有个ChromatixName的配置，这里是imx290_chromatix。<br>那么我们就继续在当前目录下找imx290_chromatix.xml这个文件</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag"><<span class="name">ResolutionChromatixInfo</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">ChromatixName</span> <span class="attr">sensor_resolution_index</span>=<span class="string">"0"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">ISPPreview</span>></span>imx290_preview<span class="tag"></<span class="name">ISPPreview</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">ISPSnapshot</span>></span>imx290_preview<span class="tag"></<span class="name">ISPSnapshot</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">ISPVideo</span>></span>imx290_preview<span class="tag"></<span class="name">ISPVideo</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">CPPPreview</span>></span>imx290_cpp_preview<span class="tag"></<span class="name">CPPPreview</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">CPPSnapshot</span>></span>imx290_cpp_preview<span class="tag"></<span class="name">CPPSnapshot</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">CPPVideo</span>></span>imx290_cpp_preview<span class="tag"></<span class="name">CPPVideo</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">CPPLiveshot</span>></span>imx290_cpp_preview<span class="tag"></<span class="name">CPPLiveshot</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">A3Preview</span>></span>imx290_default_preview_3a<span class="tag"></<span class="name">A3Preview</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">A3Video</span>></span>imx290_default_preview_3a<span class="tag"></<span class="name">A3Video</span>></span></span><br><span class="line">  <span class="tag"></<span class="name">ChromatixName</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">ChromatixName</span> <span class="attr">sensor_resolution_index</span>=<span class="string">"1"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">ISPPreview</span>></span>imx290_preview<span class="tag"></<span class="name">ISPPreview</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">ISPSnapshot</span>></span>imx290_preview<span class="tag"></<span class="name">ISPSnapshot</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">ISPVideo</span>></span>imx290_preview<span class="tag"></<span class="name">ISPVideo</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">CPPPreview</span>></span>imx290_cpp_preview<span class="tag"></<span class="name">CPPPreview</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">CPPSnapshot</span>></span>imx290_cpp_preview<span class="tag"></<span class="name">CPPSnapshot</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">CPPVideo</span>></span>imx290_cpp_preview<span class="tag"></<span class="name">CPPVideo</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">CPPLiveshot</span>></span>imx290_cpp_preview<span class="tag"></<span class="name">CPPLiveshot</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">A3Preview</span>></span>imx290_default_preview_3a<span class="tag"></<span class="name">A3Preview</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">A3Video</span>></span>imx290_default_preview_3a<span class="tag"></<span class="name">A3Video</span>></span></span><br><span class="line">  <span class="tag"></<span class="name">ChromatixName</span>></span></span><br><span class="line"><span class="tag"></<span class="name">ResolutionChromatixInfo</span>></span></span><br></pre></td></tr></tbody></table></figure>
<p>这个文件配置了两套分辨率（帧率），这个分辨率分组是根据sensor_lib.h配置的。<br>当选择第一组分辨率时，可以看到在preview，snapshot，video数据流都可以指定对应的chromatix头文件。<br><strong>注意</strong>，这里的imx290_preview并非直接是头文件的名称，而是动态库的名称。<br>到对应的chromatix头文件夹下可以找到对应目录下的Android.mk</p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">LOCAL_SRC_FILES:= chromatix_imx290_preview.c</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE           := libchromatix_imx290_preview</span><br></pre></td></tr></tbody></table></figure>
<p>libchromatix_imx290_preview就是这个路径下的头文件生成的动态库。去掉前面的libchromatix_，正好就是需要的动态库名称。</p>
<p>如果是老平台，一般在代码中找LOAD_CHROMATIX函数，可以直接看到加载的是哪个动态库，再反过来找对应的头文件。</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像</category>
      </categories>
      <tags>
        <tag>tunning</tag>
        <tag>chromatix</tag>
      </tags>
  </entry>
  <entry>
    <title>变焦设备的AF初步学习</title>
    <url>/posts/720ad51b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>原作陈瑶，部分内容来源于<a href="https://zhuanlan.zhihu.com/p/38544418" target="_blank" rel="noopener">网络</a>，我在此基础上进行了理解和整理。</p>
</blockquote>
<p>经过学习，我把AF分为两个部分，第一部分是在变焦的过程中保持图像清晰，用的是tracking算法。简单的来说，是通过镜头曲线去预估变焦后，镜头应该对焦到什么位置。</p>
<p>第二部分是聚焦清晰，用的是爬坡算法。通过滤波器计算出图像的清晰度，移动镜片，找到最清晰的位置，也可以利用镜头曲线去缩小爬坡的范围。</p>
<p>所以镜头曲线是什么？先来介绍一下硬件相关的原理。</p>
<h2 id="（一）硬件原理"><a href="#（一）硬件原理" class="headerlink" title="（一）硬件原理"></a>（一）硬件原理</h2><p>目前在监控镜头中遇到的控制zoom和focus的电机都是步进电机，其优点是技术成熟，控制简单，缺点也较明显，存在机械磨损，一颗镜头的正常拉伸周期在30万-50万次，以枪球联动为例，日夜频繁拉伸，理论寿命也就在3个月左右。</p>
<p>在镜头手册中对步进电机的说明一般包含以下几个参数：</p>
<ol>
<li><p>线圈阻抗；</p>
</li>
<li><p>驱动电压；</p>
</li>
<li><p>激励方法：1-2相驱动，2-2相驱动；</p>
</li>
<li><p>螺杆螺距，螺距即螺纹上相邻两牙对应点之间的轴向距离，目前遇到的大部分镜头都是0.4mm；</p>
</li>
</ol>
<p>我们主要关心的是第3条和第4条，目前算法中电机都采用的是2-2相驱动，根据电机步进角和细分步数及螺杆螺距最终将镜头的移动距离换算成电机步数，后面会结合具体的镜头介绍如何计算。</p>
<p>AF算法中，使用到了镜头自身的一些固有参数，下面以联合光电T5390-HQ1为例作介绍。</p>
<h3 id="镜头曲线的概念"><a href="#镜头曲线的概念" class="headerlink" title="镜头曲线的概念"></a>镜头曲线的概念</h3><p><img src="https://image.qinxing.xyz/20200507153434.gif" alt="图1 镜头pi点位置图"></p>
<p>图1中，黑色的曲线就是镜头的对焦曲线，横坐标表示zoom电机位置，纵坐标表示focus电机的位置。该曲线表示，在某一物距（物体到透镜光心的距离）下，当zoom处于横坐标中的某一位置时，如果focus正好位于曲线上，那么该物距下就能通过镜头在sensor上获得清晰的成像。</p>
<p>不同的物距对应着不同的对焦曲线，在zoom位置相同时，物距越远focus值越小（位置越低低）；不同曲线间的间隔在不同的zoom位置是不同的，在wide端（靠近坐标原点方向），不同物距下的对焦曲线间隔较近，在tele端（远离坐标原点方向），不同物距下的曲线间隔相对较大，如图2所示，</p>
<p><img src="https://image.qinxing.xyz/20200507111319.gif" alt="图2.不同物距下的对焦曲线"></p>
<p>厂商在给出的镜头手册中包含多组不同物距下的镜头对焦曲线，在AF算法中最多选10条曲线就可以很好的满足算法需求，选择曲线的要求一般是两条曲线之间的物距间隔不宜过大，过大的曲线间隔会对tracking时位置估计的准确性带来困难（两曲线间物距相差太大，对物距像距的线性近似偏差较大）。</p>
<p><strong>注意</strong>，不同厂商给出的对焦曲线使用的坐标原点会有所差异，在整理focus坐标时要一致性的将坐标原点转换成图1中表示的坐标，便于AF算法统一识别处理。</p>
<h3 id="镜头PI点"><a href="#镜头PI点" class="headerlink" title="镜头PI点"></a>镜头PI点</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>AF算法中zoom和focus电机都有自己的坐标系统，pi点就是一个相对于坐标原点的固有位置，如图1所示。</p>
<p>图中红色小圆圈标注的点是目前AF算法中标定的坐标原点，横坐标表示zoom电机位置，纵坐标表示focus电机的位置，虚线交叉的位置是PI点所在位置。</p>
<p>AF算法中步进电机细分后最小步长为0.005mm/步（表示电机走一微步，螺杆将结构向前推动0.005mm），根据图1中的尺寸标定，可以算出zoom PI点的位置为19.9mm(26.14-6.24) ,换算成电机步数为19.9/0.005 = 3980步，同理可计算出focus电机的PI点电机步数为6.2mm/(0.005mm/步) = 1240步。</p>
<h4 id="PI坐标点搜索过程"><a href="#PI坐标点搜索过程" class="headerlink" title="PI坐标点搜索过程"></a>PI坐标点搜索过程</h4><p>PI点坐标的搜索是在AF算法正常运行之前完成的（AF依赖于zoom和focus坐标），搜索过程依赖于镜头内部的光耦电平信号，光耦电平可用来确定电机运动方向和PI点位置。</p>
<p>如图1所示，ZPI表示zoom在当前位置处的PI电平，FPI表示focus在当前位置时的PI电平，两个电平值可通过GPIO来读取。对这款镜头来说，zoom靠近wide端时ZPI是低电平，靠近tele端时ZPI是高电平；focus在靠近near（小物距）端时FPI是高电平，在靠近far(大物距)端时FPI是低电平。光耦电平跳变的地方就是PI点的位置。</p>
<p>镜头内部的光耦在机芯正常工作时的关闭的，避免光耦漏光影响成像效果。PI程序搜索开始前首先打开光耦，根据当前光耦电平决定下一步电机的运动方向，目前的搜索程序在搜索过程中多次反复越过光耦点，搜索思想如下：</p>
<ol>
<li><p>搜索开始时大步向光耦电平跳变位置移动电机；</p>
</li>
<li><p>累加大步搜索时电机运动的总步数，如果总步数超过了最大运动步数，认为光耦电平无跳变，错误退出；</p>
</li>
<li><p>大步搜索过程中，光耦电平跳变后，改变电机运动方向和运动步长（步长减半），继续搜索光耦电平跳变点；</p>
</li>
<li><p>电平跳变后再次改变电机运动方向和电机运动步长（减小），更精确的搜索电平跳变位置，重复34操作，直到通过步长为1时搜索到电平跳变点退出；</p>
</li>
<li><p>此时的电机位置即PI点的坐标。</p>
</li>
</ol>
<h4 id="偏差校正"><a href="#偏差校正" class="headerlink" title="偏差校正"></a>偏差校正</h4><p>监控一体机镜头是一个精密的机械器件，镜头内部的镜片移动距离以0.005mm为单位计，由于机械加工的精度问题，光耦的安装位置，镜头后焦的距离，sensor板sensor高度等和设计时的理论值存在偏差，在镜头的生产过程中要对偏差进行校正。</p>
<p>镜头的校正的结果分成两个部分，第一部分是光耦位置的偏差校正，可解决光耦安装带来的偏差问题；第二部分是理论镜头曲线和实际镜头曲线的校正，这一部分主要是校正光学设计和实际生产的偏差，校正后的曲线和实际相符，<strong>有利于拉伸镜头时更好的实现全程清晰效果</strong>；</p>
<p>下面介绍目前采用的机芯校正方法：</p>
<p>PI校正其实就是校正PI点理论坐标和实际坐标的偏差，分为水平和垂直两个方向，如图7所示，黑色曲线表示理论曲线，虚线交叉处的黑色点表示理论PI位置，红色的点表示实际PI点位置。</p>
<p><img src="https://image.qinxing.xyz/20200507112004.gif" alt="图7 镜头PI校正原理"></p>
<p>理论PI点和实际PI点的偏移△x和△y分别对应着zoom PI偏差和focus PI偏差，图中只表示了偏差的情况之一，实际情况，偏差可以在黑色圆点的任意方向。</p>
<p>校正时用到的工具是一个模拟无穷远物距的灯箱，实际上是一个平行光管，简化结构如图8。</p>
<p><img src="https://image.qinxing.xyz/20200507112034.jpg" alt="图8 灯箱简化结构图"></p>
<p>光源为图像模板提供照明，毛玻璃使照明均匀，分划板位于透镜的焦点上，模板图像通过透镜成像于无穷远处。因此在物镜右侧可观测到位于无穷远的像。</p>
<p>校正时采用的是镜头的无穷远物距曲线，分为以下几个步骤：</p>
<p>1、将镜头移动到PI点（图7中红色原点处），记当前zoom和focus坐标为理论PI点坐标，此时坐标和理论坐标存在偏差；</p>
<p>2、在zoom最大步长范围内选择若干个位置点（记为锚点，如图7黑色曲线上的黑色小圆点所示），选点时要在wide端和tele端留有一定的余量，避免在错误的坐标系下过分靠近边界时和机械结构相撞。将zoom移动到对应的每个锚点坐标上，在自动聚焦模式下聚焦清楚后记录下对应的focus位置，这一过程中虽然坐标系统存在偏差，但和没有偏差的坐标系统相比，同样的zoom物理位置聚焦清晰时的focus物理位置是一样的，即和没有偏差的系统相比，同样物理位置聚焦清楚后的差异主要表现在坐标值的差异上；</p>
<p>考虑一简单情况，只有zoom PI点存在偏差，focus正常，如图9所示。</p>
<p><img src="https://image.qinxing.xyz/20200507112712.gif" alt="图9 focus系统无偏差情况"></p>
<p>  在偏差系统中如果zoom=2000，聚焦清楚时focus为1000，在无差系统中zoom为2000时聚焦清楚时focus为1100，focus的这一差异就是因为zoom坐标系统偏差引起。那么可以通过focus值的偏差来校正出zoom的偏差，理论上在镜头曲线单调区间内聚焦清楚时的focus位置对应着唯一的zoom，通过计算可以得出在无差系统中focus为1000时的zoom位置，这一位置和偏差系统中的位置差即zoom PI偏差。同理只考虑focus PI偏差的情况，zoom位置相同时聚焦清楚的focus偏差就是focus PI偏差。</p>
<p>3、在无差系统的锚点坐标（非物理位置）左右以单步长递增多次循环计算理论focus位置，在理论focus位置上加上一定范围内的偏差值（pi偏差肯定在一个适当范围内），计算每次偏差系统锚点处的focus和无差系统计算出的focus位置差的平方（最小二乘），统计出最小值，此时代入无差系统计算的zoom偏移和focus偏移即zoom PI和focus PI偏差。</p>
<p>4、记录描点时的focus和PI补偿后的理论focus偏差，该偏差即镜头曲线的校正偏差。</p>
<h2 id="（二）Tracking算法"><a href="#（二）Tracking算法" class="headerlink" title="（二）Tracking算法"></a>（二）Tracking算法</h2><p>Tracking是zoom tracking是简写，指的是在变倍过程中根据清晰度变化情况自动调整focus位置使得图像保持清晰的过程。</p>
<p>如图2所示，镜头厂商会给出大约10个不同物距下的镜头曲线，范围从很近的物距一直到无穷远物距。在tracking过程中物距是一个连续变化的过程，算法会根据当前的zoom位置和物距估算出下一个zoom位置处的focus值，下文将解释这一过程。</p>
<h3 id="曲线插值"><a href="#曲线插值" class="headerlink" title="曲线插值"></a>曲线插值</h3><p><img src="https://image.qinxing.xyz/20200507113717.gif" alt="图10 focus位置估计方法"></p>
<p>如图10所示，图中黑色的点表示镜头曲线表中的某一条曲线采样位置（镜头曲线在程序中没有完整的导入，完全导入镜头数据会较大，影响生成的库的大小），需要求出中间垂直线和镜头曲线交叉处的focus值，由于镜头曲线在较小的一段范围内近似直线，如图中的红色连线所示，根据三角形等比公式有如下等式：</p>
<p>△f1/△f2 =△z1/△z2</p>
<p>其中△f2、△z1、△z2均可从曲线表中查询后计算获得，因此可算出△f1值，从而近似计算得到交叉点的focus位置（前一个圆点处的focus位置+△f1）。</p>
<h3 id="Focus位置估计"><a href="#Focus位置估计" class="headerlink" title="Focus位置估计"></a>Focus位置估计</h3><p>根据高斯成像公式</p>
<p>1/f = 1/u + 1/v</p>
<p>其中f表示焦距，u表示物距，v表示像距。聚焦时zoom在一固定位置，焦距恒定，那么上面公式可改写为：</p>
<p>C = 1/u + 1/v</p>
<p>简单变换后为：</p>
<p>v = 1/c * (1 + 1/(cu - 1))</p>
<p>函数形状如图11所示：</p>
<p><img src="https://image.qinxing.xyz/20200507113910.gif" alt="图11 焦距恒定时物距和相距的对应关系"></p>
<p>从图中可以看出，物距u和像距v之间是一一对应的关系。Focus位置估计时的已知和未知量如图12所示：</p>
<p><img src="https://image.qinxing.xyz/20200507113945.gif" alt="图12 待估计的focus位置"></p>
<p>图12中，黑色的小圆点表示已知的focus位置，红色的小圆点表示待估计的focus位置，三个小圆点的物距信息为已知，求红色小圆点处的focus位置。映射到图11中的效果如图13所示。</p>
<p><img src="https://image.qinxing.xyz/20200507114948.gif" alt="图13 "></p>
<p>其中△u1、△u2、△x1、△x2、△v2为已知信息，△v1为待求信息，在黑色点物距差较近时，黑色点的连线近似直线，有如下等式成立：</p>
<p>△u1/△u2 = △x1/△x2 = △v1/△v2</p>
<p>因此可以计算出△v1 = △u1 * △v2/△u2,从而计算出红色点处的镜头focus值。</p>
<p>总结起来分为以下几步：</p>
<ol>
<li><p>根据物距大小计算出比当前物距略小和略大的两条镜头曲线；</p>
</li>
<li><p>根据要估计的zoom位置在采样过后的曲线表中找出该点的前一个点和后一个点，在第一步中找到的两条曲线上通过插值计算出zoom位置处的两个focus值，即图10中中间垂直线和两条曲线的交叉点处的focus值；</p>
</li>
<li><p>使用第2步中计算出的focus值和图13的比例关系，计算出目标物距处的focus值。</p>
</li>
</ol>
<h3 id="物距估计"><a href="#物距估计" class="headerlink" title="物距估计"></a>物距估计</h3><p>物距估计即根据当前的zoom和focus位置及已知的镜头曲线表计算出当前focus位置的物距大小。</p>
<p>计算过程分为以下几步：</p>
<ol>
<li><p>根据镜头曲线表和zoom位置插值计算出镜头曲线上zoom位置对应的focus值；</p>
</li>
<li><p>比较实际focus值和插值处的focus值，得出当前focus位于哪两条镜头曲线之间；</p>
</li>
<li><p>根据镜头曲线标号得出第二步中两条镜头曲线的物距信息；</p>
</li>
<li><p>问题转换为根据已知的两点的focus值和对应的物距信息及一处focus值，求该focus值处的物距信息；</p>
</li>
<li><p>这样求解过程和图13类似，通过等比计算可直接算出。</p>
</li>
</ol>
<h2 id="（三）爬坡算法"><a href="#（三）爬坡算法" class="headerlink" title="（三）爬坡算法"></a>（三）爬坡算法</h2><p>目前的AF算法中搜索峰值的过程采用的是盲人爬坡算法，该方法要求清晰度评价函数具有严格的单峰性。搜索过程中只能通过爬坡和下坡来判断出山峰的方向而不能看到山峰的全貌，只有当越过山峰时才能找到山峰。</p>
<p>为了提高聚焦是速度，在af算法中将山坡划分为3个不同的区域，分别对应着平坦区域（flat），斜坡区域（slope），陡坡区域（steep）,不同区域对应着不同的爬坡步长，在平坦区域采用大步走的方式，随着坡度越来越来，步长越来越小，以达到快速精确搜索山峰的目的。爬坡过程如图14所示。</p>
<p><img src="https://image.qinxing.xyz/20200507115836.gif" alt="图14 理想山峰的爬坡过程"></p>
<p>可以采用状态机的方法，实现各种状态的跳转。</p>
<h3 id="滤波器的应用"><a href="#滤波器的应用" class="headerlink" title="滤波器的应用"></a>滤波器的应用</h3><p>如何评价清晰度？这里就要用到滤波器了。图像越清晰，说明图像的高频分量越多，用一款滤波器保留图像的高频分量，来对比到底哪张图片更加清晰。</p>
<p>基于硬件设计的成本考虑，早期的自动对焦系统都是用一些固定系数高频提取算子比如sobel，laplace等作为评价函数。</p>
<p>当图像高频成分丰富的时候，例如合焦附近的时候，高通滤波器能够提取足够的锐度信息。但是当图像离焦的时候，高通滤波器就不行了，带通滤波器和带阻滤波器比高通滤波器能更好的提取图像的锐度信息。</p>
<p>举例来说，下图画出两组滤波器对不同对比度图像的响应曲线。横轴是lens 位置，纵轴是focus value。</p>
<p>可以看出下方sobel 算子对于低对比度图像的响应非常平坦，对于高对比度离焦的情况也不好。</p>
<p><img src="https://image.qinxing.xyz/20200507144257.jpg" alt></p>
<p>从信号处理的理论上来讲，这些算子都可以认为是FIR滤波器</p>
<p><img src="https://image.qinxing.xyz/20200507144304.jpg" alt="FIR滤波器原理"></p>
<p>一个4 tap FIR滤波器其输出可表示为：</p>
<p><img src="https://image.qinxing.xyz/20200507144328.jpg" alt></p>
<p>比如 difference算子就可以用一个2 阶FIR 滤波器表示：</p>
<p>h(0) = +1,</p>
<p>h(1) = -1;</p>
<p>这些算子相当于系数固定的FIR滤波器，很多早期对焦系统的评价函数就是这些固定的算子。</p>
<p>因为镜头以及成像系统的光学特性差别很大，这种固定系数高频算子的ISP设计不能满足自动对焦系统的需要。比如在低对比度的情形下，图像缺少高频成份，如果滤波器就不能够提取到足够的图像边缘的高频成份，这样对焦算法就无法找到峰值从而实现对焦了。所以后来的自动对焦系统评价函数逐渐采用可以设定系数的FIR或者IIR滤波器。从原理上说，实现同样性能的滤波器，IIR滤波器比FIR滤波器的阶数要低，为了节省行存，硬件上采用IIR滤波器较为合适。</p>
<p><img src="https://image.qinxing.xyz/20200507150203.jpg" alt="二阶IIR滤波器"></p>
<p>上图是一个二阶IIR滤波器，与FIR滤波器相比，IIR滤波器会把输出反馈到输入。</p>
<p>传递函数数学表达式是：</p>
<p><img src="https://image.qinxing.xyz/20200507150235.jpg" alt></p>
<p>再回到具体的自动对焦系统中来说，一般会采用下面的设计：</p>
<p><img src="https://image.qinxing.xyz/20200507150249.jpg" alt></p>
<h2 id="（四）我的疑问"><a href="#（四）我的疑问" class="headerlink" title="（四）我的疑问"></a>（四）我的疑问</h2><ol>
<li><p>如果有两个物体，一个前一个后，总会聚焦在前景上怎么办？</p>
<p>可以设置ROI，设置感兴趣的区域，将这个区域对焦清楚位置</p>
</li>
<li><p>PI点是什么？它有什么作用？</p>
<p><strong>回答</strong>：刚上电的时候，zoom和focus的电机不知道自己停在什么位置。这个PI点，就是确定一个起始位置，或者说是坐标轴的中心。接下来的移动都按照这个为准</p>
</li>
<li><p>对焦曲线为什么在焦距比较长的地方会分岔？</p>
<p><strong>猜测</strong>：当焦距比较短的时候，景深比较大，像也比较近，只要对焦清楚了，基本都能看清。而焦距比较长的时候，景深比较小，不同物距的像离得比较远，想要看到不同距离的物体，就需要移动sensor的位置了。所以焦距比较长的时候，会有多根线。</p>
</li>
<li><p>理论上焦距越长，像应该越远，但是这个对焦曲线却不是一直增大的，而是先增大后减小，这是为什么呢？</p>
<p><strong>猜测</strong>：可能是变焦镜头在变焦的过程中，镜片组在移动，等效出来的理想凸透镜也在移动。虽然焦距变长了，但是镜片位置前移了，像与镜头的位置反而缩短了</p>
</li>
<li><p>镜头内部的光耦在机芯正常工作时的关闭的，避免光耦漏光影响成像效果。光耦会漏光么？我印象中的光耦是塑料封装的，应该不存在漏光的问题呀。</p>
</li>
<li><p>海思平台的滤波器貌似由横向Horizontal IIR和纵向Vertical FIR两种一维滤波器组成，为何不用二维的FIR或者IIR滤波器？</p>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像</category>
      </categories>
      <tags>
        <tag>AF</tag>
      </tags>
  </entry>
  <entry>
    <title>SENSOR HDR技术的发展与思考</title>
    <url>/posts/c3f0ff3b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>整理自<a href="https://zhuanlan.zhihu.com/p/135280041" target="_blank" rel="noopener">知乎</a>和<a href="https://www.sohu.com/a/252440543_237916" target="_blank" rel="noopener">网页</a></p>
</blockquote>
<p>高动态范围图像（High-Dynamic Range，简称HDR），相比普通的图像，可以提供更多的动态范围和图像细节，根据不同的曝光时间的LDR（Low-Dynamic Range，低动态范围图像），并利用每个曝光时间相对应最佳细节的LDR图像来合成最终HDR图像。它能够更好的反映出真实环境中的视觉效果。</p>
<p>这篇文章主要讲视频的HDR技术，拍照的HDR大部分是算法处理的结果，这里不做讨论。</p>
<h2 id="（一）原始的时域多帧HDR技术"><a href="#（一）原始的时域多帧HDR技术" class="headerlink" title="（一）原始的时域多帧HDR技术"></a>（一）原始的时域多帧HDR技术</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>相机在时间上连续输出由欠曝到过曝的图像，然后做图像融合，得到HDR图像。</p>
<p><img src="https://image.qinxing.xyz/20200430103833.png" alt></p>
<p>融合后HDR图像</p>
<p><img src="https://image.qinxing.xyz/20200430114216.jpg" alt="img"></p>
<p>比较典型的一种融合方法是根据luminance，contrast，motion等条件，对第K帧图像的像素[i，j]给出权重。Wij,k 是第K帧，位置i，j像素的权重，Xk((i,j)是原始像素值，Xf（i，j）是融合后的像素值。公式如下</p>
<p><img src="https://image.qinxing.xyz/20200430104853.png" alt></p>
<p>对彩色图像，权重的计算会考虑色彩的饱和度等因素。</p>
<h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h3><p>由于传统时域多帧是基于连续曝光的整帧图像（Frame Based）进行融合，所以图像之间的间隔时间就是一帧图像的周期，由此会产生很多artefacts：</p>
<p><img src="https://image.qinxing.xyz/20200430114246.jpg" alt="场景内物体增减"><br><img src="https://image.qinxing.xyz/20200430115705.png" alt="近距离物体快速移动形成拖影"><br><img src="https://image.qinxing.xyz/20200430115732.png" alt="Color artefact"></p>
<p>Frame based的多曝光HDR技术常用于still image 的capture，也有视频HDR 采用这种技术，比如sensor以60fps的帧率交替输出长短曝光，融合后输出30fps的HDR图像。</p>
<p><img src="https://image.qinxing.xyz/20200430114752.jpg" alt="长短帧交替输出"></p>
<p><img src="https://image.qinxing.xyz/20200430185250.jpg" alt="Frame based Video HDR sensor"></p>
<p>早期的HDR video有采用这种技术，自从DOL技术出现后，这种Frame based Video HDR技术就逐渐退出历史舞台了。</p>
<h2 id="（二）Temporal-HDR"><a href="#（二）Temporal-HDR" class="headerlink" title="（二）Temporal HDR"></a>（二）Temporal HDR</h2><p>Temporal HDR是利用不同曝光时间实现的HDR。有下面几种方案：</p>
<h3 id="1-DOL"><a href="#1-DOL" class="headerlink" title="1. DOL"></a>1. DOL</h3><p>DOL HDR 也叫做line interleaving HDR 技术。以两曝光DOL为例，sensor每行会以长短曝光两次先后输出，从readout角度来看，就是长曝光帧与短曝光帧 line interleaving 依次输出，如下图，第一行L输出，第一行S输出，第二行L输出，第二行S输出，以此类推。</p>
<p><img src="https://image.qinxing.xyz/20200430120228.jpg" alt="DOL曝光时序"></p>
<p>frame based HDR，长短曝光帧的间隔是一个帧周期，也就是必须一整帧（长）曝光结束，再开始一整帧（短）曝光，如下图</p>
<p><img src="https://image.qinxing.xyz/20200430185300.jpg" alt="frame based HDR"></p>
<p>对于DOL HDR而言，由于line interleaving（行的交织），存在两帧的overlap，等于一帧输出没结束，下一帧就来了，长短曝光帧的间隔大大缩小了。</p>
<p>从下图可见，长曝光帧与短曝光帧overlap了一部分，所以这种技术叫digital overlap。其实就是减少了短帧的消影时间（sweep time）。</p>
<p><img src="https://image.qinxing.xyz/20200430185302.jpg" alt="digital overlap"></p>
<p>Staggered-HDR可以归为这一类</p>
<p><img src="https://image.qinxing.xyz/20200430185223.jpeg" alt="Staggered-HDR的原理"></p>
<p>在一次完整曝光的过程中，sensor分别在短、中等和长曝光时读出一次数据，数据进行芯片外处理以得到HDR图像。</p>
<h4 id="DOL长短曝光时间比与动态范围扩展"><a href="#DOL长短曝光时间比与动态范围扩展" class="headerlink" title="DOL长短曝光时间比与动态范围扩展"></a>DOL长短曝光时间比与动态范围扩展</h4><p>以两曝光DOL 为例</p>
<p>Exposure ratio = Long exposure time/ short exposure time</p>
<p>假设Exposure ratio = 16，假设在亮度没有饱和的条件下，相当于曝光最大值增大了16倍：2^4。也就是动态范围扩大了4个bit。</p>
<p>以此类推，每增加一个曝光帧，如果exposure ratio =16，动态范围就可以扩大4bit。</p>
<p>按照一般HDR sensor 单曝光为12bit来算的话，2次曝光可以让sensor的输出动态范围扩大到16bit，4曝光就可以让sensor输出的动态范围扩大到24bit（12+4+4+4)。</p>
<p><img src="https://image.qinxing.xyz/20200430181942.jpg" alt="多帧曝光扩展动态范围"></p>
<p>exposure ratio 也不是越大越好，exposure ratio会受到三方面的制约，图像质量，sensor设计以及isp line delay buffer。</p>
<p>从图像质量上来说，短曝光时间越短，图像噪声越高，长曝光越长，motion的影响越大。Exposure Ratio越大，在图像融合后的SNR drop也越大。</p>
<p>从sensor设计上来说，长短曝光之比受到读出电路的限制，sony的DOL第二代采用虚拟通道技术一定程度改善了这个限制。</p>
<p>从ISP的角度来说line delay buffer 也限制了最大曝光时间。在短曝光行出来之前，第一个长曝光行应该还在delay buffer里，这样才能两者对齐好给后面的frame stitch操作。而长短曝光比越大，需要的line delay buffer就越大。</p>
<p><img src="https://image.qinxing.xyz/20200430120615.webp" alt="DOL buffer"></p>
<p>对于sensor做hdr融合case而言，line delay buffer size就是固定的，所以ISP倾向于在isp这端做HDR融合，这样可以更灵活的设计。（Maver注：对于车载而言，带宽是个主要关注点，所以大部分用户不会选择在ISP侧做HDR融合）</p>
<h3 id="2-IHDR"><a href="#2-IHDR" class="headerlink" title="2. IHDR"></a>2. IHDR</h3><p>BME(Binned multiplexed exposure)，也叫iHDR（interlaced HDR sensors）。</p>
<p><img src="https://image.qinxing.xyz/20200430183835.png" alt="IHDR"></p>
<p>如右边图案所示，在传感器上间隔两行分别使用长短曝光设置，最终合成一帧行数减半的图像。</p>
<p>DOL技术如果想要出每秒25帧的HDR视频，sensor就需要每秒出50帧，对ISP和CPU的性能要求比较高。而该技术的一帧图像就包含了长短帧曝光，降低帧率的要求。输出速率降低了，对sensor的帧缓存要求也降低了。</p>
<p>但它的缺点也很明显， binned（二合一）的读出方式让图像分辨率减少了一半，该技术主要适用于对分辨率要求不高的预览或录像HDR。</p>
<h3 id="3-Zig-zag-HDR"><a href="#3-Zig-zag-HDR" class="headerlink" title="3. Zig-zag HDR"></a>3. Zig-zag HDR</h3><p>千辛万苦研究提升的分辨率怎么能说降就降呢？不甘心啊~</p>
<p>芯片厂商又研发了新的方案，称作SME(Spatially multiplexed exposure) ，或叫做Zig-zag （Z字形）HDR。</p>
<p><img src="https://image.qinxing.xyz/20200430185316.png" alt="Zig-zag HDR"></p>
<p>图如其名，长短曝光分别呈现“Z”字型，每一行像素既有长曝光也有短曝光。据称只要算法足够优秀，该方案就能够输出接近全像素的HDR照片，并且可以用作实时预览。</p>
<p>在4合1模式下，2x2像素区域内分别设置长(L)、中等(M)、短(S)三级曝光，将 4个像素合并为一个输出，称之为3-Exposure HDR。</p>
<p><img src="https://image.qinxing.xyz/20200430191135.jpeg" alt="zig-zag HDR输出"></p>
<p>采用三曝光实现实时HDR预览，拍照时采用传统帧序列HDR方法，抓取三张不同曝光的图像进行平台端算法处理。</p>
<p>由于人眼对亮度的感知是呈对数的，用tone curve可以压缩亮区图像数据的同时，保留暗区的细节（类似一个预处理的gamma）。</p>
<h3 id="Temporal-HDR的局限"><a href="#Temporal-HDR的局限" class="headerlink" title="Temporal HDR的局限"></a>Temporal HDR的局限</h3><p>Sony在推出DOL的时候，宣传DOL是‘准同时’输出长短曝光。既然是‘准同时’，那就还不是同时，所以也会有一些典型时域多帧HDR的图像质量问题，同时DOL也有一些特有的IQ问题。</p>
<h4 id="1-伪像（HDR-Transition-Artefacts）"><a href="#1-伪像（HDR-Transition-Artefacts）" class="headerlink" title="1. 伪像（HDR Transition Artefacts）"></a>1. 伪像（HDR Transition Artefacts）</h4><p>可以从下左图看到composition noise造成的edge，这种edge有时候会误导机器视觉。</p>
<p><img src="https://image.qinxing.xyz/20200430120703.jpg" alt="HDR Transition Artefacts"></p>
<p>从DOL hdr的noise profile可以看出来，如下图，在HDR拼接处，可以看到SNR的显著变化，叫做snr drop，当SNR drop大的时候，就会出现明显的edge，如上图所示。</p>
<p><img src="https://image.qinxing.xyz/20200430120725.jpg" alt="DOL HDR noise profile"></p>
<p>曝光比越小，SNR drop就越小, 可以想见，如果曝光比为1，也就没有snr drop了。反之，曝光比越大，动态范围越大，snr drop也越大，如下图所示。</p>
<p><img src="https://image.qinxing.xyz/20200430180310.jpg" alt="曝光比为32时的noise profile"></p>
<h4 id="2-水波纹（banding）"><a href="#2-水波纹（banding）" class="headerlink" title="2. 水波纹（banding）"></a>2. 水波纹（banding）</h4><p>由于短帧曝光时间短，每次曝光交流电的亮度都不同，会类似水波纹的现象banding。</p>
<p><img src="https://image.qinxing.xyz/20200430180420.jpg" alt="flicker"></p>
<p>为了避免水波纹，就得让最小曝光时间是半周期的整数倍，这样sensor的每行像素曝光时的亮度就是一样的。如果交流电是50Hz，曝光时间需要是10ms的整数倍。</p>
<p><img src="https://image.qinxing.xyz/20200430180523.jpg" alt="antibanding"></p>
<p>这样就不会出现水波纹现象了。但是由于最小曝光时间变大了，动态范围就损失了。所以有时候为了保证不损失动态范围，就得容忍水波纹。这就得看应用场景了。</p>
<h4 id="3-PWM光源图像的闪烁与丢失"><a href="#3-PWM光源图像的闪烁与丢失" class="headerlink" title="3. PWM光源图像的闪烁与丢失"></a>3. PWM光源图像的闪烁与丢失</h4><p>类似的问题发生在PWM供电的Led光源上，尤其是交通信号灯以及汽车信号灯，如下图所示</p>
<p><img src="https://image.qinxing.xyz/20200430182027.jpg" alt="抓拍红绿灯不亮的原因"></p>
<p>我们看到的红绿灯不是一直亮着的，一个电源周期里面，只有比较小的一段时间是亮的。</p>
<p>sensor的长曝光帧能捕捉到到红绿灯亮的时候，但是短曝光帧就没捕捉到，这样也会造成闪烁（flickering）甚至信号灯图像的丢失。</p>
<p><strong>注意：</strong>不是仅仅宽动态才会引起这个问题，当曝光时间短的时候都会有这个问题。比如说电警设备，抓拍快门一般都在几百上千分之一，很容易出现一直黑着的情况。因此需要做一个电源同步的操作。由于红绿灯闪烁的频率和当地的供电频率一致，通过硬件的方法，可以知道红绿灯亮着的时间。从而确保每次曝光的时候，红绿灯都是亮着的。</p>
<h2 id="（三）Spatial-HDR"><a href="#（三）Spatial-HDR" class="headerlink" title="（三）Spatial HDR"></a>（三）Spatial HDR</h2><p>sensor除了在时域上用多帧进行HDR（Temporal HDR），还有另外一个方向是空间上的HDR（Spatial HDR）。</p>
<p>我目前只看到了split/sub pixel技术。</p>
<p>车载领域也广泛使用Temporal domain HDR技术，但是随着车载相机在ADAS与自动驾驶领域的迅速发展，对图像质量有着特别的需求，导致Temporal domain HDR技术不能满足需要。车载比较典型的两个IQ需求是不能有motion artefact 和 LED flickering。</p>
<p><img src="https://image.qinxing.xyz/20200430182918.jpg" alt="motion artefact"></p>
<p><img src="https://image.qinxing.xyz/20200430185330.jpg" alt="LED flickering"></p>
<p>Temporal （时间的）HDR 在原理上就存在这些缺陷，所以要解决这个问题就需要使用其他的HDR体制：Spatial（空间） HDR技术是现在车载领域的主流解决方案。</p>
<p>比较典型的是Sony sensor（imx390/490）采用的Subpixel技术与OV sensor（ovx1a)采用的split pixel技术，他们都属于SpatialHDR技术范畴，其基本原理是一致的。</p>
<h3 id="大小pixel的分离结构"><a href="#大小pixel的分离结构" class="headerlink" title="大小pixel的分离结构"></a>大小pixel的分离结构</h3><p>与普通CFA的不同，大小pixel技术的sensor在相邻位置有一大一小两个pixel，他们空间上非常接近，可以认为对空间采样相同。</p>
<p><img src="https://image.qinxing.xyz/20200430185337.jpg" alt="split/sub piexl结构"></p>
<p>由于pixel的大小不同，物理上的sensitivity不同，FWC也不同，会产生与时域HDR一样的不同曝光效果，形成了对不同动态范围的覆盖。如下图可以看到LPD（Large Pixel Diode）与SPD（Small Pixel Diode）是如何扩展动态范围的。</p>
<p><img src="https://image.qinxing.xyz/20200430185409.jpg" alt></p>
<h3 id="大小分离pixel的电路设计"><a href="#大小分离pixel的电路设计" class="headerlink" title="大小分离pixel的电路设计"></a>大小分离pixel的电路设计</h3><p>典型的大小分离pixel的电路如下图所示</p>
<p><img src="https://image.qinxing.xyz/20200430185428.jpg" alt="split/sub pixel电路设计"></p>
<p>SPD和LPD分别用黄色的二极管标出。CGC（conversion gain control）与TG（transfer gate）控制了photo diode 向FD充电，当TGs使能时，FD接收SPD来的电荷，RS会使能让FD的电荷转存出来。然后当TGL使能时，FD接收LPD来的电荷，RS会再一次使能让FD的电荷转存出来。RST负责在每一次转存后把FD电容清空。这样的电路结构就实现了LPD和SPD的分别读出。这个部分的电路时钟非常快，所以可以认为大小像素是同时曝光的。后面的读出电路也会把大小像素同时读出，由下图可见，T_lpd与T_spd是同时的。</p>
<p><img src="https://image.qinxing.xyz/20200430185449.jpg" alt="split/sub pixel读取时序"></p>
<h3 id="大小像素HDR与时域HDR在motion-artefact上的比较"><a href="#大小像素HDR与时域HDR在motion-artefact上的比较" class="headerlink" title="大小像素HDR与时域HDR在motion artefact上的比较"></a>大小像素HDR与时域HDR在motion artefact上的比较</h3><p>由下图可以看出基于大小像素的HDR与时域HDR在拍摄运动物体上的motion artefact比较。</p>
<p>左图是基于大小像素的图像，完全没有motion artefact，右图是时域HDR，可以看到明显的motion artefact。</p>
<p><img src="https://image.qinxing.xyz/20200430185501.jpg" alt="motion artefact"></p>
<p>对于这种更挑战的场景，舞厅的旋转光球，左图是大小像素HDR，右图是时域HDR，可以看到时域HDR的图像把小的运动光点都混到了一起。</p>
<p><img src="https://image.qinxing.xyz/20200430185548.jpg" alt="motion artefact"></p>
<h3 id="大小像素与Dual-conversion-gain的结合"><a href="#大小像素与Dual-conversion-gain的结合" class="headerlink" title="大小像素与Dual conversion gain的结合"></a>大小像素与Dual conversion gain的结合</h3><p>单独靠大小像素只能形成两个曝光的图像，再结合之前介绍过的DCG技术，在大小pixel分别配合HCG，LCG，就可以形成4曝光。</p>
<p>假设单曝光输出12bit，曝光比是16，那总共的动态范围可以达到24bit输出。</p>
<p><strong>注意</strong>：在相同增益下，HCG比LCG模式图像要亮，相当于自带一个增益。</p>
<p><img src="https://image.qinxing.xyz/20200430185553.jpg" alt="Dual conversion gain"></p>
<h3 id="两种场景的切换"><a href="#两种场景的切换" class="headerlink" title="两种场景的切换"></a>两种场景的切换</h3><p>如下图，横轴是场景的光亮度，纵轴是SNR，红色曲线是LPD像素的SNR曲线，蓝色曲线是LPD像素的SNR曲线。</p>
<p><img src="https://image.qinxing.xyz/20200430191108.jpg" alt="SNR"></p>
<p>SPD的饱和点更高，而LPD的低光SNR更高。这两条曲线说明了大小像素这种设计可以很灵活的适配场景的变化，当场景非常亮的情况，就用大小像素融合输出，这样可以扩大动态范围。</p>
<p>当场景非常暗的情况，就完全切换到LPD像素，因为它的SNR更高。</p>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p><strong>疑问1</strong>：是否会对清晰度有影响？大的像素和小像素的位置不一样，接收到的画面也就可能不一样，融合起来是否会对清晰度造成影响？</p>
<p><strong>疑问2</strong>：如果用sub pixel 的技术，能不能解决红绿灯闪烁甚至消失的问题？是不是电警设备不需要加电源同步（这边一般是FPGA做的），用宽动态就可以解决红绿灯不亮的问题。这样会不会更加节省成本？</p>
<p><strong>回答</strong>：不行，电警设备抓拍车要求快门时间很小，只要是曝光时间小，就还是会抓不到，一定要做电源同步。</p>
<p>用sub pixel技术的话，他们是一起曝光的，只是感光度不一样，感光率比较低的可以完美的抓拍到红绿灯而不过曝。但是必须要求曝光时间大于红绿灯的一个周期，这样曝光时间明显就会比较长，相比于电警动则几千分之一的快门，拍快速运动的物体有点问题。</p>
<p><strong>疑问3</strong>：电警的FPGA模块到底有哪些作用？</p>
<p><strong>回答</strong>：1. 控制爆闪灯下的抓拍：由于爆闪灯亮的时间很短，只有几ms，需要确保在sensor的曝光时间内闪烁 2. 电源同步：由于红绿灯闪烁的频率和当地的供电频率一致，通过硬件的方法，可以知道红绿灯亮着的时间。从而确保每次曝光的时候，红绿灯都是亮着的</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>效果调试</tag>
        <tag>sensor</tag>
        <tag>HDR</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读笔记——数码单反摄影从入门到精通</title>
    <url>/posts/29fcc0b6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>本书有不少错误和纰漏，我在这里做了记录。同时学习一些单反摄影的基本知识和构图技巧。</p>
</blockquote>
<h2 id="（一）构造"><a href="#（一）构造" class="headerlink" title="（一）构造"></a>（一）构造</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>书中说的是小孔成像，我更认为应该是凸透镜成像原理，当物距远远大于焦距的时候，才可以近似成小孔成像。<br>详细分析请看<a href="https://qinxing.xyz/posts/b31d381e/" target="_blank" rel="noopener">《相机成像原理之镜头篇》</a></p>
<p>sensor尺寸为36mm×24mm，这种相机就称为全画幅相机</p>
<h3 id="常用附件"><a href="#常用附件" class="headerlink" title="常用附件"></a>常用附件</h3><h4 id="1-UV滤镜"><a href="#1-UV滤镜" class="headerlink" title="1. UV滤镜"></a>1. UV滤镜</h4><p>UV（Ultra Violet Filter）滤镜有两个作用，其一是滤除光线中的紫外线；其二是保护镜头镜片不被擦刮、污损。在日光照射很强时，光线中的紫外线成分较多，如果不带滤镜拍摄，可能会使拍出来的照片偏蓝，</p>
<h4 id="2-偏光滤镜"><a href="#2-偏光滤镜" class="headerlink" title="2. 偏光滤镜"></a>2. 偏光滤镜</h4><p>摄影者经常遇到照片效果色彩饱和度不足、拍摄对象反光严重等问题，而这又不是拍摄技术以及相机本身所引起的，此时可能需要通过偏光滤镜来进行调节。偏光镜基本上就是用偏光角度来过滤光线的一种滤镜。<br>偏振镜允许特定方向照射来的光线，同样也会滤除另外一些方向射来的光线，最终可以调整光线进入镜头后的拍摄效果。当两者夹角为0°，即光波上下震动方向与偏振夹角相同时，透过的光线最多；夹角为90°时，通过的光线非常少。</p>
<h4 id="3-渐变滤镜"><a href="#3-渐变滤镜" class="headerlink" title="3. 渐变滤镜"></a>3. 渐变滤镜</h4><p>在拍摄部分场景的画面时，有时会遇到场景中各个部分明暗对比较强的情况。如果要获得曝光比较均匀的相片，则必须要将画面反射入镜头的光线调匀，此时可以通过渐变滤镜来调整。将滤镜的暗色部分遮挡住画面中光线较亮的场景，透光性较好的部分用于通过被摄场景中较暗的反射光，以保证绝大多数光线能够进入镜头。通过调整，可以使画面获得较均匀的曝光效果。</p>
<h4 id="4-遮光罩"><a href="#4-遮光罩" class="headerlink" title="4. 遮光罩"></a>4. 遮光罩</h4><p>在逆光、侧光或使用闪光灯摄影时，遮光罩能防止非成像光进入镜头，避免产生雾霭；在顺光和侧光摄影时，可以避免周围的散射光进入镜头；在灯光摄影或夜间摄影时，可以避免周围的干扰光进入镜头；此外，还可以在一定程度上防止意外损伤镜头。<br>遮光罩广泛用于逆光摄影，一般可以避免眩光。但如果光源距离过近，仍有可能发生眩光现象。</p>
<hr>
<h2 id="（二）镜头"><a href="#（二）镜头" class="headerlink" title="（二）镜头"></a>（二）镜头</h2><h3 id="1-焦距"><a href="#1-焦距" class="headerlink" title="1. 焦距"></a>1. 焦距</h3><p>镜头焦距的长短决定着照片的成像、视角、景深大小和透视强弱。<br>标准镜头是50mm，需要记住视场角47度，五百万的像素大概可以拍摄九米处80x80像素的人脸。<br><img src="https://image.qinxing.xyz/20200428234613.png" alt="17mm焦距到300mm焦距，镜头视角从104°缩小为8°的视角范围"></p>
<h3 id="2-非球面镜片"><a href="#2-非球面镜片" class="headerlink" title="2. 非球面镜片"></a>2. 非球面镜片</h3><p>光线通过透镜时，透镜中间位置附近透过的光线会准确地汇聚在焦点位置，但是通过透镜边缘部位的光线则会汇聚在焦点与透镜之间的位置，这样光线汇聚的散乱性就会造成最终拍摄照片的模糊。这种汇聚焦点的偏差，称为“球面像差”。如果要修正通过透镜边缘光线的汇聚偏差问题，可以使用特殊种类的透镜来解决，这种特殊的镜片即为“非球面镜片”，是指镜片中间的弧度与镜片边缘的弧度不同，以此来修正光线折射的焦距，确保通过镜片任何位置的光线都能准确地聚集在焦点上，形成清晰的图像品质。</p>
<h3 id="3-低色散镜片"><a href="#3-低色散镜片" class="headerlink" title="3. 低色散镜片"></a>3. 低色散镜片</h3><p>自然界中的光线都是复合型光线，是红、橙、黄、绿、青、蓝、紫等颜色的光线复合而成的，不同颜色的光线通过透镜后的焦点位置也不相同，这样就会造成聚集点的不一致，造成色散的问题。摄影学中，物体发出或反射的光线进入相机，在感光元件上成像时，如果发生色散，会对成像质量有严重影响，因此相机厂商多采用低色散镜片。通过低色散镜片，可以有效抑制光线通过透镜后色散严重的程度，提高画质。</p>
<h3 id="4-定焦镜头"><a href="#4-定焦镜头" class="headerlink" title="4. 定焦镜头"></a>4. 定焦镜头</h3><p>定焦镜头的光学品质一般非常好，优于一般的变焦镜头，特别是焦距、拍摄条件相同时，可以看出两者拍摄效果的明显差别。定焦镜头对拍摄画面四周的变形抑制能力很强，比变焦镜头要好一些，特别是在大广角焦段，它可达到的最大光圈较大，如F1.2、F1.4等超大光圈一般只出现在定焦镜头上。<br>另外，定焦镜头还有重量较轻、便于携带的优点</p>
<h3 id="5-微距镜头"><a href="#5-微距镜头" class="headerlink" title="5. 微距镜头"></a>5. 微距镜头</h3><p>由于物体越近，景深越小，为了达到比较大的景深效果需要很小的光圈，所以微距的光圈值都比较小<br>微距镜头特点如下：最小光圈值较小，通常可以缩至F38、F45等，因为拍摄距离很近时，比较容易造成对焦点前后景物虚化的效果，如果要将对焦点前后都拍摄清楚，就要使用非常小的光圈；对焦速度很慢，由于微距镜头从最近到最远的对焦过程比较长，因此对焦速度非常慢，即使使用超声波马达对焦，其对焦速度比一般镜头也要慢。</p>
<h3 id="6-外接设备"><a href="#6-外接设备" class="headerlink" title="6. 外接设备"></a>6. 外接设备</h3><ul>
<li>使用增倍镜后，画质会变差，包括色彩饱和度和锐度等都要有所下降；另外，使用增倍镜后，原本的最大光圈会缩小一级，如F2.8的最大光圈镜头在加装增倍镜后，最大光圈会变为F4.0。</li>
<li>使用近摄环后，最终拍摄照片的画质并不会受到明显影响，因为近摄环就是一个金属环，没有安装光学镜片；但使用近摄环后，快门速度会变慢，因为近摄环会影响进入镜头的入光量。使用近摄环后，对焦方式与一般镜头不同，必须先转动变焦环进行初步对焦，才能转动对焦环进行对焦修正；如果是定焦镜头使用近摄环，则必须前后移动拍摄位置，否则无法完成对焦。近摄环的功能就是缩短镜头的对焦距离，达到提升镜头放大倍率的目的</li>
</ul>
<hr>
<h2 id="（三）光圈"><a href="#（三）光圈" class="headerlink" title="（三）光圈"></a>（三）光圈</h2><h3 id="1-标识与种类"><a href="#1-标识与种类" class="headerlink" title="1. 标识与种类"></a>1. 标识与种类</h3><p>镜头上都会有光圈的标识，有的是1∶3.5-5.6，也有的标为1∶2.8等。1∶3.5-5.6的意思是镜头最大光圈为F3.5～F5.6，这表示假设焦距为20mm时镜头最大光圈为F3.5，当焦距变为50mm时，最大光圈可能变为F5.6，也就是说镜头的最大光圈不是恒定的，称为非恒定光圈；1∶2.8则表示无论焦距为20mm还是50mm，镜头的最大光圈都是F2.8。<br>简单地说，恒定光圈镜头无论是在广角端还是长焦端，最大光圈值都是恒定的；非恒定光圈镜头的最大光圈值随着焦距的变化而有所变动。</p>
<h3 id="2-光圈叶片"><a href="#2-光圈叶片" class="headerlink" title="2. 光圈叶片"></a>2. 光圈叶片</h3><p><img src="https://image.qinxing.xyz/20200428234744.png" alt="每组光圈金属片两侧都会发出一条星芒，可以看到路灯有10条星芒，则可以判定拍摄所用镜头内的光圈金属片有5组"><br>有的星芒多，有的星芒少，这是由光圈金属片组数决定的。但要注意，奇数组金属片和偶数组金属片形成星芒的规律也不相同<br>由此得出一个规律：当光圈金属片组数为奇数时，星芒数为组数的2倍；当金属片组数为偶数时，星芒数与组数相等。例如10组金属片有10条星芒；11组金属片和22组金属片都有22条星芒。</p>
<h3 id="3-光圈大小"><a href="#3-光圈大小" class="headerlink" title="3. 光圈大小"></a>3. 光圈大小</h3><p>光圈F值 = 镜头的焦距/镜头口径的直径。光圈值系列： F1， F1.4， F2， F2.8， F4， F5.6， F8， F11， F16</p>
<p>原文内容：并且光圈每缩小一级，实际的光圈孔径会缩小一半，这样曝光量就会降低一半，即F后的数字越大，光圈越小，反之越大。<br><strong>质疑</strong>：文中关于光圈与通光量的叙述有问题，F后面跟的就是孔径，F1相比于F1.4，孔径大了1.414倍（根号2），面积应该是半径的平方，也就是原来的两倍，通光量就增大了一倍。</p>
<p><strong>质疑：</strong>文中sensor越大，景深越小的这个结论我觉得是有问题的，景深三要素定了之后，景深就定了，和sensor大小是没有关系的。</p>
<h3 id="4-光圈大小的选择"><a href="#4-光圈大小的选择" class="headerlink" title="4. 光圈大小的选择"></a>4. 光圈大小的选择</h3><p>当光圈开至很大时，外界进入镜头的光量很足，镜头内的透镜边缘部分也会允许光线通过，但透镜上下两个端点的弧度比中间的弧度要大，所以它们的会聚性能就有差别，这会在会聚的成像点周围有一些乱光干扰，使成像质量有一定的下降，造成最终拍摄的照片画质稍差的现象。<br>当光圈缩至最小时，孔径非常小，如果有光线透过，就会在孔后发生光线衍射的现象，这也会破坏入射光线的规律性，造成成像画质下降的现象。</p>
<hr>
<h2 id="（四）拍照模式"><a href="#（四）拍照模式" class="headerlink" title="（四）拍照模式"></a>（四）拍照模式</h2><h3 id="情景模式"><a href="#情景模式" class="headerlink" title="情景模式"></a>情景模式</h3><ol>
<li>人像模式<br>拍摄人像类题材的照片时，一般的拍摄方法是采用极大的光圈，焦距设定在中长焦段，这样可以极大地虚化背景，并充分拉近人物，使人物主体在画面中非常突出。<br>使用人像拍摄模式拍摄的照片，可以使人物肤色还原较好，并且能够表现得白皙粉嫩。应该注意，人像模式下镜头光圈开得较大，这时画面中景深景浅的各个部位要求区别比较严格，因此在对焦点合焦时应该特别小心，避免失焦的情况发生，否则就会造成对焦点不够清晰的情况。<br>人像拍摄模式为程序控制曝光模式，因此在光线不足时，相机会自动弹起闪光灯进行补光。按住相机快门不放，可以将驱动模式由单拍改为连拍，方便摄影者从拍摄到的多张照片中挑选最满意的作品。</li>
<li>风光拍摄模式<br>相比于全自动模式，风光拍摄模式的色彩比较鲜艳明快，绿色和蓝色较多，因为这样比较善于表现绿色植物和蓝色的天空。为达到这样的效果，风景拍摄模式下相机会自动设定光圈为F8.0～F11.0，光圈在这一范围内可保持相对高速的快门速度，避免照片因相机震荡而变得模糊不清</li>
<li>微距模式<br>在微距模式下，相机会自动将光圈开大，照片风格默认为风光。对于摄影者来说，需要进行的操作就是尽量靠近被摄的主体，这样可以将微观对象拍摄得更大，并对要表现的具体部位对焦，使其清晰，而由于光圈较大，对焦点前后有虚化的效果。</li>
<li>运动模式<br>主要用于拍摄运动主体的画面，在这种模式下，如果环境光线条件合适，相机会自动将快门速度设定在一个比较快的程度，以凝结运动主体瞬间的画面。但这里会涉及对焦的问题，如果对焦速度较慢，可能还没合焦但主体已经移动到取景框外。</li>
<li>夜景人像<br>夜景人像模式则不同，开启这种模式后，相对于正常的人像模式，夜景人像模式的闪光灯闪光强度会有轻微的减弱，且最为重要的是相机会启动闪光灯慢速同步模式，拍摄时快门速度并没有明显加快，闪光灯作用主体仍然会曝光准确，但由于较慢的快门速度，会使画面中的背景可以得到充分的曝光时间而整体曝光充足，显得比较明亮。也就是说，使用夜景人像模式拍摄夜晚中的人像，主体与背景都能够拍摄得比较明亮。</li>
</ol>
<h3 id="进阶模式"><a href="#进阶模式" class="headerlink" title="进阶模式"></a>进阶模式</h3><ol>
<li>程序曝光（P档）<br>程序曝光模式，即半自动曝光模式。在P模式下，数码单反相机的曝光由相机自动控制，但允许摄影者对白平衡、ISO感光度、曝光补偿数值、测光模式等拍摄参数进行调整，是一种简单快速，但又有一定的创造性拍摄的模式。<br>P模式在默认不进行调整的状态时类似于全自动模式，初级摄影者可以使用这种模式直接拍摄照片，大多数情况下能够拍得令人满意的作品。因为P模式下的曝光由相机根据现场光线情况自动曝光完成，所以不存在曝光不足或过度的情况，即使是现场环境光线不足，闪光灯也不会弹起，这是与全自动模式的不同。<br>这和手机上的相机拍照是一样的方法。</li>
<li>全自动模式（AUTO/A+档）<br>数码单反相机的全自动模式类似于之前人们使用的傻瓜相机拍摄，用户只要选好拍摄对象，稳定住相机，然后按下快门，即可拍摄到清晰的照片。与最终照片拍摄效果有关的光圈大小、曝光时间（快门）、白平衡设置、ISO感光度、照片风格、对焦点的位置选择等参数都由相机程序自动控制，相机程序会根据拍摄场景中的环境条件进行运算，然后得出最佳的拍摄参数，继而得到最佳的拍摄效果。<br>使用全自动模式在室内或夜晚光线较暗的条件下拍摄时，相机一般不会根据光圈的条件而设定很长的曝光时间，而是启动闪光灯补光以获得较快的快门速度。这时全自动模式的缺陷就会体现出来，因为强行闪光拍摄会使得夜晚近处的景物曝光正常，而远处的景物却因无法获得充足的曝光量而漆黑一片，但这种情况的好处是不会因为快门速度过慢而使拍摄的照片模糊。</li>
<li>光圈优先（AV档）<br>将相机模式设置为光圈优先，快门速度和感光度交给相机来自行设定，几乎可以满足绝大多数的拍摄场合。需要考虑的就是景深。</li>
<li>快门优先模式（TV档）<br>快门优先模式则是只要调整快门速度，然后相机会根据你的快门速度设定一个光圈值，这个和光圈优先模式正好相反。使用快门优先来设定快门速度，能够控制画面中被摄物体的运动、静止状态，比如你想拍摄出瀑布流动的效果，这种情况下就需要首先调整到合适的快门速度。</li>
<li>手动模式（M档）<br>手动档模式下，光圈、快门、感光度等等全部需要自己手动设置，从而实现对画面全部掌握。</li>
</ol>
<hr>
<h2 id="（五）摄影用光"><a href="#（五）摄影用光" class="headerlink" title="（五）摄影用光"></a>（五）摄影用光</h2><h3 id="1-直射光与扩散光"><a href="#1-直射光与扩散光" class="headerlink" title="1. 直射光与扩散光"></a>1. 直射光与扩散光</h3><p>补光并不一定使用闪光灯或外拍灯等直射光源，可以使用亮度较高的平面体反射光线，利用反射光线对被摄体补光，这种补光效果要比主光源的效果弱，从而形成一定的光比，画面看起来更加真实，并且效果更加柔和。</p>
<p>一般使用的反射体是反光板或反光伞。</p>
<h3 id="2-光的强度、反差与光比"><a href="#2-光的强度、反差与光比" class="headerlink" title="2. 光的强度、反差与光比"></a>2. 光的强度、反差与光比</h3><p>光的反差也称为对比，但不是光线本身的反差，而是对于光线所照射的对象来说。<br>光比是摄影中的重要参数之一，指被摄景物受光面亮度与阴影面亮度的比值。</p>
<h3 id="3-光的方向与效果"><a href="#3-光的方向与效果" class="headerlink" title="3. 光的方向与效果"></a>3. 光的方向与效果</h3><ul>
<li>斜射光效果是在画面中表现出主体亮部和阴影部位，亮部和暗部位于同一画面，能够很容易表现出画面的影调层次。</li>
<li>后斜射光也会在画面中营造出被摄体的亮部和暗部两个位置，但与前斜射光相比，后斜射光更善于勾画被摄主体的轮廓线，这对于表现主体的形态非常有帮助。<br>后斜射光的这种特点，决定了其比较适合于拍摄风光、花卉、微距等题材的作品。</li>
<li>使用侧光拍摄人像类题材时，会在面部中线两侧形成明显的反差，即出现阴阳脸的情况，所以一般很少使用侧光拍摄人物。<br>要避免这种情况发生，就只能通过使用闪光灯对被摄主体的正面进行补光，或利用反光板等道具补光</li>
<li>顶光和脚光拍摄人物往往能营造出恐怖、诡异的视觉效果</li>
</ul>
<h3 id="4-测光与曝光原理"><a href="#4-测光与曝光原理" class="headerlink" title="4. 测光与曝光原理"></a>4. 测光与曝光原理</h3><p>反射率为18%的亮度介于黑色与白色之间，通常为中性灰色（Middle Gray）。难怪校准白平衡的时候，都要拿18度灰卡进行校准。</p>
<p>入射式测光是指将测光表放在被摄主体附近，使其与被摄体接收到几乎完全一样的光线照射，这样可以准确地测出被摄体的曝光数值</p>
<p>反射式测光是测量被摄体反射出来的光线，使用时将测光表的测光部位对准主体即可。</p>
<h3 id="5-人像摄影的用光"><a href="#5-人像摄影的用光" class="headerlink" title="5. 人像摄影的用光"></a>5. 人像摄影的用光</h3><ul>
<li><p>顺光人像<br>顺光拍摄人像时，光线从正面照射到人物脸上，面部五官光线照射均匀，缺乏明暗变化效果，影调层次较少，因此使用这种方向的光线拍摄人像时，通常不会对人物正面的角度进行拍摄，否则会使拍摄出来的人物面部平坦，缺乏变化，毫无美感可言。这种光线方向一般用于拍摄证件照。</p>
</li>
<li><p>斜射光人像<br>前斜射光是非常理想的人像摄影光源，能够照亮人物面部大部分区域，并且会因为五官的凹凸而形成丰富的明暗影调层次，既能孕育情感，又能表现出足够的立体感，还可以勾勒人物面部的轮廓线条。</p>
</li>
<li><p>侧光人像<br>标准意义上的侧光也不适合拍摄人像照片，因为光线会在人物面部的中线鼻梁位置形成受光面高亮而背光面为阴影的较大反差，会丑化人物形象。</p>
</li>
<li><p>逆光人像<br>逆光人像是一种高反差光影效果的运用，在逆光下拍摄人像时，一般分为两种情况，拍摄剪影是最为简单的一种，对背景中的高亮光源处测光，这样人物正面会因为曝光不足而完全暗掉，画面中的人物只表现出形体轮廓线条，具有非常强的感召力。另外一种逆光人像是使用闪光灯或反光板对人物的正面进行补光，使其曝光正常</p>
</li>
</ul>
<hr>
<h2 id="（六）色彩的艺术"><a href="#（六）色彩的艺术" class="headerlink" title="（六）色彩的艺术"></a>（六）色彩的艺术</h2><h3 id="1-色彩的感觉"><a href="#1-色彩的感觉" class="headerlink" title="1. 色彩的感觉"></a>1. 色彩的感觉</h3><p>颜色并不是实体的存在，而是人类对于物体受到光线照射后所产生效果的一种视觉体验。自然界中，常见的颜色有红、橙、黄、绿、青、蓝、紫几种，人们对于这些色彩的感觉是由于物体对于光线的反射产生的。</p>
<ul>
<li>红色系代表爱意、热烈、热情、力量、浪漫、警告、危险等情感信息，是一种非常强烈的色彩表现，容易引起人们的注意。</li>
<li>黄色系可传达出明快、简洁、活泼、温暖、健康与收获等情感，在中国古代，黄色还代表着尊贵与权势。黄色是非常靓丽的色调，在很多时候都能给人一种眼前一亮、豁然开朗的感觉。</li>
<li>绿色系代表自然、和谐、安全、成长、青春与活力等情感。</li>
<li>蓝色系代表专业、深邃、理智、宁静等情感。我们经常见到的计算机软件公司网页或LOGO会以蓝色调为主，可表达出专业与理智的感觉，而天空的深蓝又是深邃与宁静的代表，蓝色调的大海也会传达出深邃与宁静的感觉。在摄影中使用蓝色时，要注意白平衡的调整，否则拍摄天空时经常会有泛青的色偏效果。</li>
<li>白色并不是某种光谱的颜色，而是各种不同颜色光谱的混合色。白色系能够表达人们多种不同的情感，如平等、平和、纯净、明亮、朴素、平淡等。</li>
<li>黑色系传达出高贵、神秘、恐怖、死亡等情感。摄影中，与黑色搭配最为常见的颜色是白色，单纯的黑白搭配色可以减少画面中的杂色，以免影响欣赏者的视觉体验，能将人们的注意力吸引到作品的内涵方面，且画面视觉冲击力很强。</li>
</ul>
<h3 id="2-色彩的组合"><a href="#2-色彩的组合" class="headerlink" title="2. 色彩的组合"></a>2. 色彩的组合</h3><p><img src="https://image.qinxing.xyz/20200429001458.png" alt><br>红、橙、黄、绿、青、蓝、紫七色抽象为色彩的轮盘，非常直观。色轮上半部分的色彩为暖色系。</p>
<p>色彩的互补是指从色轮上来看处于正对位置的两种颜色，两者相差180°左右，即通过圆心的直径两端的颜色。例如，绿色的互补色是粉红，蓝色的互补色是红色等。在摄影时采用互补色彩组合，会给欣赏者以非常强烈的情感，视觉冲击力很强，色彩区别明显、清晰。</p>
<p>相邻色的特点是颜色相差不大，区分不明显，摄影时取相邻色搭配，会给欣赏者以和谐、平稳的感觉。<br>因为相邻色看起来颜色非常相近，如红色与橙色，搭配在一起经常让人无法分辨，这样获得的摄影作品往往会缺乏层次，看起来乏味。因此使用相邻色搭配时，还应注意主体与环境的搭配问题，可以通过环境来映衬主体，从而使得整个画面富有层次。</p>
<h3 id="3-影响色彩的因素"><a href="#3-影响色彩的因素" class="headerlink" title="3. 影响色彩的因素"></a>3. 影响色彩的因素</h3><p>太阳的七色光谱中，红色最先到达地表，紫色最后达到，这会在摄影中产生一个现象，如果拍摄时的曝光时间很短，在1/8000s时，蓝、紫等色调的光谱还未来得及感光，或只有极少一部分感光，曝光就已经结束，这样最终拍摄的画面中主要是红、黄等色调感光，照片会有偏暖的感觉。<br>夜晚的自然光线下，已经极少甚至没有红、黄等光谱到达地面，只有微弱的蓝、紫等光谱照射地表，如果进行长时间曝光，蓝色等光谱进行感光，则拍摄的画面会整体泛蓝色。当然，这里有一个前提，即白平衡必须准确。</p>
<h3 id="4-白平衡与色温"><a href="#4-白平衡与色温" class="headerlink" title="4. 白平衡与色温"></a>4. 白平衡与色温</h3><p>有的色彩比较纯正，有的色彩又显得非常杂。产生这种现象的原因是人在无形中会以白色作为参照标准，各种不同色彩的产生是来源于与白色相比较后的感觉。而作为标准的白色，是红、绿、蓝三原色混合叠加后产生的色彩。我们通常所说的白平衡调整，是指为了使照片所表现的色彩与人眼实际看到的色彩一致，而对相机进行的具体设定。</p>
<h3 id="5-一天四时的光影流转"><a href="#5-一天四时的光影流转" class="headerlink" title="5. 一天四时的光影流转"></a>5. 一天四时的光影流转</h3><p>由于早晨地面和太阳之间的夹角很小，相对于摄影者来说，与太阳的距离较远，太阳光线必须通过很厚的大气层才能照射到摄影者所在的位置，因此波长很短的蓝、绿、黄色光线会被大气层阻挡，依次消失，这时只有波长很长的橘红色光线能够透过大气层照射到地面（光线由红、橙、黄、绿、青、蓝、紫七种光谱组成，波长由长到短排列），因此早晨的光线色彩呈现出红色或橙色。</p>
<h3 id="6-相机的色彩设定"><a href="#6-相机的色彩设定" class="headerlink" title="6. 相机的色彩设定"></a>6. 相机的色彩设定</h3><p>当前大多数的数码单反相机设置菜单内都会有sRGB和Adobe RGB两种色彩空间供选择，且默认情况下设定为sRGB。如果没有特定的印刷目的，选择sRGB色彩空间即可，因为这样在后期处理时的兼容性可能更强。<br>与sRGB色彩空间相比，Adobe RGB色彩空间具有更为宽广的色域和良好的色彩层次表现，在摄影作品的色彩还原方面，Adobe RGB更为出色，另外，在印刷输出方面，Adobe RGB色彩空间更是远优于sRGB。</p>
<hr>
<h2 id="（七）构图"><a href="#（七）构图" class="headerlink" title="（七）构图"></a>（七）构图</h2><h3 id="1-点线面"><a href="#1-点线面" class="headerlink" title="1. 点线面"></a>1. 点线面</h3><p>大片绿色的画面中红色线条具有很强的表现力。</p>
<h3 id="2-主体与宾体"><a href="#2-主体与宾体" class="headerlink" title="2. 主体与宾体"></a>2. 主体与宾体</h3><p>主体是摄影用以表达拍摄主题思想的最主要部分，是整个拍摄画面结构的中心，也是画面的趣味点所在，应占据突出位置。主体并不一定是孤立存在的，可以是一个对象，也可以是一组对象。例如，拍摄人像照片时，通常情况下要表现的人物就是主体，需要通过使用各种构图手段使其看起来更加突出。</p>
<ul>
<li>通过调整拍摄视角以及镜头焦距，将主体比例放大，使其充满整个画面，给欣赏者以较强的视觉冲击力；</li>
<li>将主体置于画面中的某些构图点上，这些构图点的位置是欣赏者的视觉中心，这样欣赏者的注意力会更多地被主体吸引；</li>
<li>比较复杂的手段是指虚化除主体之外的景物，并在取景时要取与主体色彩反差较大的其他景物，但要注意其他色彩不要过多，这样画面中就不会有其他明显的景物或色彩分散欣赏者的注意力，进而达到突出主体的效果；第四种手段是指调整画面中主体与其他景物的明暗对比度，使得主体较亮，其他景物较暗，这样也可以有效地突出主体。</li>
</ul>
<h3 id="3-前景、背景与留白"><a href="#3-前景、背景与留白" class="headerlink" title="3. 前景、背景与留白"></a>3. 前景、背景与留白</h3><p>摄影作品中的前景是指位于主体前面或离摄影者最近的景物。前景具有<strong>烘托主体和装饰拍摄画面</strong>的作用，可以增强画面的空间深度，还可以平衡构图和美化作品画面。在画面主体轮廓或色彩比较另类时，前景可以起到过渡的作用，使主体的出现不至过于突兀，这样画面的整体效果会更加协调；移动相机镜头使其跟随运动主体时，静止的前景还可以拉出运动模糊的效果，使摄影作品更具美感及视觉冲击力。与之前介绍的构图陪体一样，前景在画面中的视觉效果也不能强于主体，否则会削弱主体的地位，画面就会失去平衡。</p>
<p>选择背景可以遵从以下几个原则：<strong>避免杂乱，力求简洁</strong>，可选用如蓝天、草地等单一成分的背景，如果背景中对象较多显得杂乱，可以通过将其虚化来简化背景；背景色彩不宜过多，背景色彩过多会造成喧闹的感觉，分散欣赏者的注意力；背景亮度不宜过高，但剪影等特殊效果例外。</p>
<p>在摄影作品中<strong>合理地留白</strong>，可以有效避免因为画面元素过多或过于拥挤给欣赏者带来的视觉疲劳，可为欣赏者留下充足的思考空间，并能够使欣赏者的思绪扩展到更深、更远的层次，这更利于表现画面主题，增加作品的艺术感染力与深度。</p>
<h3 id="4-摄影角度"><a href="#4-摄影角度" class="headerlink" title="4. 摄影角度"></a>4. 摄影角度</h3><ol>
<li><p>平视：一种是正对画面主体进行拍摄，称为正平视取景，这种方式经常用于表现画面比较平稳的主题或拍摄人物的证件照片；另外一种平视效果是侧平视取景，是指镜头与主体正面朝向稍微偏离一定的角度，如拍摄人像的侧面照片等，侧平视取景在拍摄人像时可以勾画人像的面部与身材轮廓线，拍摄风光时则经常可以营造出延展、深邃的感觉。</p>
</li>
<li><p>仰视取景：指镜头向上仰起进行拍摄，获得的摄影作品中被摄对象看起来会更加高大、重要或有气势，如果靠近被摄主体拍摄，还能使照片中的构图元素富有极度近大远小的夸张透视效果。</p>
</li>
<li><p>仰视取景：相机向上仰起的角度也有两种选择，45°左右的仰角可以拍摄出主体高大、有气势的形象，例如仰拍人像时，可以拍摄出对象修长的腿部；如果将相机的仰角调整到90°左右，则会营造一种使人眩晕的画面效果，非常具有戏剧性和压迫性，冲击力十足。</p>
</li>
<li><p>俯视取景：指摄影时镜头要高于被摄对象，是一种居高临下的拍摄方式。采用轻度俯拍的方式可以比较容易地拍摄出景物的高度落差，搭配广角镜头与较大的物距，可以突出画面广阔的空间感。采用高位俯拍的拍摄方式会压缩画面主体的视觉比例，使其投射在广阔的背景上，造成夸张的大小对比效果。俯视取景搭配广角镜头可用于拍摄大场面的风光作品，特别是平面风光，如花田、草原等，如果采用平视的角度，可能无法表现环境远处的景观。</p>
<p>拍摄人像题材时，如果使用俯拍的方式拍摄，会削弱主体人物的气势，使人物变小，并会使人物的形体发生变化，如扭曲等，可产生一种富有戏剧性的效果。</p>
</li>
</ol>
<h3 id="5-透视的概念"><a href="#5-透视的概念" class="headerlink" title="5. 透视的概念"></a>5. 透视的概念</h3><p><img src="https://image.qinxing.xyz/20200429000852.png" alt><br>实际景物与人眼位置都是固定不变的。对于在投影平面上的投影，左侧的投影只是实际景物按比例的压缩，即符合透视规律；而右侧的投影中，实际景物之间的远近距离被压缩了，即不符合透视规律。</p>
<p>透视规律的具体体现有近大远小的几何透视，还有远处模糊、近处清晰的影调透视。好的摄影作品往往这两种透视规律都非常明显，特别是大场景的风光作品中，线条透视优美，空间感强，而影调透视则使画面变得深远，意境盎然。</p>
<h3 id="6-对比构图法"><a href="#6-对比构图法" class="headerlink" title="6. 对比构图法"></a>6. 对比构图法</h3><p>相机快门速度调节或相机自身移动来实现，包括动静结合法、追踪对焦法、曝光中途变焦法。</p>
<p>在一些光线条件不理想的场景中拍摄，曝光时间会比较长，在曝光尚未完成时，用手转动变焦环，转动时要用力均匀，不能使镜头中轴线出现抖动，这样在曝光完成后的画面中会出现对焦点周围景物清晰，但周围景物呈现出放射状线条的效果，像爆炸一样，非常具有视觉冲击力。这种拍摄方式称为<strong>曝光中途变焦法</strong>。</p>
<h3 id="7-几何构图"><a href="#7-几何构图" class="headerlink" title="7. 几何构图"></a>7. 几何构图</h3><ul>
<li>水平线构图：拍摄风光作品时，地面与林木、地面与天空、水面与林木、水面与天空等景物组合的构图都可以使用水平线构图来实现；另外，建筑摄影构图中，建筑物的水平线一定要平，否则画面整体就会失去平衡。</li>
</ul>
<ul>
<li>竖直线构图：能够给欣赏者以坚定、向上、永恒的心理感受。由于人的视觉习惯是自左向右延伸，因此打破常规的上下方向延展的竖直线构图能够表现出很强的视觉压迫和冲击力。如果能够将景物拉近拍摄，则效果更佳。</li>
</ul>
<ul>
<li><p>对角线构图：指主体或重要景物沿画面对角线的方向排列，旨在表现出动感、不稳定性或生命力等感觉</p>
</li>
<li><p>S形构图强调的是线条的力量，这种构图方式可以给欣赏者以优美、活力、延伸感和空间感等视觉体验。一般欣赏者的视线会随着S形线条的延伸而移动，逐渐延展到画面远处，并随着画面透视特性的变化，使人产生一种空间广袤无垠的感觉。</p>
<p>S形构图多见于广角镜头所拍摄的画面中，此时拍摄视角较大，空间比较开阔，并且景物透视性能良好。</p>
</li>
<li><p>正三角形构图的建筑主体，给人一种非常稳定、可靠的感觉</p>
<p>如果景物以倒三角形构图的形式组合，则会让人感觉景物之间的关系非常不稳定、不牢固。</p>
</li>
<li><p>另外一种对称的形式是景物自身形态的对称，如大部分建筑物、正面人像的面部等。但要注意，拍摄景物自身形态的对称时，要将主体放在画面的中央。</p>
</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>镜头</tag>
        <tag>阅读</tag>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>YUV 存储格式分析</title>
    <url>/posts/26448c8b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>整理自<a href="https://www.cnblogs.com/yongdaimi/p/10696214.html" target="_blank" rel="noopener">博客</a></p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>由于人眼对亮度信息敏感，对颜色没有那么敏感，因此一张RGB的图片可以通过转换成YUV进行压缩。<br>本文分析下YUV码流的存储格式，YUV码流的存储格式与采样格式息息相关。总的来讲，YUV存储格式主要分为两种：</p>
<ol>
<li>planar 平面格式<br>先连续存储所有像素点的 Y 分量，然后存储 U 分量，最后是 V 分量。</li>
<li>packed 打包格式<br>指每个像素点的 Y、U、V 分量是连续交替存储的。<br>根据采样方式和存储格式的不同，就有了多种 YUV 格式。这些格式主要是基于 YUV 4:2:2 和 YUV 4:2:0 采样。</li>
</ol>
<p>常见的基于 YUV 4:2:2 采样的格式有以下几种：YUYV、UYVY、YUV422P</p>
<p>常见的基于 YUV 4:2:0 采样的格式如下表：YUV420P、YUV420SP</p>
<h2 id="基于YUV4-2-2采样的格式"><a href="#基于YUV4-2-2采样的格式" class="headerlink" title="基于YUV4:2:2采样的格式"></a>基于YUV4:2:2采样的格式</h2><p>YUV 4:2:2 采样规定了 Y 和 UV 分量按照 2: 1 的比例采样，两个 Y 分量公用一组 UV 分量。</p>
<h3 id="YUYV格式"><a href="#YUYV格式" class="headerlink" title="YUYV格式"></a>YUYV格式</h3><p>YUYV 格式是采用<strong>打包格式</strong>进行存储的，指每个像素点都采用 Y 分量，但是每隔一个像素采样它的 UV 分量，排列顺序如下：<br><code>Y0 UO Y1 V0 Y2 U2 Y3 V2</code><br>Y0 和 Y1 公用 U0 V0 分量，Y2 和 Y3 公用 U2 V2 分量</p>
<h3 id="UYVY格式"><a href="#UYVY格式" class="headerlink" title="UYVY格式"></a>UYVY格式</h3><p>UYVY 格式也是采用<strong>打包格式</strong>进行存储，它的顺序和 YUYV 相反，先采用 U 分量再采样 Y 分量，排列顺序如下：<br><code>U0 Y0 V0 Y1 U2 Y2 V2 Y3</code><br>Y0 和 Y1 公用 U0 V0 分量，Y2 和 Y3 公用 U2 V2 分量<br>根据 UV 和 Y 的顺序还有其他格式，比如，YVYU 格式，VYUY 格式等等，原理大致一样了。</p>
<h3 id="YUV422P格式"><a href="#YUV422P格式" class="headerlink" title="YUV422P格式"></a>YUV422P格式</h3><p>YUV 422P 格式，又叫做 I422，采用的是<strong>平面格式</strong>进行存储，先存储所有的 Y 分量，再存储所有的 U 分量，再存储所有的 V 分量。</p>
<h2 id="基于YUV-4-2-0采样的格式"><a href="#基于YUV-4-2-0采样的格式" class="headerlink" title="基于YUV 4:2:0采样的格式"></a>基于YUV 4:2:0采样的格式</h2><p>基于 YUV 4:2:0 采样的格式主要有 YUV 420P 和 YUV 420SP 两种类型，每个类型又有两种具体的格式。</p>
<ul>
<li>YUV 420P 类型<ul>
<li>YU12 格式</li>
<li>YV12 格式</li>
</ul>
</li>
<li>YUV 420SP 类型<ul>
<li>NV12 格式</li>
<li>NV21 格式</li>
</ul>
</li>
</ul>
<p>YUV 420P 和 YUV 420SP 都是基于 Planar 平面格式 进行存储的。<br>先存储所有的 Y 分量后， YUV420P 类型就会先存储所有的 U 分量或者 V 分量。</p>
<p><img src="https://image.qinxing.xyz/20200424121154.png" alt="YUV420P的格式"></p>
<p>而YUV420SP 则是按照 UV 或者 VU 的交替顺序进行存储了。<br><img src="https://image.qinxing.xyz/20200424121326.png" alt="YUV420SP的格式"></p>
<h3 id="YU12和YV12格式"><a href="#YU12和YV12格式" class="headerlink" title="YU12和YV12格式"></a>YU12和YV12格式</h3><p>YU12 和 YV12 格式都属于 YUV 420P 类型，即先存储 Y 分量，再存储 U、V 分量，区别在于：YU12 是先 Y 再 U 后 V，而 YV12 是先 Y 再 V 后 U 。<br><img src="https://image.qinxing.xyz/20200424121441.png" alt="YV 12 的存储格式"></p>
<p>YU 12 又称作 I420 格式，它的存储格式就是把 V 和 U 反过来了。</p>
<p><img src="https://image.qinxing.xyz/20200424135043.png" alt="YUV420P码流的表现"></p>
<h3 id="NV12和NV21格式"><a href="#NV12和NV21格式" class="headerlink" title="NV12和NV21格式"></a>NV12和NV21格式</h3><p>NV12 和 NV21 格式都属于 YUV420SP 类型。它也是先存储了 Y 分量，但接下来并不是再存储所有的 U 或者 V 分量，而是把 UV 分量交替连续存储。 </p>
<p><img src="https://image.qinxing.xyz/20200424121502.png" alt></p>
<p>其在码流中的表现形式为：<br><img src="https://image.qinxing.xyz/20200424121342.png" alt="YUV420SP码流的表现"></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>NV12是iOS中有的模式，它的存储顺序是先存Y分量，再进行UV交替存储。</p>
<p>NV21是Android中有的模式，它的存储顺序是先存Y分量，再VU交替存储。高通一般用这种模式。</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>yuv</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：sensor帧率不准</title>
    <url>/posts/2b78e151/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>编码帧率设置的是25帧，出来的却是26帧。如果设置30帧，出来的是31帧。</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><ol>
<li>确定isp组件收到的是25帧，并且正确设置下去了</li>
<li>判断是编码出了问题还是硬件出了问题</li>
<li>确定寄存器组选择正确</li>
<li>确定寄存器配置是否正确</li>
<li>确定时钟是否正常</li>
<li>如果实在找不出来，就通过修改寄存器HMAX来修改帧率</li>
</ol>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li>isp组件收到的是25帧，编码没有丢帧</li>
<li>查看isp中断，确实是26帧，是否可能是设备的时钟有偏移？有没有可能sensor是25帧，但是设备的时钟快了？</li>
<li>找硬件测量sensor的帧率。由于模组的帧同步信号没有引出来，测量不到。只能测量主时钟和MIPI了</li>
<li>仅通过MIPI量不出帧率</li>
<li>通过其他的手段进行帧率的判断，如<strong>是否频闪</strong>。如果放在很亮的日光灯下，会有横条纹。如果横条纹静止不动，可以判断为帧率是准确的25帧。如果横条纹在滚动，帧率就不是准确的25帧。</li>
<li>确定了硬件sensor的问题之后，就主要排查寄存器配置是否正确</li>
<li>确定寄存器是否正确，和帧率相关的寄存器主要有两个：<strong>HMAX</strong>和<strong>VMAX</strong>。HMAX是每个曝光行的时间（时钟数），VMAX是每帧时长（曝光行数）。这里都没有问题</li>
<li>确定寄存器设置下去了，也没有问题</li>
<li>排除其他寄存器的问题，把所有的寄存器的设置都正确设置了，甚至上电时序都正常</li>
<li>确定主时钟MCLK是否正常，MCLK是CPU给的，配置是37.125MHz，我这里配置没有问题</li>
<li>但是找硬件测量一下MCLK的频率，是38.4MHz</li>
<li>和驱动确认了一下，参考的时钟源不一样，需要重新配置</li>
<li>由于CPU的时钟输出是从参考时钟源倍频出来的，不能够达到标准的37.125MHz。测试发现，水波纹还是会跳动，不过比原来好了一点。</li>
<li>当帧率大于25帧，水波纹向下滚动，当帧率小于25帧，水波纹向上滚动。</li>
<li>问高通的人，他们说只验证过24和26M，37.125M太高了。驱动最多可以配置到37.17M，经过测试，日光灯的横条纹滚动已经不明显了，但是长时间还是有一些滚动的</li>
<li>将寄存器HMAX的值按照实际频率和理想频率的比值进行一次缩放。同时修改和高通帧率以及曝光时间对应的参数值，进行适配。<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//修改HMAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RES_1080P25_REG_ARRAY \</span></span><br><span class="line">{ \</span><br><span class="line">  ...</span><br><span class="line">  {<span class="number">0x301C</span>, <span class="number">0xA5</span>, <span class="number">0x00</span>}, <span class="comment">/*HMAX*/</span>\</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改高通有关帧率计算和曝光时间计算的配置</span></span><br><span class="line">.out_info =</span><br><span class="line">{</span><br><span class="line">  <span class="comment">/* Res 0 */</span></span><br><span class="line">  {</span><br><span class="line">    .x_output = <span class="number">1948</span>,           <span class="comment">/* 4+8+1920+9+4+3 */</span></span><br><span class="line">    .y_output = <span class="number">1097</span>, <span class="comment">//1109    /* 8+1080+9 */</span></span><br><span class="line">    .line_length_pclk = <span class="number">5285</span>,   <span class="comment">/* 37161290 / 37125000 x 5280 */</span></span><br><span class="line">    .frame_length_lines = <span class="number">1125</span>,</span><br><span class="line">    .vt_pixel_clk = <span class="number">148640625</span>,  <span class="comment">/* 5285 x 1125 x 25 */</span></span><br><span class="line">    .op_pixel_clk = <span class="number">237600000</span>,</span><br><span class="line">    .binning_factor = <span class="number">1</span>,</span><br><span class="line">    .binning_method = <span class="number">0</span>,</span><br><span class="line">    .min_fps = <span class="number">15.00</span>,</span><br><span class="line">    .max_fps = <span class="number">25.00</span>,</span><br><span class="line">    .mode = SENSOR_DEFAULT_MODE,</span><br><span class="line">    .offset_x = <span class="number">0</span>,</span><br><span class="line">    .offset_y = <span class="number">0</span>,</span><br><span class="line">    .scale_factor = <span class="number">1.0</span>,</span><br><span class="line">    .is_pdaf_supported = <span class="number">0</span>,</span><br><span class="line">  },</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>和帧率相关的寄存器，主要就是HMAX和VMAX。和帧率相关的硬件，主要是时钟频率。</li>
<li>出图正常的情况下，帧率异常需要注意时钟频率是否正常。</li>
<li>当帧率大于25帧，水波纹向下滚动，当帧率小于25帧，水波纹向上滚动，这个滚动的方向和sensor安装方向有关。可以用来初步的判断帧率的大小。</li>
<li>如果时钟频率不对，可以通过配置HMAX对帧率进行微调，同时需要注意高通对帧率以及曝光计算的配置也需要一同修改。</li>
<li>需要提前订好解决思路，并严格执行。先从大局来看问题，不能钻到一个小的问题里面出不来</li>
<li>多问多交流，别人会给你提供不一样的思路</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>帧率</tag>
      </tags>
  </entry>
  <entry>
    <title>手机摄像头的分析与思考</title>
    <url>/posts/575fbd93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="手机摄像头的分析与思考"><a href="#手机摄像头的分析与思考" class="headerlink" title="手机摄像头的分析与思考"></a>手机摄像头的分析与思考</h1><blockquote>
<p>本文是对2019年的这份报告进行了整理，以及加入自己的思考与体会</p>
</blockquote>


	<div class="row">
    <embed src="https://files.qinxing.xyz/2019%E5%85%89%E5%AD%A6%E8%A1%8C%E4%B8%9A%E6%B7%B1%E5%BA%A6%E6%8A%A5%E5%91%8A.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h2 id="（一）前沿技术"><a href="#（一）前沿技术" class="headerlink" title="（一）前沿技术"></a>（一）前沿技术</h2><h3 id="1-多摄"><a href="#1-多摄" class="headerlink" title="1. 多摄"></a>1. 多摄</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li><p>夜拍<br>黑白+彩色：彩色用于成像，黑白用于捕捉细节（最近发布的手机好像都没有黑白相机了）<br><strong>疑问</strong>：4合一，16合一的sensor输出的bayer格式发生了变化，高通上的调试软件只支持RGGB等传统的RAW格式，那么在高通平台上他们是如何进行调试处理呢？</p>
<p>另外，从最新发布的手机，如华为P40，小米10来看，好像已经放弃了这种黑白摄像头，改用更大的光圈和sensor靶面去改善夜间效果。</p>
</li>
<li><p>实现混合光学变焦<br>以华为P20 Pro为例，由于长焦摄像头的 80mm 焦距刚好是主摄像头 27mm 焦距的三倍，所以当需要变焦拍摄远处的景象时，可以从主摄像头切换到长焦摄像头，从而实现模拟 3 倍光学变焦，这一点与 iPhone 的光学变焦原理是相同的。这种变焦实际上是“突然”发生的，但通过算法的调校，可以让这个过程平滑化，让拍摄者不会感到突兀。5 倍三摄变焦实际上是对照片进行裁剪优化得到的。由于 4000 万像素彩色主摄像头的成像效果非常好，所以在需要实现 5 倍三摄变焦时，会把这颗摄像头的图像和长焦摄像头的图像进行裁剪优化，再加上黑白摄像头的细节能力，从而呈现出 5 倍变焦的效果。<br>注意，手机厂商提出的混合光学变焦并非是真正的改变了焦距，只是利用两个不同焦距的镜头拍出的图片进行了算法处理。</p>
</li>
</ul>
<h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><ul>
<li>在硬件方面，难点在于摄像头的一致性要求。这三颗摄像头均可以实现成熟的单独量产，但组合起来就会出现一致性的问题。每颗摄像头的加工过程和安装位置都会产生细微差别，对于摄像头这种高精度的装置，1mm 的偏差就足以毁掉整张照片。为此，华为在每条产线上引入了高精密的调校系统，通过光学检测和人工智能来进行分析和校准，保证对焦和成像的准确性。</li>
<li>在算法方面，难点在于解决变焦时的转换流畅度。由于三颗摄像头是两两组合来使用的，在变焦时要实现摄像头的切换，这个时候需要完美解决视差问题，即无论变焦到多少，切换到哪个摄像头，都不能感觉到明显的差异。为了实现像素级的精确，最终生成的图像都需要上万个点的对齐测试，这种算法的调校才是多摄的难点。</li>
</ul>
<h3 id="2-潜望式摄像头"><a href="#2-潜望式摄像头" class="headerlink" title="2. 潜望式摄像头"></a>2. 潜望式摄像头</h3><h4 id="原理及优势"><a href="#原理及优势" class="headerlink" title="原理及优势"></a>原理及优势</h4><p>变焦就是改变焦距，从而得到不同宽窄的视场角、不同大小的影像和不同的景物范围。变焦通常有数码变焦和光学变焦两种方式，其中数码变焦是通过数码相机内的处理器，把图片内的每个像素面积增大，从而达到放大目的；光学变焦是依靠镜头中镜片的移动（改变镜片之间的距离），进而改变镜头的焦距，实现变焦。<br>光学变焦可以分为内变焦和外变焦两类方案。内变焦指前后镜片之间的距离不变，由之间的镜片组前后移动变焦，简单理解就是变焦在机身内完成，摄像头外观没有变化；而外变焦则是通过前镜片组和后镜片组移动变焦，类似于我们平常见到的伸缩式镜头。<br><img src="https://image.qinxing.xyz/20200403095752.png" alt="通过镜头的移动实现光学变焦"><br>由于智能手机需要保持轻薄，而使用伸缩式摄像头会大幅增加手机的厚度，并且难以防水防尘，所以内变焦是手机实现光学变焦的主要方式。但由于手机厚度有限，水平放置的摄像头只能有较小的焦距，光学变焦能力有限，所以通过采用潜望式摄像头的设计，能大幅增加摄像头的焦距，实现更好的光学变焦。</p>
<p><img src="https://image.qinxing.xyz/20200405173054.png" alt="潜望式摄像头结构示意图"></p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>第一，潜望式镜头占据了大量手机内部空间，同样体积的手机，装有潜望镜头的手机需要在电池、散热等方面有所牺牲；</p>
<p>第二，由于反射棱镜的存在，潜望式镜头影响光线的射入量，光线强度在棱镜反射时候会出现较大成都衰减。因此，同样的传感器，潜望式镜头在暗光下性能相对较差；</p>
<p>第三，由于潜望镜式镜头的感光元器件的安装方式与之前不同，导致潜望式镜头后的图像传感器尺寸较小。潜望式镜头后的传感器，无法大于手机本身的厚度。</p>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p><img src="https://image.qinxing.xyz/20200403104100.png" alt="OPPO 的潜望式摄像头专利图"></p>
<ol>
<li><p>从oppo的潜望式摄像头专利图来看，这颗潜望式摄像头并没有改变焦距，运动元件是带着整个镜头组运动的，只是实现一个对焦的功能。难道说oppo的这个潜望式镜头只是实现了长焦的功能，并没有实现变焦的功能？</p>
</li>
<li><p>为何不用两个反光棱镜呢？这样sensor就可以平放在手机上，不会影响手机的高度，还可以把sensor的尺寸做大一些呀。</p>
</li>
</ol>
<h2 id="（二）手机摄像头"><a href="#（二）手机摄像头" class="headerlink" title="（二）手机摄像头"></a>（二）手机摄像头</h2><h3 id="1-镜头"><a href="#1-镜头" class="headerlink" title="1. 镜头"></a>1. 镜头</h3><h4 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h4><p>主要有两种材质<br>手机摄像头使用的镜头主要有塑胶和玻璃两种材质。塑胶镜头透光率不如玻璃镜头，但成型更为容易、良率较高、成本较低，通过不同形状的塑胶镜头进行组合，也可以达到非常好的成像效果，所以手机摄像头使用大多都是塑胶镜头。</p>
<p>如在下图中，黑白条的对比度原本是 100%，但经过镜头的处理之后，黑白条的中间地带会由于光线的串扰而呈现灰色，这就是无法完全还原对比度的情况。在这个例子中，这个镜头的 MTF 值为 90%，表示可以还原 90%的对比度。</p>
<p>在手机可见光摄像头中，尽管玻璃材料的透光量要好于塑胶镜头，但塑胶易于成型，可以组成各种所需要的组合，对光线的控制也更优，所以塑胶镜头的 MTF 反而会大于玻璃镜头。<br><img src="https://image.qinxing.xyz/20200403110315.png" alt="MTF 是镜头对对比度的还原情况的衡量"></p>
<h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>光学镜头的难点之一在于设计环节。光线在穿过镜头时，会发生非常复杂的折射过程才能到达图像传感器。<br>这些复杂的折射过程会使图像传感器上的成像与根据高斯光学得到的理论结果产生差距，这就是像差。<br>像差主要由三种原因产生：</p>
<ol>
<li>通光介质的折射率随波长变化而变化；</li>
<li>透镜表面通常为球面；</li>
<li>光具有波粒二象性。<br>由第一种原因产生的成像偏差称为色差，第二种产生的成像偏差称为球差，第三种产生的成像偏差称为衍射效应。目前已知的像差已经有几百种，比如轴向色差、球差、横向色差、慧差、场曲、像散和畸变等。<div class="justified-gallery"><p><img src="https://image.qinxing.xyz/20200403110446.png" alt="典型的轴向色差示意图"><br><img src="https://image.qinxing.xyz/20200403110502.png" alt="典型的球差示意图"><br><img src="https://image.qinxing.xyz/20200403110517.png" alt="典型的横向色差示意图"><br><img src="https://image.qinxing.xyz/20200403110533.png" alt="典型的慧差示意图"></p>
          </div>

</li>
</ol>
<p>像差无法完全消除，所以这个世界不存在完美的镜头。光学设计就是通过组合不同形状、不同数目的透镜，实现对这些像差的控制，尽可能获得尽可能完美的成像效果。但是因为像差实在太多，所以想实现完全的像差控制是不可能的，只能通过光学设计在众多像差中取得平衡。</p>
<p><img src="https://image.qinxing.xyz/20200403110756.png" alt="六种经典基础光学设计方案"></p>
<h4 id="制造"><a href="#制造" class="headerlink" title="制造"></a>制造</h4><p>光学镜头的难点之二在于制造环节。如果说设计解决的是镜头厂商能否生产的问题，那么制造环节就是决定生产良率和一致性的关键。在模具、成型、组装等环节，对于生产精度都有非常高的要求，任何一个环节出现差错都会对最后的成像效果产生非常大的影响。</p>
<p><img src="https://image.qinxing.xyz/20200403110838.png" alt="手机镜头的主要生产流程"><br>模具环节是塑胶镜头制造的最关键部分。模具的质量直接影响镜片的成型，所以需要非常高精度的模具，不仅需要有经验的设计人员来进行设计，还需要制造人员具有精密加工和检测方面的基础。在设计模具时，应该将成型时的所有可能影响精度的因素加以控制，包括成型机、成型条件、成型材料。整体模具的设计需要注意成型机的尺寸和精度、成型条件和成型材料的特性，并考虑到具有累加性的误差，如平行度、垂直度、同心度，以及影响塑胶流动的因素，例如排气孔的位置和浇口形状。在制造模具时，需要考虑模具的加工方法、工作机械和模具材料，比如零件制造的机台、方法、程序是否合理。任何失误都会直接影响模具的尺寸<br>精度，很容易导致模具无法达到设计的公差范围。在成型环节，材料发生了相变化、密度变化、温度变化以及压力变化，必须严格精确控制这些变量才能使透镜拥有良好的光学特性，这对厂商的生产提出了极高的要求，不仅需要高精度的仪器，还需要有经验的熟练工人才能完成操作，任何差错都会影响最后的成像质量。比如莱卡在冷却成型时，是按照一小时下降一度的速率逐渐降低温度的，以求得到最优质的光学镜头。</p>
<p>组装环节是按照顺序逐一将加工完成的镜片、隔片、压圈等部件完成装配，并实现光学性能的过程，目前主要通过自动化方式实现组装。镜头组装技术要点十分复杂，对部件加工精度、组装精度具有极高的要求，整体公差一般不超过 3 微米，而大立光等企业甚至达到 2 微米。组装还需要经验丰富功底深厚的专家团队，不断改进探索，需要多年积累才能制作一颗合格的镜头。</p>
<p><img src="https://image.qinxing.xyz/20200403110911.png" alt="6P镜头的结构示意图"><br><img src="https://image.qinxing.xyz/20200403110932.png" alt="镜头组装的基本流程"><br>光学镜头设计非常复杂，目前已知的像差就有数百种，仍有大量未知的像差不断被发现，需要在设计中被考虑进去。光线的折射和反射路径数不胜数，需要设计师去不断计算和权衡。透镜的形状、位置、材料可以有无数种组合方式，让设计师们有空间去不断挖掘更好的设计。光学镜头行业永远没有进步的终点，永远都有探索的空间。正因为这个行业进步永无止境，所以时间和经验才显得极为重要。</p>
<p><strong>思考：</strong>海康的黑光技术是用棱镜分光实现的，光学上的创新挺令人惊叹的。未来光学镜头的发展还有很多路可以走，也就意味着这些行业有很强的技术壁垒，其他的小厂商很难生存下来。</p>
<h3 id="2-音圈马达"><a href="#2-音圈马达" class="headerlink" title="2. 音圈马达"></a>2. 音圈马达</h3><p>手机中控制镜头对焦的器件为音圈马达（VCM）。单反相机的对焦是通过转动镜筒带动镜头里某个镜片或者某组镜片前后移动，来修正光路，使成像落在感光元件上是最清晰的。普通的手机摄像头无法做到像单反相机那样移动某块镜片或者某组镜片来对焦，因此手机摄像头是通过镜头组整个前后移动实现自动对焦，驱动这一动作的就是 VCM。</p>
<p><img src="https://image.qinxing.xyz/20200403111144.png" alt="音圈马达的组成部件示意图"><br>音圈电机（VCM）基于安培定理工作，即当线圈导电，其中的电流产生的作用力推动固定在载体上的镜头移动，从而改变对焦距离。可以看到，音圈电机（VCM）器件对于对焦距离的控制实际上是通过对线圈中电流的控制来实现的。</p>
<p>手机摄像头的 VCM 需要 Driver IC 配合完成对焦，通过 Driver IC 控制VCM 供电电流的大小，来确定 VCM 搭载的镜头移动的距离，从而调节到适当的位置拍摄清晰图像。</p>
<p>衡量 VCM 的性能主要有以下几个指标：</p>
<ol>
<li>行程，简单来说就是音圈马达在额定电流下能够跑多远；</li>
<li>灵敏度，就是电流与行程曲线之间的斜率，灵敏度越高越好；</li>
<li>磁滞，磁性物体都有保留其磁性的倾向，磁感应强度的变化总是滞后于磁场强度的变化，所以会造成音圈马达在同一电流下向上或者向下的行程产生位置差，磁滞越小越好；</li>
<li>启动电流，就是需要多大的电流来驱动 VCM，越小越好。</li>
</ol>
<h3 id="3-红外截止滤光片"><a href="#3-红外截止滤光片" class="headerlink" title="3. 红外截止滤光片"></a>3. 红外截止滤光片</h3><p>红外截止滤光片(IR-Cut filter) 是一种允许可见光透过而截止红外光的光学滤光片。当光线进入镜头，折射后可见光和红外光会在不同靶面成像，可见光成像为彩色，红外光成像为黑白。当把可见光所成图像调试好之后，红外光会在此靶面形成虚像，影响图像的颜色和质量。</p>
<p><strong>思考</strong>：原来红外滤光片不仅仅有矫正色彩的功能，还有减少红外产生的伪像的功能。难怪光学组测试镜头的时候有一项指标叫做，日夜共焦。</p>
<p>红外截止滤光片又可细分为两种，一种是反射式滤光片，另一种是吸收式滤光片。滤光片最关键的工艺是镀膜，需要保证镀膜的均匀性和一致性，镀膜又可分为真空镀膜和化学镀膜两种方式。镀膜之后基本可以滤除 650nm以上波长的光，满足基本的使用需求。<br>以蓝玻璃为基材镀膜制成的 IRCF，是采用吸收的方式过滤红外光，可过滤 630nm 以上波长的光，比较彻底；而以普通玻璃为基材镀膜所制成的IRCF 是以反射的方式过滤掉红外光，反射光容易造成干扰，效果差于蓝玻璃 IRCF。<br><img src="https://image.qinxing.xyz/20200403111322.png" alt="反射式 IRCF 和吸收式 IRCF 的原理对比"><br><img src="https://image.qinxing.xyz/20200403111302.png" alt="蓝玻璃 IRCF 的效果好于普通玻璃 IRCF"></p>
<h3 id="4-CIS传感器"><a href="#4-CIS传感器" class="headerlink" title="4. CIS传感器"></a>4. CIS传感器</h3><h4 id="原理及发展"><a href="#原理及发展" class="headerlink" title="原理及发展"></a>原理及发展</h4><p>CMOS 图像传感器（CIS，CMOS Image Sensor）是实现将光信号转换为电信号的模数转换器。</p>
<p>CMOS 图像传感器由两部分组成：感光区域和处理电路。感光区域由大量的感光二极管构成，每个感光二极管就是一个像素单元。光子在经过感光二极管之后，就会通过激发光电二极管中的材料放电，从而转化为电子被释放出来。电荷被储存而形成电势差，电势差被测量出来，从而可以得到该像素单元的灰度值。<br>处理电路是对感光区域获得的数据进行处理的电路，例如自动对焦、光学防抖、曝光时间控制、自动增益控制、时序控制、同步信号、行起始信号、场起始信号等，在传感器的工作过程中起着非常重要的作用。</p>
<ul>
<li>由前照式转变为背照式，提高画质。</li>
<li>由非堆栈式转变为堆栈式，提升性能，减小面积。</li>
<li>由双层堆栈式转变为三层堆栈式，提升数据读取速度。（大像素和高帧率）</li>
</ul>
<h4 id="定制化"><a href="#定制化" class="headerlink" title="定制化"></a>定制化</h4><p>由于各大手机厂商对拍照性能的要求不同、理解也不同，所以对 CMOS图像传感器的性能要求也不一样，这就需要进行定制化生产。与公版感光元件固定化的参数相比，定制化的感光元件在参数选择上更加灵活。以华为 P9 为例，在确定了双摄像头理念后，找到索尼定制RGB/Monochrome 架构的 CMOS 能够让双摄像头的实力得到更大发挥。另外如果在画质上有很高的追求，则可以找索尼定制一款低像素、大面积+大像素尺寸这种综合实力很强的 CMOS（诸如 IMX260）。</p>
<p>IDM 模式即将设计与制造两大环节垂直整合的模式，Fabless 模式即只专注设计而将制造环节外包的模式。根据前面的分析，CMOS 图像传感器其实有大量技术创新是在制造环节，那么 IDM 模式的厂商就可以更深刻地理解制造过程，从而实现技术上的改进，而代工的 Fabless 模式则因距离制造环节太远而无法更好地创新；与此同时，IDM 模式让厂商在生产环节有了更多的掌控力，可以更好地完成手机厂商所要求的定制化参数。</p>
<p>索尼、三星、佳能、尼康等厂商采用的是 IDM 模式，SK 海力士则通过收购 Siliconfile 而成为 IDM 厂商。其余厂商则采用 Fabless/Fablite 的模式，例如安森美（On Semi）交给 L-Foundry 代工，意法半导体交给台联电代工，豪威科技主要交给台积电代工，格科微主要交给中芯国际代工。</p>
<h3 id="5-模组"><a href="#5-模组" class="headerlink" title="5. 模组"></a>5. 模组</h3><p>模组：技术壁垒不高，良率提升决定盈利能力<br>模组是把上述零组件整合到一起后的器件。手机摄像头模组的主流工艺有 CSP、COB 和 FC 三种，其中 CSP 主要用于低端产品，COB 是最主流的工艺，FC 则仅有苹果在使用。</p>
<ul>
<li>CSP（芯片级封装）的优势在于制造设备成本低、洁净度要求低、良率较高，劣势在于镜头透光率低、模组厚度较高。</li>
<li>COB（板上封装）的优势在于设备成本较高但封装成本低，劣势在于洁净度要求高、良率较低，制程时间相对较长。</li>
<li>FC（倒装芯片）的优势在于封装密度很高、封装所得摄像头模组厚度最薄、缺点在于成本较高、良率较低。</li>
</ul>
<h2 id="（三）3D-sensing"><a href="#（三）3D-sensing" class="headerlink" title="（三）3D sensing"></a>（三）3D sensing</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h3><p>3D Sensing 的硬件可以分为发射端和接收端两部分。发射端由 VCSEL激光源、准直镜头和 DOE 扩散片组成，接收端由窄带滤光片、光学镜头和红外 CIS 组成。<br>在工作时，VCSEL 激光源首先会发射出数百束特定频率的红外光，这些红外光经过准直镜头的校准之后，被传导到 DOE 扩散片，扩散片会将红外光束分散成 3 万多个随机的红外光点，照射到人的面部；经过面部反射之后的红外光被接收端接收，在经过窄带滤光片的过滤之后，特定频率的红外光经过光学镜头的投射被红外 CIS 所接收。<br><strong>疑问</strong>：发射端为什么需要反射镜面？<br><img src="https://image.qinxing.xyz/20200403113128.png" alt="3D Sensing 的硬件有发射端和接收端组成"></p>
<h3 id="2-VCSEL激光源"><a href="#2-VCSEL激光源" class="headerlink" title="2. VCSEL激光源"></a>2. VCSEL激光源</h3><p>以砷化镓激光二极管为例，首先需要在砷化镓激光二极管芯片的上下各蒸镀一层金属电极，对着芯片施加电压，当芯片吸收电能时，会发出某种波 长的光。发射的光在左右两个反射镜（DBR1、DBR2）间来回反射，产生谐 振放大。由于右侧的反射镜被设计成可以透过一部分光（DBR2 的层数较少）， 所以特定波长的高能量光束就会从右方穿出。</p>
<p><img src="https://image.qinxing.xyz/20200405181014.png" alt="激光二极管的电激发光原理示意图"></p>
<p>阳光中的 940nm 红外光会在长距离传播中被空气中的水分吸收掉，而iPhone X 所用的 940nm 红外光则因距离面部近而不会被吸收，这样可以避免阳光中的红外光干扰产生“红暴”现象，所以苹果才选用这个波长的红外光。850nm 红外光则一般用于光通信中，普通的监控摄像头也是使用的这一波段的红外光。</p>
<h3 id="3-准直镜头"><a href="#3-准直镜头" class="headerlink" title="3. 准直镜头"></a>3. 准直镜头</h3><p>VCSEL 发出的光具有较宽的波瓣，不利于后续的衍射过程，需要将这些光汇聚校准为窄波瓣的近似平行光。这种将激光校准为平行光的器件就是准直镜头。</p>
<p>技术难度高，目前被Heptagon 垄断专利。</p>
<h3 id="4-光学衍射元件"><a href="#4-光学衍射元件" class="headerlink" title="4. 光学衍射元件"></a>4. 光学衍射元件</h3><p>经过准直镜头校准后的激光束并没有特征信息，因此下一步需要对激光束进行调制，使其具备特征结构，光学衍射元件（DOE）就是用来完成这一任务的。VCSEL 射出的激光束经准直后，通过 DOE 进行散射，即可得到所需的散斑图案（Pattern）。<br>DOE 的基本原理是利用衍射原理在元件表面制备一定深度的台阶（光栅），光束通过时产生不同的光程差，满足布拉格衍射条件。通过不同的设计来控制光束的发散角和形成光斑的形貌，实现光束形成特定图案的功能。<br>DOE 是一个单一光学元件，可将入射光束分散成无数个光束再射出。每一个分散之后再射出的光束，都与原先入射进来的光束拥有相同的光学特性，包括偏振性、相位等。DOE 可产生 1D（1xN）或 2D（MxN）的光束矩阵，视DOE 的表面微结构而定。<br>DOE 的特点是能够在保持较高衍射效率的同时对光强分布进行精确控制，因此 DOE 成为让激光生成随机散斑的理想元件。</p>
<h3 id="5-接收端镜头"><a href="#5-接收端镜头" class="headerlink" title="5. 接收端镜头"></a>5. 接收端镜头</h3><p>传统的手机镜头需要达到非常好的成像效果，所以需要非常复杂的光学设计和制造工艺。但接收端红外摄像头对光学镜头的要求远不如可见光摄像头那么高，对光线的通光量、畸变矫正等指标容忍度较高，所以目前 3D Sensing 接收端镜头主要使用已成熟的普通镜头。</p>
<h3 id="6-窄带滤光片"><a href="#6-窄带滤光片" class="headerlink" title="6. 窄带滤光片"></a>6. 窄带滤光片</h3><p>窄带滤光片是只允许特定波长的光通过而滤除其余波长的光的光学元件。3D Sensing 的发射端会发射 940nm 波长的红外光，接收端需要滤除其余波长的光而仅仅接受 940nm 红外光，所以需要使用窄带滤光片。窄带滤光片的通带相对比较窄，一般要求在中心波长值的 5%以下。<br><img src="https://image.qinxing.xyz/20200403114545.png" alt="窄带滤光片的原理示意图"><br>窄带滤光片的薄膜一般由低折射率和高折射率的两种膜组成，叠加后层数达几十层，每一层薄膜的参数漂移都可能影响最终性能；而且窄带滤光片透过率对薄膜的损耗非常敏感，所以制备峰值透过率很高、半带宽又很窄的滤光片非常困难。</p>
<h3 id="7-红外-CMOS-图像传感器"><a href="#7-红外-CMOS-图像传感器" class="headerlink" title="7. 红外 CMOS 图像传感器"></a>7. 红外 CMOS 图像传感器</h3><p>在原理上，红外 CIS 与可见光 CIS 是一致的，但可见光 CIS 需要识别RGB 三种颜色，并且需要呈现非常清晰的图像，所以对分辨率的要求很高（关于 RGB CIS 的详细分析，请参见本报告的 2.4 节）。而红外 CIS 只需要获取结构光的深度信息，不需要产生清晰的成像，所以分辨率要求不高，通常2M 像素即可满足要求。</p>
<p><img src="https://image.qinxing.xyz/20200403114908.png" alt="深沟隔离技术减少串扰"><br>由于像素与像素之间会产生光线与电流的串扰问题，这种串扰会降低成像的锐度，影响图像的还原，形成噪点。深沟隔离技术可以理解为一堵墙，可以避免像素间的干扰，增强光线利用率。</p>
<h2 id="（四）小结"><a href="#（四）小结" class="headerlink" title="（四）小结"></a>（四）小结</h2><p>以前对手机摄像头的认知就只是一个模组，技术含量应该远不如单反等专业摄像头。经过这篇文章对镜头模组行业有了一个大致的了解，手机的模组很复杂，分为很多的部分，由不同的厂家共同完成，有很强的定制化，也有很高的技术壁垒。</p>
<p>镜头厂商的技术两极分化越来越严重，优秀的一直会进步，逐步拉开差距。而小的ODM厂商很难有小米、华为那样的资金去定制镜头，和他们的摄像头差距也越来越大，如果小米华为等巨头进一步拓展业务，这些小厂商又该怎么办呢？换个好的角度思考，手机摄像头的进步也会加速其他行业的摄像头升级，让其他行业用上更小更好的摄像头。</p>
<p>另一方面，手机行业的摄像头正在一步步的进化，很有可能将来的某一天，单反这种产品会像胶卷一样不复存在。</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>镜头</tag>
        <tag>多摄</tag>
        <tag>潜望式摄像头</tag>
      </tags>
  </entry>
  <entry>
    <title>人卡微卡调试注意事项总结</title>
    <url>/posts/ee122b61/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="微卡"><a href="#微卡" class="headerlink" title="微卡"></a>微卡</h2><h3 id="一．相机安装"><a href="#一．相机安装" class="headerlink" title="一．相机安装"></a>一．相机安装</h3><p>1.垂直角度在13正负3度<br>2.为保障车牌识别的准确性，监控区域画面近端，保持两个车道7m。<br>3.画面中心在保持在需要监控道路的中心。<br>4.相机安装水平不倾斜。</p>
<h3 id="二．相机标定"><a href="#二．相机标定" class="headerlink" title="二．相机标定"></a>二．相机标定</h3><p>根据远近处的车牌大小进行标定，具体如下图：<br><img src="https://image.qinxing.xyz/20200329000918.png" alt="车牌标定"></p>
<h3 id="三．图像参数"><a href="#三．图像参数" class="headerlink" title="三．图像参数"></a>三．图像参数</h3><ol>
<li><p>快门：默认先用1/240，能覆盖大多数情况</p>
</li>
<li><p>增益：增益上限默认到50，</p>
</li>
<li><p>对比度：降低对比度调成20，有助于在比较暗环境下提高暗区亮度。</p>
</li>
<li><p>补光灯：智能配置->补光灯配置那里，根据环境中是否有外置补光灯，无外置灯的，默认模式设置为自动，阈值35，内置补光灯2 强度设置20， 有外置补光灯的默认关闭内置补光灯。</p>
</li>
<li><p>为保障车牌识别的准确性，监控区域画面近端，保持两个车道7m;<br><img src="https://image.qinxing.xyz/20200329001136.png" alt="微卡车道拍摄"></p>
</li>
</ol>
<h3 id="四-微调"><a href="#四-微调" class="headerlink" title="四. 微调"></a>四. 微调</h3><ol>
<li>若聚焦已经调整到中下部，车速太快，早上或者傍晚抓拍到大量运动模糊的车牌，降低快门下限至1/300.</li>
<li>这样配置后还是车牌过曝，优先降低一点内置补光灯强度，若降至0还不行（此时肯定有外置灯直射车牌），可以降低下增益上限，以5为单位降低增益上限。</li>
<li>若夜间车牌比较灰暗，不够亮，可以稍加内置补光灯强度，以5为单位。</li>
<li>若发现不管白天晚上，中下抓拍区域车牌亮度正常，但是整体很糊，可以试着调试聚焦，建议在白天时候 ，调试，聚焦在中下部，聚完焦后再设置镜头锁定。（保证下一半清晰）</li>
</ol>
<h2 id="人卡"><a href="#人卡" class="headerlink" title="人卡"></a>人卡</h2><h3 id="一-相机安装"><a href="#一-相机安装" class="headerlink" title="一. 相机安装"></a>一. 相机安装</h3><p>1.垂直角度在13正负3度<br>2.为保障车牌识别的准确性，监控区域纵向在2人高以内，横向5米以内。<br>3.画面中心在保持在需要监控区域的中心。<br>4.相机安装水平不倾斜。</p>
<h3 id="二-相机标定"><a href="#二-相机标定" class="headerlink" title="二. 相机标定"></a>二. 相机标定</h3><p><img src="https://image.qinxing.xyz/20200329001629.png" alt="人卡相机标定"></p>
<h3 id="三-图像参数"><a href="#三-图像参数" class="headerlink" title="三. 图像参数"></a>三. 图像参数</h3><ol>
<li><p>快门：根据实际场景中人员状态，若行人居多，默认快门上限1/100; 若电瓶车或者小三轮居多，快门往下降1/150,或1/200。</p>
</li>
<li><p>聚焦：聚焦在画面中下部，白天调完聚焦后，保存在配置->摄像机->图像->聚焦中，若晚上切换到夜模式后出现中下部比中上明显偏糊，需要再调整下聚焦保存在夜模式中，后面自动切换日夜的时候就会自动调用两个位置。</p>
</li>
<li><p>若架设场景是全天大多数时间都是背光的室内对着大门的场景，开启智能配置->参数配置->智能曝光，其他正常场景关闭该功能。</p>
</li>
</ol>
<h3 id="四-夜间注意事项"><a href="#四-夜间注意事项" class="headerlink" title="四. 夜间注意事项"></a>四. 夜间注意事项</h3><ol>
<li><p>建议在环境光比较好的场景，在配置->摄像机->图像->日夜转换的模式设置为白天。</p>
</li>
<li><p>若进行日夜切换，开启红外灯的设备，根据抓取的人脸亮度，先用默认参数，若过曝或者较暗，调整红外强度手动模式，并且修改强度。</p>
</li>
<li><p>若聚焦以及亮度都调整完后，还是觉得有点糊，可以尝试减小2D降噪，但是会引入更多噪声，谨慎调试。</p>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像效果调试</category>
      </categories>
      <tags>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：红外回调不生效</title>
    <url>/posts/4dfacae0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><ol>
<li>同一个版本，业务获取不到回调值，但是我们能获取到。同一个设备，有时能回调，有时没有回调。</li>
<li>关采集的时候没有给回调值</li>
<li>自动模式下，开红外之后关采集，再打开的时候，画面正常切到白天，但是回调给的状态是开红外</li>
</ol>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li><input checked disabled type="checkbox"> 在同一个设备中进行打印，观察何时能回调，何时没有回调</li>
</ul>
<p>关闭采集的时候没有给回调值，有两种可能性： </p>
<ul>
<li><input checked disabled type="checkbox"> 红外开关是在ROM中设置，可能关闭采集的时候，isp组件先关闭了，再去关红外灯的，就没法去执行业务的回调</li>
<li><input checked disabled type="checkbox"> 在关闭采集的时候，没有对property进行设置，isp组件中也就没有获取到当前的红外状态</li>
</ul>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li>同一台设备中打印，有的时候有回调，有的是否没有回调，后来发现和root权限有关。没有root过就没有回调，root过就有回调。这个现象在之前创建fd的时候也遇到过，SElinux对创建fd等操作进行了权限管理。</li>
<li>整理红外回调的思路：ROM中设置红外开关的时候都会设置对应的property值。在isp组件中创建一个线程，对property的值轮询，如果发生了改变，就执行业务的回调。</li>
<li>由于isp组件可能在红外灯关闭之前就被kill掉了，而不管是手动还是自动模式，关闭采集的时候都需要关闭红外，所以直接在isp组件退出的时候，回调红外关闭的状态。</li>
<li>isp组件需要保存上一次的值，否则很可能在关闭采集的时候，回调两次红外关闭的状态（isp组件检测到红外关闭回调一次，isp组件退出的时候回调一次）。回调红外关闭的状态，从isp组件退出的地方，修改到轮询property线程结束的地方，这样可以利用static保存上一次的值。</li>
<li>关闭采集的时候，发现ROM那边仅仅是把红外灯设置成关闭状态，没有更新property值，所以需要增加一句设置property的代码</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li>SElinux权限，需要找负责ROM的人开</li>
<li>isp组件：在更新红外状态的线程结束时，把红外状态设置成关，回调给业务</li>
<li>rom: 在camera关闭的状态下，也要注意更新property的值</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>不仅仅fd的创建与读写，property的读写也是由SElinux管理的，以后代码提交的时候，需要在非root的情况下也验证一下，防止出现此类问题</li>
<li>这种更新状态的问题，需要考虑到开关机，线程中途退出等等问题，必须要考虑全面</li>
<li>线程结束的时候，多思考一下，需要释放哪些资源，需要重置哪些状态等等</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>BUG</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：畸变校正算法不生效</title>
    <url>/posts/b610df15/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>设备从老版本R2B1切到了R2B3流，畸变校正算法不生效</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><ul>
<li><input checked disabled type="checkbox"> 代码解决编译问题</li>
<li><input checked disabled type="checkbox"> 2241设备已经切到R2B3了，把动态库放到设备里面看一下是否生效 ——测试：葛志海</li>
<li><input checked disabled type="checkbox"> 把动态库库放到2431中是否生效，确认一下用的媒控库是新的还是老的 —— 测试：王海龙</li>
<li><input checked disabled type="checkbox"> 如果生效了，检查路径。如果不生效，IMGVideoAlgOpen函数返回1，在其中加打印，看一下传入结构体里的值对不对</li>
<li><input checked disabled type="checkbox"> 如果不生效，查看媒控的调用情况，主要注意库名和函数名</li>
<li><input checked disabled type="checkbox"> 2241把新库放进去看一下是否生效，如果生效了，就是库的版本不对，如果不生效的话，还需要和媒控查看代码</li>
</ul>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li><p>编译 到<code>jni</code>目录下，运行<code>ndk_build.cmd</code></p>
</li>
<li><p>2241设备IP：<code>10.67.36.191</code></p>
</li>
<li><p>启动ssh登陆后，登陆17230端口，<code>openssh</code>。然后打开10023端口，输入网口转usb指令：<code>setprop service.adb.tcp.port 5555 && stop adbd && start adbd</code>，然后root：<code>setprop service.ipc.root 1</code>，最后用adb连上</p>
</li>
<li><p>防止换的库被覆盖，<code>mv /etc/update.bz2 /etc/update.bz2.bak</code>，换库路径<code>/storage/sdcard0/bin/lib</code></p>
</li>
<li><p>发现2241开关没有明显作用，联系葛志海测试多台设备发现，R2B3的每日流有效果，封闭流没效果。</p>
</li>
<li><p>又找了一台设备<code>10.67.36.194</code>发现花屏</p>
<p><img src="/posts/b610df15/f0c18288-1de3-4c2f-8811-3a8354be5218_1d808b11-dc95-4acf-81fe-05e86b38e90b@kedacom.com.png" alt></p>
</li>
<li><p>换到中试R2B1版本，有点效果</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line"># IPC</span><br><span class="line">setcapratio <span class="number">1920</span> <span class="number">1080</span> # 上面这一条是切分辨率的，<span class="number">2241</span>是<span class="number">200</span>万的，但是没有用</span><br><span class="line">mcsetldc <span class="number">1500</span> <span class="number">100</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>换上我的库后在界面上开关没有反应，但是输入命令mcsetldc就生效了 。由于mcsetldc命令是媒控封装的，是否能证明是业务的问题？</p>
</li>
<li><p>在2241上的R2B3测试：原有的库输入命令就会花屏，换上最新的算法库，在web界面上调没有反应，但是输入指令就正常了</p>
</li>
<li><p>在2431上换上最新的算法库也会报错，先搞定2431的问题 </p>
</li>
<li><p>查看媒控代码，发现老版本的媒控使用的库名和函数名都不对，用的是老的算法库，需要替换成新的</p>
</li>
<li><p>当媒控修改库之后，配上最新的算法库就正常了，联系CMO取库，发现一套代码编出了两个版本，一个放在8056目录，一个放在了660目录。2431是8056的老设备，用8056目录下的库即可</p>
</li>
<li><p>2241更新代码后，换上最新的算法库，发现一切正常。说明还是算法库用的是老的，但是CMO放的路径确实没有问题。查看业务的编译脚本，发现它把两个版本的算法库都拷贝了进来，但是用老的算法库覆盖了新库，导致最后用的还是老库</p>
</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><p>CMO分两种，第一种是专门编译代码的，第二种是专门把编译出的代码放在一个地方让业务去取的。然后业务写编译脚本，把库包含进来。</p>
</li>
<li><p>媒控有两个版本，老设备用的是alpha，新设备和双摄用的是beta版，需要关注他们的版本。</p>
</li>
<li><p>版本信息的打印很重要，只不过这个是很久不维护的，如何添加版本信息，可以参考我之前的文章。</p>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>BUG</tag>
        <tag>版本信息</tag>
      </tags>
  </entry>
  <entry>
    <title>相机成像模型</title>
    <url>/posts/42798c5a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>此文转载自<a href="https://zhuanlan.zhihu.com/p/23090593" target="_blank" rel="noopener">知乎</a></p>
</blockquote>
<p>相机在计算机视觉应用中起着重要作用，作为图像数据来源，影响着后续各个处理步骤。成像模型就是用数学公式刻画整个成像过程，即被拍摄物体空间点到照片成像点之间的几何变换关系。</p>
<p>总体上，相机成像可以分为四个步骤：刚体变换、透视投影、畸变校正和数字化图像。</p>
<p><img src="https://image.qinxing.xyz/20200722144205.png" alt></p>
<h2 id="1、刚体变换"><a href="#1、刚体变换" class="headerlink" title="1、刚体变换"></a>1、刚体变换</h2><p>刚体变换只改变物体的空间位置(平移)和朝向(旋转)，而不改变其形状，可用两个变量来描述：旋转矩阵R和平移向量t</p>
<p><img src="https://image.qinxing.xyz/20200722144203.png" alt></p>
<p>其次坐标下可写为：<br><img src="https://image.qinxing.xyz/20200722144201.png" alt></p>
<p>旋转矩阵R是正交矩阵，可通过罗德里格斯（Rodrigues）变换转换为只有三个独立变量的旋转向量：</p>
<p><img src="https://image.qinxing.xyz/20200722144158.png" alt></p>
<p>因此，刚体变换可用6个参数来描述，这6个参数就称为相机的外参(Extrinsic)，相机外参决定了空间点从世界坐标系转换到相机坐标系的变换，也可以说外参描述了相机在世界坐标系中的位置和朝向。</p>
<p><strong>我的理解：</strong></p>
<p><strong>相机的旋转就是改变了旋转矩阵R，旋转图像就是修改这个R</strong></p>
<p><strong>如果放在GPU中运行，其实其他过程都是一样的，只是要修改这个R，其他都是同一个流程，是不是简化很多算法</strong></p>
<h2 id="2、透视投影"><a href="#2、透视投影" class="headerlink" title="2、透视投影"></a>2、透视投影</h2><p>我们可以将透镜的成像简单地抽象成下图所示：</p>
<p><img src="https://image.qinxing.xyz/20200722144154.png" alt></p>
<p>设 f=OB 表示透镜的焦距，m=OC 为像距，n=AO 为物距，有：</p>
<p><img src="https://image.qinxing.xyz/20200722144152.png" alt></p>
<p>一般地，由于物距远大于焦距，即 n>>f，所以 m≈f，此时可以用小孔模型代替透镜成像：</p>
<p><img src="https://image.qinxing.xyz/20200722144149.png" alt></p>
<p>可得：</p>
<p><img src="https://image.qinxing.xyz/20200722144146.png" alt></p>
<p>齐次坐标下有：</p>
<p><img src="https://image.qinxing.xyz/20200722144143.png" alt></p>
<p>如果将成像平面移到相机光心与物体之间，则有中心透视模型：</p>
<p><img src="https://image.qinxing.xyz/20200722144141.png" alt></p>
<p>可得：</p>
<p><img src="https://image.qinxing.xyz/20200722144139.png" alt></p>
<p>齐次坐标下有：</p>
<p><img src="https://image.qinxing.xyz/20200722144137.png" alt></p>
<p>总体上看，透视投影将相机坐标系中的点投影到理想图像坐标系，其变换过程只与相机焦距 f 有关。</p>
<h2 id="3、畸变校正"><a href="#3、畸变校正" class="headerlink" title="3、畸变校正"></a>3、畸变校正</h2><p>理想的针孔成像模型确定的坐标变换关系均为线性的，而实际上，现实中使用的相机由于镜头中镜片因为光线的通过产生的不规则的折射，镜头畸变（lens distortion）总是存在的，即根据理想针孔成像模型计算出来的像点坐标与实际坐标存在偏差。畸变的引入使得成像模型中的几何变换关系变为非线性，增加了模型的复杂度，但更接近真实情形。畸变导致的成像失真可分为径向失真和切向失真两类：</p>
<p><img src="https://image.qinxing.xyz/20200722144134.png" alt></p>
<p>畸变类型很多，总体上可分为径向畸变和切向畸变两类，径向畸变的形成原因是镜头制造工艺不完美，使得镜头形状存在缺陷，包括枕形畸变和桶形畸变等，可以用如下表达式来描述：</p>
<p><img src="https://image.qinxing.xyz/20200722144132.png" alt></p>
<p>切向畸变又分为薄透镜畸变和离心畸变等，薄透镜畸变则是因为透镜存在一定的细微倾斜造成的；离心畸变的形成原因是镜头是由多个透镜组合而成的，而各个透镜的光轴不在同一条中心线上。切向畸变可以用如下数学表达式来描述：</p>
<p><img src="https://image.qinxing.xyz/20200722144130.png" alt></p>
<p>在引入镜头的畸变后，成像点从理想图像坐标系到真实图像坐标系的变换关系可以表示为：</p>
<p><img src="https://image.qinxing.xyz/20200722144128.png" alt></p>
<p>实际计算过程中，如果考虑太多高阶的畸变参数，会导致标定求解的不稳定。</p>
<h2 id="4、数字化图像"><a href="#4、数字化图像" class="headerlink" title="4、数字化图像"></a>4、数字化图像</h2><p>光线通过相机镜头后最终成像在感光阵列(CCD或CMOS)上，然后感光阵列将光信号转化为电信号，最后形成完整的图像。我们用dx和dy分别表示感光阵列的每个点在x和y方向上物理尺寸，即一个像素是多少毫米，这两个值一般比较接近，但由于制造工艺的精度问题，会有一定误差，同样的，感光阵列的法向和相机光轴也不是完全重合，即可以看作成像平面与光轴不垂直。</p>
<p><img src="https://image.qinxing.xyz/20200722144126.png" alt></p>
<p>我们用仿射变换来描述这个过程，如上图，O点是图像中心点，对应图像坐标(u0，v0)，Xd - Yd是真实图像坐标系，U-V是数字化图像坐标系，有：</p>
<p><img src="https://image.qinxing.xyz/20200722144123.png" alt></p>
<p>齐次坐标下有：</p>
<p><img src="https://image.qinxing.xyz/20200722144121.png" alt></p>
<p>上式中的变换矩阵即为相机的内参数矩阵 K，其描述了相机坐标系中点到二维图像上点的变换过程。</p>
<p>综上所述，在不考虑镜头畸变的情况下，相机的整个成像过程可表示为：</p>
<p><img src="https://image.qinxing.xyz/20200722144118.png" alt></p>
<p><strong>我的思考：</strong></p>
<p>一般来说图像的中心并不是（0,0)，而是(w/2,h/2)，也就是说u0=w/2,v0=h/2;<br> 如果说不考虑dx不等于dy的情况，因为大部分像素都是正方形的，那么公式应该变成</p>
<p><img src="https://image.qinxing.xyz/20200722144114.png" alt></p>
<p>而这与透视投影的矩阵乘在一起，变成了</p>
<p><img src="https://image.qinxing.xyz/20200722144102.png" alt></p>
<p>由于dx,dy为一个像素的长度，因此f/dx可以称做为像素焦距。</p>
<p>由于畸变校正是个非线性的变换，我们需要思考，第三步和第四步是否可以交换，由于第四步仅仅是一个实际位置转换成像素位置的过程，先做后做都是一样的。</p>
<p><strong>我的疑问：</strong></p>
<p>那么最前面的Zc如何计算？Zc可以理解成物体的距离，也就是相机到物体的距离，我们可以当做一个平面，在高通的openGL里面设置成了1。</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>camera原理</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-butterfly主题迁移</title>
    <url>/posts/d8003135/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="网站配置"><a href="#网站配置" class="headerlink" title="网站配置"></a>网站配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>参考<a href="https://jerryc.me/posts/21cfbf15/" target="_blank" rel="noopener">《hexo-theme-butterfly安装文档》</a></p>
<h3 id="模板的front-matter"><a href="#模板的front-matter" class="headerlink" title="模板的front matter"></a>模板的front matter</h3><p>将以下front matter设置在/scaffolds/post.md中，就可以在<code>hexo new "title"</code>的时候自动加上这些注释了</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top:</span><br><span class="line">top_img: （除非特定需要，可以不写）</span><br><span class="line">comments： 是否显示评论（除非设置false,可以不写）</span><br><span class="line">cover:  缩略图</span><br><span class="line">toc:  是否显示toc （除非特定文章设置，可以不写）</span><br><span class="line">toc_number: 是否显示toc数字 （除非特定文章设置，可以不写）</span><br><span class="line">copyright: 是否显示版权 （除非特定文章设置，可以不写）</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">hide:</span><br><span class="line">---</span><br></pre></td></tr></tbody></table></figure>

<h3 id="音乐界面"><a href="#音乐界面" class="headerlink" title="音乐界面"></a>音乐界面</h3><p>想增加QQ音乐和网易云音乐的歌单，可以安装插件<a href="https://github.com/MoePlayer/hexo-tag-aplayer" target="_blank" rel="noopener">hexo-tag-aplayer</a>，需要在站点配置文件_config.yml中增加</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">aplayer:</span></span><br><span class="line">  <span class="attr">meting:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>
<p>如何获取歌单的id呢？网易云音乐把歌单分享出来，链接是 <a href="http://music.163.com/playlist?id=472885344&userid=124181546" target="_blank" rel="noopener">http://music.163.com/playlist?id=472885344&userid=124181546</a> ，那么id就是472885344。但是注意QQ音乐，只有网页版的分享链接才会有id号。</p>
<p>只需要在md文件中增加以下代码就可以实现歌单效果了</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">## 我的QQ音乐歌单</span></span><br><span class="line"><span class="string">{%</span> <span class="string">meting</span> <span class="string">"4274201226"</span> <span class="string">"tencent"</span> <span class="string">"playlist"</span> <span class="string">"mutex:true"</span> <span class="string">"listmaxheight:300px"</span> <span class="string">"preload:auto"</span> <span class="string">"theme:#ad7a86"</span><span class="string">%}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 围的网易云歌单</span></span><br><span class="line"><span class="string">{%</span> <span class="string">meting</span> <span class="string">"472885344"</span> <span class="string">"netease"</span> <span class="string">"playlist"</span> <span class="string">"mutex:true"</span> <span class="string">"listmaxheight:300px"</span> <span class="string">"preload:auto"</span> <span class="string">"theme:#ad7a86"</span><span class="string">%}</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="相册"><a href="#相册" class="headerlink" title="相册"></a>相册</h3><p>butterfly的Gallery相册会自动根据图片长度进行排版，书写也更加方便，与markdown格式一样。可根据需要插入到相应的md。</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">{% gallery %}</span><br><span class="line">markdown 图片格式</span><br><span class="line">{% endgallery %}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>站点配置文件_config.yml中，url那一栏填域名，注意只能填顶级域名，不能填二级域名</li>
<li>hexo升级到4.2之后，hexo_asset_image这个插件就出bug了，原来的作者不维护了，有人出了一个修复后的插件，叫hexo_asset_image_fixed。解决方法是：把原来的插件卸载，用命令<code>npm install hexo-asset-image-fixed</code>安装一下即可</li>
<li>网站文件更新后，访问网址并没有进行更新。这是因为cdn缓存了之前的文件，需要刷新cdn缓存，拿七牛举例，需要在cdn的刷新预期->刷新目录即可</li>
<li>想要用PWA的功能，manifest.json一定不能被渲染了，不然浏览器解析不出来。除了手册说的那些操作外，还需要在站点配置文件_config.yml中增加<code>skip_render: 'manifest.json'</code>。还需要注意的是，配置offline属性的时候，要把html去掉，否则他会把html文件缓存在本地，即使文章更新了也看不到。</li>
<li><code>hexo g -d</code>会漏掉service-worker.js，以后尽量用hexo g && hexo d</li>
</ol>
<h2 id="编辑器typora配置"><a href="#编辑器typora配置" class="headerlink" title="编辑器typora配置"></a>编辑器typora配置</h2><h3 id="图片设置"><a href="#图片设置" class="headerlink" title="图片设置"></a>图片设置</h3><p>要让图片复制到当前目录下同名文件夹下，需要修改<strong>偏好设置->图片插入->复制到指定目录./${filename}->对本地和网络图片应用以上规则->勾选优先使用相对路径</strong>。这样编辑器里面的图片，网站也可以正常显示了</p>
<h3 id="上传图床"><a href="#上传图床" class="headerlink" title="上传图床"></a>上传图床</h3><p>在0.9.84版本之后，typora支持图片自动上传到图床。</p>
<p>首先安装picgo软件，软件设置中把picgo-server打开。</p>
<p>在typora的偏好设置-> 图像 ->插入图片时，选项勾选到上传图片。</p>
<p>上传服务设定中，选择一个picgo的安装路径，验证通过即可。详细步骤可以参考<a href="https://www.antmoe.com/posts/c765ad20/index.html" target="_blank" rel="noopener">博客</a></p>
<p><img src="https://image.qinxing.xyz/image-20200430103340619.png" alt="image-20200430103340619"></p>
<p>由于网络中的图片不可以通过picgo直接上传，建议先保存在本地，然后手动上传。</p>
<p>picgo设置成时间戳重命名可以有效的保证图片的名称不会有重复的。</p>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p><code>ctrl + K</code> : 将复制的链接，链接到文字上</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>工具</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>镜头畸变的那些事</title>
    <url>/posts/b7ea425d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="（一）畸变"><a href="#（一）畸变" class="headerlink" title="（一）畸变"></a>（一）畸变</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对于理想光学系统，在一对共轭的物像平面上，像的放大率是一个常数。但是对于实际的光学系统，当视场较大或很大时，像的放大率就要随视场而异，这样就会使像相对于物体失去相似性。这种使像变形的成像缺陷称为畸变。</p>
<p><img src="https://image.qinxing.xyz/20200508170641.png" alt></p>
<p>畸变定义为实际像高与理想像高差，而在实际应用中经常将其与理想像高之比的百分数来表示畸变，称为相对畸变，即：</p>
<p><img src="https://image.qinxing.xyz/20200508170656.jpg" alt></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>通常来说镜头的畸变分为径向畸变和切向畸变两类。图像径向畸变是图像像素点以畸变中心为中心点,沿着径向产生的位置偏差,从而导致图像中所成的像发生形变。径向畸变分为桶形畸变和枕形畸变。</p>
<ul>
<li><p>桶形畸变（Barrel Distortion），又称桶形失真，是由镜头中透镜物理性能以及镜片组结构引起的成像画面呈桶形膨胀状的失真现象。我们在使用广角镜头或使用变焦镜头的广角端时，最容易察觉桶形失真现象。</p>
<p>下面是桶形畸变的真实场景，本该是垂直的房屋，却发生了变形。</p>
<p><img src="https://image.qinxing.xyz/20200508170801.jpg" alt="桶形畸变真实场景"></p>
</li>
<li><p>枕形畸变（Pincushion Distortion），又称枕形失真，它是由镜头引起的画面向中间“收缩”的现象。我们在使用长焦镜头或使用变焦镜头的长焦端时，最容易察觉枕形失真现象。</p>
</li>
</ul>
<p>下图是镜头畸变的对比示意图，第一幅图像是无畸变，第二幅图像是桶形畸变，第三幅图像是枕形畸变。</p>
<p><img src="https://image.qinxing.xyz/20200508170812.gif" alt="镜头畸变的对比示意图"></p>
<p>切向畸变是由于透镜本身与相机传感器平面（成像平面）或图像平面不平行而产生的，这种情况多是由于透镜被粘贴到镜头模组上的安装偏差导致。我们一般只考虑径向畸变。</p>
<p>下图是切向畸变的示意图。</p>
<p><img src="https://image.qinxing.xyz/20200508170817.png" alt="切向畸变"></p>
<h3 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h3><p>来源于<a href="https://blog.csdn.net/u014652390/article/details/50324347" target="_blank" rel="noopener">博客</a></p>
<p>畸变的常见原因是因为在镜头系统中引入光圈，光圈的位置决定了失真的类别与程度。如下图：</p>
<p><img src="https://image.qinxing.xyz/20200508170824.png" alt="畸变原因示意图"> </p>
<p>对于恒定的物体尺寸<em>y</em>，图像尺寸  <em>h</em>有所不同  。</p>
<p>像点的位置由主光线（实线）确定，主光线是穿过光圈中心的光线。当光圈位于透镜上时，也就是中间那幅图像，主光线穿过光学中心，并以与入射角相同的角度离开透镜。这样的系统不会使图像失真，因此没有畸变。</p>
<p>这个时候引入一个镜头常见的像差概念：慧差。</p>
<p><img src="https://image.qinxing.xyz/20200619001608.png" alt="球面镜的慧差"></p>
<p>球面镜的慧差，可以看到凸透镜边缘对光线的折射能力更强。</p>
<p>如图所示，当光圈在透镜前面或后面时，主光线并不经过透镜的中心，经过的是透镜的边缘，因此光线会被折射的更厉害一些。当光圈在镜头前面，光线折射更强后，所成的像距离光轴越近了，也就是像缩小了，就造成了桶形失真。复杂的镜头，例如后焦距广角镜头，往往就会出现桶形失真，因为前组镜头会充当后组的光圈。</p>
<p>当光圈在镜头后面，像的高度增加了，也就是放大了，就是枕形失真。远焦镜头的后组为负，会导致枕形失真。</p>
<p>下面这幅图片是对应的三维图，更加清晰的看出光圈与镜头的关系。</p>
<p><img src="https://image.qinxing.xyz/20200508170829.jpg" alt="畸变原因三维示意图"></p>
<p>这里可以引申一个问题，投影仪同样也是利用凸透镜，但是畸变就很小，而相机的畸变就相对比较大。因为它可以采用比较接近对称和比较紧凑的结构，镜头就很少有畸变。</p>
<p>简单的说，镜头畸变是由远离光圈的镜片的球面像差造成的。</p>
<p>如果镜头结构关于光圈基本对称，光圈前后的畸变互相抵消，不会有畸变。<br>如果镜头镜片都在光圈很近距离内，也不会有多少畸变。<br>如果远离光圈的镜片校正了球面像差，比如采用非球面镜，也不会产生畸变。<br>如果光圈放在物方焦平面和像方焦平面上，使主光线平行于光轴，也不会产生畸变（<a href="https://baike.baidu.com/item/%E8%BF%9C%E5%BF%83%E9%95%9C%E5%A4%B4/667556?fr=aladdin" target="_blank" rel="noopener">远心镜头</a>）。</p>
<h3 id="畸变矫正的方法"><a href="#畸变矫正的方法" class="headerlink" title="畸变矫正的方法"></a>畸变矫正的方法</h3><p>一般情况下，改善畸变有2种办法：</p>
<ol>
<li><p>一种是通过软件算法把镜头的畸变系数（也就是该镜头在当前距离下拍照时的变形特点）计算出来，一般常用的图像处理平台都包含有标定模块，像OpenCV、Halcon、CCAS等；</p>
<p>软件算法的畸变矫正是通过标定，把像的实际的位置和理想的位置做了一个映射，把图片处理成没有畸变的图片。</p>
<p>缺点是：</p>
<ol>
<li>降低清晰度</li>
<li>由于矫正后边角损失部分像素，会对图像进行裁剪，视场角减小</li>
<li>由于需要一直运行算法，增加功耗</li>
</ol>
<p>优点是：降低硬件成本</p>
</li>
<li><p>另一种就是通过光路设计，从镜头硬件本身消除畸变的影响，如<a href="https://baike.baidu.com/item/%E8%BF%9C%E5%BF%83%E9%95%9C%E5%A4%B4/667556?fr=aladdin" target="_blank" rel="noopener">双远心镜头</a>就是一种非常典型的“零畸变”镜头，利用非球面镜减小畸变等等。</p>
<p>优点是不会损失清晰度。不会裁剪图像，也就不会损失视场角，不需要软件处理，降低功耗。缺点是需要定制，比较昂贵。</p>
</li>
</ol>
<h2 id="（二）畸变计算方法"><a href="#（二）畸变计算方法" class="headerlink" title="（二）畸变计算方法"></a>（二）畸变计算方法</h2><p>这里遇到一个有趣的事情</p>
<p>为什么公安一所测出的畸变值远大于镜头手册的畸变值？答案是计算方法不同。</p>
<h3 id="光学畸变和tv畸变"><a href="#光学畸变和tv畸变" class="headerlink" title="光学畸变和tv畸变"></a>光学畸变和tv畸变</h3><p>先来了解一下光学畸变(也称几何畸变）和tv畸变，他们的计算方法如下图所示。实线是实际成的像，虚线是理想中的像。</p>
<p><img src="https://image.qinxing.xyz/20200520142318.png" alt="光学畸变和TV畸变示意图"></p>
<p>光学畸变和tv畸变是有换算关系的，以1080P16：9的CMOS为例，tv畸变是光学畸变的0.38倍。</p>
<p>tv畸变有两种计算方法，SMIA TV 畸变和ISO TV畸变：</p>
<p><img src="https://image.qinxing.xyz/20200520142325.png" alt="tv畸变计算方法"></p>
<p>SMIA TV Distortion = ( A-B )/B ; A = ( A1+A2 )/2</p>
<p>ISO TV Distortion = ( A-B )/(2 * B) ; A = ( A1+A2 )/2</p>
<p>所以，SMIA TV畸变=2*ISO TV畸变，上图的tv畸变指是ISO TV畸变。从公式可以看出，TV畸变是基于图像的高度和参考中心线的高度差异，如果需要计算图像水平方向的畸变，可以导入图像之前，先把图像旋转90°再分析。</p>
<h3 id="公安一所的畸变计算方法"><a href="#公安一所的畸变计算方法" class="headerlink" title="公安一所的畸变计算方法"></a>公安一所的畸变计算方法</h3><p>拍两条横向直线，让他们与图像的上下边相切。两条直线与图像左侧相交，得到两个坐标，计算出纵向像素差A1，同样的方法可以得到右侧的纵向像素差A2。这两条直线的最大距离，也就是中间的纵向像素差是c，畸变值就是(（A1+A2）/2 - B)/B</p>
<p>举例：</p>
<p><img src="https://image.qinxing.xyz/20200520142447.jpg" alt></p>
<p>用画图工具打开后，可以看到每个点的像素位置，先算出左侧的像素差（881-181=700），右侧的像素差（912-207=705），中间的像素差为1067，就可以计算出畸变值为（（700+705）/2 - 1067）/1067 = -0.3416）</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>同一款镜头，手册上的光学畸变只有21%，理论上的SMIA tv畸变只有16%，但是用一所的方法计算出来却有37%，这是为什么呢？</p>
<p><img src="https://image.qinxing.xyz/20200520142443.png" alt></p>
<p>如上图所示，红线的方法与tv畸变不同的是，它将上边线延长到了图像左右边框，计算出来的Δh明显比tv畸变大得多。一所测试的时候需要找到两条线与上下边框相切，而不是像tv畸变那种处于中间的一条线，因此一所方法得到的畸变值比红线的方法还要大，这样就能解释为什么一所的方法类似tv畸变，却又比tv畸变大得多。因此我们选择镜头的时候，需要先计算一下是否能够真的符合一所的标准。</p>
<h2 id="（三）畸变矫正算法"><a href="#（三）畸变矫正算法" class="headerlink" title="（三）畸变矫正算法"></a>（三）畸变矫正算法</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h3><p><img src="https://image.qinxing.xyz/20200520142509.png" alt="径向失真和切向失真对畸变的影响"></p>
<p>径向畸变的形成原因包括枕形畸变和桶形畸变等，可以用如下表达式来描述：</p>
<p><img src="https://image.qinxing.xyz/20200520142345.png" alt></p>
<p>公式里（x0，y0）是畸变点在成像仪上的原始位置，（x，y）是校正后新的位置。</p>
<p>注意这个公式，（x0，y0）是畸变的原图上像素点的位置；（x，y）是校正后输出图像上像素点的位置。</p>
<p>实现过程是，对输出图的点做遍历——以1080p的图像为例，从点（0,0）到点（1919,1079），一行一行的遍历——依次找到输出点（x, y）对应的原图点（x0, y0）的像素值，再将（x0, y0）的值赋给（x, y）。如果计算出来的对应的原图的点（x0, y0）不是整数，则用二次线性插值计算此点，然后赋值给（x, y）。</p>
<p>切向畸变又分为薄透镜畸变和离心畸变等，薄透镜畸变则是因为透镜存在一定的细微倾斜造成的；离心畸变的形成原因是镜头是由多个透镜组合而成的，而各个透镜的光轴不在同一条中心线上。切向畸变可以用如下数学表达式来描述：</p>
<p><img src="https://image.qinxing.xyz/20200520142348.png" alt></p>
<p>在引入镜头的畸变后，成像点从理想图像坐标系到真实图像坐标系的变换关系可以表示为：</p>
<p><img src="https://image.qinxing.xyz/20200520142351.png" alt></p>
<p>在目前的摄像机标定研究中,对镜头畸变考虑较多的是镜头径向畸变,而忽略了镜头的切向和薄棱镜等其它非线性畸变因素。</p>
<p>实际计算过程中，如果考虑太多高阶的畸变参数，会导致标定求解的不稳定。</p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h4 id="1-图像采集"><a href="#1-图像采集" class="headerlink" title="1. 图像采集"></a>1. 图像采集</h4><p>首先在opencv官网下载<a href="https://docs.opencv.org/2.4/_downloads/pattern.png" target="_blank" rel="noopener">棋盘格图像</a>进行打印。</p>
<h4 id="2-标定"><a href="#2-标定" class="headerlink" title="2. 标定"></a>2. 标定</h4><p>主要过程：用matlab工具箱进行标定，得到畸变矫正参数，并转换成opencv的参数，参考这个<a href="https://blog.csdn.net/youyudexiaoyanjing/article/details/79145898" target="_blank" rel="noopener">博客</a>的步骤</p>
<p>这里主要记录一下，matlab参数与opencv参数的转换：</p>
<ol>
<li><p>在使用opencv中的undistort进行畸变矫正时，需要使用8个参数即fc1, fc2, cc1, cc2, kc1, kc2, kc3, kc4; </p>
</li>
<li><p>MATLAB的参数有三个：</p>
<ul>
<li><p>RadialDistorion中的参数分别是：kc1,kc2,kc5(不常用) </p>
</li>
<li><p>TangentialDistortion中的参数分别是：kc3,kc4 </p>
</li>
<li><p>IntrinsicMatrix中的参数分别是： [[fc1,无用,0],[无用,fc2,0],[cc1,cc2,1]] </p>
</li>
</ul>
</li>
</ol>
<h4 id="3-畸变矫正"><a href="#3-畸变矫正" class="headerlink" title="3. 畸变矫正"></a>3. 畸变矫正</h4><p>利用undistort函数</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_calibration</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="comment"># 设置畸变校正的参数值</span></span><br><span class="line">    fc1 = <span class="number">1.107859597442719e+03</span></span><br><span class="line">    fc2 = <span class="number">1.110705995095509e+03</span></span><br><span class="line">    cc1 = <span class="number">9.701443009307349e+02</span></span><br><span class="line">    cc2 = <span class="number">5.619129804989138e+02</span></span><br><span class="line">    kc1 = <span class="number">-0.321797722411564</span></span><br><span class="line">    kc2 = <span class="number">0.075142421519568</span></span><br><span class="line">    kc3 = <span class="number">0</span></span><br><span class="line">    kc4 = <span class="number">0</span></span><br><span class="line">    cameraMatrix = np.array([</span><br><span class="line">                  [fc1, <span class="number">0</span>  , cc1],</span><br><span class="line">                  [<span class="number">0</span>  , fc2, cc2],</span><br><span class="line">                  [<span class="number">0</span>  , <span class="number">0</span>  , <span class="number">1</span>  ]</span><br><span class="line">    ])</span><br><span class="line">    distCoeffs = np.array([kc1, kc2, kc3, kc4])</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 获取视频中的一帧图像</span></span><br><span class="line">    vidcap = cv2.VideoCapture(video)</span><br><span class="line">    success, frame = vidcap.read() </span><br><span class="line">    imageSize = (frame.shape[<span class="number">1</span>],frame.shape[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># 畸变校正</span></span><br><span class="line">    frameCalibration = cv2.undistort(frame,cameraMatrix,distCoeffs)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 绘图</span></span><br><span class="line">    plt.subplot(<span class="number">211</span>)</span><br><span class="line">    plt.imshow(frame)</span><br><span class="line">    plt.subplot(<span class="number">212</span>)</span><br><span class="line">    plt.imshow(frameCalibration)</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="keyword">return</span> map1,map2</span><br></pre></td></tr></tbody></table></figure>

<h4 id="4-算法加速"><a href="#4-算法加速" class="headerlink" title="4. 算法加速"></a>4. 算法加速</h4><p>可以参考<a href="https://blog.csdn.net/hust_bochu_xuchao/article/details/54585200" target="_blank" rel="noopener">博客</a></p>
<p>主要思路是根据内参和畸变系数，建立了一个查找表（实际位置与理想位置的映射表）</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">test_calibration</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">	# 畸变校正</span><br><span class="line">    #根据内参和畸变系数，建立了一个查找表，map1 map2设置为全局变量，所以这个函数只需要运行一次就好，不需要重复计算查找表。</span><br><span class="line">    newCameraMatrix = cv2.getOptimalNewCameraMatrix(cameraMatrix, distCoeffs, imageSize, <span class="number">1</span>, imageSize, <span class="number">0</span>)</span><br><span class="line">    map1, map2 = cv2.initUndistortRectifyMap(cameraMatrix, distCoeffs, None, newCameraMatrix[<span class="number">0</span>], imageSize, cv2.CV_16SC2);</span><br><span class="line"></span><br><span class="line">    # 此函数根据map1 map2查找表进行畸变矫正，同一个镜头下的视频中map1 map2可以重复使用</span><br><span class="line">    frameCalibration = cv2.remap(frame, map1, map2, cv2.INTER_LINEAR);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> map1,map2</span><br></pre></td></tr></tbody></table></figure>

<h4 id="5-校正效果"><a href="#5-校正效果" class="headerlink" title="5. 校正效果"></a>5. 校正效果</h4><p>下图是没有经过裁剪的畸变校正效果</p>
<p><img src="https://image.qinxing.xyz/20200520142359.png" alt="没有经过裁剪的畸变校正效果"></p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>镜头</tag>
        <tag>畸变</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：两路摄像头偶尔不能同时切换日夜模式</title>
    <url>/posts/3e245786/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>两个摄像头对着同一个场景，从夜模式切到日模式，两个摄像头切换的速度不一致，有一个会慢一点，有的时候可以到5-10s</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li><input checked disabled type="checkbox"> 确定是日夜切换判断慢了还是日夜切换执行慢了</li>
<li><input checked disabled type="checkbox"> 如果是执行慢了就好说，如果是判断慢了，需要确定是两路摄像头一起切换才有问题，还是一路摄像头自己切换也会慢</li>
<li><input checked disabled type="checkbox"> 从AE打印上来看两路摄像头的增益有什么区别，尽量保证两个摄像头的增益一致</li>
<li><input checked disabled type="checkbox"> 查看代码逻辑，尤其注意是否因为上锁，进程是否一直被抢占，以及有一路日夜模式判断那么久</li>
</ul>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li>因为执行的过程，手动日夜切换和自动日夜切换是同一个过程，因此可以用手动模式下测试摄像头切换的速度。测试结果是并未出现某一路过慢的问题。</li>
<li>由于逻辑上切5次就会锁住，测试的时候经常锁住，非常不方便，而且影响判断，将锁住的逻辑去掉了</li>
<li>之前发现一个寄存器配置问题，会造成增益小一倍（至今都不知道是不是触发了这颗sensor的隐藏技能，这里记录一下，IMX290的0x3011寄存器手册上写的是应该赋值0x0A，结果弄成了0x20，反而提高了亮度）</li>
<li>把两颗摄像头的ISP参数都设置成一致，让唐佳琪和小范帮忙测试，原以为已经修复，其实并未</li>
<li>两路摄像头基本上是交替进行的，偶尔会有连续两次处理同一个摄像头的情况，不存在进程被抢占的问题</li>
<li>查看日夜模式判断，打开AE打印，找到原因</li>
</ol>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>夜切回日模式的条件是，sensor当前的增益要连续小于日夜切换的阈值五秒。由于日夜切换的阈值默认值很小，接近普通场景下的增益，容易不满足连续小于阈值五秒的条件。虽然两个摄像头对着同一个地方，但是稍微的一点偏差增益就不同，只要大于阈值，就会开始重新计时五秒，因此偶尔会出现有的快有的慢的现象。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>打开web界面的设置，日夜切换那一栏里面的灵敏度和日夜切换阈值都调大些。比如都设置到80，这样可以提高这个阈值，就不会出现这个问题了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><p>一开始主要是一直纠结于两路摄像头切换速度不一致，其实本质是一个摄像头切换时间不固定，第二步的思路没有执行下去，导致后面绕了很多的弯路。定好了思路就该去按照思路去一步一步测试，不然就像无头苍蝇一样乱碰，浪费时间。</p>
</li>
<li><p>对db值不敏感，6db是2倍，12db只有4倍，依次类推。</p>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>BUG</tag>
      </tags>
  </entry>
  <entry>
    <title>利用又拍云cdn加速github pages</title>
    <url>/posts/54ce21be/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>作者github上的博客是xiaoqinxing.github.io，如何cdn加速，并用域名<a href="http://www.qinxing.xyz">www.qinxing.xyz</a> 进行访问呢？</p>
<p>由于国外的cdn流量较贵，因此国外就用github的源站，拥有无限的空间和不错的速度。国内由于网速较慢，需要用cdn进行加速，然后将<a href="http://www.qinxing.xyz">www.qinxing.xyz</a> 与cdn的加速域名绑定即可。</p>
<p><img src="/posts/54ce21be/1583892494033.png" alt></p>
<p>至于为什么不用云存储呢，因为我希望上传一次代码，网站可以直接更新，相比云存储还需要把生成的代码传到云端，少了一步。同时也省了一笔费用。</p>
<h2 id="cdn加速"><a href="#cdn加速" class="headerlink" title="cdn加速"></a>cdn加速</h2><p>作者使用的是又拍云，由于加入又拍云联盟每个月可以有15G免费的HTTPS流量。这是活动的<a href="https://www.upyun.com/league" target="_blank" rel="noopener">网址</a>。</p>
<p>接下来进入正题。</p>
<p>首先，国内云服务商的域名都是需要备案的，我的域名是在阿里云备案的，一两天就通过了，十分的简单。</p>
<p>第二步，在又拍云创建一个cdn服务，源站就设置成xiaoqinxing.github.io，回源协议用https（github强制https)，源站证书校验关闭。使用又拍云的朋友注意了，回源管理中的<strong>回源Host一定要再填一遍源站域名</strong>，被坑了好久，这里还是xiaoqinxing.github.io。</p>
<p>第三步，绑定域名，首先将域名<a href="http://www.qinxing.xyz">www.qinxing.xyz</a> 绑定在这个cdn上，又拍云会生成一个CNAME名称（我理解中这个是cdn服务器的域名，CNAME就是让一个域名跳转到另外一个域名上）。其次在github.io的设置中设置自定义域名<a href="http://www.qinxing.xyz">www.qinxing.xyz</a> </p>
<p>第四步，域名解析，这个域名解析是在你的域名服务商那里完成的，比如说就拿阿里云来说，创建两条<a href="http://www.qinxing.xyz">www.qinxing.xyz</a> 的域名解析记录，记录类型都是CNAME，第一条记录的解析线路是默认，记录值是又拍云cdn的CNAME名称。第二条的解析线路是境外，记录值是源站域名xiaoqinxing.github.io。</p>
<p>第五步，申请证书，开启https服务的时候需要申请SSL证书，这个可以在又拍云里面申请免费的SSL证书。申请好了之后再https配置中，勾选https访问和强制HTTPS访问。</p>
<p><img src="/posts/54ce21be/1583892988361.png" alt></p>
<p>第六步，刷新缓存查看是否生效，由于cdn相当于把源站的内容在国内缓存了好多份，想要实时生效，需要刷新cdn缓存。另外浏览器也会把原来的网站缓存一份，浏览器里面直接刷新不出来不代表真的没有生效。拿chrome浏览器举例，刷新的时候要<code>ctrl + F5</code>，才能刷新缓存。</p>
<p>最后，如果有什么问题，可以提交工单，询求技术支持，我的问题就是在他们的帮助下解决的，感谢。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>在GitHub Pages设置自定义域名之后，发现每次hexo d 后都会失效，又要重新设置</p>
<p>回：只要在source 目录添加一个新文件CNAME就好</p>
<p>CNAME –不带任何后缀，这就是全称，里面写的是你的域名</p>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>工具</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>cdn</tag>
      </tags>
  </entry>
  <entry>
    <title>如何安慰人</title>
    <url>/posts/8bf47f5a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>恰当的安慰一个人，就是去理解对方的理解和需要。恰当的安慰一个人，就是去理解一个人的情绪和感受。相反，不恰当的安慰就是把自己对一个事情的看法和感受，强加到一个痛苦的人身上，然后让对方身心更加痛苦。</p>
</blockquote>
<h2 id="安慰人的关键"><a href="#安慰人的关键" class="headerlink" title="安慰人的关键"></a>安慰人的关键</h2><p>当朋友心情不好时，我们该如何恰当的安慰一个人？</p>
<ul>
<li><strong>理解Ta的感受、承认Ta的痛苦</strong></li>
<li><strong>不“期望”Ta快快好起来</strong></li>
<li><strong>鼓励Ta表达真实的感受</strong></li>
</ul>
<p>通常，我们特别擅于给朋友打些鸡血，说：你看你拥有这些拥有那些，你还有这么多好的东东，不要难过了；说其实这不过是小事一桩，没有什么大不了的，你睡一觉明天就好了。</p>
<p>以前沟通学上老师教过，<strong>倾听这个技能并不像想象中的那么容易。倾听是个体力活。</strong>作为一个男生，这项技能点是残缺的。当他人表述的时候，你得放弃建议的意愿，你得放弃你的价值判断，你得放弃对于倾诉者本身的价值判断，你得带入她的情感而不过分表达，太他妈难了。举个例子，比如闺蜜的男朋友出轨了，找你倾述。你怎么表达算是合适的安慰呢？<br>1.天杀的，不要怕，老娘现在就去剁了他。然后拿起菜刀就出门了。（吓得你闺蜜生拉硬拽把你拉回了家，摸了摸胸口，哦哟，我的小心脏啊。）<br>2.天涯何处无芳草，像你这么优秀的女人大把的男人可以选呢。（闺蜜：选来选去都是渣男。）<br>3.妈的，老娘前前男友也出轨，前男友是个gay，你说人生怎么这么不幸呢？哭的稀里哗啦，（闺蜜反过来安慰你了。）<br>4.那他为什么会出轨呢？（闺蜜：你想说我，不温柔，还长得丑！你：我只是在帮你分析找原因。）<br>5.我早就觉得你男朋友是个人渣了。（闺蜜：你他妈才人渣呢！你：不，我是在帮你出气啊！）<br>6.我带你去吃肉，这事就这么过去了。（闺蜜：你去吧，我不饿。）<br>7.我理解你，你一定很痛苦吧。（闺蜜：你理解个屁，你是在同情我，怜悯我吗？）<br>8.他出轨肯定有他出轨的理由。（闺蜜拿起菜刀把你剁了，虽然你说的是事实。）<br>9.那我多陪陪你吧。（陪伴肯定是有效的，但是对话的过程怎么处理呢？一不小心，又走上了12345678）<br>那理论听了那么多，我到底怎么说比较合适呢？<br><strong>重复她所说的话，让她自然而流畅的倾述。（作弊技能，但具有一定的通用性。）</strong><br><strong>重复她所说的话，让她自然而流畅的倾述。</strong></p>
<p><strong>重复她所说的话，让她自然而流畅的倾述。</strong></p>
<p>闺蜜：我男朋友出轨了。</p>
<p>你：出轨了？</p>
<p>闺蜜：我看见他和谁谁谁一起牵着手逛街。</p>
<p>你：一起逛街？</p>
<p>。</p>
<p>。</p>
<p>。</p>
<p>过程中还可以加入一些语气词，嗯，啊。</p>
<p>当然这是一个作弊技能，更多的时候，还是要合适引导倾述对象的表述，和适当的支持，但这种支持最好不涉及价值观判断，建议等等。而一旦开始表述以后，持续不断的负面情绪也会同时感染你，你得和倾述者同时承担这些负面情绪，所以是很累的。</p>
<p>（不要建议，所有的话要倾述者自己说出来才有力量。是让她表达，你只是听，呵呵，是不是感觉被捆绑一样的不自由，那么多意见建议，好想说对不对，哈哈哈哈。）</p>
<p>总的来说，就是理解她，不把自己对这件事情的看法强行灌输给他。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>但是如果这是一个对自己很重要的人，再做一件错的事情呢或者总是抱怨同一件事情呢？</p>
<p>我觉得还是要提供解决方法，或者提出有帮助的办法，不是为了安慰而安慰，不去解决根本问题，问题永远不会结束。</p>
<p>关键还是这个提供解决方法的时机，不要一个劲的埋怨对方做的不对，这只会让他更加陷入情绪之中，也没有人会那么理性，跟别谈听不听得进去了。要等他缓和情绪后，再平静的提出解决方法，或许更加有效。</p>
</body></html>]]></content>
      <categories>
        <category>生活</category>
        <category>思考</category>
      </categories>
      <tags>
        <tag>围围</tag>
        <tag>宝藏</tag>
      </tags>
  </entry>
  <entry>
    <title>天线科普</title>
    <url>/posts/806ebe91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>以下文章来源于<a href="https://mp.weixin.qq.com/s/HTSM6jpzfO62CLS19G_iow" target="_blank" rel="noopener">无线深海</a>，作者蜉蝣采采</p>
</blockquote>
<blockquote>
<p>通信天线，最经常和手机直接眉目传情的就是这货。天线之所以能高速地传递信息，就是因为它能把载有信息的电磁波发射到空气中，以光速进行传播，最终抵达接收天线。如下图所示，相对于理想的点辐射源和半波振子，天线在可以把能量聚集在主瓣方向，能把电磁波发送地更远，相当于在主瓣方向上增强了。半功率角越窄，主瓣方向信号传播地越远，增益就越高。第二就是机械下倾这种调整方式太过简单粗暴，而天线垂直分量和水平分量的幅值是不变的，因此会导致覆盖方向图被强行压扁，产生畸变。</p>
</blockquote>
<h2 id="什么是天线？"><a href="#什么是天线？" class="headerlink" title="什么是天线？"></a>什么是天线？</h2><p><strong>基站的天线，比基站本身更为醒目</strong>。“天线”这两个字，也不像它们看上去那样简单。但是，蜉蝣君努力把它说得简单有趣。</p>
<p><strong>看完本篇关于天线的介绍，你将会了解：</strong></p>
<p><strong>①</strong> 到底什么是天线？</p>
<p><strong>②</strong> 天线是怎样发射信号的？</p>
<p><strong>③</strong> 天线有哪些关键指标？</p>
<h3 id="1-揭开天线的面纱"><a href="#1-揭开天线的面纱" class="headerlink" title="1. 揭开天线的面纱"></a><strong>1. 揭开天线的面纱</strong></h3><p>众所周知，天线是基站和手机发射信号用的。</p>
<p>天线这个词的英文是Antenna，原意为触须的意思。触须就是昆虫头顶上的两根长长的细丝，可别小瞧这样不起眼的玩意儿，昆虫正是由这些触角发送的各种化学信号来传递各种社交信息的。</p>
<p><img src="https://image.qinxing.xyz/20200322213538.png" alt="触须"></p>
<p>与此类似，在人类世界里，无线通信也是通过天线来传递信息的，只不过传递的是承载着有用信息的电磁波。下图就是手机和基站之间相互通信的一个示例。</p>
<p><img src="https://image.qinxing.xyz/20200322213649.png" alt></p>
<p>如果你抬起头仔细端详基站的话，会发现在铁塔的最上端，有一些板状的东西，这就是本文的主角：通信天线，最经常和手机直接眉目传情的就是这货。</p>
<p><img src="https://image.qinxing.xyz/20200322213820.png" alt></p>
<p>这种天线叫做定向天线，顾名思义，就是信号发射是有方向的。如果它正面对着你，那信号刚刚的；如果站在了它的背后，那对不起，不在服务区！</p>
<p>目前，绝大部分的基站上都用的是定向天线，一般需要三幅天线来完成360度覆盖。要揭开这货神秘的面纱，就要拆开来看看内部到底装了些什么东西。</p>
<p><img src="https://image.qinxing.xyz/20200322220442.png" alt></p>
<p>内部空荡荡的，结构并不复杂嘛，就是由振子，反射板，馈电网络和天线罩组成。这些内部结构都是做什么的，怎样就实现了定向发射接收信号的功能呢？</p>
<p>这一切就要从电磁波来说起了。</p>
<h3 id="2-剥开天线的外衣"><a href="#2-剥开天线的外衣" class="headerlink" title="2. 剥开天线的外衣"></a><strong>2. 剥开天线的外衣</strong></h3><p>天线之所以能高速地传递信息，就是因为它能把载有信息的电磁波发射到空气中，以光速进行传播，最终抵达接收天线。</p>
<p>这就好像用高速列车运送乘客一样，如果把信息比作乘客，那么运送乘客的工具：高速列车就是电磁波，而天线就相当于车站，负责管理调度电磁波的发送。</p>
<p>那么，什么是电磁波呢？</p>
<p>科学家对电和磁这两种神秘力量研究了上百年，最终英国的麦克斯韦提出：电流能在其周边产生电场，变化的电场产生磁场，变化的磁场又产生电场。最终这个理论被赫兹的实验所证实。</p>
<p>电磁场在这样的周期性变换中，电磁波就辐射出来，向空间传播。详情见文章：“<a href="http://mp.weixin.qq.com/s?__biz=MzU3NzM4OTI1OA==&mid=2247484072&idx=1&sn=466f3e43634ec57a9304fb5eea5a0f77&chksm=fd04150dca739c1b9001b99c7b77fd4c579e4d82f358fb9b992afd5ae42e5fc983295d2afc03&scene=21#wechat_redirect" target="_blank" rel="noopener">电磁波看不见摸不着，这个年轻人的奇思妙想改变了世界</a>”。</p>
<p><img src="https://image.qinxing.xyz/20200322220500.png" alt></p>
<p>如上图所示，红色的线表示电场，蓝色的线表示磁场，电磁波的传播方向同时垂直于电场和磁场的方向。</p>
<p>那么，天线是怎样把这些电磁波发送出去的呢？看完下图就明白了。</p>
<p><img src="https://image.qinxing.xyz/20200322220517.png" alt></p>
<p>上面这种产生电磁波的这两根导线就叫做“振子”。一般情况下，振子的大小在半个波长的时候效果最好，所以也经常被称作“半波振子”。</p>
<p><img src="https://image.qinxing.xyz/20200322221522.png" alt></p>
<p>有了振子，电磁波就可以源源不断地往外发射了。如下图所示。</p>
<p><img src="https://image.qinxing.xyz/20200322221538.png" alt></p>
<p>真实的振子长下图这样。</p>
<p><img src="https://image.qinxing.xyz/20200322221716.png" alt></p>
<p>半波振子把电磁波源源不断地向空间传播，但信号强度在空间上的分布却并不均匀，像是轮胎一样的环形。水平方向信号强，但垂直方向很弱。</p>
<p><img src="https://image.qinxing.xyz/20200322221727.png" alt></p>
<p>实际上，我们基站的覆盖需要在水平方向上更远一些，毕竟需要打电话的人都在地上；垂直方向就到高空了，高空中也没啥需要边飞边刷抖音的人（航线覆盖是另外一个话题，后续再讲）。</p>
<p>因此，在电磁波能量的发射上，尽管半波振子的垂直方向的能量已经比较弱了，但还需要进一步地增强水平方向，把垂直方向再削弱一些。</p>
<p><img src="https://image.qinxing.xyz/20200322221738.png" alt></p>
<p>根据能量守恒原理，能量既不会增加也不会减少，如果要提高水平方向的发射能量，就要削弱垂直方向的能量。因此就只有把标准半波阵子的能量辐射方向图拍扁了，如下图所示。</p>
<p><img src="https://image.qinxing.xyz/20200322221746.png" alt></p>
<p>那么怎样拍扁呢？答案就是增加半波振子的数量。多个振子的发射在中心汇聚起来，边缘的能量得到了削弱，就实现了拍扁辐射方向，集中水平方向能量的目的。</p>
<p><img src="https://image.qinxing.xyz/20200322221757.png" alt></p>
<p>在一般的宏基站系统中，定向天线的使用最为普遍。一般情况下，一个基站被划分为3个扇区，用3个天线来覆盖，每个天线覆盖120度的范围。</p>
<p><img src="https://image.qinxing.xyz/20200322221806.png" alt></p>
<p>从上图我们可以清楚地看出，这个基站由三个扇区组成，用了3个射频单元，也就需要三副定向天线来实现。</p>
<p><img src="https://image.qinxing.xyz/20200322221822.png" alt></p>
<p>上面这个示意图更为直观一些。基站位于圆心，把一个大饼分为3份，每份都是一个120度的扇形区域，因此叫做三扇区。</p>
<p>那么，天线是怎样实现电磁波的定向发射呢？</p>
<p>这当然难不倒聪明的设计师。给振子增加反射板，把本该向另外一边的辐射的信号反射回来不就行了么？</p>
<p><img src="https://image.qinxing.xyz/20200322221901.png" alt></p>
<p>就这样增加振子让电磁波在水平方向传得更远，再增加反射板控制方向，经过这么两下折腾，定向天线的雏形诞生，电磁波的发射方向变成了下图这样。</p>
<p><img src="https://image.qinxing.xyz/20200322221913.png" alt></p>
<p>水平方的主瓣向发射地远远地，但垂直方向产生了上旁瓣和下旁瓣，同时由于反射不完全，后面还有个尾巴，称为后瓣。</p>
<p>到了这里，对天线的最重要的指标：“增益”的解释就水到渠成了。</p>
<p>顾名思义，增益就是指天线能把信号增强。按理说天线是不需要电源的，只是把传给它的电磁波发射出去，怎么又会有“增益呢”？</p>
<p>其实，有没有“增益”，关键看跟谁比，怎么比。</p>
<p>如下图所示，相对于理想的点辐射源和半波振子，天线在可以把能量聚集在主瓣方向，能把电磁波发送地更远，相当于在主瓣方向上增强了。也就是说，所谓增益是在某个方向上相对于点辐射源或者半波振子来说的。</p>
<p><img src="https://image.qinxing.xyz/20200322222205.png" alt></p>
<p>那么，到底怎么衡量天线主波瓣的覆盖范围和增益呢？这就需要再引入一个“波束宽度”的概念。我们把主瓣上中心线两侧电磁波强度衰减到一半时的范围称为波束宽度。</p>
<p>因为强度衰减一半，也就是3dB，所以波束宽度也叫“半功率角”，或者“3dB功率角”。</p>
<p><img src="https://image.qinxing.xyz/20200322222219.png" alt></p>
<p>常见的天线半功率角以60°居多，也有窄一些的33°天线。半功率角越窄，主瓣方向信号传播地越远，增益就越高。</p>
<p>下来我们把天线的水平方向图和垂直方向图结合起来，就得到了立体图辐射图，看起来直观多了。</p>
<p><img src="https://image.qinxing.xyz/20200322222230.png" alt></p>
<p>显然，后瓣的存在破坏了定向天线的方向性，是要极力缩小的。前后波瓣之间的能量比值叫做“前后比”，这个值越大越好，是天线的重要指标。</p>
<p>上旁瓣的宝贵的功率白白地发射向了天空，也是不小的浪费，所以在设计定向天线时要尽量把上旁瓣抑制到最小。</p>
<p>另外，主瓣和下旁瓣之间有一些空洞，也称为下部零陷，导致离天线较近的地方信号不好，在设计天线的时候要尽量减少这些空洞，称作“零点填充”。</p>
<h3 id="3-与天线坦诚相见"><a href="#3-与天线坦诚相见" class="headerlink" title="3. 与天线坦诚相见"></a><strong>3. 与天线坦诚相见</strong></h3><p>下面再说天线的另一个重要概念：<strong>极化</strong>。</p>
<p>前面已经提到过，电磁波的传播本质上是电磁场的传播，而电场是有方向的。</p>
<p>如果电场方向垂直于地面，我们称它为垂直极化波。同理，平行于地面，就是水平极化波。</p>
<p>如果电场的方向和地面成45°夹角，我们就其称为±45°极化。</p>
<p><img src="https://image.qinxing.xyz/20200322222243.png" alt></p>
<p>由于电磁波的特性，决定了水平极化传播的信号在贴近地面时会在大地表面产生极化电流，从而使电场信号迅速衰减，而垂直极化方式则不易产生极化电流，从而避免了能量的大幅衰减，保证了信号的有效传播。</p>
<p>作为优化方案，现在主流的天线都是采用的±45°两种极化方式叠加起来，由两个振子在一个单元内形成两个正交的极化波，被称为双极化。这种实现方式在保证性能的同时，也使得天线的集成度大大提高。</p>
<p><img src="https://image.qinxing.xyz/20200322222253.png" alt> </p>
<p>这就是天线示意图里面喜欢画上若干个叉叉的原因，这些叉叉既形象地表示了极化方向，也表示了振子的数量。</p>
<p><img src="https://image.qinxing.xyz/20200322222305.png" alt></p>
<p>有了高增益的定向天线，直接挂在塔上就可以了吗？</p>
<p>显然，挂地低了建筑物遮挡太多，不行；挂高了，空中又没人，白白浪费信号，而且让信号传得太远的话，基站还可以勉强接受，但手机的发射功率太小，发了基站也收不到。</p>
<p>因此，这天线得对着有人的地面上发射信号，覆盖的范围还得控制住。这就需要把天线下倾一个角度，像路灯一样，每根天线各自负责各自区域的覆盖。</p>
<p><img src="https://image.qinxing.xyz/20200322222321.png" alt></p>
<p>这就引入了天线<strong>下倾角</strong>的概念。</p>
<p>所有天线都在其安装支架上设有带角度刻度的旋钮，通过扭动旋钮来控制支架的机械运动，就可以调节下倾角了。所以，通过这种方式调整下倾角又叫机械下倾。</p>
<p><img src="https://image.qinxing.xyz/20200322222330.png" alt></p>
<p>但这种方式有两个明显的弊端。</p>
<p>第一就是麻烦。为了做网络优化调整个角度，就需要工程师上站爬塔，实际效果咋样还不好说，实在是不方便，成本高。</p>
<p><img src="https://image.qinxing.xyz/20200322222340.png" alt></p>
<p>第二就是机械下倾这种调整方式太过简单粗暴，而天线垂直分量和水平分量的幅值是不变的，因此会导致覆盖方向图被强行压扁，产生畸变。</p>
<p><img src="https://image.qinxing.xyz/20200322222349.png" alt></p>
<p>费了这么大劲，调整前后的覆盖完全变了，很难达到预期的效果，而且还由于后瓣的上翘导致对其他基站的干扰也增加了，因此机械下倾角只能小幅调整。</p>
<p>那么，有没有更好的办法呢？</p>
<p>办法还真有，就是使用电子下倾。电子下倾的原理是通过改变共线阵天线振子的相位，改变垂直分量和水平分量的幅值大小，改变合成分量场强强度，从而使天线的垂直方向图下倾。</p>
<p><img src="https://image.qinxing.xyz/20200322222359.png" alt></p>
<p>也就是说，电子下倾无需真地让天线倾斜，只需要工程师在电脑前，点点鼠标，用软件调整就可以了。而且，电子下倾也不会引起辐射方向图的畸变。</p>
<p><img src="https://image.qinxing.xyz/20200322222626.png" alt></p>
<p>电子下倾的简单，方便也不是凭空而来，而是经过了业界的共同努力才实现的。</p>
<p>2001年，几个天线厂家凑在一起，成立了一个叫做AISG ( 天线接口标准组Antenna Interface Standards Group )的组织，想要把电调天线的接口标准化。</p>
<p><img src="https://image.qinxing.xyz/20200322222638.png" alt></p>
<p>截止目前，已经有了两个版本的协议：AISG 1.0和AISG 2.0。</p>
<p>有了这两个协议，即使天线和基站是由不同厂家的生产的，只要它们都遵从相同的AISG协议，它们之间就能互相传递天线下倾角的控制信息，实现下倾角的远程调整。</p>
<p><img src="https://image.qinxing.xyz/20200322222649.png" alt></p>
<p>随着AISG协议的向后演进，不但垂直方向的下倾角可以远程调整，连水平方向的方位角，还有主波瓣的宽度和增益都可以远程调整了。</p>
<p>并且，由于各运营商的无线频段越来越多，加之4G的MIMO等技术对天线端口数量的要求剧增，天线也逐渐由单频双端口向多频多端口演进。</p>
<p>天线的原理看似简单，但对性能精益求精的追求却没有止境。本文到此，也只是定性地描述了基站的基本知识，至于里面更深的奥妙，如何更好地支持向5G的演进，一波波的通信人还在上下而求索。</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>电子</category>
      </categories>
      <tags>
        <tag>电子电路</tag>
      </tags>
  </entry>
  <entry>
    <title>相机成像原理之镜头篇</title>
    <url>/posts/b31d381e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="问题1：相机是如何成像的？"><a href="#问题1：相机是如何成像的？" class="headerlink" title="问题1：相机是如何成像的？"></a>问题1：相机是如何成像的？</h2><p>我们可以把相机的成像简单的抽象成下图：</p>
<p><img src="https://image.qinxing.xyz/20200722144351.png" alt="凸透镜成像"></p>
<p>由凸透镜成像原理，我们可以知道当物距大于2倍<a href="https://baike.baidu.com/item/%E7%84%A6%E8%B7%9D" target="_blank" rel="noopener">焦距</a>时，则像距在1倍焦距和2倍焦距之间，成倒立、缩小的实像。此时像距小于物距，像比物小，物像异侧。设 f=OB 表示透镜的焦距，m=OC 为像距，n=AO 为物距，有：</p>
<p><img src="https://image.qinxing.xyz/20200722144355.png" alt></p>
<p>一般地，由于物距远大于焦距，即 n>>f，所以 m≈f，此时可以用小孔模型代替透镜成像。</p>
<p>用数学方式表示成像模型：<a href="https://zhuanlan.zhihu.com/p/23090593" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23090593</a></p>
<h2 id="问题2：-对焦和变焦有什么区别？"><a href="#问题2：-对焦和变焦有什么区别？" class="headerlink" title="问题2： 对焦和变焦有什么区别？"></a>问题2： 对焦和变焦有什么区别？</h2><h3 id="对焦"><a href="#对焦" class="headerlink" title="对焦"></a>对焦</h3><p>对焦（聚焦）就是把镜片移动到适合的位置，其要实现清晰成像，则物体应当在两倍焦距之外，像平面在一倍至两倍焦距之间，这样就可以成倒立缩小的图像，这是照相机的原理。简单的来说，就是把成的像准确的落在sensor（camera传感器）上。对焦有两种：自动对焦，手动对焦。</p>
<p><img src="https://image.qinxing.xyz/20200722144358.png" alt></p>
<p>虚线是sensor的位置，当虚线落在像的位置上就是对焦完成。</p>
<p><img src="https://image.qinxing.xyz/20200722144400.png" alt></p>
<p>左图对焦清楚，而右图没有对焦清楚，sensor在像的左边或者右边都会导致右边的效果。</p>
<h3 id="变焦"><a href="#变焦" class="headerlink" title="变焦"></a>变焦</h3><p>变焦有光学变焦和数字变焦。</p>
<p><strong>光学变焦：</strong>就是改变透镜的焦距。由于改变了焦距，根据上面的结论，焦距改变了，视场角也就变了，就可以实现拉近拉远的功能。</p>
<p><strong>数码变焦：</strong>是通过数码相机的处理器，把图片内的每个像素面积增大，从而达到放大的目的，当前变焦过的时图像就会出现失真，因为放大的过程会对图像进程插值。</p>
<p><img src="https://image.qinxing.xyz/20200722144403.png" alt></p>
<p>当焦距越大，成的像也就越大，像距也就越远。</p>
<p>反之，焦距越小，成的像也就越小，像距越小。</p>
<p>同一个物体，成的像越小，sensor的面积一样的情况下，可以看到的东西就越多，视野也就越大，因此焦距越小，视场角也就越大。</p>
<table>
<thead>
<tr>
<th>焦距</th>
<th>像</th>
<th>视场角（视野）</th>
</tr>
</thead>
<tbody><tr>
<td>长</td>
<td>大</td>
<td>小</td>
</tr>
<tr>
<td>短</td>
<td>小</td>
<td>大</td>
</tr>
</tbody></table>
<p>下图是将焦距拉长后，图像放大的效果<br><img src="https://image.qinxing.xyz/20200722144406.png" alt="长焦的放大效果"></p>
<h2 id="问题3：-景深是什么？又和什么有关？"><a href="#问题3：-景深是什么？又和什么有关？" class="headerlink" title="问题3： 景深是什么？又和什么有关？"></a>问题3： 景深是什么？又和什么有关？</h2><p>相机景深：其指的是在某个物距之间，还能够清晰成像的距离，如下图：</p>
<p><img src="https://image.qinxing.xyz/20200722144413.png" alt></p>
<p>如果sensor刚好在像距的位置上，物体的一个点，成的像也就是一个点。如果sensor在像距的前面或者后面，这个点也就成了一个圆，专业术语叫弥散圆。当这个圆大到一定的程度的时候，照片也就糊了。</p>
<p> <img src="https://image.qinxing.xyz/20200722144421.png" alt></p>
<h3 id="景深三要素"><a href="#景深三要素" class="headerlink" title="景深三要素"></a>景深三要素</h3><h4 id="光圈"><a href="#光圈" class="headerlink" title="光圈"></a>光圈</h4><p>光圈就是用来控制光线透过镜头的一个装置，光圈越大，进光量越多。</p>
<p>光圈值，是镜头的<a href="https://baike.baidu.com/item/%E7%84%A6%E8%B7%9D/1880759" target="_blank" rel="noopener">焦距</a>/镜头通光直径得出的相对值（相对孔径的倒数），光圈值越小，光圈越大。相同光圈值，sensor表面的照度相同。</p>
<p>光圈越大，景深越小。</p>
<p><img src="https://image.qinxing.xyz/20200722144425.png" alt></p>
<p>如图，当光圈减小，虚线位置的弥散圈也在减小。弥散圈越小，成的像就越清晰。原来看不清楚的物体，弥散圈变小了，就能看清了，景深就变大了。</p>
<p>夜间摄影的时候，增大光圈可以提高进光量，提升图像质量，但是大光圈也会导致景深太小，这个时候就需要两者权衡。拍人像的时候，我们又会要求景深小，这样就有背景虚化的效果，这个时候就需要大光圈。</p>
<h4 id="物距"><a href="#物距" class="headerlink" title="物距"></a>物距</h4><p>物体越近，景深越小</p>
<p><img src="https://image.qinxing.xyz/20200722144430.png" alt></p>
<p>物体123是等距的，他们成的像分别是像123，但是像的位置不是等距的。由于sensor聚焦好之后只能在一个位置上，在这个位置上能看到更多的物体，就是景深大。物体1比较远，我们将sensor聚焦在像1上，像2距离像1很近，弥散圈很小，很容易看清楚物体2。相反的，物体3比较近，我们将sensor聚焦在像3上，像2离像3比较远，弥散圈大，不容易看清楚物体2。所以从图中可以很容易的看出，物体越近，景深越小。</p>
<h4 id="焦距"><a href="#焦距" class="headerlink" title="焦距"></a>焦距</h4><p>焦距越长，景深越小。</p>
<p><img src="https://image.qinxing.xyz/20200722144433.png" alt></p>
<p>两个物体1和2，焦距fa < fb。当焦距为fa，成的像分别是1a和2a，当焦距为fb时，成的像分别为1b和2b。当焦距比较小，为fa的时候，可以很明显的看到像1a和像1b距离很近，由于sensor只能固定在一个位置，更容易同时看清两个物体。因此焦距越短，景深越大。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><table>
<thead>
<tr>
<th>景深</th>
<th>大</th>
<th>小</th>
</tr>
</thead>
<tbody><tr>
<td>光圈</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>物距</td>
<td>远</td>
<td>近</td>
</tr>
<tr>
<td>焦距</td>
<td>短</td>
<td>长</td>
</tr>
</tbody></table>
<h2 id="问题4：镜头对图像质量的影响"><a href="#问题4：镜头对图像质量的影响" class="headerlink" title="问题4：镜头对图像质量的影响"></a>问题4：镜头对图像质量的影响</h2><h3 id="（一）暗角"><a href="#（一）暗角" class="headerlink" title="（一）暗角"></a>（一）暗角</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>对着亮度均匀景物，图像画面四角有变暗的现象，叫做“失光”或“暗角”。暗角对于任何镜头都不可避免，这是由于镜头对于光学折射不均匀。</p>
<p><img src="https://image.qinxing.xyz/20200722144439.png" alt="chrom/color shading 原因"></p>
<h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><p>a. luma shading</p>
<p>由于Lens的光学特性，Sensor影像区的边缘区域接收的光强比中心小，所造成的中心和四角亮度不一致的现象。</p>
<p>b. chrom/color shading：<br> 由于各种颜色的波长不同，经过了透镜的折射，折射的角度也不一样，因此会造成color shading的现象<br><img src="https://image.qinxing.xyz/20200722144442.png" alt="暗角现象"></p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol>
<li><p>sensor和镜头的 <a href="https://blog.csdn.net/weixin_39839293/article/details/82118991" target="_blank" rel="noopener">CRA</a>需要匹配</p>
</li>
<li><p>镜头阴影校正（Lens Shading Correction）</p>
</li>
</ol>
<p>lens shading的校正是分别对于bayer的四个通道进行校正，每个通道的校正过程是相对独立的过程。</p>
<p><img src="https://image.qinxing.xyz/20200722144445.png" alt="暗角矫正"></p>
<h3 id="（二）炫光"><a href="#（二）炫光" class="headerlink" title="（二）炫光"></a>（二）炫光</h3><h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><p>入射光线进入摄像头模组后多次反射造成的</p>
<p>有兴趣的可以看一下：<a href="https://wenku.baidu.com/view/8e119588fab069dc502201f4.html?from=search" target="_blank" rel="noopener">https://wenku.baidu.com/view/8e119588fab069dc502201f4.html?from=search</a></p>
<p><img src="https://image.qinxing.xyz/20200722144450.png" alt></p>
<h4 id="炫光现象"><a href="#炫光现象" class="headerlink" title="炫光现象"></a>炫光现象</h4><p><img src="https://image.qinxing.xyz/20200722144453.png" alt="眩光现象"></p>
<h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>1.加镜头罩</p>
<p>2.镀AR增透膜，减少反射</p>
<p>3.使用蓝玻璃IR滤光片，减少IR-cut的反射</p>
<p><img src="https://image.qinxing.xyz/20200722144457.png" alt="使用蓝玻璃IR-CUT示意图"></p>
<h3 id="（三）畸变"><a href="#（三）畸变" class="headerlink" title="（三）畸变"></a>（三）畸变</h3><h4 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h4><p>镜头畸变是由远离光圈的镜片的球面像差造成的。</p>
<h4 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h4><p><img src="https://image.qinxing.xyz/20200722144459.png" alt="畸变现象"></p>
<p>理想的针孔成像模型确定的坐标变换关系均为线性的，而实际上，现实中使用的相机由于镜头中镜片因为光线的通过产生的不规则的折射，镜头畸变（lens distortion）总是存在的，即根据理想针孔成像模型计算出来的像点坐标与实际坐标存在偏差。畸变导致的成像失真可分为径向失真和切向失真两类。</p>
<h4 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h4><p>这里只介绍算法上的畸变校正，通过标定，建立一个实际位置和理想位置的映射关系，具体的可以看另一篇文章《镜头畸变那些事儿》</p>
<p><img src="https://image.qinxing.xyz/20200722144504.png" alt></p>
<h3 id="（四）清晰度不均匀"><a href="#（四）清晰度不均匀" class="headerlink" title="（四）清晰度不均匀"></a>（四）清晰度不均匀</h3><h4 id="现象-2"><a href="#现象-2" class="headerlink" title="现象"></a>现象</h4><p>用同一个镜头，中心和边缘的画面清晰度也会有区别，边缘的清晰度一般都不如中心区域。</p>
<p><img src="https://image.qinxing.xyz/20200403105817.png" alt="一款镜头的MTF曲线"></p>
<p><img src="https://image.qinxing.xyz/20200722144510.png" alt="镜头的清晰度说明书"></p>
<h4 id="解决方法-3"><a href="#解决方法-3" class="headerlink" title="解决方法"></a>解决方法</h4><p>高通660平台会根据离中心的距离,对同一幅画面中的不同区域去设置不同的降噪和锐化参数</p>
<h3 id="（五）色像差"><a href="#（五）色像差" class="headerlink" title="（五）色像差"></a>（五）色像差</h3><h4 id="原因-3"><a href="#原因-3" class="headerlink" title="原因"></a>原因</h4><p>光学玻璃的折射率随通过的光波的波长变化而变，它对短波长的光的折射率比长波长的折射率更大。这种起因于不同波长的像差，我们称它为色像差(Chromatic aberration)。</p>
<p> <img src="https://image.qinxing.xyz/20200722144514.png" alt="色像差的原因"></p>
<h4 id="现象-3"><a href="#现象-3" class="headerlink" title="现象"></a>现象</h4><p><img src="https://image.qinxing.xyz/20200722144517.png" alt="色像差的现象"></p>
<p>具体体现在图像上，就是物体边缘原本是单纯白色，因为色差而变成RGB三原色不能重叠在同一线。最为常见的就是紫边（Purple Fringe）</p>
<h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p>Color Aliasing Correction(CAC)检测图像中视觉伪像,对伪像颜色进行补偿</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>ISP</tag>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title>AI超微光简介</title>
    <url>/posts/a809ba60/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="任何一个函数都可以被一个两层的神经网络近似-–李宏毅"><a href="#任何一个函数都可以被一个两层的神经网络近似-–李宏毅" class="headerlink" title="任何一个函数都可以被一个两层的神经网络近似 –李宏毅"></a>任何一个函数都可以被一个两层的神经网络近似 –李宏毅</h2><p>这是神经网络的基础，可以去逼近真实的函数，不过也终究不会超过真实的函数<br><a href="http://neuralnetworksanddeeplearning.com/chap4.html" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap4.html</a></p>
<h2 id="低照增强算法主要流程"><a href="#低照增强算法主要流程" class="headerlink" title="低照增强算法主要流程"></a>低照增强算法主要流程</h2><p><img src="/posts/a809ba60/AL%E8%B6%85%E5%BE%AE%E5%85%89%E6%B5%81%E7%A8%8B.png" alt="AI超微光实现流程"></p>
<p>最初的输入是曝光为10ms的raw图，最后的输出是曝光是1s的RGB图像，中间相差100倍的增益，因此中间会先给raw图一个100倍的增益</p>
<p><strong>疑问</strong>：这样固定增益不会过曝么？</p>
<p>回答：因此后来这个增益是自适应的，raw图算出一个平均亮度，再从isp取一个目标亮度，算出一个倍数作为增益</p>
<p><strong>疑问</strong>：如果去掉黑电平和增益会怎么样？ </p>
<p>回答：如果包含了太多的操作，可能会导致函数不收敛，难训练</p>
<p><strong>疑问</strong>：为什么深度学习不直接RAW to RAW，对RAW进行滤波和增强处理，再由ISP进行处理？</p>
<p>回答：ISP后续的gamma，降噪等模块可能会引入很多的噪声，和抹去很多的细节</p>
<h2 id="网络架构的设计"><a href="#网络架构的设计" class="headerlink" title="网络架构的设计"></a>网络架构的设计</h2><p><img src="/posts/a809ba60/1584540035684.png" alt></p>
<p>encoder是不断降采样的过程，减少运算，decoder是不断升采样的过程</p>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p><img src="/posts/a809ba60/1584540832671.png" alt></p>
<p>就实验而言，L1>L2, L1就是一次方，求绝对值。L2就是平方差。L1可以防止不拟合，或者找的只是局部最优解</p>
<p>带来的问题，L1损失基于全图的平均，导致图像模糊，细节丢失。这个损失函数也就决定了这个模型训练出来的就类似一个低通滤波器</p>
<p><strong>疑问</strong>：为什么不可以直接用统计值去训练，而不是直接用像素一一对应  </p>
<p>回答：如果只需要统计值，那可以说是非监督训练，一般来说，非监督训练99.9%不如监督训练，能用监督训练，就尽量用监督训练 </p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>一维卡尔曼滤波</title>
    <url>/posts/124f9d98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">I = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> xk_1 == <span class="number">0</span> </span><br><span class="line">    xk_1 = x;</span><br><span class="line">    xk = x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    zk = H*x;                   <span class="comment">% 观测量方程</span></span><br><span class="line">    <span class="comment">% 预测</span></span><br><span class="line">    X = A*xk_1;                 <span class="comment">% 状态预测             </span></span><br><span class="line">    P = A*Pk_1*A' + Q;          <span class="comment">% 误差协方差预测 	P = Pk-1 +Q</span></span><br><span class="line">    <span class="comment">% 更新(校正)</span></span><br><span class="line">    K = P*H'*inv(H*P*H'+R);     <span class="comment">% 卡尔曼增益更新	K = P * inv(P + R)</span></span><br><span class="line">    xk = X + K*(zk - H*X);      <span class="comment">% 更新校正	</span></span><br><span class="line">    xk_1 = xk;                  <span class="comment">% 保存校正后的值，下一次滤波使用	</span></span><br><span class="line">    Pk = (I - K*H)*P;           <span class="comment">% 更新误差协方差	Pk = (1 - K *H)*p</span></span><br><span class="line">    Pk_1 = Pk;                  <span class="comment">% 保存校正后的误差协方差，下一次滤波使用</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>以下是我的卡尔曼滤波代码</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kalman_filter</span><span class="params">(self,input_array,Q=<span class="number">0.0001</span>,R=<span class="number">0.005</span>)</span>:</span></span><br><span class="line">        <span class="comment"># r 测量噪声， Q预测噪声</span></span><br><span class="line">        out_array = []</span><br><span class="line">        xk = <span class="number">0</span></span><br><span class="line">        pk2_k = R*R</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(input_array)):</span><br><span class="line">            <span class="keyword">if</span>(i >= <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># zk = input_array[i]	k = xk + 0.005*(input_array[i]-xk)</span></span><br><span class="line">                zk = input_array[i]</span><br><span class="line">                pk2_k_1 = pk2_k + Q*Q	</span><br><span class="line">                kk = math.sqrt(pk2_k_1/(pk2_k_1 + R*R))</span><br><span class="line">                xk = xk + kk*(zk - xk)</span><br><span class="line">                pk2_k = (<span class="number">1</span>-kk)*pk2_k_1</span><br><span class="line">                out_array.append(xk)n </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                out_array.append(input_array[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> out_array</span><br></pre></td></tr></tbody></table></figure>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>经过实验对比，用注释的一句代码替换代码的9-14行并没什么区别。注释的那句话用的是互补滤波的方法写的。</p>
<p>卡尔曼滤波和互补滤波相比，主要特点是增益Kg可以变动的，会根据方差等计算出一个最优的增益。<br>不过这个公式里面的Kg跟输入一点关系都没有，只和Q和R有关，算来算去，就是这个增益按照一定的规则变化而已。<br>那为什么会有低通滤波的效果呢，因为你的Q值很小，这就导致了这个增益很小，更加信任上一次的值。 </p>
<p>其实说到底这段程序就是上一次的值加上这次测量值的乘以一个很小的系数，而上一次的值又是之前的值累加起来的。<br>如果这个系数（增益）保持固定，就是普通的一阶低通滤波。</p>
<p>一维的卡尔曼滤波退化成了一个普通的低通滤波。</p>
<p>而这个增益的话，我觉得可以用自己的逻辑去控制，不需要用卡尔曼滤波这种看似复杂的算法。</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习简介</title>
    <url>/posts/ab156def/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>以从零DIY MNIST分类作为例子，来解释一下深度学习的原理</p>
<p><img src="/posts/ab156def/1584538518218.png" alt></p>
<h2 id="（一）损失函数"><a href="#（一）损失函数" class="headerlink" title="（一）损失函数"></a>（一）损失函数</h2><p>就是计算模型出来的函数与实际值之间的差距</p>
<p><img src="/posts/ab156def/1584538775923.png" alt></p>
<h2 id="（二）过拟合和欠拟合"><a href="#（二）过拟合和欠拟合" class="headerlink" title="（二）过拟合和欠拟合"></a>（二）过拟合和欠拟合</h2><ol>
<li>第一个图是欠拟合，说明模型太简单了</li>
<li>第三个图是过拟合，模型太复杂了</li>
</ol>
<p><img src="/posts/ab156def/1584538805796.png" alt></p>
<p><img src="/posts/ab156def/1584538822068.png" alt></p>
<h2 id="（三）神经网络"><a href="#（三）神经网络" class="headerlink" title="（三）神经网络"></a>（三）神经网络</h2><p>如果不存在线性解，就需要将这个模型变得更加复杂。w是线性变换，g是非线性变换，wg(w1g1x)就组成了简单的神经网络</p>
<p><img src="/posts/ab156def/1584538842934.png" alt></p>
<p><img src="/posts/ab156def/1584538855608.png" alt></p>
<h2 id="（四）神经网络的基本单元"><a href="#（四）神经网络的基本单元" class="headerlink" title="（四）神经网络的基本单元"></a>（四）神经网络的基本单元</h2><p>层数的多少不一定代表好坏，层数少了有利于计算</p>
<h3 id="1-全连接层"><a href="#1-全连接层" class="headerlink" title="1. 全连接层"></a>1. 全连接层</h3><p>就是上面的w</p>
<p><img src="/posts/ab156def/1584539135418.png" alt></p>
<h3 id="2-卷积层"><a href="#2-卷积层" class="headerlink" title="2. 卷积层"></a>2. 卷积层</h3><p>就是滤波器 ，和传统的滤波器不一样的地方是，这个值是学习出来的，不是预设的</p>
<p>卷积层没必要规定输入的大小，但是全连接层需要规定输入的大小，参考图像卷积</p>
<p><img src="/posts/ab156def/1584539149546.png" alt></p>
<p><img src="/posts/ab156def/1584539161436.png" alt></p>
<h3 id="3-pooling层"><a href="#3-pooling层" class="headerlink" title="3. pooling层"></a>3. pooling层</h3><p>为了降采样 -> 可以减少计算，提取边缘</p>
<p><img src="/posts/ab156def/1584539085149.png" alt></p>
<h3 id="4-dropout层"><a href="#4-dropout层" class="headerlink" title="4. dropout层"></a>4. dropout层</h3><p>为了减少过拟合</p>
<p><img src="/posts/ab156def/1584539189846.png" alt></p>
<h3 id="5-batch-normalization归一化"><a href="#5-batch-normalization归一化" class="headerlink" title="5. batch normalization归一化"></a>5. batch normalization归一化</h3><p><img src="/posts/ab156def/1584539217241.png" alt></p>
<h2 id="（五）常用的激活函数"><a href="#（五）常用的激活函数" class="headerlink" title="（五）常用的激活函数"></a>（五）常用的激活函数</h2><p><img src="/posts/ab156def/1584539242812.png" alt></p>
<h2 id="（六）网络模型优化"><a href="#（六）网络模型优化" class="headerlink" title="（六）网络模型优化"></a>（六）网络模型优化</h2><p>梯度 （偏导数，利用反向传播求解）-> 更新参数 </p>
<h2 id="（七）问题"><a href="#（七）问题" class="headerlink" title="（七）问题"></a>（七）问题</h2><p>门禁设备从一万张照片中训练识别出一千个人，那如果加一个人，是否这个模型就需要重新训练呢？</p>
<p>答案：当然不是，他这个训练其实训练出来的是一个人脸的特征，一张人脸的特征有很多个。如果说识别到的人脸和数据库里面的某张人脸特征十分类似，就可以说明这是同一个人</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>视频防抖预研（三）—— 数据的读取与校准</title>
    <url>/posts/be8526f2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>算法仿真的方法主要有两种，python和MATLAB<br>由于需要对设备进行移植，opencv更加方便。同时MATLAB是收费软件，公司没有买licence。最终选择Python+OpenCV</p>
<p>新手不建议安装anaconda，经常会出现模块导入问题，我还出现过matplotlib模块缺失的问题，所以建议直接在系统中安装python程序。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我把它分为三个部分<br>第一个部分，数据的读取与校准<br>第二个部分，数据的处理<br>第三个部分，视频的处理</p>
<h3 id="数据的读取和校准"><a href="#数据的读取和校准" class="headerlink" title="数据的读取和校准"></a>数据的读取和校准</h3><p>定义一个陀螺仪数据读取与校准的类，将有关陀螺仪数据的读取和校准方法包含进来，有利于梳理代码结构。</p>
<h4 id="数据的读取"><a href="#数据的读取" class="headerlink" title="数据的读取"></a>数据的读取</h4><p>定义一个陀螺仪数据读取与校准的类，这个类初始化的输入就是文件的路径</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GyroscopeDataFile</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># the file path to read</span></span><br><span class="line">    <span class="comment"># a dictionary of angular velocities</span></span><br><span class="line">    <span class="comment"># This dictionary will store mappings between the timestamp</span></span><br><span class="line">    <span class="comment"># and the angular velocity at that instant.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filepath)</span>:</span></span><br><span class="line">        self.filepath = filepath</span><br><span class="line">        self.omega = {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_getfile_object</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> open(self.filepath)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># read the file and populate the Omega dictionary.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self._getfile_object() <span class="keyword">as</span> fp:</span><br><span class="line">            <span class="comment"># We validate that the first line of the csv file matches our</span></span><br><span class="line">            <span class="comment"># expectation. If not, the csv file was probably not compatible</span></span><br><span class="line">            <span class="comment"># and will error out over the next few lines.</span></span><br><span class="line">            firstline = fp.readline().strip()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> firstline == <span class="string">"gyro"</span>:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">"The first line isn't valid"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># The strip function removed any additional whitespace</span></span><br><span class="line">            <span class="comment"># (tabs, spaces, newline characters, among others)</span></span><br><span class="line">            <span class="comment"># that might be stored in the file.</span></span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> fp.readlines():</span><br><span class="line">                line = line.strip()</span><br><span class="line">                parts = line.split(<span class="string">","</span>)</span><br><span class="line">                <span class="comment"># convert strings into numetric type</span></span><br><span class="line">                timestamp = int(parts[<span class="number">3</span>])</span><br><span class="line">                ox = float(parts[<span class="number">0</span>])</span><br><span class="line">                oy = float(parts[<span class="number">1</span>])</span><br><span class="line">                oz = float(parts[<span class="number">2</span>])</span><br><span class="line">                <span class="string">'''</span></span><br><span class="line"><span class="string">                if timestamp < 100000000:</span></span><br><span class="line"><span class="string">                    timestamp = timestamp * 10</span></span><br><span class="line"><span class="string">                if timestamp < 100000000:</span></span><br><span class="line"><span class="string">                    timestamp = timestamp * 10</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">                print(<span class="string">"%s: %s, %s, %s"</span> % (timestamp, ox, oy, oz))</span><br><span class="line">                self.omega[timestamp] = (ox, oy, oz)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># return a sorted list of timestamps from small to large num</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_timestamps</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sorted(self.omega.keys())</span><br></pre></td></tr></tbody></table></figure>

<h4 id="数据的序列化"><a href="#数据的序列化" class="headerlink" title="数据的序列化"></a>数据的序列化</h4><p>有些中间生成的数据，调试的时候需要经常使用。如果每次都重新运行程序生成的话，会浪费很多的时间。<br>这里利用pickle模块进行数据的序列化<br>python文件的打开尽量用with的方法，防止忘记关闭文件，保证安全</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_gyro_data</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(self.gyrofilename):</span><br><span class="line">        print(<span class="string">"start creating "</span>+self.gyrofilename)</span><br><span class="line">        <span class="keyword">with</span> open(self.gyrofilename, <span class="string">"wb"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            pickle.dump(self.omega, fp)</span><br><span class="line">            <span class="keyword">return</span> self.omega</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">with</span> open(self.gyrofilename, <span class="string">"rb"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            <span class="keyword">return</span> pickle.load(fp)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="镜头参数校准"><a href="#镜头参数校准" class="headerlink" title="镜头参数校准"></a>镜头参数校准</h4><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LenParametersFromMatlab</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    get opencv camera parameters from matlab parameters</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">        radialDistortion,</span></span></span><br><span class="line"><span class="function"><span class="params">        tangentialDistortion,</span></span></span><br><span class="line"><span class="function"><span class="params">        intrinsicMatrix,</span></span></span><br><span class="line"><span class="function"><span class="params">        focalLength,</span></span></span><br><span class="line"><span class="function"><span class="params">        principalPoint</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        radialDistortion:     1 x 2 matrix</span></span><br><span class="line"><span class="string">        tangentialDistortion: 1 x 2 matrix</span></span><br><span class="line"><span class="string">        intrinsicMatrix:      3 x 3 matrix</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.kc1 = radialDistortion[<span class="number">0</span>]</span><br><span class="line">        self.kc2 = radialDistortion[<span class="number">1</span>]</span><br><span class="line">        self.kc3 = tangentialDistortion[<span class="number">0</span>]</span><br><span class="line">        self.kc4 = tangentialDistortion[<span class="number">1</span>]</span><br><span class="line">        self.fc1 = intrinsicMatrix[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        self.fc2 = intrinsicMatrix[<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">        self.cc1 = intrinsicMatrix[<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line">        self.cc2 = intrinsicMatrix[<span class="number">2</span>][<span class="number">1</span>]</span><br><span class="line">        self.focalLength = focalLength</span><br><span class="line">        self.principalPoint = principalPoint</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCameraMatrix</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.array([</span><br><span class="line">            [self.fc1, <span class="number">0</span>, self.cc1],</span><br><span class="line">            [<span class="number">0</span>, self.fc2, self.cc2],</span><br><span class="line">            [<span class="number">0</span>,         <span class="number">0</span>,       <span class="number">1</span>]</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getdistCoeffs</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.array([self.kc1, self.kc2, self.kc3, self.kc4])</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
        <tag>camera原理</tag>
        <tag>防抖</tag>
      </tags>
  </entry>
  <entry>
    <title>视频防抖预研（二）—— 数据采集</title>
    <url>/posts/37b90cd9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p><code>代码仓库</code>：<a href="https://github.com/xiaoqinxing/EIS_data_request_app" target="_blank" rel="noopener">https://github.com/xiaoqinxing/EIS_data_request_app</a></p>
</blockquote>
<h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>第一个方案是从camera底层获取录像和陀螺仪数据。</p>
<ol>
<li>问题1：我们一直使用的是预览流数据，根本不知道从什么时候开始录像，录像和拍照只是媒控取得预览流数据进行编码得到的。</li>
<li>问题2：很难将每帧图像对应的陀螺仪数据采集下来。</li>
</ol>
<p>第二个方案是用Java做一个APP去实现陀螺仪和图像数据的采集<br>毫无疑问，我们选择第二种方案。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="（一）权限申请"><a href="#（一）权限申请" class="headerlink" title="（一）权限申请"></a>（一）权限申请</h3><h4 id="1-安卓6-0之前"><a href="#1-安卓6-0之前" class="headerlink" title="1. 安卓6.0之前"></a>1. 安卓6.0之前</h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag"><<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CAMERA"</span> /></span></span><br><span class="line"><span class="tag"><<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /></span></span><br></pre></td></tr></tbody></table></figure>
<p>放在xml中申请权限，位置在application之前</p>
<h4 id="2-安卓6-0之后"><a href="#2-安卓6-0之后" class="headerlink" title="2. 安卓6.0之后"></a>2. 安卓6.0之后</h4><p>权限需要动态申请：在APP初始化的时候，进行权限的申请。本文引用了一个权限的工具类，具体的内容可以查看<a href="https://github.com/xiaoqinxing/EIS_data_request_app/blob/master/app/src/main/java/com/example/eis_test/PermissionsUtils.java" target="_blank" rel="noopener">源码</a>。</p>
<h3 id="（二）实现预览及录像功能"><a href="#（二）实现预览及录像功能" class="headerlink" title="（二）实现预览及录像功能"></a>（二）实现预览及录像功能</h3><h4 id="1-修改界面布局xml"><a href="#1-修改界面布局xml" class="headerlink" title="1. 修改界面布局xml"></a>1. 修改界面布局xml</h4><ol>
<li>添加一个textureView作为预览画面的显示</li>
<li>添加一个button控制录像的开关</li>
</ol>
<h4 id="2-初始化（去除申请权限的代码）"><a href="#2-初始化（去除申请权限的代码）" class="headerlink" title="2. 初始化（去除申请权限的代码）"></a>2. 初始化（去除申请权限的代码）</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recorder</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> TextureView mPreview;  <span class="comment">// For displaying the live camera preview</span></span><br><span class="line">    <span class="keyword">private</span> Camera mCamera;        <span class="comment">// Object to contact the camera hardware</span></span><br><span class="line">    <span class="keyword">private</span> MediaRecorder mMediaRecorder;    <span class="comment">// Store the camera's image stream as a video</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isRecording = <span class="keyword">false</span>; <span class="comment">// Is video being recoded</span></span><br><span class="line">    <span class="keyword">private</span> Button btnRecord;            <span class="comment">// Button that triggers recording</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String TAG = <span class="string">"GyroRecorder"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">//显示一个页面</span></span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//id is elements's id to find which elements you choose</span></span><br><span class="line">        mPreview = (TextureView)findViewById(R.id.textureView1);</span><br><span class="line">        btnRecord = (Button)findViewById(R.id.button1);</span><br><span class="line"></span><br><span class="line">        btnRecord.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>{</span><br><span class="line">                onCaptureClick(view);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-处理按键按下的逻辑"><a href="#3-处理按键按下的逻辑" class="headerlink" title="3. 处理按键按下的逻辑"></a>3. 处理按键按下的逻辑</h4><ol>
<li>当没有录像时，按下按键就创建一个新的线程，启动录像。在启动录像的之后，把按键上的名称改成“Stop”</li>
<li>当正在录像的时候，就停止录像并释放资源</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCaptureClick</span><span class="params">(View view)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (isRecording) {</span><br><span class="line">        <span class="comment">// Already recording? Release camera lock for others</span></span><br><span class="line">        mMediaRecorder.stop();</span><br><span class="line">        releaseMediaRecorder();</span><br><span class="line">        mCamera.lock();</span><br><span class="line"></span><br><span class="line">        isRecording = <span class="keyword">false</span>;</span><br><span class="line">        releaseCamera();</span><br><span class="line">        mGyroFile.close();</span><br><span class="line">        mGyroFile = <span class="keyword">null</span>;</span><br><span class="line">        btnRecord.setText(<span class="string">"Start"</span>);</span><br><span class="line">        mStartTime = -<span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// Not recording – launch new "thread" to initiate!</span></span><br><span class="line">        <span class="keyword">new</span> MediaPrepareTask().execute(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MediaPrepareTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span><<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">Boolean</span>> </span>{</span><br><span class="line">    <span class="comment">//automatically creates a new thread and runs doInBackground in that thread</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Boolean <span class="title">doInBackground</span><span class="params">(Void... voids)</span> </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//identifying supported image sizes from the camera, finding the suitable height,</span></span><br><span class="line">        <span class="comment">// setting the bitrate of the video and specifying the destination video file.</span></span><br><span class="line">        <span class="keyword">if</span>(prepareVideoRecorder()) {</span><br><span class="line">            mMediaRecorder.start();</span><br><span class="line">            isRecording = <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            releaseMediaRecorder();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Boolean result)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(!result) {</span><br><span class="line">            Recorder.<span class="keyword">this</span>.finish();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        btnRecord.setText(<span class="string">"Stop"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放recorder</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseMediaRecorder</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(mMediaRecorder != <span class="keyword">null</span>) {</span><br><span class="line">        mMediaRecorder.reset();</span><br><span class="line">        mMediaRecorder.release();</span><br><span class="line">        mMediaRecorder = <span class="keyword">null</span>;</span><br><span class="line">        mCamera.lock();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//释放camera</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseCamera</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(mCamera != <span class="keyword">null</span>) {</span><br><span class="line">        mCamera.release();</span><br><span class="line">        mCamera = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="4-打开预览及开始录像"><a href="#4-打开预览及开始录像" class="headerlink" title="4. 打开预览及开始录像"></a>4. 打开预览及开始录像</h4><ol>
<li>打开相机</li>
<li>查找并设置camera预览的尺寸</li>
<li>开启camera的预览，并通过textureView显示出来</li>
<li>查找并设置camera录像的尺寸、格式、输出路径等参数</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@TargetApi</span>(Build.VERSION_CODES.HONEYCOMB)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">prepareVideoRecorder</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// because mCamera is privated object, so other class can't used</span></span><br><span class="line">    mCamera = Camera.open();</span><br><span class="line">    <span class="keyword">if</span> (mCamera == <span class="keyword">null</span>) {</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">"没有可用相机"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Camera.Parameters parameters = mCamera.getParameters();</span><br><span class="line">    List<Camera.Size> mSupportedPreviewSizes = parameters.getSupportedPreviewSizes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the optimal image size for the camera</span></span><br><span class="line">    Camera.Size optimalSize = getOptimalPreviewSize(mSupportedPreviewSizes,mPreview.getWidth(),mPreview.getHeight());</span><br><span class="line">    parameters.setPreviewSize(optimalSize.width,optimalSize.height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//With the optimal size in hand, we can now set up the camera recorder settings</span></span><br><span class="line">    CamcorderProfile profile = CamcorderProfile.get(CamcorderProfile.QUALITY_HIGH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//contact the camera hardware and set up these parameters</span></span><br><span class="line">    mCamera.setParameters(parameters);</span><br><span class="line">    mCamera.startPreview();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        mCamera.setPreviewTexture(mPreview.getSurfaceTexture());</span><br><span class="line">    } <span class="keyword">catch</span>(IOException e) {</span><br><span class="line">        Log.e(TAG,<span class="string">"Surface texture is unavailable or unsuitable"</span> + e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//camera unlock need before new a MediaRecorder object</span></span><br><span class="line">    mCamera.unlock();</span><br><span class="line">    <span class="comment">//set up the media recorder</span></span><br><span class="line">    mMediaRecorder = <span class="keyword">new</span> MediaRecorder();</span><br><span class="line"></span><br><span class="line">    mMediaRecorder.setCamera(mCamera);</span><br><span class="line"></span><br><span class="line">    mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);</span><br><span class="line"></span><br><span class="line">    mMediaRecorder.setOutputFormat(profile.fileFormat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//maybe video sizes are different from preview stream, so get max supported video sizes</span></span><br><span class="line">    List<Camera.Size> supportedVideoSizes = parameters.getSupportedVideoSizes();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<supportedVideoSizes.size();i++){</span><br><span class="line">        Log.d(<span class="string">"init"</span>, <span class="string">"supportedVideoSize:"</span>+supportedVideoSizes.get(i).height+</span><br><span class="line">                <span class="string">"x"</span>+supportedVideoSizes.get(i).width);</span><br><span class="line">    }</span><br><span class="line">    profile.videoFrameWidth = supportedVideoSizes.get(<span class="number">0</span>).width;</span><br><span class="line">    profile.videoFrameHeight = supportedVideoSizes.get(<span class="number">0</span>).height;</span><br><span class="line">    mMediaRecorder.setVideoSize(profile.videoFrameWidth,profile.videoFrameHeight);</span><br><span class="line"></span><br><span class="line">    mMediaRecorder.setVideoEncodingBitRate(profile.videoBitRate);</span><br><span class="line"></span><br><span class="line">    mMediaRecorder.setVideoEncoder(profile.videoCodec);</span><br><span class="line">    mMediaRecorder.setOutputFile(getOutputMediaFile().toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//initialize the PrintStream</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        mGyroFile = <span class="keyword">new</span> PrintStream(getOutputGyroFile());</span><br><span class="line">        mGyroFile.append(<span class="string">"gyro\n"</span>);</span><br><span class="line">    } <span class="keyword">catch</span>(IOException e) {</span><br><span class="line">        Log.d(TAG, <span class="string">"Unable to create acquisition file"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        mMediaRecorder.prepare();</span><br><span class="line">    } <span class="keyword">catch</span> (IllegalStateException e) {</span><br><span class="line">        Log.d(TAG, <span class="string">"IllegalStateException preparing MediaRecorder: "</span> + e.getMessage());</span><br><span class="line">        releaseMediaRecorder();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        Log.d(TAG, <span class="string">"IOException preparing MediaRecorder: "</span> + e.getMessage());</span><br><span class="line">        releaseMediaRecorder();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="（三）添加传感器数据"><a href="#（三）添加传感器数据" class="headerlink" title="（三）添加传感器数据"></a>（三）添加传感器数据</h3><p>当录像的时候开始记录陀螺仪的数据，主要记录陀螺仪的值以及对应的时间戳</p>
<h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//The SensorManager object manages all sensors on the hardware</span></span><br><span class="line"><span class="keyword">private</span> SensorManager mSensorManager;</span><br><span class="line"><span class="keyword">private</span> Sensor mGyro;</span><br><span class="line"><span class="keyword">private</span> PrintStream mGyroFile;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> mStartTime = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> List<Sensor> sensorList;</span><br><span class="line">mSensorManager = (SensorManager)getSystemService(Context.SENSOR_SERVICE);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//print all sensor's name</span></span><br><span class="line">    List<String> sensorNameList = <span class="keyword">new</span> ArrayList<String>();</span><br><span class="line">    sensorList = mSensorManager.getSensorList(Sensor.TYPE_ALL);</span><br><span class="line">    <span class="keyword">for</span>(Sensor sensor : sensorList) {</span><br><span class="line">        sensorNameList.add(sensor.getName()+<span class="string">"\r\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    Log.d(<span class="string">"sensor"</span>,sensorNameList.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//register sensor listener for gyro</span></span><br><span class="line">    mGyro = mSensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);</span><br><span class="line">    <span class="comment">//fetching the gyroscope sensor and registering that this class should receive events (registerListener)</span></span><br><span class="line">    mSensorManager.registerListener(gyro_listener, mGyro, SensorManager.SENSOR_DELAY_FASTEST);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-数据打印流初始化"><a href="#2-数据打印流初始化" class="headerlink" title="2. 数据打印流初始化"></a>2. 数据打印流初始化</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//initialize the PrintStream</span></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">//获取陀螺仪文件输出路径</span></span><br><span class="line">    mGyroFile = <span class="keyword">new</span> PrintStream(getOutputGyroFile());</span><br><span class="line">    mGyroFile.append(<span class="string">"gyro\n"</span>);</span><br><span class="line">} <span class="keyword">catch</span>(IOException e) {</span><br><span class="line">    Log.d(TAG, <span class="string">"Unable to create acquisition file"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">#### 3. 监听传感器数据</span><br><span class="line">``` java</span><br><span class="line"><span class="keyword">private</span> SensorEventListener gyro_listener = <span class="keyword">new</span> SensorEventListener(){</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAccuracyChanged</span><span class="params">(Sensor sensor, <span class="keyword">int</span> accuracy)</span> </span>{</span><br><span class="line">        <span class="comment">// Empty on purpose</span></span><br><span class="line">        <span class="comment">// Required because we implement SensorEventListener</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSensorChanged</span><span class="params">(SensorEvent sensorEvent)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(isRecording) {</span><br><span class="line">            <span class="keyword">if</span>(mStartTime == -<span class="number">1</span>) {</span><br><span class="line">                mStartTime = sensorEvent.timestamp;</span><br><span class="line">            }</span><br><span class="line">            mGyroFile.append(sensorEvent.values[<span class="number">0</span>] + <span class="string">","</span> +</span><br><span class="line">                    sensorEvent.values[<span class="number">1</span>] + <span class="string">","</span> +</span><br><span class="line">                    sensorEvent.values[<span class="number">2</span>] + <span class="string">","</span> +</span><br><span class="line">                    (sensorEvent.timestamp-mStartTime) + <span class="string">"\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="（四）遇到过的问题"><a href="#（四）遇到过的问题" class="headerlink" title="（四）遇到过的问题"></a>（四）遇到过的问题</h3><h4 id="1-编译问题以及gradle的配置问题"><a href="#1-编译问题以及gradle的配置问题" class="headerlink" title="1. 编译问题以及gradle的配置问题"></a>1. 编译问题以及gradle的配置问题</h4><p>删除.gradle目录（AS和用户目录下都删除），重新打开Android studio进行同步就好了<br>代理配置问题可以查看这个<a href="https://blog.csdn.net/fongim/article/details/100272588" target="_blank" rel="noopener">博客</a></p>
<h4 id="2-图像崩溃"><a href="#2-图像崩溃" class="headerlink" title="2. 图像崩溃"></a>2. 图像崩溃</h4><p>预览和录像的分辨率设置的有问题，需要先进行获取！</p>
<h4 id="3-添加陀螺仪传感器数据"><a href="#3-添加陀螺仪传感器数据" class="headerlink" title="3. 添加陀螺仪传感器数据"></a>3. 添加陀螺仪传感器数据</h4><p>监听错误</p>
<h4 id="4-android6-0权限申请问题"><a href="#4-android6-0权限申请问题" class="headerlink" title="4. android6.0权限申请问题"></a>4. android6.0权限申请问题</h4><p>android6.0之后权限需要动态申请：在APP初始化的时候，进行权限的申请。本文引用了一个权限的工具类，具体的内容可以查看<a href="https://github.com/xiaoqinxing/EIS_data_request_app/blob/master/app/src/main/java/com/example/eis_test/PermissionsUtils.java" target="_blank" rel="noopener">源码</a>。</p>
<h4 id="5-U2P安装不了第三方应用程序"><a href="#5-U2P安装不了第三方应用程序" class="headerlink" title="5. U2P安装不了第三方应用程序"></a>5. U2P安装不了第三方应用程序</h4><p>业务对外部app的安装进行了限制：<code>kdb shell setprop sys.pkg.plat_sign_req false</code></p>
<h4 id="6-录像图像只有一部分，没有全部的视场角"><a href="#6-录像图像只有一部分，没有全部的视场角" class="headerlink" title="6. 录像图像只有一部分，没有全部的视场角"></a>6. 录像图像只有一部分，没有全部的视场角</h4><p>分辨率设置问题</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>camera原理</tag>
        <tag>防抖</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：帧率切换遇到的问题</title>
    <url>/posts/850c69c7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>切换夜模式后，切换采集帧率，图像会出现斑点<br><img src="https://image.qinxing.xyz/20200330111659.png" alt="切换夜模式后，切换采集帧率，图像会出现斑点"></p>
<h3 id="排查方法"><a href="#排查方法" class="headerlink" title="排查方法"></a>排查方法</h3><p>RAW图正常，YUV不正常。</p>
<h3 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h3><p>夜模式会有两个动作，一个是硬件操作（打开红外，关闭IRCUT），一个是软件的黑白效果。</p>
<p>经过实测，主要问题在黑白效果这里，当开启黑白效果后，切换采集帧率，图像会出现斑点。</p>
<p>向高通提交了case，待解决。</p>
<p>在设置帧率时候强制切换到日模式，设置完再切换到夜模式，这种方法不可行。可以成功切到日模式，但是夜模式不能生效。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>开启夜模式或者自动模式的同时会设置帧率为30帧，并保存日模式时的帧率。<br>开启日模式的同时会设置存储的帧率，如果没有存储帧率，就不进行设置。<br>在切换帧率的时候，如果判断是在夜模式，就不进行切换。</p>
<h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><h3 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h3><p>出图出不了</p>
<h3 id="排查方法-1"><a href="#排查方法-1" class="headerlink" title="排查方法"></a>排查方法</h3><ol>
<li>骁龙相机可以出图，而执法仪APP不能出图，可以缩小问题范围到媒控或者isp组件。</li>
<li>ispversion没有打印，代表ispctrl没有初始化。也没有startpreview，说明媒控没有开启采集。</li>
<li>媒控设置分辨率和帧率的时候，会获取camera的能力集，帧率需要大于15帧，支持的分辨率需要大于等于设置的分辨率，<br>否则就不会加载ispctrl，也不会开启采集。preview支持的分辨率最大只有320*240</li>
</ol>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>Android8.0的代码对上报的preview尺寸做了限制，最大为屏幕尺寸</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>去除相关逻辑</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>摸清楚帧率的整个初始化设置流程。最一开始，camera初始化会有一个初始帧率，然后媒控初始化，会再次设置一个帧率。然后ISP组件初始化的时候，会根据抗闪烁模式和编码帧率设置一个采集帧率。</li>
<li>高通设备不要在黑白模式下切换采集帧率，图像会出现异常！</li>
<li>Android8.0之后的代码对preview的原始支持的分辨率有限制，最大为屏幕尺寸</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>帧率</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：fd泄露总结</title>
    <url>/posts/b77ef29a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>web登陆不了，cameraserver的fd泄露</p>
<h2 id="排查方法"><a href="#排查方法" class="headerlink" title="排查方法"></a>排查方法</h2><p>fd泄露的排查方法：<br>查看cameraserver进程的PID：<code>ps -ef|grep cameraserver</code><br>查看这个进程打开的fd数量，804是进程的PID：<code>cd proc/804/fd | ls |wc -l</code><br>最大的数量是1024，接近这个数量就是fd泄露了，正常来说应该一百多<br>可以查看一下打开的fd路径：<code>lsof -p 804</code></p>
<h2 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h2><p>查看一下哪些fd重复打开没有关闭</p>
<ol>
<li><p>如果是CAM_KSocketServer0，是ISP的socket通信没有释放fd</p>
<ul>
<li>linux有安全子系统SElinux，会对进程的权限进行控制，没有权限就创建不了文件，直接退出，没有释放fd</li>
<li>摄像头关闭的时候，cameraserver服务端没有关闭连接的socket文件</li>
</ul>
</li>
<li><p>如果是sof_freeze_dump.txt，可能是出现了<code>sof timeout</code>和recover的错误</p>
<ul>
<li>timeout一般是帧数据接收超时的错误，是通过相邻两帧的时间戳确定的，如果上层进行了时间同步，也会出现超时错误</li>
<li>recover的操作是在下一帧数据又正常的情况下出现的，把之前的log文件覆盖掉，此时高通的代码删除文件的时候没有先把文件关闭</li>
</ul>
</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li>如果是ISP的socket通信没有释放fd<ol>
<li>没有该目录下的权限<ul>
<li>修改启动文件init.qcom.rc，修改对应目录的对应权限</li>
<li>对没有权限的情况进行处理，服务端和客户端都需要进行处理</li>
<li>向驱动申请在SElinux中增加cameraserver进程的权限</li>
</ul>
</li>
<li>socket服务端关闭的时候，需要关闭连接的文件，用到epoll注意需要关闭所有的连接文件</li>
</ol>
</li>
<li>如果是sof_freeze_dump.txt<ol>
<li>如果是上层时间同步引起的超时错误，只有一帧会出现问题。所以判断超时错误的时候再加一个判断，确定两帧都超时了才算超时错误</li>
<li>在删除sof_freeze_dump.txt文件之前把文件关闭（server_debug.c）</li>
</ol>
</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>用到文件fd的地方一定要检查程序的各个结束的情况，有打开就必须要有关闭。</li>
<li>文件的打开关闭可以在构造和析构函数中进行，更加不容易忘记。</li>
<li>创建和打开文件、property的时候，都需要注意是否有权限，更要注意没有权限时的处理。</li>
<li>时间同步的时候，需要注意规避高通原生代码fd泄露的bug</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>hal</tag>
        <tag>fd泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>视频防抖预研（一）—— 提纲与路线</title>
    <url>/posts/a21dfc81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="（一）计划"><a href="#（一）计划" class="headerlink" title="（一）计划"></a>（一）计划</h2><ol>
<li>实现高通原生防抖</li>
<li>视频防抖调研</li>
<li>自研防抖算法<ol>
<li>确定技术路线：阅读相关论文和资料，熟悉防抖算法原理后确定合适的基础版本算法</li>
<li>数据采集：获取原始正常行走的视频以及对应的陀螺仪数据</li>
<li>验证算法：在PC端仿真算法，分析起来更加直观直观</li>
<li>优化算法：通过基础版本的验证发现问题，继续查找解决方案，给予优化</li>
<li>移植算法：考虑性能，针对高通设备进行移植</li>
</ol>
</li>
</ol>
<h2 id="（二）高通660平台原生防抖"><a href="#（二）高通660平台原生防抖" class="headerlink" title="（二）高通660平台原生防抖"></a>（二）高通660平台原生防抖</h2><h3 id="开启方法"><a href="#开启方法" class="headerlink" title="开启方法"></a>开启方法</h3><p>开启防抖：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">adb shell setprop persist.camera.is_type 5</span><br></pre></td></tr></tbody></table></figure>
<p>开启log：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">adb shell setprop persist.camera.stats.debug 49152</span><br><span class="line">adb shell setprop persist.camera.imglib.logs 6</span><br><span class="line">adb shell setprop persist.camera.stats.is.debug 7</span><br></pre></td></tr></tbody></table></figure>
<p><code>判断是否生效的方法</code>：logcat中是否出现eis3_init，如果没有出现，代表着没有初始化成功</p>
<p>查看代码发现需要打开m_bDISEnabled，在骁龙相机中找到有打开防抖功能的开关。但是当打开开关后，发现骁龙相机报错：不支持当前分辨率，而高通文档明显是支持的。经过网上的理解，电子防抖是需要牺牲分辨率的。<strong>分辨率改成720p</strong>就成功的打开了防抖！可以很明显的看到开启电子防抖后，视场角小了很多</p>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ol>
<li>分辨率损失严重<br>由于是电子防抖，需要对图像进行裁剪，会带来分辨率和视场角的损失，下面实际测算了一下高通算法裁剪的比例：<br><img src="https://image.qinxing.xyz/20200405224120.png" alt="防抖前后视野对比"><br>左边的是开启防抖，右边的是关闭防抖的图像，左边的图是右边的图像经过裁剪得来的，可以算出裁剪掉的比例，大概是1/4到1/5的样子。也就是说如果需要1080p的图像，像素需要约260万像素以上的摄像头，目前的IMX290是达不到要求的。</li>
<li>原生防抖效果不好<br>实际测试出来发现开了防抖比不开抖动还要大。<br>根据高通的文档90-p2482-80_a，SDM660算是老平台，用的是EIS3.0，没有什么可以调的参数，只能开关。670/710等是新平台，用的是EIS4，在文档80-nd928-8_a中说明了一些可以调试的参数，如镜头失真模型，陀螺仪角度等，但是这些参数660都找不到。<br>执法仪的镜头有严重的畸变，这就带来一个问题：同一物体在图像的不同位置呈现出来的图像不同。当防抖算法对这一物体进行旋转或平移使之稳定的时候，会带来图像的失真。<br>在新平台中会用工具校准出镜头的失真模型，类似于先做一遍畸变校正再进行防抖。在2241上那种畸变较小的镜头我觉得可以试一下效果。执法仪的镜头我觉得需要用新平台可能会好一些，但是高通那边也没有个明确的说法，因为手机上用的镜头大多没有什么畸变，其次对防抖效果没有那么重视，可能需要向高通提需求。</li>
</ol>
<h2 id="（三）防抖调研"><a href="#（三）防抖调研" class="headerlink" title="（三）防抖调研"></a>（三）防抖调研</h2><h3 id="光学防抖与电子防抖"><a href="#光学防抖与电子防抖" class="headerlink" title="光学防抖与电子防抖"></a>光学防抖与电子防抖</h3><ol>
<li><p>OIS（Optical Image Stabilization）光学防抖技术：<br> 在模组内的陀螺仪侦测到微小的移动时，将信号传至微处理器立即计算需要补偿的位移量，然后通过补偿镜片组或者感光元件的相对位置，根据镜头的抖动方向及位移量加以补偿，从而有效的克服因相机的振动产生的影像模糊</p>
<p> 镜片移动式和感光元件相对移动式的差异在于，一个是移动镜片组一个是移动整个镜头或者sensor。镜片移动式常用在单反相机或一体机镜头中，利用镜组中了n组镜片做XY方向的移动达到光学防抖的效果。由于手机镜头轻、小、像面尺寸小，更容易实现感光芯片相对移动式的防抖。<br> <img src="https://image.qinxing.xyz/20200405230432.png" alt></p>
<p> 优点：防抖效果好，可做到0-20Hz/0-±10°的防抖、保证图像清晰度<br> 缺点：成本高、镜头或者VCM需要特别设计、芯片算法难做、功耗高、抗跌落是个隐患</p>
</li>
<li><p>EIS（Electronic Image Stabilization ）电子防抖：<br> 优点：成本低、易兼容、容易实现<br> 缺点：损失图像清晰度、降低sensor利用率、防抖效果较差</p>
</li>
</ol>
<h3 id="实测以及可行性分析"><a href="#实测以及可行性分析" class="headerlink" title="实测以及可行性分析"></a>实测以及可行性分析</h3><p>通过实测，人在走路、跑步、打斗、推搡时，穿戴在上衣口袋、帽檐、肩部的振动频率集中在5Hz；人体摆动幅度比较大，振动角度需要±5°以上。这个数据和运动相机比较类似。<br>电子防抖不能满足需求，在条件允许的情况下，尽量选用光学防抖。</p>
<ol>
<li>纽扣相机镜头尺寸是：M12*9.4mm，镜头尺寸相对较小，选用感光元件相对移动式OIS技术比较合适。</li>
<li>纽扣相机使用场合不同于手机，人在运动时，运动频率和方向不规律，属于低频率高振幅。手机OIS现状：防抖频率和振幅较小，4-5Hz，1°左右。手机防抖不能适用</li>
<li>马达需要重新开模定制</li>
<li>由于防抖模组要给镜头一个摆动空间，所以镜头基本处于腾空状态，耐跌落会是一项隐患</li>
<li>模组体积会增大，原有的框架不能兼容</li>
<li>功耗增大，预计峰值电流有200mA</li>
</ol>
<h3 id="厂家调研"><a href="#厂家调研" class="headerlink" title="厂家调研"></a>厂家调研</h3><p>舜宇：研发实力、生产能力都是国内领先。实力雄厚。目前量产5Hz，±2°的手机防抖模组，无意向合作定制更高振幅的OIS模组<br>信利：有EIS和OIS两种技术，只做模组，防抖芯片用的ST，马达需重新开模。<br>三鸣科技：与HTC、华硕、舜宇、欧菲光、夏普都合作过。有自己的防抖算法芯片。已经有5Hz、±5°类似规格的样品，用在运动相机上的，效果很不错。<br>科宝：科宝与小蚁商议10Hz、±10°的运动相机项目，与长步道也在开发防抖产品。防抖芯片是第三方的，与小蚁合作的项目用的东芝芯片。iPhone 7的后置摄像头防抖也科宝也做过（一年内不能开放）。<br>其他：大部分不愿意合作定制，量少成本高利润低</p>
<h2 id="（四）电子视频防抖"><a href="#（四）电子视频防抖" class="headerlink" title="（四）电子视频防抖"></a>（四）电子视频防抖</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>目前的视频防抖主要有两个方向。一个是纯粹基于图像的，另一个是基于陀螺仪的。<br>不用陀螺仪稳定图像需要找到关键点，理解整张图像的移动。有一些著名的算法，SIFT，SURF，ORB，FREAK等。然而这个关键点检测器有自身的缺点：</p>
<ol>
<li>稳定的结果高度依赖于图像的质量。低分辨率图像可能无法生成最佳功能集，还可能失焦和模糊图像</li>
<li>图像中的关键点图案有很多重复的，会使算法混淆，不能判断图像运动的轨迹。</li>
<li>如果图像中有大量的运动（例如人们在背景中行走或 一辆卡车越过马路，稳定性将因此而倾斜。关键点是跟踪移动物体而不是摄像机本身的运动。</li>
</ol>
<p>当然还有一点原因没有讲到，基于图像防抖很吃资源，在低功耗的设备中实现基本不可能。因此我们肯定是选择用陀螺仪防抖了。利用陀螺仪感知到相机的运动角度，对图像进行旋转变换，补偿相机的运动。</p>
<h3 id="挑选算法"><a href="#挑选算法" class="headerlink" title="挑选算法"></a>挑选算法</h3><p>高通的EIS是electronic image stablization。所以一开始搜索的是image stablization，图像防抖，发现大部分是多帧抖动的图片合成一张图片，适用于拍照。我们产品的定位是录像，应该视频防抖，video stablization。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>意法半导体OIS的介绍文章：<a href="https://www.st.com/content/ccc/resource/technical/document/white_paper/c9/a6/fd/e4/e6/4e/48/60/ois_white_paper.pdf/files/ois_white_paper.pdf/jcr:content/translations/en.ois_white_paper.pdf" target="_blank" rel="noopener">Optical Image Stabilization</a></p>
<p>防抖算法论文参考：<br>Gyroscope-based Video Stabilisation With Auto-Calibration<br>Stabilizing Cell Phone Video using Inertial Measurement Sensors</p>
<p>比较好的参考书籍：<br><a href="https://files.qinxing.xyz/OpenCV%203%20Blueprints%20by%20Howse%20J.%20et%20al.%20(z-lib.org).epub" target="_blank" rel="noopener">OpenCV3 Blueprints</a></p>
<h3 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h3><ol>
<li>由于电子视频防抖只是让视频稳定，不能让因为运动模糊的物体复原，所以尽可能的使图像清晰。因此开启防抖时快门应该为1/100,可能会导致夜间效果不好，可以在AE算法中增加一段，在比较亮的环境下，快门上限为1/100，在比较暗的环境下，快门上限调至1/50</li>
<li>收集传感器和镜头等资料，算法中需要用到一些参数</li>
<li>准备一个视场角小畸变小的镜头，与原镜头进行效果对比</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>camera原理</tag>
        <tag>防抖</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：高温导致帧率异常</title>
    <url>/posts/3db0f223/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><ul>
<li>温度过高时户外出现过曝，夏天出现的频率更高</li>
<li>图像高温下出现偏绿的情况</li>
<li>设备崩溃，崩溃在thermal</li>
<li>界面上调节自动快门的下限图像上不生效</li>
</ul>
<h2 id="排查方式"><a href="#排查方式" class="headerlink" title="排查方式"></a>排查方式</h2><ol>
<li>增加thermal level的打印，可以在QCamera2HWI.cpp中的updateThermalLevel中增加thermal_level的打印</li>
<li>打开sensor，stats模块的打印，<code>logcat|grep  fps</code>，查看是否有帧率有异常，比如说负数</li>
<li>此时如果打开骁龙相机，会出现异常而打不开</li>
</ol>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>温控策略中的bug</p>
<p>QCamera2HWI.cpp中的updateThermalLevel是对不同温度等级实现帧率控制，温度比较高，实行降帧策略。</p>
<p>其中的<code>calcThermalLevel</code>是根据温度等级计算目标的帧率。当在<code>QCAMERA_THERMAL_SHUTDOWN</code>模式下，却没有对目标帧率进行赋值，<code>adjustPreviewFpsRange</code>函数就将没有赋初值的帧率设置下去了，导致异常。</p>
<p>这个异常的设置不会影响到sensor的采集帧率，也不会影响到hal层每帧回调的输出帧率，但是会影响到stats模块，导致最大曝光行等参数错误，随后写入sensor的曝光时间出错，最终导致图像或者设备异常。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>去除温度对帧率的控制代码</li>
</ul>
<ol>
<li>注释掉updateThermalLevel函数中的内容</li>
<li>注释掉setPreviewFpsRange函数中<code>QCAMERA_THERMAL_ADJUST_FPS</code>模式下对帧率的控制</li>
</ol>
<ul>
<li>联系驱动提高ISP温度上限</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>BUG</tag>
      </tags>
  </entry>
  <entry>
    <title>色彩标准及调试</title>
    <url>/posts/c230c3c4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="色彩标准"><a href="#色彩标准" class="headerlink" title="色彩标准"></a>色彩标准</h2><p>判断色彩是否准确的方法是在不同的色温下拍摄24色卡后用imatest软件进行测量。<br>偏色的判定依据是连接图像坐标中心点和对应的目标方形色块点，得到一条直线，如果对应的圆形camera色块点，在这条直线上，则说明色差较小，方块和圆形的距离越远说明饱和度相差比较大，越近则饱和度相差比较小。<br><img src="https://image.qinxing.xyz/20200330182801.png" alt="色彩偏色标准"><br>当坐标原点，方块ideal点和对应camera圆点，三点在一条直线上时，色差最小。camera圆点偏离的角度越大，则色差越大。当camera圆点越往外发散，则饱和度越高，越往内收敛，则饱和度越低。<br>24色卡中重点关注蓝色（13）绿色（14）红色（15）肤色（2）的色偏问题。</p>
<h2 id="理想色温值"><a href="#理想色温值" class="headerlink" title="理想色温值"></a>理想色温值</h2><table>
<thead>
<tr>
<th>色温</th>
<th>色温标准值K</th>
</tr>
</thead>
<tbody><tr>
<td>D75</td>
<td>7500</td>
</tr>
<tr>
<td>D65</td>
<td>6500</td>
</tr>
<tr>
<td>D50</td>
<td>5000</td>
</tr>
<tr>
<td>CWF</td>
<td>4200</td>
</tr>
<tr>
<td>TL84</td>
<td>4000</td>
</tr>
<tr>
<td>A</td>
<td>2856</td>
</tr>
<tr>
<td>HZ</td>
<td>2300</td>
</tr>
</tbody></table>
<h2 id="高通的色度调试"><a href="#高通的色度调试" class="headerlink" title="高通的色度调试"></a>高通的色度调试</h2><p>高通除了CCM校正颜色以外，还有ACE高级色度增强，可以对颜色进行微调。ACE 模块可增强空间色彩，同时不会影响其他颜色。<br>下面是各个参数对颜色造成的影响示意图<br><img src="https://image.qinxing.xyz/20200330183323.png" alt="高通色度调试"></p>
<h2 id="我们的测试标准"><a href="#我们的测试标准" class="headerlink" title="我们的测试标准"></a>我们的测试标准</h2><table>
<thead>
<tr>
<th>色温</th>
<th>imagetestSAT</th>
<th>ΔE*abmean</th>
<th>ΔE*abmax</th>
<th>WB ΔC</th>
</tr>
</thead>
<tbody><tr>
<td>D75</td>
<td>120%±5%</td>
<td>13</td>
<td>25</td>
<td>2</td>
</tr>
<tr>
<td>D65</td>
<td>120%±5%</td>
<td>13</td>
<td>25</td>
<td>2</td>
</tr>
<tr>
<td>D50</td>
<td>120%±5%</td>
<td>13</td>
<td>25</td>
<td>2</td>
</tr>
<tr>
<td>CWF</td>
<td>110%±5%</td>
<td>13</td>
<td>25</td>
<td>2</td>
</tr>
<tr>
<td>TL84</td>
<td>110%±5%</td>
<td>13</td>
<td>25</td>
<td>2</td>
</tr>
<tr>
<td>A</td>
<td>100%±5%</td>
<td>13</td>
<td>25</td>
<td>3</td>
</tr>
<tr>
<td>HZ</td>
<td>100%±5%</td>
<td>13</td>
<td>25</td>
<td>3</td>
</tr>
</tbody></table>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像效果调试</category>
      </categories>
      <tags>
        <tag>调试</tag>
        <tag>色彩</tag>
      </tags>
  </entry>
  <entry>
    <title>高通预览流实现60帧</title>
    <url>/posts/42980f77/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>首先需要实现高通平台采集帧率的切换，参考前一篇文章</p>
</blockquote>
<p>我们拍照和录像的数据流一直都是使用的预览流，由媒控去编码，实现拍照和录像的功能。高通的高帧率HFR模式需要在video流下实现，这就意味着我们的很多代码都失效了，加上初步配置video流出现异常的问题，最后还是决定在preview数据流上实现60帧采集</p>
<ol>
<li><p>首先我们需要工作在普通的预览模式，sensor配置文件中out_info的mode需要是SENSOR_DEFAULT_MODE，而非是SENSOR_HFR_MODE</p>
</li>
<li><p>相比于配置30帧，注意一下60帧需要的寄存器配置更多，主要是<code>global timing</code>。我们需要根据sensor手册修改60帧对应的寄存器列表<code>RES_1080P60_REG_ARRAY</code>，如下图：</p>
<p><img src="https://image.qinxing.xyz/20200520141455.png" alt></p>
</li>
<li><p>preview默认限制在最高30帧，我们修改到60帧</p>
</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mct_pipeline.c mct_pipeline_fill_dimensions_snapshot() #ifdef IPC_60FPS_SUPPORT   property_get("persist.camera.max.previewfps", fps_str, "60"); #else   property_get("persist.camera.max.previewfps", fps_str, "30"); #endif</span></span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li>注意在xml里面增加50帧和60帧的chromatix文件配置</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>帧率</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter 注意事项和总结</title>
    <url>/posts/e2f4e564/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>网络问题<br>卡在了resolving dependence<br>网络不行，需要把仓库改成阿里云或者增加代理配置<br>增加代理：在gradle.properties文件增加：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">org.gradle.jvmargs=-DsocksProxyHost=127.0.0.1 -DsocksProxyPort=10800</span><br><span class="line">systemProp.socks.proxyHost=127.0.0.1</span><br><span class="line">systemProp.socks.proxyPort=10800</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>出现<code>“\android\gradlew.bat" exited abnormally</code>的报错<br>先flutter doctor<br>a. 因为不接受某些Android许可证：运行<code>flutter doctor --android-licenses</code>，并接受所有许可证<br>b. sdk文件找不到：下载对应版本的sdk（从Android studio）下载</p>
</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><p>建议最好统一使用命名路由的管理方式，这将会带来如下好处：</p>
<ul>
<li>语义化更明确。</li>
<li>代码更好维护；如果使用匿名路由，则必须在调用Navigator.push的地方创建新路由页，这样不仅需要import新路由页的dart文件，而且这样的代码将会非常分散。</li>
<li>可以通过onGenerateRoute做一些全局的路由跳转前置处理逻辑。</li>
<li>不用传递值的路由用Navigator.pushNamed(context,”old_device_main”);需要传递值的路由用<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Navigator.push(</span><br><span class="line">                    context,</span><br><span class="line">                    MaterialPageRoute(</span><br><span class="line">                    builder: (BuildContext context) =></span><br><span class="line">                        CallSample(arguments: "124.108.21.113")));</span><br></pre></td></tr></tbody></table></figure>
onGenerateRoute 理论上是在每个路由跳转之前判断，但我的代码中不起作用，建议还是用上面的方法。 </li>
</ul>
</li>
<li><p>免费的icons: <a href="https://material.io/resources/icons/?style=baseline" target="_blank" rel="noopener">https://material.io/resources/icons/?style=baseline</a></p>
</li>
<li><p>数据持久化插件： <code>shared_preferences</code></p>
</li>
<li><p>生成json model命令： <code>flutter packages pub run json_model</code></p>
</li>
<li><p>使用<code>?.</code>来确认前操作数不为空</p>
</li>
<li><p>route的字符串名称尽量不要用/隔开，否则会找不到！可以把名字在class里面定义，其他地方引用就行</p>
</li>
<li><p>很多插件都需要sdk27,以及build tools也是27版本的，在Android studio中安装（安卓8.1)</p>
</li>
<li><p>初始化一个类的时候需要加（）！！！</p>
</li>
<li><p>node.js 程序管理：pm2，后台运行npm start程序，使用方法：<a href="https://blog.csdn.net/qq_32281471/article/details/91369344" target="_blank" rel="noopener">https://blog.csdn.net/qq_32281471/article/details/91369344</a></p>
</li>
<li><p>使用multi_image_picker插件的时候，注意需要在文件gradle.properties中加入</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">android.useAndroidX=true</span><br><span class="line">android.enableJetifier=true</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>插件就是与原生的java代码做个借口，flutter其实就是一个UI库，注意增加依赖的时候，settings.gradle和build.gradle都需要添加依赖，package名需要一致</p>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>linux</tag>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 入门</title>
    <url>/posts/49f1e1db/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="（一）简介"><a href="#（一）简介" class="headerlink" title="（一）简介"></a>（一）简介</h2><p>Docker 是一个开源的应用容器引擎,可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。<br>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<h3 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h3><p>• Web 应用的自动化打包和发布。<br>• 自动化测试和持续集成、发布。<br>• 在服务型环境中部署和调整数据库或其他的后台应用。<br>• 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</p>
<h3 id="Docker-的优点"><a href="#Docker-的优点" class="headerlink" title="Docker 的优点"></a>Docker 的优点</h3><p>• 1、简化程序：<br>    Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成。<br>• 2、避免选择恐惧症：<br>    如果你有选择恐惧症，还是资深患者。那么你可以使用 Docker 打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。<br>• 3、节省开支：<br>    一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。</p>
<p>我的理解是可以将依赖程序等打包好，就像一个镜像一下，下载下来可以直接用，省了一大堆的安装步骤</p>
<h3 id="介绍与优点"><a href="#介绍与优点" class="headerlink" title="介绍与优点"></a>介绍与优点</h3><p><a href="https://blog.csdn.net/nfzhlk/article/details/78430152" target="_blank" rel="noopener">https://blog.csdn.net/nfzhlk/article/details/78430152</a><br>可以在windows上使用</p>
<h2 id="（二）安装"><a href="#（二）安装" class="headerlink" title="（二）安装"></a>（二）安装</h2><p>从官网下载比较慢：<br>在这个DaoCloud网站可以快速下载<br><a href="https://www.jianshu.com/p/b21c508514ae" target="_blank" rel="noopener">https://www.jianshu.com/p/b21c508514ae</a><br><a href="https://www.cnblogs.com/mq0036/p/8512703.html" target="_blank" rel="noopener">https://www.cnblogs.com/mq0036/p/8512703.html</a></p>
<h3 id="加速"><a href="#加速" class="headerlink" title="加速"></a>加速</h3><p>Docker For Windows<br>在桌面右下角状态栏中右键 docker 图标，修改在 Docker Daemon 标签页中的 json ，把下面的地址:<br><a href="http://f1361db2.m.daocloud.io" target="_blank" rel="noopener">http://f1361db2.m.daocloud.io</a><br>加到” registry-mirrors”的数组里。点击 Apply 。</p>
<h3 id="pull报错"><a href="#pull报错" class="headerlink" title="pull报错"></a>pull报错</h3><p>在docker pull 镜像时一直报错：<br>Error response from daemon: Get <a href="https://registry-1.docker.io/v2/" target="_blank" rel="noopener">https://registry-1.docker.io/v2/</a>: dial tcp: lookup registry-1.docker.io on 10.0.2.3:53: server misbehaving<br>一开始以为服务器挂了，后来觉得不太可能，就网上搜了下，原来是dns服务器的错误，把服务器改成8.8.8.8或者114.114.114.114即可<br>linux下安装不了也可能是DNS错误</p>
<h3 id="官网docker安装"><a href="#官网docker安装" class="headerlink" title="官网docker安装"></a>官网docker安装</h3><pre><code>1. 建立
Docker镜像是一个私有文件系统，仅适用于您的容器。它提供了容器所需的所有文件和代码。运行docker build命令可以使用Dockerfile创建Docker镜像。此构建的映像位于计算机的本地Docker映像注册表中。

cd doodle\cheers2019 ; docker build -t qinxing/cheers2019 .

2. run
docker run -it --rm qinxing/cheers2019
3. 分享
docker login ; docker push qinxing/cheers2019</code></pre><h2 id="（三）常用命令："><a href="#（三）常用命令：" class="headerlink" title="（三）常用命令："></a>（三）常用命令：</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker run ubuntu:15.10 /bin/echo "Hello world"</span><br><span class="line">docker run -i -t ubuntu:15.10 /bin/bash</span><br></pre></td></tr></tbody></table></figure>
<p>• -t:在新容器内指定一个伪终端或终端。<br>• -i:允许你对容器内的标准输入 (STDIN) 进行交互<br>• ubuntu:15.10指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。<br>• /bin/echo “Hello world”: 在启动的容器里执行的命令</p>
<ol>
<li>查看运行的容器：<code>docker ps</code></li>
<li>查看容器标准输出 ：<code>docker logs</code></li>
<li>载入镜像: <code>docker pull name</code></li>
<li><code>docker run -d -P training/webapp python app.py</code><ul>
<li>-d:让容器在后台运行。</li>
<li>-P:将容器内部使用的网络端口映射到我们使用的主机上。</li>
<li>-p : 是容器内部端口绑定到指定的主机端口。<br>可以通过 -p 参数来设置不一样的端口，前面的是主机端口，后者是docker端口<br><code>docker run -d -p 5000:5000 training/webapp python app.py</code></li>
</ul>
</li>
<li>查看docker底层信息： <code>docker inspect</code></li>
</ol>
<h2 id="（四）使用docker现成的xwiki模板来部署"><a href="#（四）使用docker现成的xwiki模板来部署" class="headerlink" title="（四）使用docker现成的xwiki模板来部署"></a>（四）使用docker现成的xwiki模板来部署</h2><h3 id="安装教程："><a href="#安装教程：" class="headerlink" title="安装教程："></a>安装教程：</h3><ol>
<li><a href="https://github.com/xwiki-contrib/docker-xwiki/blob/master/README.md#docker-run-example" target="_blank" rel="noopener">https://github.com/xwiki-contrib/docker-xwiki/blob/master/README.md#docker-run-example</a></li>
<li><a href="http://help.websoft9.com/lms-guide/xwiki/install.html" target="_blank" rel="noopener">http://help.websoft9.com/lms-guide/xwiki/install.html</a></li>
</ol>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>创建网络<br><code>docker network create -d bridge xwiki-nw</code></p>
</li>
<li><p>创建mysql<br><code>docker run --net=xwiki-nw --name mysql-xwiki -v /my/own/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=xwiki -e MYSQL_USER=xwiki -e MYSQL_PASSWORD=xwiki -e MYSQL_DATABASE=xwiki -d mysql:5.7 --character-set-server=utf8 --collation-server=utf8_bin --explicit-defaults-for-timestamp=1</code></p>
</li>
<li><p>创建xwiki<br><code>docker run -d --net=xwiki-nw --name xwiki -p 0.0.0.0:8080:8080 -v /my/own/xwiki:/usr/local/xwiki -e DB_USER=xwiki -e DB_PASSWORD=xwiki -e DB_DATABASE=xwiki -e DB_HOST=mysql-xwiki xwiki:mysql-tomcat</code></p>
</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>外网可以访问需要指定IP：0.0.0.0<br>之前是127.0.0.1，结果外网无法访问，需要改成0.0.0.0。要去搞清楚两者的区别。</li>
</ol>
<h3 id="TIPS-0-0-0-0-127-0-0-1和localhost之间有什么区别？"><a href="#TIPS-0-0-0-0-127-0-0-1和localhost之间有什么区别？" class="headerlink" title="TIPS:0.0.0.0,127.0.0.1和localhost之间有什么区别？"></a>TIPS:0.0.0.0,127.0.0.1和localhost之间有什么区别？</h3><h4 id="127-0-0-1"><a href="#127-0-0-1" class="headerlink" title="127.0.0.1"></a>127.0.0.1</h4><p>是个（特殊的）IP地址，往往被分配给了loopback或仅局域网可以访问的接口本地接口<br>这是一个伪照的，假的，网络适配器，其只能于同主机的主机内通信<br>常用于：让一个可以支持网络的程序，仅仅响应于同主机的主机内的客户端<br>一个程序监听127.0.0.1的话，则只能接受来自于本地的访问</p>
<h4 id="localhost"><a href="#localhost" class="headerlink" title="localhost"></a>localhost</h4><p>往往是127.0.0.1这个IP地址的主机名的主机名</p>
<ul>
<li>Linux的中是在/etc/hosts中设置的</li>
<li>windows中等价于host，往往在％WINDIR％中设置的<ul>
<li>换句话说，你也可以设置为其它名字</li>
<li>ping localhost，则会输出：127.0.0.1</li>
</ul>
</li>
</ul>
<h4 id="0-0-0-0"><a href="#0-0-0-0" class="headerlink" title="0.0.0.0"></a>0.0.0.0</h4><p>本身包含很多方面的含义，但是此处指的是：<br>当一个服务器监听这个IP地址的话，意味着：监听所有的网络请求<br>（对应着IP地址为127.0.0.1的）回送这个适配器适配器的请求，就像其它本机中的其它的网络适配器一样。<br>如果一个服务器有两个IP地址：192.168.1.1和10.1.2.1，则本机中的一个服务监听0.0.0.0的话，则两个IP地址都可以访问该服务</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>高通660平台实现实时切换采集帧率</title>
    <url>/posts/7945ca2a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="配置及代码改动（ROM"><a href="#配置及代码改动（ROM" class="headerlink" title="配置及代码改动（ROM)"></a>配置及代码改动（ROM)</h2><h3 id="（一）寄存器配置"><a href="#（一）寄存器配置" class="headerlink" title="（一）寄存器配置"></a>（一）寄存器配置</h3><p>按照已经配置好的imx327.lib.h为例，之后新的sensor可以照着配置</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">.out_info_array =</span><br><span class="line">    {</span><br><span class="line">        .out_info =</span><br><span class="line">        {</span><br><span class="line">            #<span class="keyword">if</span> IMX327_INC_RES_1920x1080P25</span><br><span class="line">            {</span><br><span class="line">                .x_output           = <span class="number">1948</span>, <span class="comment">/* 4+8+1920+9+4+3 */</span></span><br><span class="line">                .y_output           = <span class="number">1097</span>, <span class="comment">/* 8+1080+9 */</span></span><br><span class="line">                .line_length_pclk   = <span class="number">5280</span>,</span><br><span class="line">                .frame_length_lines = <span class="number">1125</span>,</span><br><span class="line">                .vt_pixel_clk       = <span class="number">148500000</span>,</span><br><span class="line">                .op_pixel_clk       = <span class="number">237600000</span>,</span><br><span class="line">                .binning_factor     = <span class="number">1</span>,</span><br><span class="line">                .min_fps            = <span class="number">12.5</span>,</span><br><span class="line">                .max_fps            = <span class="number">25.0</span>,</span><br><span class="line">                .mode               = SENSOR_DEFAULT_MODE,</span><br><span class="line">                .offset_x           = <span class="number">0</span>,</span><br><span class="line">                .offset_y           = <span class="number">0</span>,</span><br><span class="line">                .scale_factor       = <span class="number">0</span>,</span><br><span class="line">            },</span><br><span class="line">           #endif</span><br><span class="line">            #<span class="keyword">if</span> IMX327_INC_RES_1920x1080P30</span><br><span class="line">            {</span><br><span class="line">                .x_output           = <span class="number">1948</span>, <span class="comment">/* 4+8+1920+9+4+3 */</span></span><br><span class="line">                .y_output           = <span class="number">1097</span>, <span class="comment">/* 8+1080+9 */</span></span><br><span class="line">                .line_length_pclk   = <span class="number">4400</span>,</span><br><span class="line">                .frame_length_lines = <span class="number">1125</span>,</span><br><span class="line">                .vt_pixel_clk       = <span class="number">148500000</span>,<span class="comment">//74250000,</span></span><br><span class="line">                .op_pixel_clk       = <span class="number">237600000</span>,<span class="comment">//74250000, //DDR 92.8125,4 lane,10bit</span></span><br><span class="line">                .binning_factor     = <span class="number">1</span>,</span><br><span class="line">                .min_fps            = <span class="number">15.0</span>,</span><br><span class="line">                .max_fps            = <span class="number">30.0</span>,</span><br><span class="line">                .mode               = SENSOR_DEFAULT_MODE,</span><br><span class="line">                .offset_x           = <span class="number">0</span>,</span><br><span class="line">                .offset_y           = <span class="number">0</span>,</span><br><span class="line">                .scale_factor       = <span class="number">0</span>,</span><br><span class="line">            },</span><br><span class="line">           #endif</span><br><span class="line">           ...</span><br><span class="line">        },</span><br><span class="line">        .<span class="built_in">size</span> = <span class="number">0</span></span><br><span class="line">        #<span class="keyword">if</span> IMX327_INC_RES_1920x1080P25</span><br><span class="line">         +<span class="number">1</span></span><br><span class="line">        #endif</span><br><span class="line">        #<span class="keyword">if</span> IMX327_INC_RES_1920x1080P30</span><br><span class="line">         +<span class="number">1</span></span><br><span class="line">        #endif</span><br><span class="line">         ...</span><br><span class="line">        ,</span><br><span class="line">    },</span><br></pre></td></tr></tbody></table></figure>

<h3 id="（二）寄存器选择"><a href="#（二）寄存器选择" class="headerlink" title="（二）寄存器选择"></a>（二）寄存器选择</h3><p>由于原生高通代码没有切换sensor采集帧率的功能，我们只是在此基础上修改。<br>out_info_array是每组寄存器配置的属性。sensor_pick_res.c文件中sensor_pick_resolution则是根据上层设置的帧率分辨率等去选择最适合的一组寄存器值。<br>但是由于这个原先是用来设置分辨率的，相同分辨率的情况下它永远会选择第一套配置，这就导致我们不能根据帧率切换寄存器。因此注释掉下面的函数。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_FPS_SWITCH</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">sensor_pick_check_aspect_ratio</span><span class="params">(<span class="keyword">sensor_pick_data_t</span> *pick_data)</span></span></span><br><span class="line"><span class="function"> </span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> IPC_FPS_SWITCH</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  ......</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="（三）xml配置"><a href="#（三）xml配置" class="headerlink" title="（三）xml配置"></a>（三）xml配置</h3><p>每组分辨率以及帧率都有对应的chromatix头文件，如果没有进行配置，会出现没有图像或者崩溃的情况。需要注意！</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag"><<span class="name">ChromatixName</span> <span class="attr">sensor_resolution_index</span>=<span class="string">"0"</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">ISPPreview</span>></span>imx327_preview<span class="tag"></<span class="name">ISPPreview</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">ISPSnapshot</span>></span>imx327_preview<span class="tag"></<span class="name">ISPSnapshot</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">ISPVideo</span>></span>imx327_preview<span class="tag"></<span class="name">ISPVideo</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">CPPPreview</span>></span>imx327_cpp_preview<span class="tag"></<span class="name">CPPPreview</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">CPPSnapshot</span>></span>imx327_cpp_preview<span class="tag"></<span class="name">CPPSnapshot</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">CPPVideo</span>></span>imx327_cpp_preview<span class="tag"></<span class="name">CPPVideo</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">CPPLiveshot</span>></span>imx327_cpp_preview<span class="tag"></<span class="name">CPPLiveshot</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">A3Preview</span>></span>imx327_default_preview_3a<span class="tag"></<span class="name">A3Preview</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">A3Video</span>></span>imx327_default_preview_3a<span class="tag"></<span class="name">A3Video</span>></span></span><br><span class="line"><span class="tag"></<span class="name">ChromatixName</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">ChromatixName</span> <span class="attr">sensor_resolution_index</span>=<span class="string">"1"</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">ISPPreview</span>></span>imx327_preview<span class="tag"></<span class="name">ISPPreview</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">ISPSnapshot</span>></span>imx327_preview<span class="tag"></<span class="name">ISPSnapshot</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">ISPVideo</span>></span>imx327_preview<span class="tag"></<span class="name">ISPVideo</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">CPPPreview</span>></span>imx327_cpp_preview<span class="tag"></<span class="name">CPPPreview</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">CPPSnapshot</span>></span>imx327_cpp_preview<span class="tag"></<span class="name">CPPSnapshot</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">CPPVideo</span>></span>imx327_cpp_preview<span class="tag"></<span class="name">CPPVideo</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">CPPLiveshot</span>></span>imx327_cpp_preview<span class="tag"></<span class="name">CPPLiveshot</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">A3Preview</span>></span>imx327_default_preview_3a<span class="tag"></<span class="name">A3Preview</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">A3Video</span>></span>imx327_default_preview_3a<span class="tag"></<span class="name">A3Video</span>></span></span><br></pre></td></tr></tbody></table></figure>

<p>有几组寄存器配置，sensor_resolution_index就需要写几组。</p>
<h3 id="（四）能力集配置"><a href="#（四）能力集配置" class="headerlink" title="（四）能力集配置"></a>（四）能力集配置</h3><p>由于媒控设置帧率的时候需要检测设备是否支持这个帧率，这就需要提供该设备的能力集，告诉媒控我们支持哪些帧率。帧率的能力集不仅仅是我们lib.h中配置的那几个帧率，还有高通默认帧率，这就可能出现设备并不支持这个帧率，能力集中却依旧有的情况。因此我们把默认支持的帧率清空，让这个能力集呈现出来的全部都是我们自己配置的。<br><strong>注意：</strong>部分8953设备不支持，因为老媒控检测到能力集中没有30帧，会停止采集，如果想设置25帧，会出现没有图像的情况。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mct_pipeline.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_FPS_SWITCH</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">cam_fps_range_t</span> default_fps_ranges[] = {</span><br><span class="line">#ifdef IPC_FPS_SWITCH</span><br><span class="line">  {  <span class="number">0.0</span>,  <span class="number">0.0</span>,  <span class="number">0.0</span>,  <span class="number">0.0</span>},</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">   { <span class="number">15.0</span>, <span class="number">15.0</span>, <span class="number">15.0</span>, <span class="number">15.0</span>},</span><br><span class="line">   { <span class="number">20.0</span>, <span class="number">20.0</span>, <span class="number">20.0</span>, <span class="number">20.0</span>},</span><br><span class="line">   { <span class="number">24.0</span>, <span class="number">24.0</span>, <span class="number">24.0</span>, <span class="number">24.0</span>},</span><br><span class="line">   { <span class="number">30.0</span>, <span class="number">30.0</span>, <span class="number">30.0</span>, <span class="number">30.0</span>},</span><br><span class="line">   { <span class="number">60.0</span>, <span class="number">60.0</span>, <span class="number">60.0</span>, <span class="number">60.0</span>},</span><br><span class="line">#endif</span><br><span class="line"> };</span><br></pre></td></tr></tbody></table></figure>
<h3 id="（五）hal层设置代码修改"><a href="#（五）hal层设置代码修改" class="headerlink" title="（五）hal层设置代码修改"></a>（五）hal层设置代码修改</h3><h4 id="1-帧率设置需要重启"><a href="#1-帧率设置需要重启" class="headerlink" title="1. 帧率设置需要重启"></a>1. 帧率设置需要重启</h4><p>采集帧率只有在camera启动的时候才会去设置。高通设置参数有两种方式，一种是不需要重启，一种是重启才能把参数设置进去。原生的程序没有去修改采集帧率，所以走的是需要重启的方式。</p>
<p>如果想让设置参数之后重启camera，只需要加上一句<code>m_bNeedRestart = true;</code>。</p>
<h4 id="2-删除其他可能对帧率造成影响的代码"><a href="#2-删除其他可能对帧率造成影响的代码" class="headerlink" title="2. 删除其他可能对帧率造成影响的代码"></a>2. 删除其他可能对帧率造成影响的代码</h4><p>防止帧率对，删去温度对帧率的影响代码</p>
<h4 id="3-需要将帧率立刻传到vendor层"><a href="#3-需要将帧率立刻传到vendor层" class="headerlink" title="3. 需要将帧率立刻传到vendor层"></a>3. 需要将帧率立刻传到vendor层</h4><p><strong>注意：</strong>在<code>ADD_SET_PARAM_ENTRY_TO_BATCH</code>之后需要加上<code>rc = commitSetBatch();</code>,让帧率立刻传递到vendor层，否则可能会出现启动之后帧率还没有传下去，用的是上一次的值的BUG。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">QCameraParameters::setPreviewFpsRange</span><span class="params">(<span class="keyword">int</span> min_fps,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> max_fps, <span class="keyword">int</span> vid_min_fps,<span class="keyword">int</span> vid_max_fps)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int32_t</span> rc = NO_ERROR;</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> REMOVE_THERMAL_ADJUST</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> != m_AdjustFPS ) {</span><br><span class="line">        <span class="keyword">if</span> (m_ThermalMode == QCAMERA_THERMAL_ADJUST_FPS &&</span><br><span class="line">                !m_bRecordingHint_new) {</span><br><span class="line">            <span class="keyword">float</span> minVideoFps = min_fps, maxVideoFps = max_fps;</span><br><span class="line">            <span class="keyword">if</span> (isHfrMode()) {</span><br><span class="line">                minVideoFps = m_hfrFpsRange.video_min_fps;</span><br><span class="line">                maxVideoFps = m_hfrFpsRange.video_max_fps;</span><br><span class="line">            }</span><br><span class="line">            m_AdjustFPS->recalcFPSRange(min_fps, max_fps, minVideoFps,</span><br><span class="line">                                         maxVideoFps, fps_range, m_bRecordingHint_new);</span><br><span class="line">            LOGH(<span class="string">"Thermal adjusted Preview fps range %3.2f,%3.2f, %3.2f, %3.2f"</span>,</span><br><span class="line">                   fps_range.min_fps, fps_range.max_fps,</span><br><span class="line">                  fps_range.video_min_fps, fps_range.video_max_fps);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (ADD_SET_PARAM_ENTRY_TO_BATCH(m_pParamBuf, CAM_INTF_PARM_FPS_RANGE, fps_range)) {</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> IPC_SET_FPS</span></span><br><span class="line">    rc = commitSetBatch();</span><br><span class="line">    <span class="keyword">if</span> (rc != NO_ERROR) {</span><br><span class="line">        LOGE(<span class="string">"Failed to parameter changes"</span>);</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    }</span><br><span class="line">    m_bNeedRestart = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="对外接口（ispctrl部分）"><a href="#对外接口（ispctrl部分）" class="headerlink" title="对外接口（ispctrl部分）"></a>对外接口（ispctrl部分）</h2><h3 id="（一）帧率切换代码逻辑"><a href="#（一）帧率切换代码逻辑" class="headerlink" title="（一）帧率切换代码逻辑"></a>（一）帧率切换代码逻辑</h3><p>高通配置sensor输出帧率只有在sensor启动时设置分辨率的时候进行配置。寄存器手册中也要求设置帧率等寄存器时需要先让sensor进入standby模式。也就是说设置帧率的时候，得重启一下。之前切换帧率是媒控帮忙停流，我们再去设置帧率，会浪费比较多的时间。现在我们可以在hal层设置参数后让sensor重启，减少了需要重新设置的模块，实测切换速度不少。<br>这样帧率可以我们自己控制，我们可以提供给外部接口，这就需要修改ispctrl层的代码。</p>
<h3 id="（二）ispctrl接口修改"><a href="#（二）ispctrl接口修改" class="headerlink" title="（二）ispctrl接口修改"></a>（二）ispctrl接口修改</h3><h4 id="解除帧率与抗闪烁的绑定"><a href="#解除帧率与抗闪烁的绑定" class="headerlink" title="解除帧率与抗闪烁的绑定"></a>解除帧率与抗闪烁的绑定</h4><p>50Hz的抗闪烁要求快门是1/100的整数倍，60Hz的抗闪烁要求快门是1/120的整数倍。帧率是限制了快门的最大值，30帧意味着快门最大1/30，但是同样是可以支持50Hz的抗闪烁。25帧也可以支持60Hz的抗闪烁，这两者并没有必然联系。因此将它们之间的联系去除。<br><strong>注意：</strong>25帧的采集帧率，有利于50Hz供电频率的抗闪烁。即使曝光时间小于10ms，25帧仍然可以让日光灯产生条纹带稳定在图像的同一个位置。如果是30帧，条纹就会不停的跳动，让人难以接受。所以最后还是加上了采集帧率和抗闪烁的绑定，不过优化了代码结构。</p>
<h3 id="（三）平台的适配"><a href="#（三）平台的适配" class="headerlink" title="（三）平台的适配"></a>（三）平台的适配</h3><p>apq8056_one是比较老的设备，更注重稳定性，不会去解除绑定帧率与抗闪烁的关系</p>
<p>平台的识别，取自媒控</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">platform_e <span class="title">GetPlatform</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    FILE *pfile;</span><br><span class="line">    <span class="keyword">char</span> tmp[<span class="number">128</span>], *buf;</span><br><span class="line">    <span class="keyword">static</span> s32 is_first = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> platform_e platform = PLATFORM_UNKNOWN;</span><br><span class="line">    <span class="keyword">if</span> (is_first)</span><br><span class="line">    {</span><br><span class="line">        is_first = <span class="number">0</span>;</span><br><span class="line">        pfile = fopen(<span class="string">"/proc/cpuinfo"</span>, <span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">if</span> (pfile == <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            PRINT(<span class="string">"open %s error\n"</span>, <span class="string">"/proc/cpuinfo"</span>);</span><br><span class="line">            <span class="keyword">return</span> PLATFORM_UNKNOWN;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            buf = fgets(tmp, <span class="keyword">sizeof</span>(tmp), pfile);</span><br><span class="line">            <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                PRINT(<span class="string">"%s fgets error\n"</span>, __func__);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(tmp, <span class="string">"Hardware"</span>, <span class="number">8</span>))</span><br><span class="line">            {</span><br><span class="line">                PRINT(<span class="string">"%s\n"</span>, tmp);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strstr</span>(tmp, <span class="string">"8076"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">                {</span><br><span class="line">                    platform = PLATFORM_QCOM8076;</span><br><span class="line">                    PRINT(<span class="string">"this platfom is qcom 8076\n"</span>);</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strstr</span>(tmp, <span class="string">"8056"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">                {</span><br><span class="line">                    platform = PLATFORM_QCOM8056;</span><br><span class="line">                    PRINT(<span class="string">"this platfom is qcom 8056\n"</span>);</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strstr</span>(tmp, <span class="string">"8094"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">                {</span><br><span class="line">                    platform = PLATFORM_QCOM8094;</span><br><span class="line">                    PRINT(<span class="string">"this platfom is qcom 8094\n"</span>);</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strstr</span>(tmp, <span class="string">"8939"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">                {</span><br><span class="line">                    platform = PLATFORM_QCOM8939;</span><br><span class="line">                    PRINT(<span class="string">"this platfom is qcom 8039\n"</span>);</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strstr</span>(tmp, <span class="string">"SDM660"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">                {</span><br><span class="line">                platform = PLATFORM_SDM660;</span><br><span class="line">                PRINT(<span class="string">"this platfom is SDM660\n"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">       fclose(pfile);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> platform;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="（四）遇到过的问题"><a href="#（四）遇到过的问题" class="headerlink" title="（四）遇到过的问题"></a>（四）遇到过的问题</h3><p>现象：图像偶尔会闪烁</p>
<p>排查结果：采集帧率在25帧和30帧跳动，ispctrl收到业务设置的帧率值也在25和30帧跳动</p>
<p>原因：业务那边做过一个根据网络状况改变帧率的逻辑。很可能是由于网络问题，导致设置的帧率一直在跳动，需要让业务修改或者去掉这个逻辑。</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>帧率</tag>
      </tags>
  </entry>
  <entry>
    <title>AWB调试总结</title>
    <url>/posts/1185222e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="一-基础的AWB调试步骤"><a href="#一-基础的AWB调试步骤" class="headerlink" title="一. 基础的AWB调试步骤"></a>一. 基础的AWB调试步骤</h2><h3 id="1-调试-AWB-参考点（reference-points）"><a href="#1-调试-AWB-参考点（reference-points）" class="headerlink" title="1.调试 AWB 参考点（reference points）"></a>1.调试 AWB 参考点（reference points）</h3><p>灰色的参考点用来为 AWB 计算确定<strong>灰色区</strong></p>
<h3 id="2-调试室内和室外指数（indoor-and-outdoor-index）"><a href="#2-调试室内和室外指数（indoor-and-outdoor-index）" class="headerlink" title="2.调试室内和室外指数（indoor and outdoor index）"></a>2.调试室内和室外指数（indoor and outdoor index）</h3><p>室内和室外指数参数区分室内/室外， 以及日光直射与阴天/暗光条件。 这是许多<strong>启发式算法、 插值和阈值</strong>的基础。</p>
<h3 id="3-调试异常值距离（outlier-distance）"><a href="#3-调试异常值距离（outlier-distance）" class="headerlink" title="3.调试异常值距离（outlier distance）"></a>3.调试异常值距离（outlier distance）</h3><p>异常值距离是从参考点/线到灰色区边界的距离。 它会建立<strong>灰色区的范围</strong></p>
<h3 id="4-调试绿色区（green-zone）"><a href="#4-调试绿色区（green-zone）" class="headerlink" title="4.调试绿色区（green zone）"></a>4.调试绿色区（green zone）</h3><p>绿色区用于检测室外的绿色场景。 室外绿色的树叶颜色对应于 F/A 区中的灰色。 AWB使用<strong>绿色启发式算法</strong>来做出正确决策。</p>
<h3 id="5-调试弱光-LUT（-low-light-LUT）"><a href="#5-调试弱光-LUT（-low-light-LUT）" class="headerlink" title="5.调试弱光 LUT（ low light LUT）"></a>5.调试弱光 LUT（ low light LUT）</h3><p>弱光 LUT 用于<strong>增大异常值并平移绿色区</strong>， 以便在弱光条件下采集灰色和绿色统计数据并且 AWB 可以做出正确决策。</p>
<h2 id="二-高级的AWB调试步骤"><a href="#二-高级的AWB调试步骤" class="headerlink" title="二. 高级的AWB调试步骤"></a>二. 高级的AWB调试步骤</h2><h3 id="1-调试光源权重向量（illuminant-weight-vectors）"><a href="#1-调试光源权重向量（illuminant-weight-vectors）" class="headerlink" title="1.调试光源权重向量（illuminant weight vectors）"></a>1.调试光源权重向量（illuminant weight vectors）</h3><p>不同光照下设置各个色温不同的权重值，调整AWB颜色喜好，一共13个Region trigger:exp_index<br><img src="https://image.qinxing.xyz/20200330181617.png" alt="AWB 光源权重"></p>
<h3 id="2-调试极端蓝色-Blue-Sky-Params"><a href="#2-调试极端蓝色-Blue-Sky-Params" class="headerlink" title="2.调试极端蓝色(Blue Sky Params)"></a>2.调试极端蓝色(Blue Sky Params)</h3><p>极端蓝色调试将检测蓝天颜色， 避免出现<strong>天空发紫</strong>的问题。</p>
<h3 id="3-调试高级绿色区-AWB-Green-Tuning"><a href="#3-调试高级绿色区-AWB-Green-Tuning" class="headerlink" title="3.调试高级绿色区(AWB Green Tuning)"></a>3.调试高级绿色区(AWB Green Tuning)</h3><p>设置阈值，以及斜率之类，调整绿区启发式颜色的风格</p>
<h3 id="4-调试误导性颜色区（AWB-Misleading-Zone-Process）"><a href="#4-调试误导性颜色区（AWB-Misleading-Zone-Process）" class="headerlink" title="4.调试误导性颜色区（AWB Misleading Zone Process）"></a>4.调试误导性颜色区（AWB Misleading Zone Process）</h3><p>在一些极端情况中， 如果 AWB 受到有效灰色区域中包含的非灰色颜色对象的统计数据的误导， 则会出现 AWB 准确性问题。 AWB 算法将使用误导性颜色 (MLC) 区域将非灰色颜色对象的统计数据从有效灰色区域中排除， 从而提高准确性。<br><img src="https://image.qinxing.xyz/20200330181651.png" alt="误导性颜色区的位置"><br><img src="https://image.qinxing.xyz/20200330181711.png" alt="误导性区域参数说明"><br><img src="https://image.qinxing.xyz/20200330181730.png" alt="室内外index定义"></p>
<h3 id="5-调试-AWB-增益调整（AWB-Adjust-Gain-Tables）"><a href="#5-调试-AWB-增益调整（AWB-Adjust-Gain-Tables）" class="headerlink" title="5.调试 AWB 增益调整（AWB Adjust Gain Tables）"></a>5.调试 AWB 增益调整（AWB Adjust Gain Tables）</h3><p>AWB 增益调整的增益与 R 通道和 B 通道的增益对应相乘， 得到最终的 AWB 增益。根据预览和快照模式下的相关色温（ CCT） 输出， 确定调整相应光照的 AWB 增益<br><img src="https://image.qinxing.xyz/20200330181812.png" alt="AWB增益调整"></p>
<h3 id="6-调试预闪光-AWB（AWB-Pre-flash）"><a href="#6-调试预闪光-AWB（AWB-Pre-flash）" class="headerlink" title="6.调试预闪光 AWB（AWB Pre-flash）"></a>6.调试预闪光 AWB（AWB Pre-flash）</h3><p>闪光灯 AWB 算法使用单 LED 手动白平衡增益来计算最终的主闪光灯 AWB 增益。 上述功能通过混合不同照度条件下最后的无闪光灯预览 AWB 增益来实现。 该算法无法克服 LED偏差， 因为 LED 手动白平衡增益是单一且根据标准 LED 样本修正的。预闪光 AWB 算法使用源于预闪光的 AWB 统计数据， 可预测最终的闪光灯 AWB 增益，以克服 LED 样本的偏差并使 LED 最小和最大样本的闪光灯 IQ 尽可能相似。</p>
<h3 id="7-调试距离权重表（Dist-Weight-Table）-不修改"><a href="#7-调试距离权重表（Dist-Weight-Table）-不修改" class="headerlink" title="7.调试距离权重表（Dist Weight Table） 不修改"></a>7.调试距离权重表（Dist Weight Table） 不修改</h3><p>距离权重表包含灰色区中用于计算加权样本平均灰度世界（ R/G， B/G） 的有效统计数据权重。 权重值基于到最近参考点/线的统计数据距离。 与参考点/线的距离越近， 为每个有效样本分配的权重就应该越高（ 根据到参考点/线的距离） 。</p>
<h3 id="8-调整白色世界控制（AWB-White-World）-一般默认值"><a href="#8-调整白色世界控制（AWB-White-World）-一般默认值" class="headerlink" title="8.调整白色世界控制（AWB White World） 一般默认值"></a>8.调整白色世界控制（AWB White World） 一般默认值</h3><h3 id="9-AWB群集调试（AWB-Cluster-Tuning）"><a href="#9-AWB群集调试（AWB-Cluster-Tuning）" class="headerlink" title="9.AWB群集调试（AWB Cluster Tuning）"></a>9.AWB群集调试（AWB Cluster Tuning）</h3><p>解决大面积纯色偏色问题<br><img src="https://image.qinxing.xyz/20200330181838.png" alt="AWB群集调试代码位置"><br><img src="https://image.qinxing.xyz/20200330181902.png" alt="AWB群集调试公式"></p>
<h3 id="10-使用扩展室外启发式算法调试室外白平衡（Extended-OutdoorHeuristics）-选调"><a href="#10-使用扩展室外启发式算法调试室外白平衡（Extended-OutdoorHeuristics）-选调" class="headerlink" title="10.使用扩展室外启发式算法调试室外白平衡（Extended OutdoorHeuristics） 选调"></a>10.使用扩展室外启发式算法调试室外白平衡（Extended OutdoorHeuristics） 选调</h3><p>作用：</p>
<ul>
<li>在灰色统计数据不足的情况下提供良好的白平衡图像</li>
<li>针对客户喜好调整最终 AWB 决策</li>
</ul>
<ol>
<li>室外启发式AWB（special outdoor heuristics）<br><img src="https://image.qinxing.xyz/20200330181938.png" alt="室外启发式AWB"></li>
<li>调试 Green Adjust参数<br>即使绿色图像效果达到很好的平衡， 一些客户也可能要更改图像的整体色调， 使图像更加偏蓝或偏黄。</li>
<li>调试 Bright Blue Sky Adjust 参数<br>在曝光指数非常低、 也就是非常明亮的条件下， 调试明亮蓝天调节参数会使天空的颜色更蓝。 此功能假定已达到良好的白平衡效果， 并使用调节增益来更改最终决策.仅由亮度控制， 因此可能对其他场景有一些副作用</li>
<li>调试 Not Enough Stat Adjust 参数<br>即使图像包含的有效灰色统计数据很少， 通过 Not Enough Stat Adjust 参数调试过程也可实现良好的白平衡增益。 此过程适用于包含<strong>饱和颜色图像或单色图像.</strong></li>
<li>调试 Blue Ground Adjust 参数 <strong>不建议调</strong></li>
<li>天空调节(Sky Adjust)异常过程(有特定的白平衡目标点)<br>天空调节由三个不同的异常过程组成， 分别针对有云天空、 蓝天和雾天。 这三个过程的基本操作相同， 但使用不同参数来调节亮度和饱和度方面的特征差异。<br>Cloud Sky Adjust, Blue Sky Adjust, Fog Sky Adjust<br>与c区别：Bright Blue Sky Adjust 没有目标点； 它会将调节比应用到通过正常 AWB 过程获得的白平衡点。 相反， Sky Adjust 有特定的白平衡目标点； 它会将调节比应用到预定义的白平衡点。</li>
<li>调试 Green Detect Adjust 参数<br>绿色检测调节过程主要是为几乎达到 100% FOV 的绿色图像设置合适的白平衡点。与b区别：Green Adjust 没有目标点； 它会将调节比应用到计算得出的白平衡点， 比如加权样本平均值。 相反， Green Detect Adjust 有特定的白平衡目标点； 它会将调节比应用到预定义的白平衡点。</li>
<li>调试 No Day Weighted Sample Adjust 和 All Out of ZoneAdjust 参数<br>No Day Weighted Sample Adjust 和 All out of Zone Adjust 过程用于为非常极端的用例（ 即不存在有效采样的情况） 分配调节比。 强烈建议使用与 Not Enough StatsAdjust 参数相同的调节比<h3 id="11-A-H预热（Low-CCT-Scene-A-H-Warm-Up-）"><a href="#11-A-H预热（Low-CCT-Scene-A-H-Warm-Up-）" class="headerlink" title="11. A/H预热（Low CCT Scene (A/H) Warm Up ）"></a>11. A/H预热（Low CCT Scene (A/H) Warm Up ）</h3>低色温下图片偏暖调整<h2 id="三-AWB流程"><a href="#三-AWB流程" class="headerlink" title="三. AWB流程"></a>三. AWB流程</h2><img src="https://image.qinxing.xyz/20200330182012.png" alt="AWB流程"><h3 id="1-统计数据筛选操作"><a href="#1-统计数据筛选操作" class="headerlink" title="1. 统计数据筛选操作"></a>1. 统计数据筛选操作</h3>筛选统计数据样本， 作出初始 AWB 决策， 然后为启发式算法收集信息。<h3 id="2-启发式算法操作"><a href="#2-启发式算法操作" class="headerlink" title="2. 启发式算法操作"></a>2. 启发式算法操作</h3>检测特定场景并对光源进行估算， 以调整初始 AWB 决策， 实现决策准确性。<h3 id="3-调整操作"><a href="#3-调整操作" class="headerlink" title="3. 调整操作"></a>3. 调整操作</h3>根据喜好和特定场景调整白平衡增益。</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像效果调试</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 强制类型转换</title>
    <url>/posts/64e59afd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>在C语言中，强制类型转换存在两种等价形式：Type(Value)或(Type)Value。</p>
<p>而C++强调安全，不仅为用户提供了自定义类型转换的极大自由度，也在语法层面为类型转换可能会带来的各种错综复杂的情况作出了严谨的规定。</p>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>在<strong>编译</strong>期间，将值从一种数值类型转换为另一种数值类型，比如说从int转换成double型</p>
<h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>reinterpret，即“重新解释”，顾名思义，这个强制类型转换的作用是提供某个变量在底层数据上的重新解释。转换前后内存中的二进制值是不变的。当我们对一个变量使用reinterpretcast后，编译器将无视任何不合理行为，强行将被转换变量的内存数据重解释为某个新的类型。需要注意的是，reinterpretcast要求转换前后的类型所占用内存大小一致，否则将引发编译时错误。</p>
<p>比如将指针a转换成void*，reinterpret_cast < void * >a。</p>
<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>可以为一个变量强行增加或删除其const限定。</p>
<p>即使用户通过const_cast强行去除了const属性，也不代表当前变量从不可变变为了可变。constcast只是使得用户接管了编译器对于const限定的管理权，故用户必须遵守“不修改变量”的承诺。如果违反此承诺，编译器也不会因此而引发编译时错误，但可能引发运行时错误。</p>
<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>当一个静态类型为基类指针或引用的变量确实存放了继承类指针或引用时，从基类向继承类的类型转换，即向下类型转换理论上是可行的，dynamic_cast即用于在运行时实现向下类型转换。</p>
<h2 id="const的用法"><a href="#const的用法" class="headerlink" title="const的用法"></a>const的用法</h2><p>《The C++ Programming Language》里面给出过一个助记的方法：把一个声明从右向左读。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// * 读成 pointer to</span></span><br><span class="line"><span class="comment">// const只能属于前面的类型</span></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> cp;  </span><br><span class="line">cp is a <span class="keyword">const</span> pointer to <span class="keyword">char</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * p; </span><br><span class="line">p is a pointer to <span class="keyword">const</span> <span class="keyword">char</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>因此const char * 这样才可以确保字符串不被修改，当然如果想要改还是有办法的，这个只是在编辑器的层面不让修改。这样可以让自己的代码更加健全</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode使用技巧</title>
    <url>/posts/ac164e6c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ol>
<li>按住ctrl点击一下函数名，在当前窗口下跳转到定义。<br>按住ctrl点击两下函数名，跳转到定义并打开新窗口。</li>
<li>自定义快捷键：在使用终端情况下，ctrl+左右：切换聚焦的终端</li>
<li>ctrl+M放大或者缩小终端面板，ctrl+shift+M关闭终端面板</li>
<li>安装remote deployment实现远程开发遇到的问题（新版本已解决）：<ol>
<li>ssh连接失败，安装openssh之后，执行quitstart.txt中的命令，</li>
<li>连接失败，会提示realpath找不到，将远程服务器上的脚本server.sh第10行的(dirname”(realpath “0”)”)改成(dirname “$0”)</li>
</ol>
</li>
<li>行尾换行LF/CRLF切换：右下角LF/CRLF可以手动切换</li>
<li>F3/F4是跳转上一个和下一个搜索结果。对一个单词ctrl+d，就不需要ctrl+f，直接在本文中搜索</li>
<li>菜单和侧边栏的字体改不了大小，在设置中搜索zoomLevel，调整整体的放大等级即可</li>
<li>c++ 书写函数注释， /** 自动会出来， 紧接着的是函数名称，下面的是函数变量，变量值前面需要加上@，最后是函数的作用和意义，与上面的定义空出一行</li>
<li>vscode online 可以自己配置服务器，参考<a href="https://www.cnblogs.com/lee-li/p/12041546.html" target="_blank" rel="noopener">博客</a>，也可以使用腾讯的cloud studio(五人以下免费)</li>
</ol>
<h2 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h2><ol>
<li>settings.json:<br> pythonPath: 告诉你用的python.exe的地址</li>
<li>launch.json: 配置运行脚本<br> 比如python:<br> program:后面代表运行的文件<br> argv：代表后面运行的参数</li>
<li>ssh配置<br> 远程连接ssh服务器时需要加上两句话：<br> PreferredAuthentications publickey<br> PubkeyAuthentication yes</li>
<li>添加未定义的宏<br> 在c_cpp_properties.json中的configuration中增加一项<br> “defines”: [<pre><code>    "U2P_CAMERA_FEATURE"
],</code></pre></li>
</ol>
<h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><ol>
<li>Comment Translate: 很多API的注释都是英文的，对于英文不好的同学来说，都是煎熬，这个可以把函数定义等注释翻译成中文，简直是神奇</li>
<li>Remote Development: 远程开发神器！不用把代码下载下来，终端、端口映射、docker和代码管理特别方便</li>
<li>One Dark Pro: 推荐的主题</li>
<li>Prettier: 代码格式化</li>
<li>Markdown All in One: markdown必备插件</li>
<li>Live server: web实时预览</li>
<li>Gitlens: git加强版版本管理</li>
</ol>
<h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><ol>
<li><p>vscode的终端不能使用系统的环境变量</p>
<p>解决方法：</p>
<ol>
<li>首先关闭所有的vscode窗口</li>
</ol>
</li>
<li><p>在系统自带的终端中输入<code>code + 环境变量path</code>,这样打开的vscode，里面带的终端就带有系统环境变量了</p>
</li>
</ol>
<p>chmod 777 /data/misc/camera</p>
<p>setprop persist.camera.isp.dump_cnt 1</p>
<p>setprop persist.camera.isp.dump 0</p>
<p>setprop persist.camera.isp.dump 2 </p>
<p>adb pull /data/misc/camera Z:\liqinxing\test_photo\raw</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>工具</category>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>使用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>软件推荐</title>
    <url>/posts/c92482f1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="无损音乐下载神器-——-洛雪音乐助手"><a href="#无损音乐下载神器-——-洛雪音乐助手" class="headerlink" title="无损音乐下载神器 —— 洛雪音乐助手"></a>无损音乐下载神器 —— 洛雪音乐助手</h2><p>全网歌曲，基本上有的都能搜到<br>音质可选（大多都支持无损），下载很快，完全开源免费</p>
<blockquote>
<p><code>安装包URL</code>: <a href="https://files.qinxing.xyz/softwares/lx-music-desktop-v0.17.0-x86_64-Setup.exe" target="_blank" rel="noopener">https://files.qinxing.xyz/softwares/lx-music-desktop-v0.17.0-x86_64-Setup.exe</a><br><code>github地址</code>： <a href="https://github.com/lyswhut/lx-music-desktop/releases" target="_blank" rel="noopener">https://github.com/lyswhut/lx-music-desktop/releases</a></p>
</blockquote>
<h2 id="百度文库下载助手-——-冰点文库"><a href="#百度文库下载助手-——-冰点文库" class="headerlink" title="百度文库下载助手 —— 冰点文库"></a>百度文库下载助手 —— 冰点文库</h2><p>把百度文库的链接复制进去，就可以进行下载，可以到处pdf和txt两种格式<br>解压后运行即可</p>
<blockquote>
<p><code>安装包URL</code>: <a href="https://files.qinxing.xyz/softwares/Fish-v319-0228.zip" target="_blank" rel="noopener">https://files.qinxing.xyz/softwares/Fish-v319-0228.zip</a></p>
</blockquote>
</body></html>]]></content>
      <categories>
        <category>生活</category>
        <category>推荐</category>
      </categories>
      <tags>
        <tag>推荐</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>网站推荐</title>
    <url>/posts/b149eb90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h4 id="搞学习"><a href="#搞学习" class="headerlink" title="搞学习"></a>搞学习</h4><ul>
<li>知乎：<a href="http://www.zhihu.com" target="_blank" rel="noopener">www.zhihu.com</a></li>
<li>iData（论文搜索）：<a href="http://www.cn-ki.net" target="_blank" rel="noopener">www.cn-ki.net</a></li>
<li>鸠摩搜书：<a href="http://www.jiumodiary.com" target="_blank" rel="noopener">www.jiumodiary.com</a></li>
<li>网易公开课：<a href="https://open.163.com/ted/" target="_blank" rel="noopener">https://open.163.com/ted/</a></li>
<li>网易云课堂：<a href="https://study.163.com/" target="_blank" rel="noopener">https://study.163.com/</a></li>
<li>中国大学 MOOC：<a href="http://www.icourse163.org" target="_blank" rel="noopener">www.icourse163.org</a></li>
<li>B站：<a href="http://www.bilibili.com" target="_blank" rel="noopener">www.bilibili.com</a></li>
<li>猫咪论文：<a href="https://lunwen.im/" target="_blank" rel="noopener">https://lunwen.im/</a></li>
<li>码农之家（计算机电子书下载）：<a href="http://www.xz577.com" target="_blank" rel="noopener">www.xz577.com</a></li>
</ul>
<h4 id="小工具"><a href="#小工具" class="headerlink" title="小工具"></a>小工具</h4><ul>
<li>云端超级应用空间（PS，PPT，Excel，Ai）：<a href="https://uzer.me/" target="_blank" rel="noopener">https://uzer.me/</a></li>
<li>在线接口测试（Getman）：<a href="https://getman.cn/" target="_blank" rel="noopener">https://getman.cn/</a></li>
<li>二维码生成：<a href="https://cli.im/" target="_blank" rel="noopener">https://cli.im/</a></li>
<li>熵数（图表制作）：<a href="https://dydata.io/appv2/#/pages/index/home" target="_blank" rel="noopener">https://dydata.io/appv2/#/pages/index/home</a></li>
<li>图片无限变放大：<a href="http://bigjpg.com/zh" target="_blank" rel="noopener">http://bigjpg.com/zh</a></li>
<li>拷贝兔：<a href="https://cp.anyknew.com/" target="_blank" rel="noopener">https://cp.anyknew.com/</a></li>
<li>奶牛快传（在线传输文件利器）：<a href="https://cowtransfer.com/" target="_blank" rel="noopener">https://cowtransfer.com/</a></li>
<li>在线转换器（在线转换器转换任何测量单位）：<a href="https://zh.justcnw.com/" target="_blank" rel="noopener">https://zh.justcnw.com/</a></li>
<li>调查问卷制作：<a href="https://www.wenjuan.com/" target="_blank" rel="noopener">https://www.wenjuan.com/</a></li>
<li>果核剥壳（软件下载）：<a href="https://www.ghpym.com/" target="_blank" rel="noopener">https://www.ghpym.com/</a></li>
</ul>
<h4 id="资源搜索"><a href="#资源搜索" class="headerlink" title="资源搜索"></a>资源搜索</h4><ul>
<li>DogeDoge 搜索引擎：<a href="http://www.dogedoge.com" target="_blank" rel="noopener">www.dogedoge.com</a></li>
<li>秘迹搜索：<a href="https://mijisou.com/" target="_blank" rel="noopener">https://mijisou.com/</a></li>
<li>小白盘：<a href="https://www.xiaobaipan.com/" target="_blank" rel="noopener">https://www.xiaobaipan.com/</a></li>
<li>云盘精灵（资源搜索）：<a href="http://www.yunpanjingling.com" target="_blank" rel="noopener">www.yunpanjingling.com</a></li>
<li>虫部落（资源搜索）：<a href="http://www.chongbuluo.com" target="_blank" rel="noopener">www.chongbuluo.com</a></li>
<li>如风搜（资源搜索）：<a href="http://www.rufengso.net/" target="_blank" rel="noopener">http://www.rufengso.net/</a></li>
<li>爱扒：<a href="https://www.zyboe.com/" target="_blank" rel="noopener">https://www.zyboe.com/</a></li>
</ul>
<h4 id="导航页（工具集）"><a href="#导航页（工具集）" class="headerlink" title="导航页（工具集）"></a>导航页（工具集）</h4><ul>
<li>NiceTool.net 好工具网：<a href="http://www.nicetool.net/" target="_blank" rel="noopener">http://www.nicetool.net/</a></li>
<li>现实君工具箱（综合型在线工具集成网站）：<a href="http://tool.uixsj.cn/" target="_blank" rel="noopener">http://tool.uixsj.cn/</a></li>
<li>蓝调网站：<a href="http://lcoc.top/" target="_blank" rel="noopener">http://lcoc.top/</a></li>
<li>偷渡鱼：<a href="https://touduyu.com/" target="_blank" rel="noopener">https://touduyu.com/</a></li>
<li>牛导航：<a href="http://www.ziliao6.com/" target="_blank" rel="noopener">http://www.ziliao6.com/</a></li>
<li>小呆导航：<a href="https://www.webjike.com/index.html" target="_blank" rel="noopener">https://www.webjike.com/index.html</a></li>
<li>简法主页：<a href="http://www.jianfast.com/" target="_blank" rel="noopener">http://www.jianfast.com/</a></li>
<li>KIM 主页：<a href="https://kim.plopco.com/" target="_blank" rel="noopener">https://kim.plopco.com/</a></li>
<li>聚 BT：<a href="https://jubt.net/cn/index.html" target="_blank" rel="noopener">https://jubt.net/cn/index.html</a></li>
<li>精准云工具合集：<a href="https://jingzhunyun.com/" target="_blank" rel="noopener">https://jingzhunyun.com/</a></li>
<li>兔 2 工具合集：<a href="https://www.tool2.cn/" target="_blank" rel="noopener">https://www.tool2.cn/</a></li>
<li>爱资料工具（在线实用工具集合）：<a href="http://www.toolnb.com" target="_blank" rel="noopener">www.toolnb.com</a></li>
<li>工具导航：<a href="https://hao.logosc.cn/" target="_blank" rel="noopener">https://hao.logosc.cn/</a></li>
</ul>
<h4 id="看视频"><a href="#看视频" class="headerlink" title="看视频"></a>看视频</h4><ul>
<li>电影推荐（分类别致）：<a href="http://www.mvcat.com" target="_blank" rel="noopener">http://www.mvcat.com</a></li>
<li>去看 TV：<a href="https://www.qukantv.net/" target="_blank" rel="noopener">https://www.qukantv.net/</a></li>
<li>动漫视频网：<a href="http://www.zzzfun.com/" target="_blank" rel="noopener">http://www.zzzfun.com/</a></li>
<li>94 神马电影网：<a href="http://www.9rmb.com/" target="_blank" rel="noopener">http://www.9rmb.com/</a></li>
<li>NO 视频官网：<a href="http://www.novipnoad.com/" target="_blank" rel="noopener">http://www.novipnoad.com/</a></li>
<li>蓝光画质电影：<a href="http://www.languang.co/" target="_blank" rel="noopener">http://www.languang.co/</a></li>
<li>在线看剧：<a href="http://dy.27234.cn/" target="_blank" rel="noopener">http://dy.27234.cn/</a></li>
<li>大数据导航：<a href="http://hao.199it.com/" target="_blank" rel="noopener">http://hao.199it.com/</a></li>
<li>牛牛 TV：<a href="http://www.ziliao6.com/tv/" target="_blank" rel="noopener">http://www.ziliao6.com/tv/</a></li>
<li>蓝调网站：<a href="http://lcoc.top/vip2.3/" target="_blank" rel="noopener">http://lcoc.top/vip2.3/</a></li>
</ul>
<h4 id="学设计"><a href="#学设计" class="headerlink" title="学设计"></a>学设计</h4><ul>
<li>免费音频素材：<a href="https://icons8.cn/music" target="_blank" rel="noopener">https://icons8.cn/music</a></li>
<li>新 CG 儿（视频素材模板，无水印 + 免费下载）：<a href="https://www.newcger.com/" target="_blank" rel="noopener">https://www.newcger.com/</a></li>
<li>小图标下载：<a href="https://www.easyicon.net/" target="_blank" rel="noopener">https://www.easyicon.net/</a></li>
<li>第一字体转换器：<a href="http://www.diyiziti.com/" target="_blank" rel="noopener">http://www.diyiziti.com/</a></li>
<li>doyoudosh（平面设计）：<a href="http://www.doyoudo.com" target="_blank" rel="noopener">www.doyoudo.com</a></li>
<li>企业宣传视频在线制作：<a href="https://duomu.tv/" target="_blank" rel="noopener">https://duomu.tv/</a></li>
<li>MAKE 海报设计官网：<a href="http://maka.im/" target="_blank" rel="noopener">http://maka.im/</a></li>
<li>一键海报神器：<a href="https://www.logosc.cn/photo/?utmsource=hao.logosc.cn&utmmedium=referral" target="_blank" rel="noopener">https://www.logosc.cn/photo/?utmsource=hao.logosc.cn&utmmedium=referral</a></li>
<li>字由（字体设计）：<a href="http://www.hellofont.cn/" target="_blank" rel="noopener">http://www.hellofont.cn/</a></li>
<li>查字体网站：<a href="https://fonts.safe.360.cn/" target="_blank" rel="noopener">https://fonts.safe.360.cn/</a></li>
<li>爱给网（免费素材下载的网站，包括音效、配乐，3D、视频、游戏，平面、教程）：<a href="http://www.aigei.com/" target="_blank" rel="noopener">http://www.aigei.com/</a></li>
<li>在线视频剪辑：<a href="https://bilibili.clipchamp.com/editor" target="_blank" rel="noopener">https://bilibili.clipchamp.com/editor</a></li>
</ul>
<h4 id="搞文档"><a href="#搞文档" class="headerlink" title="搞文档"></a>搞文档</h4><ul>
<li>即书（在线制作 PPT）：<a href="https://www.keysuper.com/" target="_blank" rel="noopener">https://www.keysuper.com/</a></li>
<li>PPT 在线制作：<a href="https://www.woodo.cn/" target="_blank" rel="noopener">https://www.woodo.cn/</a></li>
<li>优品 PPT（模板下载）：<a href="http://www.ypppt.com/" target="_blank" rel="noopener">http://www.ypppt.com/</a></li>
<li>第一 PPT（模板下载）：<a href="http://www.1ppt.com/xiazai/" target="_blank" rel="noopener">http://www.1ppt.com/xiazai/</a></li>
</ul>
<ul>
<li>PDF 处理：<a href="https://smallpdf.com/cn" target="_blank" rel="noopener">https://smallpdf.com/cn</a></li>
<li>PDF 处理：<a href="https://www.ilovepdf.com/zh-cn" target="_blank" rel="noopener">https://www.ilovepdf.com/zh-cn</a></li>
<li>PDF 处理：<a href="https://www.pdfpai.com/" target="_blank" rel="noopener">https://www.pdfpai.com/</a></li>
</ul>
<ul>
<li><p>腾讯文档（在线协作编辑和管理文档）：<a href="https://docs.qq.com/" target="_blank" rel="noopener">https://docs.qq.com/</a></p>
</li>
<li><p>ProcessOn（在线协作制作结构图）：<a href="http://www.processon.com" target="_blank" rel="noopener">www.processon.com</a></p>
</li>
<li><p>福昕云编辑（在线编辑 PDF）：edit.foxitcloud.cn</p>
</li>
<li><p>UZER.ME（在线使用各种大应用，在线使用 CAD，MATLAB，Office 三件套）：uzer.me</p>
</li>
<li><p>三顿 PPT 导航：sandunppt.com</p>
</li>
</ul>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><ul>
<li>免费版权图片搜索：<a href="https://www.logosc.cn/so/" target="_blank" rel="noopener">https://www.logosc.cn/so/</a></li>
<li>壹伴图片搜索：<a href="https://yiban.io/image_editor" target="_blank" rel="noopener">https://yiban.io/image_editor</a></li>
<li>IMGBOT（在线图片处理）：<a href="http://www.imgbot.ai" target="_blank" rel="noopener">www.imgbot.ai</a></li>
<li>TinyPNG（在线压缩图片）：<a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a></li>
<li><a href="https://unsplash.com/" target="_blank" rel="noopener">https://unsplash.com/</a></li>
<li><a href="https://pixabay.com/" target="_blank" rel="noopener">https://pixabay.com/</a></li>
<li><a href="https://www.pexels.com/" target="_blank" rel="noopener">https://www.pexels.com/</a></li>
<li><a href="https://visualhunt.com/" target="_blank" rel="noopener">https://visualhunt.com/</a></li>
<li><a href="https://www.ssyer.com/" target="_blank" rel="noopener">https://www.ssyer.com/</a></li>
<li>电脑壁纸：<a href="http://lcoc.top/bizhi/" target="_blank" rel="noopener">http://lcoc.top/bizhi/</a></li>
<li>彼岸图网：<a href="http://pic.netbian.com/" target="_blank" rel="noopener">http://pic.netbian.com/</a></li>
<li>极像素（超高清大图）：<a href="https://www.sigoo.com/" target="_blank" rel="noopener">https://www.sigoo.com/</a></li>
</ul>
</body></html>]]></content>
      <categories>
        <category>生活</category>
        <category>推荐</category>
      </categories>
      <tags>
        <tag>网站</tag>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>v2ray 配置</title>
    <url>/posts/9e74e0b2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="1-服务端搭建"><a href="#1-服务端搭建" class="headerlink" title="1. 服务端搭建"></a>1. 服务端搭建</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">bash <(curl -s -L https://git.io/v2ray.sh)</span><br></pre></td></tr></tbody></table></figure>
<p>然后选择安装，即是输入 1 回车<br>选择传输协议，如果没有特别的需求，使用默认的 TCP 传输协议即可，直接回车<br>选择端口，如果没有特别的需求，使用默认的端口即可，直接回车<br>是否屏蔽广告，除非你真的需要，一般来说，直接回车即可<br>有什么疑问可以参考<a href="https://github.com/233boy/v2ray/wiki/V2Ray%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">wiki</a></p>
<h2 id="2-时间需要同步"><a href="#2-时间需要同步" class="headerlink" title="2. 时间需要同步"></a>2. 时间需要同步</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">timedatectl # 查看时间状态</span><br><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu</span></span><br><span class="line">sudo apt-get install -y ntp # 安装NTP服务</span><br><span class="line">systemctl ntp status # 查看NTP服务</span><br><span class="line"><span class="meta">#</span><span class="bash"> Centos</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo yum install chrony</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> timedatectl <span class="built_in">set</span>-timezone Asia/Shanghai <span class="comment"># 设置中国时区</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> timedatectl <span class="built_in">set</span>-ntp yes <span class="comment"># 启用NTP同步</span></span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-防火墙配置"><a href="#3-防火墙配置" class="headerlink" title="3. 防火墙配置"></a>3. 防火墙配置</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo ufw default deny</span><br><span class="line">sudo ufw enable</span><br><span class="line">sudo ufw allow 端口号 # 端口号是服务端v2ray配置的端口号</span><br></pre></td></tr></tbody></table></figure>
<p>可以参考<a href="https://www.cnblogs.com/exmyth/p/5770691.html" target="_blank" rel="noopener">防火墙配置文档</a></p>
<h2 id="4-客户端手册"><a href="#4-客户端手册" class="headerlink" title="4. 客户端手册"></a>4. 客户端手册</h2><p>参考[博客](<a href="https://tlanyan.me/v2ray-clients-download/" target="_blank" rel="noopener">https://tlanyan.me/v2ray-clients-download/</a></p>
<h3 id="iOS平台"><a href="#iOS平台" class="headerlink" title="iOS平台"></a>iOS平台</h3><p>注意ios/ipados端 已经下架，需要将apple id换成美区的，比较麻烦<br>这是我在网上找到的在线安装的网址，用safari浏览器打开即可：<a href="https://v2net.github.io/ios" target="_blank" rel="noopener">https://v2net.github.io/ios</a><br>登录共享APPLE ID，注意不能登录iCloud<br>如果这个网址不能用，可以在google搜索小火箭账号</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>v2ray</tag>
      </tags>
  </entry>
  <entry>
    <title>线程学习</title>
    <url>/posts/c3eb2d02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>深入解析锁和条件变量</p>
</blockquote>
<p>锁的概念：在CPU运行过程中，不会单一的取执行一个事件，而是通过线程，或者进程来进行执行，这样CPU的利用率才得以提高，但是在不同的线程之间，由于互相独立，那么对于资源的访问来说，就可能同时进行，假如A进程获取一个临时变量temp的值，但是在获取的同时，B进程却将temp的值改变了，这时就会出现资源访问的冲突，为了更好的解决这个问题，就有了锁的概念，说的明白些，他就像现实中的锁一样，我们程序中所有的资源，包括变量，内存等都存放在一个房子里，开始时，锁处于开锁状态，如果某一个线程需要访问资源时，就需要拿到这把锁，进到房子里，把门锁上，这样就不会有其他人来干扰你，等你对资源访问结束后，在把锁打开，放下锁，这样别人就可以进入，这样就保证了对资源访问的顺序，这种锁叫互斥锁，这种机制是我们所说的避免竞争。</p>
<p>条件变量：条件变量是线程同步的一种机制。它给多个线程提供一个回合场所。所谓的条件变量就是需要满足这个条件，才可以继续进行操作。</p>
<h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><h2 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h2><p>1)动态方式</p>
<p>int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr);<br>mutex   出参，互斥锁<br>attr    互斥锁的属性，NULL表示默认/缺省的属性</p>
<p>2)静态的方式<br>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;     //一般都选择静态方式</p>
<h2 id="加锁："><a href="#加锁：" class="headerlink" title="加锁："></a>加锁：</h2><p>int pthread_mutex_lock(pthread_mutex_t *mutex);<br>给mutex互斥锁加锁<br>1.互斥锁没有被锁：加锁<br>2.互斥锁已经被锁：阻塞/等待，直到被解锁，然后再对mutex互斥锁加锁</p>
<h2 id="解锁："><a href="#解锁：" class="headerlink" title="解锁："></a>解锁：</h2><p>int pthread_mutex_unlock(pthread_mutex_t *mutex);</p>
<h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><h2 id="什么是条件变量"><a href="#什么是条件变量" class="headerlink" title="什么是条件变量"></a>什么是条件变量</h2><p>条件变量是线程的另外一种同步机制，这些同步对象为线程提供了会合的场所，理解起来就是两个（或者多个）线程需要碰头（或者说进行交互-一个线程给另外的一个或者多个线程发送消息），我们指定在条件变量这个地方发生，一个线程用于修改这个变量使其满足其它线程继续往下执行的条件，其它线程则接收条件已经发生改变的信号。</p>
<p>（核心作用）条件变量同锁一起使用使得线程可以以一种<strong>无竞争</strong>的方式等待任意条件的发生。所谓无竞争就是，条件改变这个信号会发送到所有等待这个信号的线程。而不是说一个线程接受到这个消息而其它线程就接收不到了。</p>
<h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化:"></a>初始化:</h3><p>动态方式:<br>int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);<br>静态的方式：<br>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</p>
<h3 id="等待条件变量"><a href="#等待条件变量" class="headerlink" title="等待条件变量"></a>等待条件变量</h3><p>int pthread_cond_wait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex);</p>
<p>原子性的解锁并阻塞/等待条件变量。</p>
<h3 id="唤醒条件变量"><a href="#唤醒条件变量" class="headerlink" title="唤醒条件变量"></a>唤醒条件变量</h3><p>int pthread_cond_signal(pthread_cond_t *cond);</p>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>下例实现了生产者和消费者模型，生产者向队列中插入数据，消费者则在生产者发出<strong>队列准备好（有数据了）</strong>后接收消息，然后取出数据进行处理。实现的关键点在以下几个方面：</p>
<ul>
<li>生产者和消费者都对条件变量的使用加了锁</li>
<li>消费者调用pthread_cond_wait,等待队列是否准备好的信息，注意参数有两个，一个是pthread_cond_t，另外一个是pthread_mutex_t.</li>
</ul>
<p>代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">m_next</span>;</span></span><br><span class="line"><span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">workq</span>;</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> qready = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> qlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">process_msg(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">    pthread_mutex_lock(&qlock);</span><br><span class="line">    <span class="keyword">while</span> (workq == <span class="literal">NULL</span>)</span><br><span class="line">        pthread_cond_wait(&qready, &qlock);</span><br><span class="line">    mp = workq;</span><br><span class="line">    workq = mp->m_next;</span><br><span class="line">    pthread_mutex_unlock(&qlock);</span><br><span class="line">    <span class="comment">/* now process the message mp */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">enqueue_msg(struct msg *mp)</span><br><span class="line">{</span><br><span class="line">    pthread_mutex_lock(&qlock);</span><br><span class="line">    mp->m_next = workq;</span><br><span class="line">    workq = mp;</span><br><span class="line">    pthread_mutex_unlock(&qlock);</span><br><span class="line">    pthread_cond_signal(&qready);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="配合"><a href="#配合" class="headerlink" title="配合"></a>配合</h1><p>上面的是函数的介绍，为了方便查看，接下来说一下为什么cond和mutex要配合使用。</p>
<p>首先：在pthread_cond_wait()函数之前，要人为获取一把锁，在pthread_cond_wait()执行时，会自动释放这个锁，并且处于等待/阻塞条件，等待信号来临，一但信号来临，那么在pthread_cond_wait()函数调用返回之前，自动将指定的互斥量重新锁住，所以必须在pthread_cond_wait()之后再人为释放锁。其结实际用法为下：</p>
<p>pthread_mutex_lock(&mutex);         //加锁</p>
<p>pthread_cond_wait(&flag,&mutex); //等待，清除标记flag</p>
<p>pthread_mutex_unlock(&mutex);    //解锁<br>其次：对于pthread_cond_signal()函数有两种用法，第一种在加锁与解锁之间，第二种是在加锁解锁之后：</p>
<p>pthread_mutex_lock(&mutex);</p>
<p>pthread_cond_signal(&flag);</p>
<p>pthread_mutex_unlock(&mutex);</p>
<p>这种方式的缺点是：在某线程中，会遭虫等待线程从内核中唤醒(cond_signal是有内核发起的)，然后又回到内核空间(cond_wait返回后会有原子加锁的行为)，所以这一来一回会产生性能的问题，但是在Linux下或者NPTL里面不会，因为Linux线程中有两个队列即cond_wait和cond_signal两个队列，pthread_cond_signal()只是让线程在从wait队列移动到cond队列，不会再永和空间和内核之间往返，不会有应能损耗。</p>
<p>pthread_mutex_lock(&mutex);</p>
<p>pthread_mutex_unlock(&mutex);</p>
<p>pthread_cond_signal(&flag);<br>这种方式的缺点是：如果在unlock和signal之前有一个优先级更低的线程正在等待mutex的话，那么他就会抢占高优先级的线程，而上面的情况则不会出现。</p>
<p>优点是：不会产生性能的损耗，因为在signal之前就已经解锁了。</p>
<p>cond和mutex两个组合使用是为了避免，在一个线程中，如果在wait之前，另一个函数已经完成signal了，那么这个线程将阻塞在这里，从而错过了signal，所以用mutex来实现两个进程的同步，当我等待前上锁，等待后释放锁，然后另一个线程获取锁，产生signal信号，在释放锁。</p>
<h2 id="线程结束时发生死锁"><a href="#线程结束时发生死锁" class="headerlink" title="线程结束时发生死锁"></a>线程结束时发生死锁</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>媒控在红外的回调函数中，对ISP内部线程进行了关闭。在关闭函数中使用了pthread_cancel发送进程终止信号，之后用join等待线程的关闭。<br>经过检查，需要在线程中加入pthread_testcancel()，对线程终止信号进行处理，退出线程。然而并没有解决问题。<br>它的回调也在此线程之中，这就带来了一个问题。</p>
<h3 id="线程死锁的原因"><a href="#线程死锁的原因" class="headerlink" title="线程死锁的原因"></a>线程死锁的原因</h3><p>线程A控制着线程B的运行和销毁。线程B中执行一个回调函数，会调用到线程A中对线程B的释放。线程A发送了一个线程销毁的信号并进行等待，但是必须等到线程B对这个销毁信号进行处理才能推出。而线程B又需要等待A执行完这个释放函数，才能去对销毁信号进行处理。因此发生了死锁。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>单独创建一个回调函数的线程C，和线程AB分离开来，在线程C中调用就没有什么问题了</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>同步与互斥</title>
    <url>/posts/b30fed39/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>多线程的同步与互斥</p>
<p>学习<a href="https://blog.csdn.net/daaikuaichuan/article/details/82950711" target="_blank" rel="noopener">https://blog.csdn.net/daaikuaichuan/article/details/82950711</a></p>
</blockquote>
<h1 id="一、同步与互斥的概念"><a href="#一、同步与互斥的概念" class="headerlink" title="一、同步与互斥的概念"></a>一、同步与互斥的概念</h1><p>现代操作系统基本都是多任务操作系统，即同时有大量可调度实体在运行。在多任务操作系统中，同时运行的多个任务可能：</p>
<p>都需要访问/使用同一种资源；<br>多个任务之间有依赖关系，某个任务的运行依赖于另一个任务。<br>同步】：</p>
<p>是指散步在不同任务之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。最基本的场景就是：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。比如 A 任务的运行依赖于 B 任务产生的数据。</p>
<p>【互斥】：</p>
<p>是指散步在不同任务之间的若干程序片断，当某个任务运行其中一个程序片段时，其它任务就不能运行它们之中的任一程序片段，只能等到该任务运行完这个程序片段后才可以运行。最基本的场景就是：一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。</p>
<h1 id="二、互斥锁（同步）"><a href="#二、互斥锁（同步）" class="headerlink" title="二、互斥锁（同步）"></a>二、互斥锁（同步）</h1><p>在多任务操作系统中，同时运行的多个任务可能都需要使用同一种资源。这个过程有点类似于，公司部门里，我在使用着打印机打印东西的同时（还没有打印完），别人刚好也在此刻使用打印机打印东西，如果不做任何处理的话，打印出来的东西肯定是错乱的。<br>在线程里也有这么一把锁——互斥锁（mutex），互斥锁是一种简单的加锁的方法来控制对共享资源的访问，互斥锁只有两种状态,即上锁( lock )和解锁( unlock )。</p>
<h2 id="【特点】"><a href="#【特点】" class="headerlink" title="【特点】"></a>【特点】</h2><ol>
<li><p>原子性：把一个互斥量锁定为一个原子操作，这意味着操作系统（或pthread函数库）保证了如果一个线程锁定了一个互斥量，没有其他线程在同一时间可以成功锁定这个互斥量；</p>
</li>
<li><p>唯一性：如果一个线程锁定了一个互斥量，在它解除锁定之前，没有其他线程可以锁定这个互斥量；</p>
</li>
<li><p>非繁忙等待：如果一个线程已经锁定了一个互斥量，第二个线程又试图去锁定这个互斥量，则第二个线程将被挂起（不占用任何cpu资源），直到第一个线程解除对这个互斥量的锁定为止，第二个线程则被唤醒并继续执行，同时锁定这个互斥量。</p>
</li>
</ol>
<h2 id="【操作流程】"><a href="#【操作流程】" class="headerlink" title="【操作流程】"></a>【操作流程】</h2><ol>
<li>在访问共享资源后临界区域前，对互斥锁进行加锁；</li>
<li>在访问完成后释放互斥锁导上的锁。在访问完成后释放互斥锁导上的锁；</li>
<li>对互斥锁进行加锁后，任何其他试图再次对互斥锁加锁的线程将会被阻塞，直到锁被释放。对互斥锁进行加锁后，任何其他试图再次对互斥锁加锁的线程将会被阻塞，直到锁被释放。<h2 id="【函数】"><a href="#【函数】" class="headerlink" title="【函数】"></a>【函数】</h2></li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"time.h"</span></span></span><br><span class="line"><span class="comment">// 初始化一个互斥锁。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, </span></span></span><br><span class="line"><span class="function"><span class="params">						<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对互斥锁上锁，若互斥锁已经上锁，则调用者一直阻塞，</span></span><br><span class="line"><span class="comment">// 直到互斥锁解锁后再上锁。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用该函数时，若互斥锁未加锁，则上锁，返回 0；</span></span><br><span class="line"><span class="comment">// 若互斥锁已加锁，则函数直接返回失败，即 EBUSY。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当线程试图获取一个已加锁的互斥量时，pthread_mutex_timedlock 互斥量</span></span><br><span class="line"><span class="comment">// 原语允许绑定线程阻塞时间。即非阻塞加锁互斥量。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_timedlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abs_timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对指定的互斥锁解锁。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁指定的一个互斥锁。互斥锁在使用完毕后，</span></span><br><span class="line"><span class="comment">// 必须要对互斥锁进行销毁，以释放资源。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="【实例1】"><a href="#【实例1】" class="headerlink" title="【实例1】"></a>【实例1】</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//使用互斥量解决多线程抢占资源的问题</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span>* buf[<span class="number">5</span>]; <span class="comment">//字符指针数组  全局变量</span></span><br><span class="line"><span class="keyword">int</span> pos; <span class="comment">//用于指定上面数组的下标</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//1.定义互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">task</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//3.使用互斥量进行加锁</span></span><br><span class="line">    pthread_mutex_lock(&mutex);</span><br><span class="line"> </span><br><span class="line">    buf[pos] = (<span class="keyword">char</span> *)p;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    pos++;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//4.使用互斥量进行解锁</span></span><br><span class="line">    pthread_mutex_unlock(&mutex);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//2.初始化互斥量, 默认属性</span></span><br><span class="line">    pthread_mutex_init(&mutex, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//1.启动一个线程 向数组中存储内容</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid, tid2;</span><br><span class="line">    pthread_create(&tid, <span class="literal">NULL</span>, task, (<span class="keyword">void</span> *)<span class="string">"zhangfei"</span>);</span><br><span class="line">    pthread_create(&tid2, <span class="literal">NULL</span>, task, (<span class="keyword">void</span> *)<span class="string">"guanyu"</span>);</span><br><span class="line">    <span class="comment">//2.主线程进程等待,并且打印最终的结果</span></span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//5.销毁互斥量</span></span><br><span class="line">    pthread_mutex_destroy(&mutex);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"字符指针数组中的内容是："</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i < pos; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s "</span>, buf[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="【实例2】"><a href="#【实例2】" class="headerlink" title="【实例2】"></a>【实例2】</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"time.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tout</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tmp</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_lock (&lock);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"mutex is locked\n"</span>);</span><br><span class="line">    clock_gettime (CLOCK_REALTIME, &tout);</span><br><span class="line">    tmp = localtime (&tout.tv_sec); </span><br><span class="line">    strftime (buf, <span class="keyword">sizeof</span> (buf), <span class="string">"%r"</span>, tmp);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"current time is %s\n"</span>, buf);</span><br><span class="line">    tout.tv_sec += <span class="number">10</span>;</span><br><span class="line">    err = pthread_mutex_timedlock (&lock, &tout);</span><br><span class="line">    clock_gettime (CLOCK_REALTIME, &tout);</span><br><span class="line">    tmp = localtime (&tout.tv_sec);</span><br><span class="line">    strftime (buf, <span class="keyword">sizeof</span> (buf), <span class="string">"%r"</span>, tmp);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"the time is now %s\n"</span>, buf);</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"mutex locked again\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"can`t lock mutex again:%s\n"</span>, strerror (err));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="三、条件变量（同步）"><a href="#三、条件变量（同步）" class="headerlink" title="三、条件变量（同步）"></a>三、条件变量（同步）</h1><h2 id="【特点】-1"><a href="#【特点】-1" class="headerlink" title="【特点】"></a>【特点】</h2><p>与互斥锁不同，条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。<br>条件变量使我们可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步 的一种机制，主要包括两个动作：</p>
<p>一个线程等待”条件变量的条件成立”而挂起；<br>另一个线程使 “条件成立”（给出条件成立信号）。</p>
<h2 id="【原理】"><a href="#【原理】" class="headerlink" title="【原理】"></a>【原理】</h2><p>  条件的检测是在互斥锁的保护下进行的。线程在改变条件状态之前必须首先锁住互斥量。如果一个条件为假，一个线程自动阻塞，并释放等待状态改变的互斥锁。如果另一个线程改变了条件，它发信号给关联的条件变量，唤醒一个或多个等待它的线程，重新获得互斥锁，重新评价条件。如果两进程共享可读写的内存，条件变量 可以被用来实现这两进程间的线程同步。</p>
<h2 id="【条件变量的操作流程如下】"><a href="#【条件变量的操作流程如下】" class="headerlink" title="【条件变量的操作流程如下】"></a>【条件变量的操作流程如下】</h2><ol>
<li><p>初始化：init()或者pthread_cond_tcond=PTHREAD_COND_INITIALIER；属性置为NULL；</p>
</li>
<li><p>等待条件成立：pthread_wait，pthread_timewait.wait()释放锁,并阻塞等待条件变量为真 timewait()设置等待时间,仍未signal,返回ETIMEOUT(加锁保证只有一个线程wait)；</p>
</li>
<li><p>激活条件变量：pthread_cond_signal,pthread_cond_broadcast(激活所有等待线程)</p>
</li>
<li><p>清除条件变量：destroy;无线程等待,否则返回EBUSY清除条件变量:destroy;无线程等待,否则返回EBUSY</p>
</li>
</ol>
<h2 id="【实例】"><a href="#【实例】" class="headerlink" title="【实例】"></a>【实例】</h2><p>生产者和消费者模型，生产者向队列中插入数据，消费者则在生产者发出<strong>队列准备好（有数据了）</strong>后接收消息，然后取出数据进行处理。实现的关键点在以下几个方面：</p>
<ul>
<li>生产者和消费者都对条件变量的使用加了锁</li>
<li>消费者调用pthread_cond_wait,等待队列是否准备好的信息，注意参数有两个，一个是pthread_cond_t，另外一个是pthread_mutex_t.</li>
</ul>
<p>代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">m_next</span>;</span></span><br><span class="line"><span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">workq</span>;</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> qready = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> qlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">process_msg(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">    pthread_mutex_lock(&qlock);</span><br><span class="line">    <span class="keyword">while</span> (workq == <span class="literal">NULL</span>)</span><br><span class="line">        pthread_cond_wait(&qready, &qlock);</span><br><span class="line">    mp = workq;</span><br><span class="line">    workq = mp->m_next;</span><br><span class="line">    pthread_mutex_unlock(&qlock);</span><br><span class="line">    <span class="comment">/* now process the message mp */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">enqueue_msg(struct msg *mp)</span><br><span class="line">{</span><br><span class="line">    pthread_mutex_lock(&qlock);</span><br><span class="line">    mp->m_next = workq;</span><br><span class="line">    workq = mp;</span><br><span class="line">    pthread_mutex_unlock(&qlock);</span><br><span class="line">    pthread_cond_signal(&qready);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="【疑问】"><a href="#【疑问】" class="headerlink" title="【疑问】"></a>【疑问】</h2><h3 id="为什么pthread-cond-wait需要加锁？？"><a href="#为什么pthread-cond-wait需要加锁？？" class="headerlink" title="为什么pthread_cond_wait需要加锁？？"></a>为什么pthread_cond_wait需要加锁？？</h3><p>pthread_cond_wait中的mutex用于保护条件变量，调用这个函数进行等待条件的发生时,mutex会被自动释放，以供其它线程（生产者）改变条件，pthread_cond_wait中的两个步骤必须是原子性的(atomically,万恶的APUE中文版把这个单词翻译成了『自动』，误人子弟啊)，也就是说必须把两个步骤捆绑到一起：</p>
<ul>
<li>把调用线程放到条件等待队列上</li>
<li>释放mutex</li>
</ul>
<p>不然呢，如果不是原子性的，上面的两个步骤中间就可能插入其它操作。比如，如果先释放mutex，这时候生产者线程向队列中添加数据，然后signal,之后消费者线程才去『把调用线程放到等待队列上』，signal信号就这样被丢失了。</p>
<p>如果先把调用线程放到条件等待队列上，这时候另外一个线程发送了pthread_cond_signal（我们知道这个函数的调用是不需要mutex的），然后调用线程立即获取mutex，两次获取mutex会产生deadlock.</p>
<h3 id="在生产者线程中修改条件时为什么要加mutex？？"><a href="#在生产者线程中修改条件时为什么要加mutex？？" class="headerlink" title="在生产者线程中修改条件时为什么要加mutex？？"></a>在生产者线程中修改条件时为什么要加mutex？？</h3><p>如果不这么做信号可能会丢失，看下面的例子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Thead A                             Thread B</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&qlock);</span><br><span class="line">while (workq == NULL)</span><br><span class="line">                                   mp->m_next = workq;</span><br><span class="line">                                   workq = mp;</span><br><span class="line">                                   pthread_cond_signal(&cond);</span><br><span class="line"></span><br><span class="line">pthread_cond_wait(&qready, &qlock);</span><br></pre></td></tr></tbody></table></figure>

<p>在while判断之后向队列中插入数据，虽然已经有数据了，但线程A还是调用了pthread_cond_wait等待下一个信号到来。。</p>
<h3 id="消费者线程中判断条件为什么要放在while中？？"><a href="#消费者线程中判断条件为什么要放在while中？？" class="headerlink" title="消费者线程中判断条件为什么要放在while中？？"></a>消费者线程中判断条件为什么要放在while中？？</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">while (workq == NULL)</span><br><span class="line">    pthread_cond_wait(&qready, &qlock);</span><br><span class="line">mp = workq;</span><br></pre></td></tr></tbody></table></figure>

<p>我们把while换成if可不可以呢？</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if (workq == NULL)</span><br><span class="line">    pthread_cond_wait(&qready, &qlock);</span><br><span class="line">mp = workq;</span><br></pre></td></tr></tbody></table></figure>

<p>答案是不可以，一个生产者可能对应着多个消费者，生产者向队列中插入一条数据之后发出signal，然后各个消费者线程的pthread_cond_wait获取mutex后返回，当然，这里只有一个线程获取到了mutex，然后进行处理，其它线程会pending在这里，处理线程处理完毕之后释放mutex，刚才等待的线程中有一个获取mutex，如果这里用if，就会在当前队列为空的状态下继续往下处理，这显然是不合理的。</p>
<h3 id="signal到底是放在unlock之前还是之后？？"><a href="#signal到底是放在unlock之前还是之后？？" class="headerlink" title="signal到底是放在unlock之前还是之后？？"></a>signal到底是放在unlock之前还是之后？？</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">void</span><br><span class="line">enqueue_msg(struct msg *mp)</span><br><span class="line">{</span><br><span class="line">    pthread_mutex_lock(&qlock);</span><br><span class="line">    mp->m_next = workq;</span><br><span class="line">    workq = mp;</span><br><span class="line">    pthread_mutex_unlock(&qlock);</span><br><span class="line">    pthread_cond_signal(&qready);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果先unlock，再signal,如果这时候有一个消费者线程恰好获取mutex，然后进入条件判断，这里就会判断成功，从而跳过pthread_cond_wait,下面的signal就会不起作用；另外一种情况，一个优先级更低的不需要条件判断的线程正好也需要这个mutex，这时候就会转去执行这个优先级低的线程，就违背了设计的初衷。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">    void</span><br><span class="line">enqueue_msg(struct msg *mp)</span><br><span class="line">{</span><br><span class="line">    pthread_mutex_lock(&qlock);</span><br><span class="line">    mp->m_next = workq;</span><br><span class="line">    workq = mp;</span><br><span class="line">    pthread_cond_signal(&qready);</span><br><span class="line">    pthread_mutex_unlock(&qlock);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果把signal放在unlock之前，消费者线程会被唤醒，获取mutex发现获取不到，就又去sleep了。浪费了资源.但是在LinuxThreads或者NPTL里面，就不会有这个问题，因为在Linux 线程中，有两个队列，分别是cond_wait队列和mutex_lock队列， cond_signal只是让线程从cond_wait队列移到mutex_lock队列，而不用返回到用户空间，不会有性能的损耗。<br>所以在Linux中推荐使用这种模式。</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言设计模式</title>
    <url>/posts/290d8643/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>有哪些设计模式？c语言如何实现这些设计模式？<br>《C现代编程》读书笔记</p>
</blockquote>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>管理资源（文件或者内存）是一件很麻烦的事情，因为分配资源后还必须释放资源，如fopen和fclose需要对应，malloc和free需要对应。因此处理资源的代码总是显得非常繁杂。</p>
<p>如果函数在处理到一半的时候，返回了，而不去释放文件或内存，让文件或者内存一直处于打开状态，就会出现问题。但是如果加入的话，又容易出现代码混乱。</p>
<p>方法：将程序中的部分处理作为可以被替换的函数，将其他处理作为固定处理，使其可以重复利用，这里资源的分配和释放处理是固定处理，而获取文件中数值范围的处理则是可以被替换的处理。</p>
<p>优点：</p>
<p>首先， 文件的打开和关闭等操作都集中在 read_file函数中。也就是说只能在其中分配和释放资源。通常情况下，最好尽量将分配和释放资源的处理放在一起，否则很容易忘记。另外 ， 该结构将文件处理分离到 processor函数中。 这样一来． 各函数的职责更加清晰明确 。也可以避免中途退出循环时发生的问题。</p>
<h3 id="升级1：返回非int值"><a href="#升级1：返回非int值" class="headerlink" title="升级1：返回非int值"></a>升级1：返回非int值</h3><p>C语言中多用void或者联合体解决问题</p>
<p>这里可以使用一个结构体，需要什么返回值，就增加一个什么样的结构体。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FileReaderContext</span> {</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> pFname;</span><br><span class="line">    <span class="keyword">void</span>(*<span class="keyword">const</span> processor)(struct FileReaderContext *pThis, FILE *p);</span><br><span class="line">}FileReaderContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    FileReaderContext base;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">}MyFileReaderContext;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="升级二：处理其他资源"><a href="#升级二：处理其他资源" class="headerlink" title="升级二：处理其他资源"></a>升级二：处理其他资源</h3><p>实现将一个文件中的数据读取到内存中，进行排序后，再输出给另一个文件的功能。</p>
<p>将最常用的写成模板，而不是将整体写成模板。</p>
<p>处理文件+处理内存</p>
<blockquote>
<p>源码：<a href="https://github.com/xiaoqinxing/myrepo_c" target="_blank" rel="noopener">https://github.com/xiaoqinxing/myrepo_c</a></p>
</blockquote>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：两路摄像头自动日夜切换问题</title>
    <url>/posts/356a46c3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><ol>
<li>手动切换没有问题</li>
<li>单路摄像头自动切换日夜没有问题</li>
<li>双路摄像头自动切换日夜不受控制</li>
</ol>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li><input checked disabled type="checkbox"> 查看两路camera是如何实现对应参数的传递</li>
<li><input checked disabled type="checkbox"> 了解如何实现两路摄像头的分别控制</li>
<li><input checked disabled type="checkbox"> 了解日夜切换的逻辑</li>
</ul>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li>两路camera是如何实现不同的参数的？<br>需要看HAL层camera类的构造函数。可以看到HWI中是总的类，里面包含状态机，回调函数等等函数封装，初始化用QCamera2HardwareInterface(camera_id)，多一个摄像头就增加一个对象。<br>在hal层里面加一个对cameraid的判断，由于是创建了两个对象，互不干扰，因此只需要对id号进行判断，赋值还是一样的赋值。<br>注意了ispctrl参数是用QCameraParameters进行传递，它是在QCameraParametersIntf类里面的，随着QCamera2HardwareInterface类的定义而定义。QCamera2HardwareInterface又是在QCamera2HardwareInterface中定义的，也就是说随着一个摄像头的创建，会创建这个摄像头的整个实现方法。</li>
<li>高通代码是以面向对象的思想去写的，日夜切换的代码只有一套，由上层创建了两个摄像头，分别进行控制，两个摄像头的运行互不干扰。</li>
<li>问题就出现在两个摄像头的运行受到了干扰，每个摄像头都需要保存上次切换的时间，而这个时间应该是分离的，但是用的是static变量，导致这两个摄像头用的是同一个变量。</li>
</ol>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>C++中的static变量是静态数据成员<br>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，<strong>静态成员是类的所有对象中共享的成员，而不是某个对象的成员。</strong><br>但是遇到一个问题，需要保存上一个动作的时间，以前都是用static的方法保存，但是用对象的方法时，就不能这样了，创建一个新的对象，这个时间不能自动增加一个。就会导致异常！！<br>因此static变量要注意使用的时机。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>将static变量转成私有的类成员变量，既能保证私有性，又能保证创建新对象的时候自动新建变量。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>c++：面向对象的写法中，慎重使用static变量</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>IR-CUT</tag>
        <tag>2412M</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>编译版本信息打印功能实现</title>
    <url>/posts/9c00316/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>如何打印分支和目标设备的信息？<br>如何进行Makefile的编写？<br>如何引用Makefile中的宏定义？</p>
</blockquote>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>能够获取到分支信息、编译时间</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>下面有四种方案，下面的一种方案是上面方案的改进版</p>
<h3 id="方案一：用fopen打开文件"><a href="#方案一：用fopen打开文件" class="headerlink" title="方案一：用fopen打开文件"></a>方案一：用fopen打开文件</h3><p>git是编译服务器上的程序，git log也仅仅存在于服务器上，而代码的运行位置是在设备上。所以如果想要自动打印版本信息的话，log信息保存在设备的某个位置下，然后在代码中读取文件。<br>可以利用git log格式化输出</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git log --pretty=format:"\"%h\",\"%s\"" -n 1 > source/debug/git_log.txt</span><br></pre></td></tr></tbody></table></figure>

<h3 id="方案二：用头文件包含的方案"><a href="#方案二：用头文件包含的方案" class="headerlink" title="方案二：用头文件包含的方案"></a>方案二：用头文件包含的方案</h3><p>为了减少读取文件这种开销，可以把log信息放到头文件里面，具体可以参考高通camera 3A信息的头文件。<br><code>注意：</code>发现#include必须要写在最前面，表达式中间不能有#，但是却有一个投机取巧的方法，就是定义一个结构体，将文档文件读取成结构体。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line"><span class="keyword">char</span> hash[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> commit_log[<span class="number">64</span>];</span><br><span class="line">}GitVersion_t;</span><br><span class="line"><span class="keyword">static</span> GitVersion_t s_GitVersion = {</span><br><span class="line">#include <span class="string">"git_log.txt"</span></span><br><span class="line">};</span><br><span class="line">OsApi_Printf(<span class="number">1</span>,<span class="number">0</span>,<span class="string">"Commit ID:%s\nDetail: %s"</span>,s_GitVersion.hash, s_GitVersion.commit_log);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="方案三：用宏定义进行读取"><a href="#方案三：用宏定义进行读取" class="headerlink" title="方案三：用宏定义进行读取"></a>方案三：用宏定义进行读取</h3><p><code>注意：</code></p>
<ol>
<li><p>Android.mk对宏定义进行字符串赋值的时候，一定要注意用转义字符<code>\</code><br>例如：<code>CFLAGS += -DMY_PATH=\"/etc/mycfg\"</code></p>
</li>
<li><p>编译一个宏定义后，就算Makefile里面删除了，也还会存在</p>
</li>
<li><p>在make.mk中定义一个自定义的mk变量，但是在子Makefile中引用这个变量不行，因为子Makefile文件的一开始会把变量全部清空</p>
</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_PRODUCT</span></span><br><span class="line">    OsApi_Printf(<span class="number">1</span>,<span class="number">0</span>, (<span class="keyword">char</span> *)<span class="string">"TARGET_VERSION = %s"</span>, TARGET_PRODUCT);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="方案四：利用mk脚本生成宏定义"><a href="#方案四：利用mk脚本生成宏定义" class="headerlink" title="方案四：利用mk脚本生成宏定义"></a>方案四：利用mk脚本生成宏定义</h4><ol>
<li>首先获取git log的信息。<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 脚本一（媒控的）：</span></span><br><span class="line">git log -1 2> /dev/null # 打印最近一条commit信息</span><br><span class="line">head -n 1 # 取第一行</span><br><span class="line"><span class="meta">#</span><span class="bash"> 脚本二：</span></span><br><span class="line">git log --pretty=format:"%H" -n 1 |cut -b -8</span><br></pre></td></tr></tbody></table></figure></li>
<li>利用Makefile脚本生成文件<br>makefile中call是调用函数的意思 后面的第一个参数是函数名，下面的参数就是函数的参数了<br>第二句话是定义了一个函数，1是第一个参数，也就是说这个函数的作用就是往文件1中写入hello<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># function call</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> autogenerate_modesubversion,<span class="variable">$(AUTO_SUBVERSION_FILE_NAME)</span>)</span></span><br><span class="line"><span class="comment"># function define</span></span><br><span class="line">autogenerate_modesubversion = <span class="variable">$(<span class="built_in">shell</span> echo "hello" > $(1)</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>增加版本信息的宏定义，在文件中进行读取<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">current_makefile := <span class="variable">$(<span class="built_in">lastword</span> <span class="variable">$(MAKEFILE_LIST)</span>)</span></span><br><span class="line">current_make_path := <span class="variable">$(<span class="built_in">patsubst</span> %/,%,$(<span class="built_in">dir</span> $(current_makefile:%/=%)</span>))/..</span><br><span class="line"><span class="comment"># MODULE_SUBVERSION := $(shell cd $(current_make_path) && git log -1 2> /dev/null | head -n 1 | awk ' {print $$2 } ' | cut -b -8)</span></span><br><span class="line">MODULE_SUBVERSION := <span class="variable">$(<span class="built_in">shell</span> cd <span class="variable">$(current_make_path)</span> && git log --pretty=format:"%H" -n 1 |cut -b -8)</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(MODULE_SUBVERSION)</span>,)</span><br><span class="line">MODULE_SUBVERSION := AA5555AA</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment"># module_auto_subversion_gen = $(shell echo "Do nothing..")</span></span><br><span class="line">autogenerate_modesubversion = <span class="variable">$(<span class="built_in">shell</span> echo "/**" > $(1)</span> ; \</span><br><span class="line">echo <span class="string">" * Kedacom module subversion defines."</span> >> $(1) ; \</span><br><span class="line">echo <span class="string">" * Automatically generated file, DO NOT EDIT."</span> >> $(1) ; \</span><br><span class="line">echo <span class="string">" * Don't push it to repository."</span> >> $(1) ; \</span><br><span class="line">echo <span class="string">" *"</span> >> $(1) ; \</span><br><span class="line">echo <span class="string">" */"</span> >> $(1) ; \</span><br><span class="line">echo <span class="string">"\#define MODULE_SUBVERSION 0x<span class="variable">$(MODULE_SUBVERSION)</span>"</span> >> $(1))</span><br></pre></td></tr></tbody></table></figure></li>
<li>注意提交代码的时候不要把生成的头文件提交上去。每次编译都会更新生成的版本文件，从而去更新编译时间和版本号。</li>
</ol>
<h2 id="附录（完整代码）"><a href="#附录（完整代码）" class="headerlink" title="附录（完整代码）"></a>附录（完整代码）</h2><figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">current_makefile := <span class="variable">$(<span class="built_in">lastword</span> <span class="variable">$(MAKEFILE_LIST)</span>)</span></span><br><span class="line">current_make_path := <span class="variable">$(<span class="built_in">patsubst</span> %/,%,$(<span class="built_in">dir</span> $(current_makefile:%/=%)</span>))/..</span><br><span class="line"></span><br><span class="line"><span class="comment"># MODULE_SUBVERSION := $(shell cd $(current_make_path) && git log -1 2> /dev/null | head -n 1 | awk ' {print $$2 } ' | cut -b -8)</span></span><br><span class="line">MODULE_SUBVERSION := <span class="variable">$(<span class="built_in">shell</span> cd <span class="variable">$(current_make_path)</span> && git log --pretty=format:"%H" -n 1 |cut -b -8)</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(MODULE_SUBVERSION)</span>,)</span><br><span class="line">MODULE_SUBVERSION := AA5555AA</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">MODULE_GIT_COMMIT := <span class="variable">$(<span class="built_in">shell</span> git -C <span class="variable">$(current_make_path)</span> rev-parse --short=8 HEAD 2>/dev/null)</span></span><br><span class="line"></span><br><span class="line">MODULE_GIT_BRANCH := <span class="variable">$(<span class="built_in">shell</span> cd <span class="variable">$(current_make_path)</span> && git branch 2> /dev/null | grep "*" | awk ' {print $$2 } ')</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(MODULE_GIT_BRANCH)</span>,)</span><br><span class="line">MODULE_GIT_BRANCH := branch-unknow</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">BranchDetached:= (detached</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(MODULE_GIT_BRANCH)</span>,<span class="variable">$(BranchDetached)</span>)</span><br><span class="line">MODULE_GIT_BRANCH := <span class="variable">$(<span class="built_in">shell</span> cd <span class="variable">$(current_make_path)</span> && git branch -a 2> /dev/null | grep "\->" |cut -d '>' -f 2 | cut -d '/' -f 2 )</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># module_auto_subversion_gen = $(shell echo "Do nothing..")</span></span><br><span class="line">autogenerate_modesubversion = <span class="variable">$(<span class="built_in">shell</span> echo "/**" > $(1)</span> ; \</span><br><span class="line">    echo <span class="string">" * Kedacom module subversion defines."</span> >> $(1) ; \</span><br><span class="line">    echo <span class="string">" * Automatically generated file, DO NOT EDIT."</span> >> $(1) ; \</span><br><span class="line">    echo <span class="string">" * Don't push it to repository."</span> >> $(1) ;\</span><br><span class="line">    echo <span class="string">" *"</span> >> $(1) ;	\</span><br><span class="line">    echo <span class="string">" */"</span> >> $(1) ;\</span><br><span class="line">    echo <span class="string">"\#ifndef _AUTO_MODSUBVER_H_"</span> >> $(1) ; \</span><br><span class="line">    echo <span class="string">"\#define _AUTO_MODSUBVER_H_"</span> >> $(1) ; \</span><br><span class="line">    echo <span class="string">""</span> >> $(1) ; \</span><br><span class="line">    echo <span class="string">"\#define MODULE_GIT_BRANCH \"<span class="variable">$(MODULE_GIT_BRANCH)\"</span>"</span> >> $(1) ; \</span><br><span class="line">    echo <span class="string">"\#define MODULE_BUILD_DATE \"`date "</span>+%Y-%m-%d %H:%M:%S<span class="string">"`\""</span> >> $(1) ; \</span><br><span class="line">    echo <span class="string">"\#define MODULE_GIT_COMMIT \"<span class="variable">$(MODULE_GIT_COMMIT)\"</span>"</span> >> $(1) ; \</span><br><span class="line">    echo <span class="string">"\#define MODULE_SUBVERSION 0x<span class="variable">$(MODULE_SUBVERSION)</span>"</span> >> $(1);\</span><br><span class="line">    echo <span class="string">""</span> >> $(1) ; \</span><br><span class="line">    echo <span class="string">"\#endif /* _AUTO_MODSUBVER_H_ */"</span> >> $(1))</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>version</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>c-使用结构和指针</title>
    <url>/posts/b5b198bb/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表就是一些包含数据的独立数据结构的集合。每个节点通过链或者指针连接在一起。程序通过指针访问链表的节点，节点通常是动态分配的，但有时你也能看到有节点数组构建的链表。即使这种情况下，程序也是通过指针来遍历链表的。</p>
<h3 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1. 单链表"></a>1. 单链表</h3><p>每个节点饱和一个指向链表下一个节点的指针。链表最后一个节点的指针字段的值为NULL，提示链表后面不在有其他节点。</p>
<p>找到链表的第一个节点后，指针就可以带你访问剩余的所有节点。为了记住链表的起始位置，可以用一个根指针（root pointer)。根指针指向链表的第一个节点。<strong>注意根指针只是一个指针，不包含数据。</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">typedef struct NODE {</span><br><span class="line">    struct NODE *link;</span><br><span class="line">    int          value;</span><br><span class="line">}NODE;</span><br></pre></td></tr></tbody></table></figure>

<p>单链表可以通过链从开始位置遍历链表知道结束位置，<strong>但是链表无法从相反的方向进行遍历。</strong></p>
<p><strong>疑问：</strong>为什么无法从相反方向遍历？通过&查找不行么？</p>
<p><strong>思考：</strong>一个内存地址可以由很多指针指向。地址说到底也只是一串数，指针就是在内存的其他位置存着这一串数，可能你又怎么知道那个位置存着这一串数呢？这串数可能出现很多次，也根本没法判断。<strong>&符号只是取出地址，而这个地址可以给其他任意地方存着。</strong></p>
<h3 id="2-双链表"><a href="#2-双链表" class="headerlink" title="2. 双链表"></a>2. 双链表</h3><p>相比单链表，就是增加一个指向上一个节点的指针</p>
<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>由于正常的堆栈没有给堆栈设置一个限额，为了安全起见，本文为堆栈设置了一个限制，如果需要取消这个限制，就<code>#define STACK_LIMIT 0</code></p>
<h3 id="1-结构体定义"><a href="#1-结构体定义" class="headerlink" title="1. 结构体定义"></a>1. 结构体定义</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment">*   作    者    ：xiaoqinxing</span></span><br><span class="line"><span class="comment">*   功能描述    ：单链表实现的动态堆栈</span></span><br><span class="line"><span class="comment">*   使用说明    ：</span></span><br><span class="line"><span class="comment">******************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  __STACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __STACK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//定义存储数据类型（可以定义为指针）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_TYPE int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//是否限制堆栈长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_LIMIT 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//堆栈默认长度，开启STACK_LIMIT后生效</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_LIMIT_DEFAULT_LENTH 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">STACK_NODE</span> {</span></span><br><span class="line">        STACK_TYPE value;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">STACK_NODE</span> *<span class="title">next</span>;</span></span><br><span class="line">}StackNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">STACK_PRIVATE</span>{</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_len;</span><br><span class="line">}STACK_PRIVATE;</span><br><span class="line"><span class="comment">//结构体里面的函数指针 参数中包含结构体时一定要加struct，否则会报错，</span></span><br><span class="line"><span class="comment">//但是c文件里面可以不加；可能是Stack还没有定义完就使用了</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">//第一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">char</span> <span class="params">(*is_empty_func)</span><span class="params">(struct Stack *stack_obj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*push_func)</span><span class="params">(struct Stack *stack_obj, STACK_TYPE value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pop_func)</span><span class="params">(struct Stack *stack_obj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">STACK_TYPE</span><span class="params">(*top_func)</span><span class="params">(struct Stack *stack_obj)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> {</span></span><br><span class="line">    StackNode *node;</span><br><span class="line">    is_empty_func is_empty;</span><br><span class="line">    push_func push;</span><br><span class="line">    pop_func pop;</span><br><span class="line">    top_func top;</span><br><span class="line">}Stack;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> {</span></span><br><span class="line">    StackNode *node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> STACK_LIMIT</span></span><br><span class="line">    STACK_PRIVATE stack_private;</span><br><span class="line">    <span class="keyword">char</span>(*is_full)(struct Stack *stack_obj);</span><br><span class="line">    <span class="keyword">void</span>(*set_length)(struct Stack *stack_obj);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">char</span>(*is_empty)(struct Stack *stack_obj);</span><br><span class="line">    <span class="keyword">void</span>(*push)(struct Stack *stack_obj, STACK_TYPE value);</span><br><span class="line">    STACK_TYPE(*pop)(struct Stack *stack_obj);</span><br><span class="line">    STACK_TYPE(*top)(struct Stack *stack_obj);</span><br><span class="line">}Stack;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">is_stack_full</span><span class="params">(struct Stack *stack_obj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_stack_length</span><span class="params">(struct Stack *stack_obj, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">is_stack_empty</span><span class="params">(Stack * stack_obj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Stack * stack_obj, STACK_TYPE value)</span></span>;</span><br><span class="line"><span class="function">STACK_TYPE <span class="title">pop</span><span class="params">(Stack * stack_obj)</span></span>;</span><br><span class="line"><span class="function">STACK_TYPE <span class="title">top</span><span class="params">(Stack * stack_obj)</span></span>;</span><br><span class="line"><span class="function">Stack* <span class="title">create_stack</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_stack</span><span class="params">(Stack *stack_obj)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-创建和销毁"><a href="#2-创建和销毁" class="headerlink" title="2. 创建和销毁"></a>2. 创建和销毁</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Stack* <span class="title">create_stack</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    Stack *stack_obj=MALLOC(<span class="number">1</span>,Stack);</span><br><span class="line">    stack_obj->node = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> STACK_LIMIT</span></span><br><span class="line">    stack_obj->stack_private.length = <span class="number">0</span>;</span><br><span class="line">    stack_obj->stack_private.max_len = STACK_LIMIT_DEFAULT_LENTH;</span><br><span class="line">    stack_obj->set_length = set_stack_length;</span><br><span class="line">    stack_obj->is_full = is_stack_full;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    stack_obj->push = push;</span><br><span class="line">    stack_obj->pop  = pop;</span><br><span class="line">    stack_obj->top = top;</span><br><span class="line">    stack_obj->is_empty = is_stack_empty;</span><br><span class="line">    <span class="keyword">return</span> stack_obj;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_stack</span><span class="params">(Stack *stack_obj)</span></span>{</span><br><span class="line">    <span class="keyword">while</span> (!is_stack_empty(stack_obj)) {</span><br><span class="line">        pop(stack_obj);</span><br><span class="line">    }</span><br><span class="line">    FREE(stack_obj);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-判断是否为空或满"><a href="#3-判断是否为空或满" class="headerlink" title="3. 判断是否为空或满"></a>3. 判断是否为空或满</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> STACK_LIMIT</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">is_stack_full</span><span class="params">(Stack * stack_obj)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> stack_obj->stack_private.length >= stack_obj->stack_private.max_len;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">is_stack_empty</span><span class="params">(Stack *stack_obj)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> stack_obj->node == <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-设置堆栈最大长度"><a href="#4-设置堆栈最大长度" class="headerlink" title="4. 设置堆栈最大长度"></a>4. 设置堆栈最大长度</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> STACK_LIMIT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_stack_length</span><span class="params">(Stack * stack_obj, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    stack_obj->stack_private.max_len = value;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-push"><a href="#5-push" class="headerlink" title="5. push"></a>5. push</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Stack *stack_obj, STACK_TYPE value)</span></span>{</span><br><span class="line">    StackNode *new_node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> STACK_LIMIT</span></span><br><span class="line">    <span class="keyword">if</span> (is_stack_full(stack_obj)) {</span><br><span class="line">        LOGE(<span class="string">"stack is full,push is error"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    new_node = MALLOC(<span class="number">1</span>, StackNode);</span><br><span class="line">    new_node->value = value;</span><br><span class="line">    new_node->next = stack_obj->node;</span><br><span class="line">    stack_obj->node = new_node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> STACK_LIMIT</span></span><br><span class="line">    stack_obj->stack_private.length++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="6-pop"><a href="#6-pop" class="headerlink" title="6. pop"></a>6. pop</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">STACK_TYPE <span class="title">pop</span><span class="params">(Stack *stack_obj)</span> </span>{</span><br><span class="line">    StackNode *first_node = stack_obj->node;</span><br><span class="line">    <span class="keyword">if</span> (is_stack_empty(stack_obj)) {</span><br><span class="line">        LOGE(<span class="string">"stack is empty,pop is error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    STACK_TYPE rc = first_node->value;</span><br><span class="line">    stack_obj->node = stack_obj->node->next;</span><br><span class="line">    FREE(first_node);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> STACK_LIMIT</span></span><br><span class="line">    stack_obj->stack_private.length--;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>与堆栈类似，这里就不列出来了，具体可以参考我的代码仓库</p>
<blockquote>
<p><code>代码位置</code>：<a href="https://github.com/xiaoqinxing/myrepo_c" target="_blank" rel="noopener">https://github.com/xiaoqinxing/myrepo_c</a></p>
</blockquote>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>c 结构和联合</title>
    <url>/posts/4f008442/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>结构体和联合体的简单介绍</p>
<a id="more"></a>

<blockquote>
<p>《c和指针》阅读笔记</p>
</blockquote>
<h1 id="（一）结构（struct）"><a href="#（一）结构（struct）" class="headerlink" title="（一）结构（struct）"></a>（一）结构（struct）</h1><p>聚合数据类型就是能够同时存储超过一个的单个数据。包括数据和结构，数组是相同类型的集合，结构的各个成员可能有不同的类型。</p>
<p>数组元素可以通过下标访问，这是因为数组的元素长度相同；而结构成员都有自己的名字，大小可能不同，只能通过名字访问的。</p>
<h2 id="结构体声明"><a href="#结构体声明" class="headerlink" title="结构体声明"></a>结构体声明</h2><p><strong>注意：</strong>定义两个结构体的声明，即使他们的成员列表完全相同，也会被当做两种截然不同的类型，因此不能进行赋值或者指针的赋值。</p>
<p><strong>解决方案：</strong>用标签来创建变量，可以用typedef创建一种新的类型。  </p>
<p>只有当两个变量是同一结构体类型，才可以进行赋值或者指向。</p>
<p>如果你想在多个源文件中使用同一种类型的结构体，你应该吧标签声明或者typedef形式的声明放在一个头文件中。当源文件需要这个声明是可以使用#include指令将头文件包含进来。</p>
<h2 id="成员访问"><a href="#成员访问" class="headerlink" title="成员访问"></a>成员访问</h2><p>直接访问，直接访问结构的成员：<strong>.</strong></p>
<p>结合性：从左往右</p>
<p>间接访问，访问变量所指向的结构的成员：<strong>-></strong></p>
<h2 id="自引用"><a href="#自引用" class="headerlink" title="自引用"></a>自引用</h2><p>一个结构体中不可以包含它自身，这样重复包含自己永无止境。</p>
<p>但是可以包含一个指向该结构类型本身的指针。如：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF</span> {</span></span><br><span class="line">    <span class="keyword">int</span>    a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF</span> *<span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">int</span>    c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>它事实上所指向的是<strong>同类型的不同结构</strong>。更加高级的数据结构，如链表和树都是用这个技巧实现的。</p>
<p>注意下面这个是错误的：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">int</span>     a;</span><br><span class="line">    SELF_REF *b;</span><br><span class="line">    <span class="keyword">int</span>     c;</span><br><span class="line">}SELF_REF;</span><br></pre></td></tr></tbody></table></figure>

<p>类型名知道声明的末尾才定义，所以在结构体声明的内部它尚未定义。</p>
<p>应该写成</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF_TAG</span>{</span></span><br><span class="line">    <span class="keyword">int</span>     a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SELF_REF_TAG</span> *<span class="title">b</span>;</span></span><br><span class="line">    <span class="keyword">int</span>     c;</span><br><span class="line">}SELF_REF;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="不完整声明"><a href="#不完整声明" class="headerlink" title="不完整声明"></a>不完整声明</h2><p>偶尔要声明一些互相之间存在依赖的结构，也就是说其中一个结构包含了另一个结构体的一个或者多个成员，那么哪个结构应该首先声明呢？</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> *<span class="title">p</span>;</span></span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">p</span>;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>解决方案是不完整声明，它先声明一个作为结构标签的标识符。然后可以把这个标签用在不需要知道这个结构长度的声明中，如声明指向这个结构体的指针（指针长度都一样）。接下来的声明吧这个标签和成员列表联系在一起。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>用花括号和逗号隔开。如果初始化列表的值不够，剩余的结构成员将使用缺省值进行初始化。</p>
<h2 id="结构的存储分配"><a href="#结构的存储分配" class="headerlink" title="结构的存储分配"></a>结构的存储分配</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALIGH</span>{</span></span><br><span class="line">    <span class="keyword">char</span>  a;</span><br><span class="line">    <span class="keyword">int</span>   b;</span><br><span class="line">    <span class="keyword">char</span>  c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果某个机器的整型值长度为4，并且它的其实存储位置必须要能够被4整除，那么这个结构体的长度为12个字节。因为系统静止编译器在一个结构的其实位置跳过几个字节来满足边界对齐要求，因此所有结构的其实存储位置必须死结构中边界要求最严格的数据类型所要求的位置。</p>
<p><strong>解决方案：</strong>我们可以对结构的成员列表重新排泄，让那些对边界要求最严格的成员首先出现，对边界要求最弱的成员最后出现，可以最大限度的减少因为边界对齐带来的空间损失。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALIGN</span>{</span></span><br><span class="line">    <span class="keyword">int</span>   b;</span><br><span class="line">    <span class="keyword">char</span>  a;</span><br><span class="line">    <span class="keyword">char</span>  c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果需要确定结构体中某个成员的实际位置，应该考虑边界对齐因素的影响，可以使用<strong>offsetof宏</strong>（定义于stddef.h）</p>
<p>offsetof ( type,  member);  表示一个指定成员开始存储的位置距离结构体开始存储的位置偏移几个字节。</p>
<h2 id="作为函数参数的结构"><a href="#作为函数参数的结构" class="headerlink" title="作为函数参数的结构"></a>作为函数参数的结构</h2><p>如果用按值传递的调用方式效率很低，会把结构体中的所有数据复制到堆栈再丢弃。</p>
<p>我们可以用按地址传递的调用方式，只是传递结构体的地址，可以大大提高效率，也节省了内存。</p>
<p>在许多机器中，可以把参数声明为寄存器变量，从而进一步提高指针传递方案的效率。在有些机器上，这种声明在函数的起始部分还需要一条额外的指令，用于吧堆栈中的参数（参数先传递给堆栈）赋值到寄存器，供函数使用。但是如果函数对这个指针的间接访问次数超过两三次，那么使用这种方法所节省的时间将远远高于一条额外指令所花费的时间。</p>
<p>但是这个缺陷是函数会对调用程序的结构变量进行修改。</p>
<p>如果我们不希望如此，可以在函数中使用const关键字来防止这类修改。现在函数原型变成了：</p>
<p><code>void print_rec(register SELF_REF const *trans );</code></p>
<h1 id="（二）位段"><a href="#（二）位段" class="headerlink" title="（二）位段"></a>（二）位段</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>位段的声明和普通的结构成员声明相同，但是有两个例外，位段成员必须声明为int、unsigned int类型。其次，在成员名的后面是一个冒号和整数，这个整数指定该位段所占用的位的数目。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>可移植性程序应该避免使用位段，因为不同的系统，位段可能有不同的结构。</p>
<ol>
<li>int位段被当做有符号数还是无符号书</li>
<li>位段中位的最大数目。许多编译器把位段成员的长度限制在一个整型值的长度以内，所以32位机器上运行的16位可能不能运行。</li>
<li>位段中的成员在内存中是从左往右分配的还是从右往左分配的</li>
<li>当一个声明指定了两个位段，第二个位段比较大，无法容纳于第一个位段剩余的位时，编译器可能吧第二个位段放在内存的下一个字，也可能直接放在第一个位段后面，从而在两个内存位置的边界上形成重叠。</li>
</ol>
<p>是用于控制寄存器的较好的方法。任何可以用位段实现的功能都可以用移位和屏蔽（用与或者非）实现，在源代码中用位段表示这个处理过程更加简单一点，但在目标代码中，这两种方法并不存在任何区别。</p>
<h1 id="（三）联合（union）"><a href="#（三）联合（union）" class="headerlink" title="（三）联合（union）"></a>（三）联合（union）</h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>当你想在不同的时刻把不同的东西存储于同一个位置时，就可以用联合。</p>
<p>一般和自定义的类型连用，如：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VARIABLE</span> {</span></span><br><span class="line">    <span class="keyword">enum</span> {INT, FLOAT, STRING} type;</span><br><span class="line">    <span class="keyword">union</span> {</span><br><span class="line">        <span class="keyword">int</span>   i;</span><br><span class="line">        <span class="keyword">float</span> f;</span><br><span class="line">        <span class="keyword">char</span>  *s;</span><br><span class="line">    }value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在高通的代码中就很常见，通常是一个模块的接口，不同的事件请求 携带不同的数据。</p>
<p><strong>疑问：为何不能不同的事件请求都用相同的data指针，这个data指针根据事件请求指向不同的地址。高通的代码中两种写法都有，是不是如果用union传递可以保护原来的变量不被修改？</strong></p>
<p>在成员长度不同的联合里，分配给联合的内存数量取决于它的最长成员的长度，这样联合的长度总是足以容纳它最大的长远，如果这些成员的长度相差悬殊，节省的空间相当可观。</p>
<p>在这种情况下，更好的方法是：在联合中存储指向不同成员的指针，而不是直接存储成员本身。所有的指针长度都是相同的，这样就解决了内存浪费的问题。</p>
<p><strong>疑问：这样还有必要去声明一个union么？直接定义一个data指针，不同的时候指向不同的地址不就行了么？</strong></p>
<h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><p>可以初始化，但是这个初始值必须是联合第一个成员的类型，而且他必须位于一对花括号里面。</p>
<p>比如定义一个union，第一个成员是int，第二个是float；我们不能把这个变量初始化为一个浮点数或者字符值。如果给出的初始值是其他类型，它可能会转换为int类型，进行使用。</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>c 动态内存分配</title>
    <url>/posts/ca78d72f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>为什么要使用动态内存分配？函数的局部变量会进行回收，相比于函数的局部变量，有什么好处呢？</p>
</blockquote>
<blockquote>
<p>《c和指针》阅读笔记</p>
</blockquote>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>动态内存分配就是在程序运行的时候去再去申请所需要的内存空间。</p>
<h2 id="malloc-和free"><a href="#malloc-和free" class="headerlink" title="malloc 和free"></a>malloc 和free</h2><p>malloc所分配的是一块连续的内存。并没有进行初始化，要么手动初始化，要么用calloc进行初始化。</p>
<p>注意：如果内存池是空的，或者他的可用内存无法满足你的需要，会返回一个NULL指针，因此对每个从malloc返回的指针进行检查，确保它并非NULL非常重要。</p>
<p>malloc又是如何知道你说请求的内存是整数，浮点还是数组呢？它并不知情，它只是返回了一个void *指针。标准表示一个void *类型的指针可以转换为其他任何类型的指针，但是有些编译器，可能要求你在转换时强制类型转换。</p>
<h2 id="calloc和realloc"><a href="#calloc和realloc" class="headerlink" title="calloc和realloc"></a>calloc和realloc</h2><p>malloc和calloc的主要区别是后者在返回指向内存的指针之前将它初始化为0。另一个小区别是，它们请求内存数量的方式不同，calloc的参数包括所需元素的数量和每个元素的字节数，根据这个值去计算出总共需要分配多少内存。</p>
<p>realloc用于修改一个原先已经分配的内存块的大小。使用这个函数，你可以是一块内存扩大或者缩小。扩大的话，不会对原先的内容有所改变，缩小的话，剩余部分的内容也依然保留。</p>
<p>如果原先的内存块无法改变大小，会将另外分配一个正确大小的内存，并把原先的内存内容复制到新的块上。<strong>因此，使用realloc之后，就不能再使用指向就内存的指针，而是应该改用realloc返回的指针。</strong></p>
<p>如果realloc的第一个参数是NULL，那么和malloc一样。</p>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>对NULL指针进行解引用操作</p>
<p>对分配的内存进行操作是越过边界</p>
<p>释放并非动态分配的内存</p>
<p>试图释放一块动态分配的内存的一部分</p>
<p>一块动态内存被释放后被继续使用</p>
<h1 id="实例测试"><a href="#实例测试" class="headerlink" title="实例测试"></a>实例测试</h1><h2 id="不易发生错误的内存分配器实现"><a href="#不易发生错误的内存分配器实现" class="headerlink" title="不易发生错误的内存分配器实现"></a>不易发生错误的内存分配器实现</h2><p>动态内存分配最常见的错误是忘记检查所请求的内存是否成功分配。下面是一种技巧，可以很可靠的进行这个错误检查。不经过直接调用malloc函数，通过自定义的alloc函数调用malloc，并对malloc进行检查。</p>
<p>这个#define malloc指令，是用于防止由于其他代码块直接调用malloc的行为。增加这个指令后，直接调用malloc将会因为语法错误而无法编译。在alloc.v中必须加入#undef，这样它才能调用malloc而不至于出错。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">**alloc.h</span></span><br><span class="line"><span class="comment">**定义一个不易发生错误的内存分配器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="comment">//不要直接调用malloc!</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC(num, type) (type *)alloc((num) * sizeof(type))</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">alloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">**alloc.c</span></span><br><span class="line"><span class="comment">**不易发生错误的内存分配器的实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"alloc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> malloc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">alloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>{</span><br><span class="line">    <span class="keyword">void</span> *new_mem;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ** 请求所需的内存</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    new_mem = <span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span>(new_mem == <span class="literal">NULL</span>){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"out of memory\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> new_mem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">**a_client.c</span></span><br><span class="line"><span class="comment">**一个使用很少引起错误的内存分配器的程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> *new_memory;</span><br><span class="line">    mew_memory = MALLOC(<span class="number">25</span>,<span class="keyword">int</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当动态内存分配的程序失败时，我们很容易将问题责任推给malloc和free函数，其实往往都是出现在了自己的程序中，而且常常是由于访问了分配内存以外的区域而引起的。</p>
<p>当使用free的时候，可能会出现不同的错误，传递给free的指针必须死一个从malloc，calloc，realloc返回的指针。让free函数释放一块不是动态分配的内存可能导致程序立刻终止或者晚些时候终止。</p>
<p><strong>试图释放一块动态内存的一部分也可能会引起类似问题</strong>。比如说在程序中对指针进行了修改，如自增自减之后，再去free，就可能会出现问题。</p>
<p><strong>必须小心不要访问已经被free函数释放了的内存</strong>。（很容易出现）假设你对一个指向动态分配的内存的指针进行了赋值，而且这个指针的几个拷贝散布于程序各处。<strong>你无法保证当你使用其中一个指针的时候它所指向的内存是不是已经被另一个指针释放。</strong>另一方面，你必须确保程序中所有使用这块内存的地方在这块内存被释放之前停止对它的使用。</p>
<h2 id="内存分配实例"><a href="#内存分配实例" class="headerlink" title="内存分配实例"></a>内存分配实例</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//invendor.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __INVENDOR_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INVENDOR_H__</span></span><br><span class="line"><span class="comment">//定义一个存货记录的声明</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">	<span class="keyword">int</span> cost;</span><br><span class="line">	<span class="keyword">int</span> supplier;</span><br><span class="line">}Partinfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">	<span class="keyword">char</span> partno[<span class="number">20</span>];</span><br><span class="line">	short quan;</span><br><span class="line">}SUBASSYPART;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">	<span class="keyword">int</span> n_parts;</span><br><span class="line">	SUBASSYPART *part;</span><br><span class="line">}Subassyinfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">	<span class="keyword">char</span> partno[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> quan;</span><br><span class="line">	<span class="keyword">enum</span> {PART, SUBASSY}type;</span><br><span class="line">	<span class="keyword">union</span> {</span><br><span class="line">		Partinfo *part;</span><br><span class="line">		Subassyinfo *subassy;</span><br><span class="line">	}info;</span><br><span class="line">}Invrec;</span><br><span class="line"></span><br><span class="line"><span class="function">Invrec *<span class="title">create_subassy_record</span><span class="params">(<span class="keyword">int</span> n_parts)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discard_inventory_record</span><span class="params">(Invrec *record)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !__DATA_TYPE_H__</span></span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">**invrecord.c</span></span><br><span class="line"><span class="comment">**用于创建SUBASSEMBLY存货纪录的函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"invendor.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建存货信息</span></span><br><span class="line"><span class="function">Invrec *<span class="title">create_subassy_record</span><span class="params">(<span class="keyword">int</span> n_parts)</span> </span>{</span><br><span class="line">	Invrec *new_rec;</span><br><span class="line">	<span class="comment">//尝试为Invrec部分分配内存</span></span><br><span class="line">	new_rec = MALLOC(<span class="number">1</span>, Invrec);</span><br><span class="line">	new_rec->info.subassy = MALLOC(<span class="number">1</span>, Subassyinfo);</span><br><span class="line">	new_rec->info.subassy->part = MALLOC(n_parts, SUBASSYPART);</span><br><span class="line">	new_rec->type = SUBASSY;</span><br><span class="line">	new_rec->info.subassy->n_parts = n_parts;</span><br><span class="line">	<span class="keyword">return</span> new_rec;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除存货信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discard_inventory_record</span><span class="params">(Invrec *record)</span> </span>{</span><br><span class="line">	<span class="keyword">switch</span> (record->type) {</span><br><span class="line">	<span class="keyword">case</span> SUBASSY:</span><br><span class="line">		<span class="built_in">free</span>(record->info.subassy->part);</span><br><span class="line">		<span class="built_in">free</span>(record->info.subassy);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PART:</span><br><span class="line">		<span class="built_in">free</span>(record->info.part);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"record type is error"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">free</span>(record);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"invendor.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Invrec *a;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	**注意了，由于动态分配的内存需要释放，如果将这个指针进行了运算</span></span><br><span class="line"><span class="comment">	**free的时候就会出问题，另外如果运算了，其他地方进行引用，也容易</span></span><br><span class="line"><span class="comment">	**出现找错内存块的问题。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	a = create_subassy_record(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">//将参与运算的指针保护起来。</span></span><br><span class="line">	SUBASSYPART *new_part = a->info.subassy->part;</span><br><span class="line">	<span class="built_in">strcpy</span>(new_part->partno,<span class="string">"hello world"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%p\r\n"</span>, new_part);</span><br><span class="line">	new_part++;</span><br><span class="line">	<span class="built_in">strcpy</span>(new_part->partno, <span class="string">"this is my"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%p\r\n"</span>, new_part);</span><br><span class="line">	new_part++;</span><br><span class="line">	<span class="comment">//注意此处如果拷贝的数据超过数组长度，内存溢出</span></span><br><span class="line">	<span class="built_in">strcpy</span>(new_part->partno, <span class="string">"first function"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%p\r\n"</span>, new_part);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s"</span>, new_part->partno);</span><br><span class="line">	discard_inventory_record(a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ok"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>出现过的问题：</p>
<ul>
<li>注意了，由于动态分配的内存需要释放，如果将这个指针进行了运算，free的时候就会出问题，可能<strong>只释放了内存的一部分</strong>。另外如果运算了，其他地方进行引用，也容易内存块<strong>位置偏移</strong>的问题。</li>
<li>用strcpy的时候需要注意不能超出规定的内存范围，注意不能越界访问</li>
</ul>
<p><code>代码位置</code>：<a href="https://github.com/xiaoqinxing/myrepo_c" target="_blank" rel="noopener">https://github.com/xiaoqinxing/myrepo_c</a></p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 网络编程</title>
    <url>/posts/87d5a42a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的<strong>IP地址</strong>和<strong>端口号</strong>，再指定<strong>协议类型</strong>即可。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 导入socket库:</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个socket:</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 建立连接:</span></span><br><span class="line">s.connect((<span class="string">'www.sina.com.cn'</span>, <span class="number">80</span>))</span><br></pre></td></tr></tbody></table></figure>

<p>创建<code>Socket</code>时，<code>AF_INET</code>指定使用IPv4协议，如果要用更先进的IPv6，就指定为<code>AF_INET6</code>。<code>SOCK_STREAM</code>指定使用面向流的TCP协议，这样，一个<code>Socket</code>对象就创建成功，但是还没有建立连接。</p>
<p>客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。新浪网站的IP地址可以用域名<code>www.sina.com.cn</code>自动转换到IP地址，但是怎么知道新浪服务器的端口号呢？</p>
<p>答案是作为服务器，提供什么样的服务，端口号就必须固定下来。由于我们想要访问网页，因此新浪提供网页服务的服务器必须把端口号固定在<code>80</code>端口，因为<code>80</code>端口是Web服务的标准端口。其他服务都有对应的标准端口号，例如SMTP服务是<code>25</code>端口，FTP服务是<code>21</code>端口，等等。端口号小于1024的是Internet标准服务的端口，端口号大于1024的，可以任意使用。</p>
<p>建立TCP连接后，我们就可以向新浪服务器发送请求，要求返回首页的内容：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 发送数据:</span></span><br><span class="line">s.send(<span class="string">b'GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>TCP连接创建的是双向通道，双方都可以同时给对方发数据。但是谁先发谁后发，怎么协调，要根据具体的协议来决定。例如，HTTP协议规定客户端必须先发请求给服务器，服务器收到后才发数据给客户端。</p>
<p>发送的文本格式必须符合HTTP标准，如果格式没问题，接下来就可以接收新浪服务器返回的数据了：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 接收数据:</span></span><br><span class="line">buffer = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 每次最多接收1k字节:</span></span><br><span class="line">    d = s.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> d:</span><br><span class="line">        buffer.append(d)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">data = <span class="string">b''</span>.join(buffer)</span><br></pre></td></tr></tbody></table></figure>

<p><strong>接收数据时，调用<code>recv(max)</code>方法，一次最多接收指定的字节数，因此，在一个while循环中反复接收，直到<code>recv()</code>返回空数据，表示接收完毕，退出循环。</strong></p>
<p><strong>join函数指的是用指定字符连接生成一个新的字符串，由于这个字符是空，因此就是将list连接，生成新的字符串。</strong></p>
<p>当我们接收完数据后，调用<code>close()</code>方法关闭Socket，这样，一次完整的网络通信就结束了：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭连接:</span></span><br><span class="line">s.close()</span><br></pre></td></tr></tbody></table></figure>

<p><strong>split()</strong> 函数通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串；也就是说第一句是将data分割成两块</p>
<p>接收到的数据包括HTTP头和网页本身，我们只需要把HTTP头和网页分离一下，把HTTP头打印出来，网页内容保存到文件：——http头和网页分离是通过两个\r\n识别的</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">header, html = data.split(<span class="string">b'\r\n\r\n'</span>, <span class="number">1</span>)</span><br><span class="line">print(header.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="comment"># 把接收的数据写入文件:</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'sina.html'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(html)</span><br></pre></td></tr></tbody></table></figure>

<h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><p>和客户端编程相比，服务器编程就要复杂一些。</p>
<p>服务器进程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。</p>
<p>所以，服务器会打开固定端口（比如80）监听，每来一个客户端连接，就创建该Socket连接。由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。</p>
<p>但是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。</p>
<p>我们来编写一个简单的服务器程序，它接收客户端连接，把客户端发过来的字符串加上<code>Hello</code>再发回去。</p>
<h1 id="网页介绍"><a href="#网页介绍" class="headerlink" title="网页介绍"></a>网页介绍</h1><p>安装好Chrome浏览器后，打开Chrome，在菜单中选择“视图”，“开发者”，“开发者工具”，就可以显示开发者工具：</p>
<p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001399878215246e5c00e9142244698a91c5d558c5901a1000" alt="chrome-dev-tools"></p>
<p><code>Elements</code>显示网页的结构，<code>Network</code>显示浏览器和服务器的通信。我们点<code>Network</code>，确保第一个小红灯亮着，Chrome就会记录所有浏览器和服务器之间的通信：</p>
<p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001399878404470cf9e8257a27a4807b856b7dfa23f93a0000" alt="chrome-devtools-network"></p>
<p>当我们在地址栏输入<code>www.sina.com.cn</code>时，浏览器将显示新浪的首页。在这个过程中，浏览器都干了哪些事情呢？通过<code>Network</code>的记录，我们就可以知道。在<code>Network</code>中，定位到第一条记录，点击，右侧将显示<code>Request Headers</code>，点击右侧的<code>view source</code>，我们就可以看到浏览器发给新浪服务器的请求：</p>
<p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001399877287994279bc3d41b3040f985e3e8b838211465000" alt="sina-http-request"></p>
<p>最主要的头两行分析如下，第一行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br></pre></td></tr></tbody></table></figure>

<p><code>GET</code>表示一个读取请求，将从服务器获得网页数据，<code>/</code>表示URL的路径，URL总是以<code>/</code>开头，<code>/</code>就表示首页，最后的<code>HTTP/1.1</code>指示采用的HTTP协议版本是1.1。目前HTTP协议的版本就是1.1，但是大部分服务器也支持1.0版本，主要区别在于1.1版本允许多个HTTP请求复用一个TCP连接，以加快传输速度。</p>
<p>从第二行开始，每一行都类似于<code>Xxx: abcdefg</code>：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Host: www.sina.com.cn</span><br></pre></td></tr></tbody></table></figure>

<p>表示请求的域名是<code>www.sina.com.cn</code>。如果一台服务器有多个网站，服务器就需要通过<code>Host</code>来区分浏览器请求的是哪个网站。</p>
<p>继续往下找到<code>Response Headers</code>，点击<code>view source</code>，显示服务器返回的原始响应数据：</p>
<p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/0013998772979993bf20079a3d8452f9b44f9ec88f8a5c8000" alt="sina-http-response"></p>
<p>HTTP响应分为Header和Body两部分（Body是可选项），我们在<code>Network</code>中看到的Header最重要的几行如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">200 OK</span><br></pre></td></tr></tbody></table></figure>

<p><code>200</code>表示一个成功的响应，后面的<code>OK</code>是说明。失败的响应有<code>404 Not Found</code>：网页不存在，<code>500 Internal Server Error</code>：服务器内部出错，等等。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Content-Type: text/html</span><br></pre></td></tr></tbody></table></figure>

<p><code>Content-Type</code>指示响应的内容，这里是<code>text/html</code>表示HTML网页。请注意，浏览器就是依靠<code>Content-Type</code>来判断响应的内容是网页还是图片，是视频还是音乐。浏览器并不靠URL来判断响应的内容，所以，即使URL是<code>http://example.com/abc.jpg</code>，它也不一定就是图片。</p>
<p>HTTP响应的Body就是HTML源码，我们在菜单栏选择“视图”，“开发者”，“查看网页源码”就可以在浏览器中直接查看HTML源码：</p>
<p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001399877306431ffee0ff7d3fe48bb88da759bb977c1e0000" alt="sina-http-source"></p>
<p>当浏览器读取到新浪首页的HTML源码后，它会解析HTML，显示页面，然后，根据HTML里面的各种链接，再发送HTTP请求给新浪服务器，拿到相应的图片、视频、Flash、JavaScript脚本、CSS等各种资源，最终显示出一个完整的页面。所以我们在<code>Network</code>下面能看到很多额外的HTTP请求。</p>
<h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p>跟踪了新浪的首页，我们来总结一下HTTP请求的流程：</p>
<p>步骤1：浏览器首先向服务器发送HTTP请求，请求包括：</p>
<p>方法：GET还是POST，GET仅请求资源，POST会附带用户数据；</p>
<p>路径：/full/url/path；</p>
<p>域名：由Host头指定：Host: <a href="http://www.sina.com.cn" target="_blank" rel="noopener">www.sina.com.cn</a></p>
<p>以及其他相关的Header；</p>
<p>如果是POST，那么请求还包括一个Body，包含用户数据。</p>
<p>步骤2：服务器向浏览器返回HTTP响应，响应包括：</p>
<p>响应代码：200表示成功，3xx表示重定向，4xx表示客户端发送的请求有错误，5xx表示服务器端处理时发生了错误；</p>
<p>响应类型：由Content-Type指定；</p>
<p>以及其他相关的Header；</p>
<p>通常服务器的HTTP响应会携带内容，也就是有一个Body，包含响应的内容，网页的HTML源码就在Body中。</p>
<p>步骤3：如果浏览器还需要继续向服务器请求其他资源，比如图片，就再次发出HTTP请求，重复步骤1、2。</p>
<p>Web采用的HTTP协议采用了非常简单的请求-响应模式，从而大大简化了开发。当我们编写一个页面时，我们只需要在HTTP请求中把HTML发送出去，不需要考虑如何附带图片、视频等，浏览器如果需要请求图片和视频，它会发送另一个HTTP请求，因此，一个HTTP请求只处理一个资源。</p>
<p>HTTP协议同时具备极强的扩展性，虽然浏览器请求的是<code>http://www.sina.com.cn/</code>的首页，但是新浪在HTML中可以链入其他服务器的资源，比如<code><img src="http://i1.sinaimg.cn/home/2013/1008/U8455P30DT20131008135420.png"></code>，从而将请求压力分散到各个服务器上，并且，一个站点可以链接到其他站点，无数个站点互相链接起来，就形成了World Wide Web，简称WWW。</p>
<h3 id="HTTP格式"><a href="#HTTP格式" class="headerlink" title="HTTP格式"></a>HTTP格式</h3><p>每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分，其中Body是可选的。</p>
<p>HTTP协议是一种文本协议，所以，它的格式也非常简单。HTTP GET请求的格式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">GET /path HTTP/1.1</span><br><span class="line">Header1: Value1</span><br><span class="line">Header2: Value2</span><br><span class="line">Header3: Value3</span><br></pre></td></tr></tbody></table></figure>

<p>每个Header一行一个，换行符是<code>\r\n</code>。</p>
<p>HTTP POST请求的格式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">POST /path HTTP/1.1</span><br><span class="line">Header1: Value1</span><br><span class="line">Header2: Value2</span><br><span class="line">Header3: Value3</span><br><span class="line"></span><br><span class="line">body data goes here...</span><br></pre></td></tr></tbody></table></figure>

<p>当遇到连续两个<code>\r\n</code>时，Header部分结束，后面的数据全部是Body。</p>
<p>HTTP响应的格式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">200 OK</span><br><span class="line">Header1: Value1</span><br><span class="line">Header2: Value2</span><br><span class="line">Header3: Value3</span><br><span class="line"></span><br><span class="line">body data goes here...</span><br></pre></td></tr></tbody></table></figure>

<p>HTTP响应如果包含body，也是通过<code>\r\n\r\n</code>来分隔的。请再次注意，Body的数据类型由<code>Content-Type</code>头来确定，如果是网页，Body就是文本，如果是图片，Body就是图片的二进制数据。</p>
<p>当存在<code>Content-Encoding</code>时，Body数据是被压缩的，最常见的压缩方式是gzip，所以，看到<code>Content-Encoding: gzip</code>时，需要将Body数据先解压缩，才能得到真正的数据。压缩的目的在于减少Body的大小，加快网络传输。</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>手动快门增益功能实现</title>
    <url>/posts/c6559357/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>如何实现手动设置快门和增益？<br>如何避免因为不同的数据流在不同的地方设置增益和快门？</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>拍照和预览设置增益可能会发生改变，如果用手动AE也可能出问题。最好的地方是他们共用的地方，可以想到的是sensor模块，sensor模块是和硬件最密切的，在这里可以进行寄存器的设置。我们找到不论何种模式都会进行设置的地方进行修改就行了。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>拿imx290举例，它的常用寄存器地址和函数是在imx290_lib.h中定义的。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">sensor_lib_t</span> sensor_lib_ptr =</span><br><span class="line">{</span><br><span class="line">    .sensor_slave_info =</span><br><span class="line">    {</span><br><span class="line">        .sensor_name    = SENSOR_MODEL,</span><br><span class="line">        .slave_addr     = <span class="number">0x34</span>,</span><br><span class="line">        .i2c_freq_mode  = SENSOR_I2C_MODE_FAST,</span><br><span class="line">        .addr_type      = CAMERA_I2C_WORD_ADDR,</span><br><span class="line">        .sensor_id_info =</span><br><span class="line">        {</span><br><span class="line">            .sensor_id_reg_addr = <span class="number">0x301E</span>, <span class="comment">// a fake id register</span></span><br><span class="line">            .sensor_id          = <span class="number">0xB201</span>, <span class="comment">// a fixed value</span></span><br><span class="line">        }</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这是对结构体的乱序赋值，既能初始化时赋值，也可以不考虑顺序。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">.exposure_func_table =</span><br><span class="line">    {</span><br><span class="line">        .sensor_calculate_exposure  = sensor_calculate_exposure,</span><br><span class="line">        .sensor_fill_exposure_array = sensor_fill_exposure_array,</span><br><span class="line">    },</span><br></pre></td></tr></tbody></table></figure>
<p>仔细看其中，会发现这个结构体里还有函数方法。而这个函数就是具体不同型号中对寄存器的操作，就比如写入增益寄存器，可能存在有的有一个字节，有的需要两个字节。给一个相同的函数入口，其实就是实现了面向对象编程中的多态。</p>
<p>我们需要修改的是写入sensor的增益和快门，因此越接近底层越不容易出现问题，比如避免因为预览和拍照流的参数位置不同造成的影响。</p>
<p><code>sensor_fill_exposure_array</code>函数是对曝光类寄存器进行操作，<br>由于<code>sensor_fill_exposure_array</code>是对曝光表的直接寄存器操作，因此可以说是最底层了，但是不同的sensor这个函数的内容也不一样，因此我们需要先找到调用它的函数。</p>
<p>我们可以看到sensor模块中的<code>sensor_apply_exposure</code>和<code>sensor_set_exposure</code>函数不仅仅是在sensor aec的init中进行调用，还有双摄，从摄，手动AE，自动AE的设置，可以说它是所有数据流设置曝光增益流程的必经之处。</p>
<p>在<code>sensor_apply_exposure</code>中会对aec的最大曝光行最大增益等进行判断，保证不会超过lib.h的限制之后，然后通过<code>sensor_fill_exposure_array</code>写入。不希望我们写入的值超过了sensor的设置，因此我们最好在apply函数之前，也就是<code>sensor_set_exposure</code>函数之后进行修改。</p>
<p>在<code>sensor_calculate_exposure</code>函数中，将增益转换成了可以写入寄存器的整型，因此我们也不要动，在<code>sensor_calculate_exposure</code>之前进行修改，同时又尽可能的少，就选择在<code>sensor_set_exposure</code>函数里的<code>sensor_calculate_exposure</code>对曝光和增益进行修改。</p>
<p>让人吐血的是，这里已经有高通的设置了。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_MANUAL_EXPOSURE_UPDATE</span></span><br><span class="line">  <span class="keyword">if</span>(updateExtGain(&ext_real_gain) == SENSOR_SUCCESS)</span><br><span class="line">    real_gain = ext_real_gain;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(updateExtLinecount(&ext_linecount) == SENSOR_SUCCESS)</span><br><span class="line">    linecount = ext_linecount;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int32_t</span> <span class="title">updateExtGain</span><span class="params">(<span class="keyword">float</span> *real_gain)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">char</span> ext_real_gain[PROPERTY_VALUE_MAX];</span><br><span class="line"></span><br><span class="line">  RETURN_ERROR_ON_NULL(real_gain);</span><br><span class="line"></span><br><span class="line">  property_get(<span class="string">"persist.camera.sensor.gain"</span>, ext_real_gain, <span class="string">"0"</span>);</span><br><span class="line">  *real_gain = atoi(ext_real_gain);</span><br><span class="line">  <span class="keyword">if</span> (*real_gain > <span class="number">0</span>) {</span><br><span class="line">    SERR(<span class="string">"Updated gain: %f"</span>, *real_gain);</span><br><span class="line">    <span class="keyword">return</span> SENSOR_SUCCESS;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SENSOR_FAILURE;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int32_t</span> <span class="title">updateExtLinecount</span><span class="params">(<span class="keyword">uint32_t</span> *linecount)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">char</span> ext_linecount[PROPERTY_VALUE_MAX];</span><br><span class="line"></span><br><span class="line">  RETURN_ERROR_ON_NULL(linecount);</span><br><span class="line"></span><br><span class="line">  property_get(<span class="string">"persist.camera.sensor.linecount"</span>, ext_linecount, <span class="string">"0"</span>);</span><br><span class="line">  *linecount = atoi(ext_linecount);</span><br><span class="line">  <span class="keyword">if</span> (*linecount > <span class="number">0</span>) {</span><br><span class="line">    SERR(<span class="string">"Updated linecount: %d"</span>, *linecount);</span><br><span class="line">    <span class="keyword">return</span> SENSOR_SUCCESS;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SENSOR_FAILURE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是将<code>ENABLE_MANUAL_EXPOSURE_UPDATE</code>定义一下，去修改<code>persist.camera.sensor.gain</code>和<code>persist.camera.sensor.linecount</code>，没有发现图像有明显变化。</p>
<p>发现赋值过去的real_gain和linecount两个变量根本没有用到，没有进行设置，于是将</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* 修改前   </span></span><br><span class="line"><span class="comment">   lib->sensor_lib_ptr->exposure_func_table.sensor_calculate_exposure(</span></span><br><span class="line"><span class="comment">       exposure.real_gain, exposure.linecount, &exp_info, &exposure.hdr_exposure);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    lib->sensor_lib_ptr->exposure_func_table.sensor_calculate_exposure(</span><br><span class="line">       real_gain, linecount, &exp_info, &exposure.hdr_exposure);</span><br></pre></td></tr></tbody></table></figure>
<p>对比660设备的代码，发现660代码进行了设置。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (lib->sensor_lib_ptr->exposure_func_table.calc_exp_array_type ==</span><br><span class="line">  CALC_CUSTOM_IN_LIB &&</span><br><span class="line">  lib->sensor_lib_ptr->exposure_func_table.sensor_calculate_exposure) {</span><br><span class="line">  lib->sensor_lib_ptr->exposure_func_table.sensor_calculate_exposure(</span><br><span class="line">     real_gain, linecount, &exp_info, exposure.s_real_gain);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  sensor_cmn_calc_exposure(lib->sensor_lib_ptr,</span><br><span class="line">    real_gain, linecount, &exp_info, exposure.s_real_gain);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里应该是高通之前代码的错误，并没有像手册一样实现手动控制增益的功能。</p>
<p><img src="https://image.qinxing.xyz/1552546053938.png" alt></p>
<h2 id="功能叙述"><a href="#功能叙述" class="headerlink" title="功能叙述"></a>功能叙述</h2><p><code>persist.camera.sensor.gain</code>用来设置手动增益，默认是整数，我改成了浮点数，方便去细调。如果不设置或者设置为0,则增益是自动</p>
<p><code>persist.camera.sensor.linecount</code>用来设置手动快门，需要是整数，同样不进行设置或者设置为0，快门是自动。</p>
<p><strong>注意：</strong> 8056平台不适用这套代码逻辑</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>手动增益实现</tag>
        <tag>sensor模块</tag>
      </tags>
  </entry>
  <entry>
    <title>sensor模块代码理解及学习</title>
    <url>/posts/6cbd822f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>sensor模块如何识别不同的设备和型号？如何选用相应型号的头文件？</p>
</blockquote>
<p>拿imx290举例，它的常用寄存器地址和函数是在imx290_lib.h中定义的。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">sensor_lib_t</span> sensor_lib_ptr =</span><br><span class="line">{</span><br><span class="line">    .sensor_slave_info =</span><br><span class="line">    {</span><br><span class="line">        .sensor_name    = SENSOR_MODEL,</span><br><span class="line">        .slave_addr     = <span class="number">0x34</span>,</span><br><span class="line">        .i2c_freq_mode  = SENSOR_I2C_MODE_FAST,</span><br><span class="line">        .addr_type      = CAMERA_I2C_WORD_ADDR,</span><br><span class="line">        .sensor_id_info =</span><br><span class="line">        {</span><br><span class="line">            .sensor_id_reg_addr = <span class="number">0x301E</span>, <span class="comment">// a fake id register</span></span><br><span class="line">            .sensor_id          = <span class="number">0xB201</span>, <span class="comment">// a fixed value</span></span><br><span class="line">        }</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这是对结构体的乱序赋值，既能初始化时赋值，也可以不考虑顺序。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">.exposure_func_table =</span><br><span class="line">    {</span><br><span class="line">        .sensor_calculate_exposure  = sensor_calculate_exposure,</span><br><span class="line">        .sensor_fill_exposure_array = sensor_fill_exposure_array,</span><br><span class="line">    },</span><br></pre></td></tr></tbody></table></figure>
<p>仔细看其中，会发现这个结构体里还有函数方法。而这个函数就是具体不同型号中对寄存器的操作，就比如写入增益寄存器，可能存在有的有一个字节，有的需要两个字节。给一个相同的函数入口，其实就是实现了面向对象编程中的多态。</p>
<p>我们需要修改的是写入sensor的增益和快门，因此越接近底层越不容易出现问题，比如避免因为预览和拍照流的参数位置不同造成的影响。</p>
<p><code>sensor_fill_exposure_array</code>函数是对曝光类寄存器进行操作，</p>
<p>在头文件中初始化如何引用？不是说变量不要在头文件中初始化么？<br>虽然在代码中好像使用了相同的变量，但是实际上使用的是不同的变量，在每个源文件中都有单独的变量。所以，在头文件中定义static变量会造成变量多次定义，造成内存空间的浪费，而且也不是真正的全局变量。应该避免使用这种定义方式。<br>先假定为声明，多次声明是没错的，最后才是定义<br>问：</p>
<p>一般来说，静态全局变量只应该定义在实现文件中，但有时由于一些特殊的目的，也可能定义在头文件中。比如在有些标准库的实现中，就用这种方法来初始化标准流cin, cout，或者在在tr1库中，也用这种方法来定义占位符。每一个包含该头文件的实现文件中都拥有该变量的一份拷贝，这些变量放在运行体的data段或者bss段。<br>比如下面这个变量定义在一个头文件中：<br>static int data[1024*1024];<br>我把这个文件同时包含在几个cpp文件中，按我的理解，这个程序占用的内存应该显著增大，但是，从实际运行结果来看，并没有变化，生成的exe文件大小也没有变化，这是因为延迟加载呢，还是被编译器优化掉了？有没有明白的达人解释一下。</p>
<p>答：<br>这不是编译器的问题，而是OS的virtual memeory管理机制导致的。数据在实际使用之前，是不会占用内存的——缺页异常处理程序会为数据分配需要的内存。</p>
<p>要理解static，就必须要先理解另一个与之相对的关键字，很多人可能都还不知道有这个关键字，那就是auto，其实我们通常声明的不用static修饰的变量，都是auto的，因为它是默认的，就象short和long总是默认为int一样；我们通常声明一个变量：<br>int a;<br>string s;<br>其实就是：<br>auto int a;<br>auto string s;<br>而static变量的声明是：<br>static int a;<br>static string s;<br>这样似乎可以更有利于理解auto和static是一对成对的关键字吧，就像private，protected，public一样；<br>对于static的不理解，其实就是对于auto的不理解，因为它是更一般的；有的东西你天天在用，但未必就代表你真正了解它；auto的含义是由程序自动控制变量的生存周期，通常指的就是变量在进入其作用域的时候被分配，离开其作用域的时候被释放；而static就是不auto，变量在程序初始化时被分配，直到程序退出前才被释放；也就是static是按照程序的生命周期来分配释放变量的，而不是变量自己的生命周期；所以，像这样的例子：<br>void func()<br>{<br>int a;<br>static int b;<br>}<br>每一次调用该函数，变量a都是新的，因为它是在进入函数体的时候被分配，退出函数体的时候被释放，所以多个线程调用该函数，都会拥有各自独立的变量a，因为它总是要被重新分配的；而变量b不管你是否使用该函数，在程序初始化时就被分配的了，或者在第一次执行到它的声明的时候分配（不同的编译器可能不同），所以多个线程调用该函数的时候，总是访问同一个变量b，这也是在多线程编程中必须注意的！ </p>
<p>只在cpp内有效的全局变量：<br>在cpp文件的全局范围内声明：<br>static int g_ = 0;<br>这个变量的含义是在该cpp内有效，但是其他的cpp文件不能访问这个变量；如果有两个cpp文件声明了同名的全局静态变量，那么他们实际上是独立的两个变量；<br>如果不使用static声明全局变量：<br>int g_ = 0;<br>那么将无法保证这个变量不被别的cpp共享，也无法保证一定能被别的cpp共享，因为要让多个cpp共享一个全局变量，应将它声明为extern（外部）的；也有可能编译会报告变量被重复定义；总之不建议这样的写法，不明确这个全局变量的用法；<br>如果在一个头文件中声明：<br>static int g_vaule = 0;<br>那么会为每个包含该头文件的cpp都创建一个全局变量，但他们都是独立的；所以也不建议这样的写法，一样不明确需要怎样使用这个变量，因为只是创建了一组同名而不同作用域的变量。<br>这里顺便说一下如何声明所有cpp可共享的全局变量，在头文件里声明为extern的：<br>extern int g_; // 注意，不要初始化值！<br>然后在其中任何一个包含该头文件的cpp中初始化（一次）就好：<br>int g_ = 0; // 初始化一样不要extern修饰，因为extern也是声明性关键字；<br>然后所有包含该头文件的cpp文件都可以用g_这个名字访问相同的一个变量； </p>
<p>也就是说在头文件中定义变量，调用一次其实就会创建一个新变量。那么这个的好处是什么呢？为什么不放在C语言中呢？</p>
<p>利用<code>sensor_open_lib</code>函数传递相应设备的结构体（包含方法和变量），但是他是如何引用？</p>
<p>在sensor.c中的<code>sensor_load_library</code>函数中用到了<code>sensor_open_lib</code>;也就是说在这个地方进行了调用。从此函数可以看出来是根据sensor的名字进行调用。</p>
<p>把容易变化的放在动态库中，</p>
<p>注意：sensor_lib.h</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">  <span class="comment">/** Tells the way the gain is computed and how gain and exposure are applied</span></span><br><span class="line"><span class="comment">   fill_exp_array_type     -> Mentions how exposure and gain api is implemented</span></span><br><span class="line"><span class="comment">   calc_exp_array_type     -> Mentions how gain is calculated</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  fill_exp fill_exp_array_type;</span><br><span class="line">  calc_exp calc_exp_array_type;</span><br><span class="line">  <span class="comment">/** Function to calculate exosure based on real gain and</span></span><br><span class="line"><span class="comment">   *  linecount value, 1st param - real gain, 2nd param -</span></span><br><span class="line"><span class="comment">   *  linecount, 3rd param - exposure info output, return staus -</span></span><br><span class="line"><span class="comment">   *  success / failure */</span></span><br><span class="line">  <span class="keyword">int</span> (*sensor_calculate_exposure) (<span class="keyword">float</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>,</span><br><span class="line">    <span class="keyword">sensor_exposure_info_t</span> *, <span class="keyword">float</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Function to create register table from exposure settings</span></span><br><span class="line"><span class="comment">   * input param1 - register gain value</span></span><br><span class="line"><span class="comment">   * input param2 - digital gain value</span></span><br><span class="line"><span class="comment">   * input param3 - coarse integration time value</span></span><br><span class="line"><span class="comment">   * input param4 - frame length line value</span></span><br><span class="line"><span class="comment">   * input param5 - hdr luma</span></span><br><span class="line"><span class="comment">   * input param6 - hdr param</span></span><br><span class="line"><span class="comment">   * input param7 - register settings</span></span><br><span class="line"><span class="comment">   * return value - 0 for success and negative value for</span></span><br><span class="line"><span class="comment">   * failure **/</span></span><br><span class="line">  <span class="keyword">int</span> (*sensor_fill_exposure_array)(<span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>,</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>, struct camera_i2c_reg_setting *,</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">} <span class="keyword">sensor_exposure_table_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sensor_calculate_exposure</span><span class="params">(<span class="keyword">float</span> real_gain,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">unsigned</span> <span class="keyword">int</span> line_count, <span class="keyword">sensor_exposure_info_t</span> *exp_info, <span class="keyword">float</span> s_real_gain)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sensor_fill_exposure_array</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gain,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">unsigned</span> <span class="keyword">int</span> digital_gain, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">line</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">unsigned</span> <span class="keyword">int</span> fl_lines, <span class="keyword">int</span> luma_avg, <span class="keyword">unsigned</span> <span class="keyword">int</span> hdr_param,</span></span></span><br><span class="line"><span class="function"><span class="params">  struct camera_i2c_reg_setting* reg_setting,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">unsigned</span> <span class="keyword">int</span> s_reg_gain, <span class="keyword">int</span> s_linecount, <span class="keyword">int</span> is_hdr_enabled)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>结构体中的函数指针和函数名相同，并没直接引用。而是在imx290_lib.h文件中进行了引用。</p>
<p>.exposure_func_table =<br>    {<br>        .sensor_calculate_exposure  = sensor_calculate_exposure,<br>        .sensor_fill_exposure_array = sensor_fill_exposure_array,<br>    },</p>
<p>其实这两者虽然名字相同，但是并没有进行对应。结构体中的int(*p)（int,int)其实就是定义的一个函数。我觉得虽然加了括号，但是其实本质还是定义了一个指针，交代了指向的区域是什么类型。是否这个括号是必须的？</p>
<p>*p[4] 是一个指针数组，首先它是一个数组，数组中存的是指针，存指针的数组。<br>(*q)[4] 是数组指针，加括号先与 *结合，它是一个指针，指向一个第一维包含2个元素的2维数组，存数组地址的指针。</p>
<p>也就是说int(*p)（int,int)是一个函数指针，p指向这个函数。</p>
<p>当引用的时候可以直接把函数指针p当做函数名耐用，也可以用*p。</p>
<p><strong>注意区分：</strong></p>
<table>
<thead>
<tr>
<th>声明</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>int p(int);</td>
<td>简单的使用名字调用函数P,但是执行过程可能和我想象的不太一样，函数名p首先转换为一个函数指针，该指针指定函数在内存中的位置。然后函数调用操作符调用该函数，执行开始于这个地址的代码。</td>
</tr>
<tr>
<td>int  *p();</td>
<td>声明和普通的表达式在求值所用的规则相同。首先执行的是函数调用操作符()，因为它的优先级高于间接访问操作符*；因此p是一个函数，它的返回类型是一个整型的指针。</td>
</tr>
<tr>
<td>int (*p)();</td>
<td>第二队括号是函数调用操作符，第一对括号迫使间接访问在函数调用之前进行，使f成为一个函数指针，他所指向的函数返回一个整型值。</td>
</tr>
<tr>
<td>int *(*p)();</td>
<td>p是一个函数指针，所指向的函数的返回值是一个整型指针。</td>
</tr>
</tbody></table>
<p>​       </p>
<p>刚刚看到一个有意思的问题：float可以表示的数范围大的多，那么float是否能比int表示更多不同的值呢？</p>
<p>答案是否定的，float和int长度一样，这就代表他们能够表示的不同的值的数量是相同的，但是在绝大多数浮点系统中，这个答案是错误的，0通常有很多种表示形式，而且通过使用不规范的小数形式，其他值也具有多种不同的表示形式。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *(*sensor_open_lib)(<span class="keyword">void</span>) = <span class="literal">NULL</span>;<span class="comment">//初始化声明</span></span><br><span class="line">*(<span class="keyword">void</span> **)&sensor_open_lib = dlsym(sensor_lib_params->sensor_lib_handle,</span><br><span class="line">    open_lib_str);<span class="comment">//赋值</span></span><br><span class="line">sensor_lib_params->sensor_lib_ptr = (<span class="keyword">sensor_lib_t</span> *)sensor_open_lib();<span class="comment">//调用</span></span><br></pre></td></tr></tbody></table></figure>

<p>但是这么多指针什么意思需要考虑一下</p>
<p>由于<code>sensor_fill_exposure_array</code>是对曝光表的直接寄存器操作，因此可以说是最底层了，但是不同的sensor这个函数的内容也不一样，因此我们需要先找到调用它的函数。</p>
<p>我们可以看到sensor模块中的``sensor_apply_exposure<code>和</code>sensor_set_exposure`函数不仅仅是在sensor aec的init中进行调用，还有双摄，从摄，手动AE，自动AE的设置，可以说它是所有数据流设置曝光增益流程的必经之处。</p>
<p>在<code>sensor_apply_exposure</code>中会对aec的最大曝光行最大增益等进行判断，保证不会超过lib.h的限制之后，然后通过<code>sensor_fill_exposure_array</code>写入。不希望我们写入的值超过了sensor的设置，因此我们最好在apply函数之前，也就是<code>sensor_set_exposure</code>函数之后进行修改。</p>
<p>在<code>sensor_calculate_exposure</code>函数中，将增益转换成了可以写入寄存器的整型，因此我们也不要动，在<code>sensor_calculate_exposure</code>之前进行修改，同时又尽可能的少，就选择在<code>sensor_set_exposure</code>函数里的<code>sensor_calculate_exposure</code>对曝光和增益进行修改。</p>
<p>让人吐血的是，这里已经有高通的设置了。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_MANUAL_EXPOSURE_UPDATE</span></span><br><span class="line">  <span class="keyword">if</span>(updateExtGain(&ext_real_gain) == SENSOR_SUCCESS)</span><br><span class="line">    real_gain = ext_real_gain;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(updateExtLinecount(&ext_linecount) == SENSOR_SUCCESS)</span><br><span class="line">    linecount = ext_linecount;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>但是将<code>ENABLE_MANUAL_EXPOSURE_UPDATE</code>定义一下，发现并没有出现问题。</p>
<p>但是会有一个问题，打印可能不会显示。</p>
<p>typedef 允许为各种数据类型定义新名字。typedef声明的写法和普通的声明基本相同，只是把typedef这个关键字出现在了声明前面。</p>
<p>如：char  *ptr;代表ptr声明为一个指向字符的指针。加上typedef之后：</p>
<p>typedef char  *ptr;把标识符ptr作为指向字符类型的指针类型的新名字。</p>
<p>ptr a;就是声明a是一个指向字符的指针。</p>
<p>一直以为typedef和define类似，走进了这个误区。</p>
<p>可以在sensor_load_library看到通过sensor name加载不同的动态库。<br>又是如何确定sensor name呢？<br>通过sebsor_probe调用，又被init_xml_probe函数通过xml文件，配置相应的sensor及chromatix。<br>#define CONFIG_XML_SYSTEM_PATH “/system/etc/camera/“<br>进入/system/etc/camera/会发现几个文件：camera_config.xml csidtg_camera.xml csidtg_chromatix.xml imx290_chromatix.xml<br>这就代表了这个用的是290的sensor</p>
<p>可是你会发现在文件夹media-controller\modules\sensors\configs中，xml文件又有很多很多，每个设备都有对应的xml</p>
<p>那么又是如何区分的呢？</p>
<p>media-controller/modules/sensors/configs/Android.mk文件中</p>
<p>LOCAL_SRC_FILES代表着根据不同的设备选用不同的xml文件</p>
<p><img src="/posts/6cbd822f/../../../Users/keda/Pictures/photo/1553493767329.png" alt></p>
<p>看xml文件，里面交代了每个sensor的名字，以及镜头，视场角等信息，</p>
<p>xml里面还有HWID，每个HWID对应了不同的sensor和chromatix文件</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>手动增益实现</tag>
        <tag>sensor模块</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile基础和编译模板</title>
    <url>/posts/21c9d9a6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>如何进行Makefile的编写？<br>如何编译动态库？<br>如何引用动态库？</p>
</blockquote>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="Makefile-gcc的参数"><a href="#Makefile-gcc的参数" class="headerlink" title="Makefile gcc的参数"></a>Makefile gcc的参数</h2><p>-Wall： 是打开警告开关，</p>
<p>-O：    代表默认优化，可选：-O0不优化，-O1低级优化，-O2中级优化，-O3高级优化，-Os代码空间优化。</p>
<p>-g：     是生成调试信息，生成的可执行文件具有和源代码关联的可调试的信息。 </p>
<p>-I（大写的i）：代表后面跟的目录为第一个寻找<strong>头文件</strong>的目录</p>
<p>-L：     代表后面跟的目录为第一个寻找<strong>库文件</strong>的目录</p>
<p>-l（小写的L）：表示libxxx.so<strong>库文件</strong></p>
<p>-static：  静态编译的</p>
<p>-c（小写）：    只编译，不链接</p>
<p>-C（大写）：   切换到指定目录再执行 make 过程，makefile 在这个指定目录里面，然后返回到当前目录继续读入、执行当前的Makefile。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">gcc -o hello hello.c -I /home/hello/include -L /home/hello/lib -lworld</span><br><span class="line"></span><br><span class="line">上面这句表示在编译hello.c时：</span><br><span class="line"></span><br><span class="line">-I /home/hello/include表示将/home/hello/include目录作为第一个寻找头文件的目录，寻找的顺序是：/home/hello/include-->/usr/include-->/usr/local/include</span><br><span class="line"></span><br><span class="line">-L /home/hello/lib表示将/home/hello/lib目录作为第一个寻找库文件的目录，寻找的顺序是：/home/hello/lib-->/lib-->/usr/lib-->/usr/local/lib</span><br><span class="line"></span><br><span class="line">-lworld表示在上面的lib的路径中寻找libworld.so动态库文件（如果gcc编译选项中加入了“-static”表示寻找libworld.a静态库文件）</span><br></pre></td></tr></tbody></table></figure>

<h1 id="android-mk"><a href="#android-mk" class="headerlink" title="android.mk"></a>android.mk</h1><p>官方介绍：<a href="http://android.mk/" target="_blank" rel="noopener">http://android.mk/</a></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>可以生成一下几个类别：</p>
<table>
<thead>
<tr>
<th>JAVA代码的</th>
<th>C/C++代码的</th>
</tr>
</thead>
<tbody><tr>
<td>JAR包</td>
<td>二进制可执行文件：ELF (BUILD_EXECUTABLE)</td>
</tr>
<tr>
<td>应用程序：APK</td>
<td>动态库：.so　　         (BUILD_SHARED_LIBRARY)</td>
</tr>
<tr>
<td></td>
<td>静态库：.a                (BUILD_STATIC_LIBRARY)</td>
</tr>
</tbody></table>
<p>常用的变量：</p>
<table>
<thead>
<tr>
<th><code>名字</code></th>
<th>含义</th>
<th>常用的方式</th>
</tr>
</thead>
<tbody><tr>
<td><code>LOCAL_PATH</code></td>
<td>当前模块的相对路径</td>
<td>LOCAL_PATH := $(call my-dir)</td>
</tr>
<tr>
<td><code>LOCAL_MODULE</code></td>
<td>编译生成的目标名称</td>
<td>LOCAL_MODULE := test</td>
</tr>
<tr>
<td>LOCAL_SRC_FILES</td>
<td>编译该模块需要的源文件</td>
<td>LOCAL_SRC_FILES := test.c</td>
</tr>
<tr>
<td>LOCAL_C_INCLUDES</td>
<td>包含C的头文件目录</td>
<td></td>
</tr>
<tr>
<td>LOCAL_SHARED_LIBRARIES</td>
<td>导入共享库</td>
<td>LOCAL_SHARED_LIBRARIES += liblog</td>
</tr>
</tbody></table>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hejin@desk-ubuntu:/home/desk/myandroid$ ls external/test/</span><br><span class="line">Android.mk  test2.c  test2.h  test.c</span><br></pre></td></tr></tbody></table></figure>



<p>分别查看四个源文件的内容：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hejin@desk-ubuntu:/home/desk/myandroid$ cat external/test/test.c</span><br><span class="line">#include "stdio.h"</span><br><span class="line">#include "test2.h"</span><br><span class="line">int main(){</span><br><span class="line">        printf("hello world\n");</span><br><span class="line">        test2();</span><br><span class="line">        return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hejin@desk-ubuntu:/home/desk/myandroid$ cat external/test/test2.c</span><br><span class="line">#include"stdio.h"</span><br><span class="line"></span><br><span class="line">void test2(){</span><br><span class="line">        printf("hello test2\n");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hejin@desk-ubuntu:/home/desk/myandroid$ cat external/test/test2.h</span><br><span class="line">void test2();</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Android.mk:</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hejin@desk-ubuntu:/home/desk/myandroid$ cat external/test/Android.mk</span><br><span class="line">LOCAL_PATH := $(call my-dir)      #定义了当前模块的相对路径</span><br><span class="line">include $(CLEAR_VARS)             #清空当前环境变量， 除了LOCAL_PATH</span><br><span class="line">LOCAL_MODULE := libtest              #编译生成的目标名称</span><br><span class="line">LOCAL_SRC_FILES := test.c \       #编译该模块需要的源文件</span><br><span class="line">                   test2.c</span><br><span class="line">include $(BUILD_SHARED_LIBRARY)       #编译所生成的目标文件格（在这里是动态库文件）</span><br></pre></td></tr></tbody></table></figure>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hejin@desk-ubuntu:/home/desk/myandroid$ source build/envsetup.sh</span><br><span class="line">hejin@desk-ubuntu:/home/desk/myandroid$ lunch</span><br><span class="line">hejin@desk-ubuntu:/home/desk/myandroid$ mmm external/test/</span><br><span class="line">============================================</span><br><span class="line">PLATFORM_VERSION_CODENAME=REL</span><br><span class="line">PLATFORM_VERSION=5.1.1</span><br><span class="line">TARGET_PRODUCT=sabresd_6dq</span><br><span class="line">TARGET_BUILD_VARIANT=user</span><br><span class="line">TARGET_BUILD_TYPE=release</span><br><span class="line">TARGET_BUILD_APPS=</span><br><span class="line">TARGET_ARCH=arm</span><br><span class="line">TARGET_ARCH_VARIANT=armv7-a-neon</span><br><span class="line">TARGET_CPU_VARIANT=cortex-a9</span><br><span class="line">TARGET_2ND_ARCH=</span><br><span class="line">TARGET_2ND_ARCH_VARIANT=</span><br><span class="line">TARGET_2ND_CPU_VARIANT=</span><br><span class="line">HOST_ARCH=x86_64</span><br><span class="line">HOST_OS=linux</span><br><span class="line">HOST_OS_EXTRA=Linux-3.16.0-30-generic-x86_64-with-Ubuntu-14.04-trusty</span><br><span class="line">HOST_BUILD_TYPE=release</span><br><span class="line">BUILD_ID=2.1.0-ga-rc3</span><br><span class="line">OUT_DIR=out</span><br><span class="line">============================================</span><br><span class="line">No private recovery resources for TARGET_DEVICE sabresd_6dq</span><br><span class="line">make: Entering directory `/home/desk/myandroid'</span><br><span class="line">target thumb C: test <= external/test/test.c</span><br><span class="line">target thumb C: test <= external/test/test2.c</span><br><span class="line">target Executable: test (out/target/product/sabresd_6dq/obj/EXECUTABLES/test_intermediates/LINKED/test)</span><br><span class="line">target Symbolic: test (out/target/product/sabresd_6dq/symbols/system/bin/test)    </span><br><span class="line">target Strip: test (out/target/product/sabresd_6dq/obj/EXECUTABLES/test_intermediates/test)</span><br><span class="line">Install: out/target/product/sabresd_6dq/system/bin/test    //将可执行文件安装到这个目录下</span><br><span class="line">make: Leaving directory `/home/desk/myandroid'</span><br><span class="line"></span><br><span class="line">#### make completed successfully (1 seconds) ####</span><br></pre></td></tr></tbody></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>makefile文件有一个基础的东西就是变量。大家可以自己了解下。这里我们说说android.mk这个变量的不同的地方。主要是用它来做代码管理。</p>
<p>首先在执行make文件的时候这些变量是全局有效的，一些公共的变量会通过include $(CLEAR_VARS)给清除掉。我们这里主要是添加自己的变量。我们在使用自己定义变量的时候有两种情况，一种是在mk中使用，一种是在cpp中使用。注意java不支持的。这两种情况有点不同，请注意。</p>
<p>首先我们得定义这个变量，一般来讲都是在产品的BoardConfig.mk中定义，例如：</p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">TARGET_MEMORY_STYLE := TARGET_MEM_256MB</span><br><span class="line"><span class="comment">#TARGET_MEMORY_STYLE := TARGET_MEM_256MB_ST</span></span><br><span class="line"><span class="comment">#TARGET_MEMORY_STYLE := TARGET_MEM_512MB</span></span><br><span class="line"><span class="comment">#TARGET_MEMORY_STYLE := TARGET_MEM_512MB_ST</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># board-specific configuration</span></span><br><span class="line">BOARD_OPENCORE_FLAGS := -DTELECHIPS_ALSA</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(BOARD_KERNEL_BASE)</span>,0x40000000)</span><br><span class="line">BOARD_MEM_FLAGS := -DTCC_MEM_256MB</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">BOARD_MEM_FLAGS := -DTCC_MEM_512MB</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></tbody></table></figure>

<p>这里总共有两个我们经常用的东西。</p>
<p><strong>第一：</strong><br>如果是mk中使用，定义如前四行就可以了。  </p>
<p>变量 := 字符串</p>
<p>在mk中的使用方法就像后面例子一样。</p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span>($(变量),对比值)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>第二：</strong>如果你想在cpp中使用，请定义方式如下：  </p>
<p>变量 := -D+变量名</p>
<p>如后面几行示例一样的。</p>
<p>如果想在cpp中应用，首先必须在cpp对于的mk文件中，声明如下<br>LOCAL_CFLAGS += $(BOARD_MEM_FLAGS)</p>
<p>格式：   LOCAL_CFLAGS += $(变量)</p>
<p>然后它的cpp中就可以引用如下：<br>此时去掉了-D前缀。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ifdef TCC_MEM_512MB</span><br><span class="line">......</span><br><span class="line">endif</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Android-mk变量"><a href="#Android-mk变量" class="headerlink" title="Android.mk变量"></a>Android.mk变量</h3><p>这些是您在Android.mk文件中常见的变量，按字母顺序列出。首先，关于变量命名的注释：</p>
<ul>
<li><p><strong>LOCAL_</strong> - 这些变量是按模块设置的。它们被行清除<code>include $(CLEAR_VARS)</code>，因此您可以在包含该文件后依赖它们为空。您将在大多数模块中使用的大多数变量都是LOCAL_变量。</p>
</li>
<li><p><strong>PRIVATE_</strong> - 这些变量是特定于make-target的变量。这意味着它们只能在该模块的命令中使用。这也意味着他们不可能从你的后面的模块背后改变。此 <a href="http://www.gnu.org/software/make/manual/make.html#Target_002dspecific" target="_blank" rel="noopener">make链接提供了</a> 有关特定于目标的变量的更多信息。</p>
</li>
<li><p><strong>HOST_</strong>和<strong>TARGET_</strong> - 包含特定于主机或目标版本的目录和定义。不要在makefile中设置以HOST_或TARGET_开头的变量。</p>
</li>
<li><p><strong>BUILD_</strong>和<strong>CLEAR_VARS</strong> - 包含要包含的明确定义的模板makefile的名称。一些示例是CLEAR_VARS和BUILD_HOST_PACKAGE。</p>
</li>
<li><p>任何其他名称都是公平游戏，供您在Android.mk中使用。但是，请记住，这是一个非递归构建系统，因此您的变量可能会被稍后包含的另一个Android.mk更改，并且在执行规则/模块的命令时会有所不同。</p>
</li>
<li><p><strong>定义C/CPP编译的宏时，注意格式，后面=1，不能带空格！</strong></p>
<p>LOCAL_CFLAGS += -DLIBUTILS_NATIVE=1</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LOCAL_AAPT_FLAGS</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_ACP_UNAVAILABLE</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_ADDITIONAL_JAVA_DIR</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_AIDL_INCLUDES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_ALLOW_UNDEFINED_SYMBOLS</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_ARM_MODE</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_ASFLAGS</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_ASSET_DIR</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_ASSET_FILES</td>
<td>在Android.mk文件中，<code>include $(BUILD_PACKAGE)</code>将此文件设置为您希望在应用程序中内置的文件集。通常：<code>LOCAL_ASSET_FILES += $(call find-subdir-assets)</code></td>
</tr>
<tr>
<td align="left">LOCAL_BUILT_MODULE_STEM</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_C_INCLUDES</td>
<td>指示C / C ++编译器查找头文件的其他目录。这些路径根植于树的顶部。<code>LOCAL_PATH</code>如果您在包含路径中包含您想要的子目录，请使用 此选项。例如：<code>LOCAL_C_INCLUDES += extlibs/zlib-1.2.3LOCAL_C_INCLUDES += $(LOCAL_PATH)/src</code>您不应该添加include的子目录 <code>LOCAL_C_INCLUDES</code>，而应该在<code>#include</code>语句中引用这些文件及其子目录。例如：<code>#include <utils/KeyedVector.h></code> 不 <code>#include <KeyedVector.h></code></td>
</tr>
<tr>
<td align="left">LOCAL_CC</td>
<td>如果要为此模块使用不同的C编译器，请将LOCAL_CC设置为编译器的路径。如果LOCAL_CC为空，则使用相应的默认编译器。</td>
</tr>
<tr>
<td align="left">LOCAL_CERTIFICATE</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_CFLAGS</td>
<td><strong>如果您有其他标志要传递到C或C ++编译器，请在此处添加它们。例如：</strong><code>LOCAL_CFLAGS += -DLIBUTILS_NATIVE=1</code></td>
</tr>
<tr>
<td align="left">LOCAL_CLASSPATH</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_COMPRESS_MODULE_SYMBOLS</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_COPY_HEADERS</td>
<td>要复制到安装的文件集包括树。你还必须提供<code>LOCAL_COPY_HEADERS_TO</code>。这会消失，因为复制标题会混淆错误消息，并可能导致人们编辑这些标题而不是正确标题。它还可以更容易地在系统中执行错误的分层，我们希望避免这种分层。我们也没有使用C / C ++ SDK，因此没有最终要求复制任何标头。</td>
</tr>
<tr>
<td align="left">LOCAL_COPY_HEADERS_TO</td>
<td>“include”中的目录，用于复制<code>LOCAL_COPY_HEADERS</code>to中列出的标题 。这会消失，因为复制标题会混淆错误消息，并可能导致人们编辑这些标题而不是正确标题。它还可以更容易地在系统中执行错误的分层，我们希望避免这种分层。我们也没有使用C / C ++ SDK，因此没有最终要求复制任何标头。</td>
</tr>
<tr>
<td align="left">LOCAL_CPP_EXTENSION</td>
<td>如果您的C ++文件以“ <code>.cpp</code>” 之外的其他内容结尾，则可以在此处指定自定义扩展名。例如：<code>LOCAL_CPP_EXTENSION := .cc</code>请注意，给定模块的所有C ++文件必须具有相同的扩展名; 目前无法混合不同的扩展。</td>
</tr>
<tr>
<td align="left">LOCAL_CPPFLAGS</td>
<td>如果还有其他标志<em>只</em>传递给C ++编译器，请在此处添加。例如：<code>LOCAL_CPPFLAGS += -ffriend-injection``LOCAL_CPPFLAGS</code>保证<code>LOCAL_CFLAGS</code> 在编译行之后，因此您可以使用它来覆盖中列出的标志 <code>LOCAL_CFLAGS</code></td>
</tr>
<tr>
<td align="left">LOCAL_CXX</td>
<td>如果要为此模块使用不同的C ++编译器，请将LOCAL_CXX设置为编译器的路径。如果LOCAL_CXX为空，则使用相应的默认编译器。</td>
</tr>
<tr>
<td align="left">LOCAL_DX_FLAGS</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_EXPORT_PACKAGE_RESOURCES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_FORCE_STATIC_EXECUTABLE</td>
<td>如果您的可执行文件应静态链接，请设置 <code>LOCAL_FORCE_STATIC_EXECUTABLE:=true</code>。我们以静态形式存在一个非常短的库列表（目前只有libc）。这实际上只用于根文件系统上/ sbin中的可执行文件。</td>
</tr>
<tr>
<td align="left">LOCAL_GENERATED_SOURCES</td>
<td>添加到的文件<code>LOCAL_GENERATED_SOURCES</code>将自动生成，然后在构建模块时链接。有关示例，请参阅<a href="http://android.mk/#custom-tools" target="_blank" rel="noopener">自定义工具</a>模板makefile。</td>
</tr>
<tr>
<td align="left">LOCAL_INSTRUMENTATION_FOR</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_INSTRUMENTATION_FOR_PACKAGE_NAME</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_INTERMEDIATE_SOURCES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_INTERMEDIATE_TARGETS</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_IS_HOST_MODULE</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_JAR_MANIFEST</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_JARJAR_RULES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_JAVA_LIBRARIES</td>
<td>链接Java应用程序和库时，<code>LOCAL_JAVA_LIBRARIES</code> 指定要包含的Java类集。目前有两个：<code>core</code>和<code>framework</code>。在大多数情况下，它看起来像这样：<code>LOCAL_JAVA_LIBRARIES := core framework</code>请注意，<code>LOCAL_JAVA_LIBRARIES</code>使用“ <code>include $(BUILD_PACKAGE)</code>” 构建APK时，无需进行设置（并且不允许）。将自动包含适当的库。</td>
</tr>
<tr>
<td align="left">LOCAL_JAVA_RESOURCE_DIRS</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_JAVA_RESOURCE_FILES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_JNI_SHARED_LIBRARIES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_LDFLAGS</td>
<td>您可以通过设置将其他标志传递给链接器 <code>LOCAL_LDFLAGS</code>。请记住，参数的顺序对于ld非常重要，因此请测试您在所有平台上执行的操作。</td>
</tr>
<tr>
<td align="left">LOCAL_LDLIBS</td>
<td><code>LOCAL_LDLIBS</code>允许您指定不属于可执行文件或库的构建的其他库。在-lxxx格式中指定所需的库; 它们直接传递给链接线。但是，请记住，不会为这些库生成依赖关系。它在您希望使用主机上预安装的库的模拟器构建中最有用。链接器（ld）是一个特别挑剔的野兽，所以如果你做鬼鬼祟祟的话，有时候必须在这里传递其他标志。一些例子：<code>LOCAL_LDLIBS += -lcurses -lpthreadLOCAL_LDLIBS += -Wl,-z,origin</code></td>
</tr>
<tr>
<td align="left">LOCAL_MODULE</td>
<td><code>LOCAL_MODULE</code>是应该从Android.mk生成的名称。例如，对于libkjs，它<code>LOCAL_MODULE</code>是“libkjs”（构建系统添加适当的后缀 - .so .dylib .dll）。对于应用程序模块，请使用<code>LOCAL_PACKAGE_NAME</code>而不是 <code>LOCAL_MODULE</code>。</td>
</tr>
<tr>
<td align="left">LOCAL_MODULE_PATH</td>
<td>指示构建系统将模块放在除其类型之外的其他位置。如果覆盖它，请确保您还设置 <code>LOCAL_UNSTRIPPED_PATH</code>它是可执行文件还是共享库，以便未提取的二进制文件可以去哪里。如果忘记，将会发生错误。有关更多信息，请参阅<a href="http://android.mk/#moving-modules" target="_blank" rel="noopener">将模块置于其</a></td>
</tr>
<tr>
<td align="left">LOCAL_MODULE_STEM</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_MODULE_TAGS</td>
<td>设置<code>LOCAL_MODULE_TAGS</code>为任意数量的以空格分隔的标记。此变量控制包所包含的构造风格。例如：<code>user</code>：在user / userdebug构建中包含此内容<code>eng</code>：在eng版本中包含此内容<code>tests</code>：目标是测试目标并使其可用于测试<code>optional</code>：不包括这个</td>
</tr>
<tr>
<td align="left">LOCAL_NO_DEFAULT_COMPILER_FLAGS</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_NO_EMMA_COMPILE</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_NO_EMMA_INSTRUMENT</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_NO_STANDARD_LIBRARIES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_OVERRIDES_PACKAGES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_PACKAGE_NAME</td>
<td><code>LOCAL_PACKAGE_NAME</code>是应用程序的名称。例如，拨号器，联系人等</td>
</tr>
<tr>
<td align="left">LOCAL_POST_PROCESS_COMMAND</td>
<td>对于主机可执行文件，您可以指定在链接后在模块上运行的命令。由于早期或晚期变量评估，您可能必须经历一些扭曲以获得正确的变量：<code>module := $(HOST_OUT_EXECUTABLES)/$(LOCAL_MODULE)LOCAL_POST_PROCESS_COMMAND := /Developer/Tools/Rez -d __DARWIN__ -t APPL\       -d __WXMAC__ -o $(module) Carbon.r</code></td>
</tr>
<tr>
<td align="left">LOCAL_PREBUILT_EXECUTABLES</td>
<td>包含$（BUILD_PREBUILT）或$（BUILD_HOST_PREBUILT）时，请将这些设置为要复制的可执行文件。它们自动位于正确的bin目录中。</td>
</tr>
<tr>
<td align="left">LOCAL_PREBUILT_JAVA_LIBRARIES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_PREBUILT_LIBS</td>
<td>包含$（BUILD_PREBUILT）或$（BUILD_HOST_PREBUILT）时，请将这些设置为要复制的库。它们自动位于右侧lib目录中。</td>
</tr>
<tr>
<td align="left">LOCAL_PREBUILT_OBJ_FILES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_PRELINK_MODULE</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_REQUIRED_MODULES</td>
<td>设置<code>LOCAL_REQUIRED_MODULES</code>为任意数量的以空格分隔的模块名称，例如“libblah”或“Email”。如果安装了此模块，则还将安装所需的所有模块。这可用于例如确保在安装给定应用程序时安装必要的共享库或提供程序。</td>
</tr>
<tr>
<td align="left">LOCAL_RESOURCE_DIR</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_SDK_VERSION</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_SHARED_LIBRARIES</td>
<td>这些是您直接链接的库。您不需要传递包含传递的库。指定不带后缀的名称：<code>LOCAL_SHARED_LIBRARIES := \    libutils \    libui \    libaudio \    libexpat \    libsgl</code></td>
</tr>
<tr>
<td align="left">LOCAL_SRC_FILES</td>
<td>构建系统会查看<code>LOCAL_SRC_FILES</code>要编译的源文件 - .cpp .c .y .l .java。对于lex和yacc文件，它知道如何自动正确执行中间.h和.c / .cpp文件。如果文件位于包含Android.mk的文件的子目录中，请在其前面加上目录名称：<code>LOCAL_SRC_FILES := \    file1.cpp \    dir/file2.cpp</code></td>
</tr>
<tr>
<td align="left">LOCAL_STATIC_JAVA_LIBRARIES</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_STATIC_LIBRARIES</td>
<td>这些是要包含在模块中的静态库。大多数情况下，我们使用共享库，但有几个地方，比如sbin和主机可执行文件中的可执行文件，我们使用静态库代替。<code>LOCAL_STATIC_LIBRARIES := \    libutils \    libtinyxml</code></td>
</tr>
<tr>
<td align="left">LOCAL_UNINSTALLABLE_MODULE</td>
<td></td>
</tr>
<tr>
<td align="left">LOCAL_UNSTRIPPED_PATH</td>
<td>指示构建系统将模块的未剥离版本放在除了其类型的正常之外的某个位置。通常，您重写此操作是因为您<code>LOCAL_MODULE_PATH</code>为可执行文件或共享库进行了覆盖。如果您覆盖<code>LOCAL_MODULE_PATH</code>但不是 <code>LOCAL_UNSTRIPPED_PATH</code>，则会发生错误。有关更多信息，请参阅<a href="http://android.mk/#moving-modules" target="_blank" rel="noopener">将模块置于其</a></td>
</tr>
<tr>
<td align="left">LOCAL_WHOLE_STATIC_LIBRARIES</td>
<td>这些是您希望包含在模块中的静态库，而不允许链接器从中删除死代码。如果要将静态库添加到共享库并从共享库中公开静态库的内容，这将非常有用。<code>LOCAL_WHOLE_STATIC_LIBRARIES := \    libsqlite3_android</code></td>
</tr>
<tr>
<td align="left">LOCAL_YACCFLAGS</td>
<td>要传递给模块的yacc调用的任何标志。这里的一个已知限制是，对于模块的所有YACC调用，标志都是相同的。这可以修复。如果您需要它，请问。<code>LOCAL_YACCFLAGS := -p kjsyy</code></td>
</tr>
<tr>
<td align="left">OVERRIDE_BUILT_MODULE_PATH</td>
<td></td>
</tr>
</tbody></table>
<h1 id="Makefile模板"><a href="#Makefile模板" class="headerlink" title="Makefile模板"></a>Makefile模板</h1><h2 id="文件目录结构："><a href="#文件目录结构：" class="headerlink" title="文件目录结构："></a>文件目录结构：</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">- dynamiclibapp.c</span><br><span class="line">- Makefile</span><br><span class="line">- comm/inc/apue.h</span><br><span class="line">- comm/errorhandle.c</span><br><span class="line">- dynamiclib/Makefile</span><br><span class="line">- dynamiclib/dynamiclib_add.c</span><br><span class="line">- dynamiclib/dynamiclib_mul.c</span><br><span class="line">- dynamiclib/inc/dynamiclibs.h</span><br><span class="line">- dynamiclib/libs/</span><br></pre></td></tr></tbody></table></figure>
<h2 id="dynamiclib目录"><a href="#dynamiclib目录" class="headerlink" title="dynamiclib目录"></a>dynamiclib目录</h2><ul>
<li>dynamiclib/inc/dynamiclibs.h （对两个c文件中函数的声明）  </li>
</ul>
<p>文件内容如下:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">ifndef</span> __dynamic_libs_h__</span></span><br><span class="line"><span class="number">2</span> <span class="meta">#<span class="meta-keyword">define</span> __dynamic_libs_h__</span></span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="number">5</span> <span class="function"><span class="keyword">int</span> <span class="title">dynamic_lib_func_add</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span></span>;</span><br><span class="line"><span class="number">6</span> <span class="function"><span class="keyword">int</span> <span class="title">dynamic_lib_func_mul</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span></span>;</span><br><span class="line"><span class="number">7</span> </span><br><span class="line"><span class="number">8</span> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>dynamiclib/dynamiclib_add.c 文件内容如下:</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dynamiclibs.h"</span></span></span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> <span class="function"><span class="keyword">int</span> <span class="title">dynamic_lib_func_add</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span></span><br><span class="line"><span class="function">4 </span>{</span><br><span class="line"><span class="number">5</span>     <span class="keyword">int</span> iret = i1 + i2; </span><br><span class="line"><span class="number">6</span>     <span class="built_in">printf</span>(<span class="string">"... in .so func, %d add %d,return %d\n"</span>, i1, i2, iret);</span><br><span class="line"><span class="number">7</span>     <span class="keyword">return</span> iret;</span><br><span class="line"><span class="number">8</span> }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>dynamiclib/dynamiclib_mul.c 文件内容如下:</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dynamiclibs.h"</span></span></span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> <span class="function"><span class="keyword">int</span> <span class="title">dynamic_lib_func_mul</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span></span><br><span class="line"><span class="function">4 </span>{</span><br><span class="line"><span class="number">5</span>     <span class="keyword">int</span> iret = i1 * i2; </span><br><span class="line"><span class="number">6</span>     <span class="built_in">printf</span>(<span class="string">"... in .so func, %d multiplys %d, retun %d\n"</span>, i1, i2, iret);</span><br><span class="line"><span class="number">7</span>     <span class="keyword">return</span> iret;</span><br><span class="line"><span class="number">8</span> }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>dynamiclib/Makefile 文件内容如下:</li>
</ul>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line"> 1 CC       = gcc </span><br><span class="line"> 2 CFLAGS   = -Wall -g -O -fPIC     </span><br><span class="line">   <span class="comment"># 需要加上 -fPIC</span></span><br><span class="line">   <span class="comment"># 为了兼容各个系统，在生成位置无关的代码的时候，应该使用-fPIC参数。</span></span><br><span class="line"> 3 CXXFLAGS = </span><br><span class="line"> 4 INCLUDE  = -I ./inc -I ../comm/inc</span><br><span class="line"> 5 TARGET   = libmytest.so</span><br><span class="line"> 6 LIBPATH  = ./libs/</span><br><span class="line"> 7 </span><br><span class="line"> 8 <span class="keyword">vpath</span> %.h ./inc</span><br><span class="line"> 9 </span><br><span class="line">10 OBJS     = dynamiclib_add.o dynamiclib_mul.o</span><br><span class="line">11 SRCS     = dynamiclib_add.c dynamiclib_mul.c</span><br><span class="line">12 </span><br><span class="line">13 <span class="variable">$(OBJS)</span>:<span class="variable">$(SRCS)</span></span><br><span class="line">14    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(INCLUDE)</span> -c <span class="variable">$^</span></span><br><span class="line">15 </span><br><span class="line">16 all:<span class="variable">$(OBJS)</span></span><br><span class="line">17    <span class="variable">$(CC)</span> -shared -fPIC -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span>    需要加上 -shared -fPIC</span><br><span class="line">18    mv <span class="variable">$(TARGET)</span> <span class="variable">$(LIBPATH)</span></span><br><span class="line">19 </span><br><span class="line">20 clean:</span><br><span class="line">21    rm -f *.o</span><br><span class="line">22    rm -f <span class="variable">$(LIBPATH)</span>*</span><br></pre></td></tr></tbody></table></figure>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>以上文件，就可以生成动态库文件 libmytest.so，应用程序以两种方式加载动态库函数，如下</p>
<h4 id="在编译应用程序时加载动态库"><a href="#在编译应用程序时加载动态库" class="headerlink" title="在编译应用程序时加载动态库"></a>在编译应用程序时加载动态库</h4><p>dynamiclibapp.c 文件内容如下</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dynamiclibs.h"</span></span></span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> 5 </span>{</span><br><span class="line"> <span class="number">6</span>     err_msg(<span class="string">"step in main\n"</span>);</span><br><span class="line"> <span class="number">7</span>     dynamic_lib_func_add(<span class="number">1</span>, <span class="number">9</span>); </span><br><span class="line"> <span class="number">8</span>     dynamic_lib_func_mul(<span class="number">1</span>, <span class="number">9</span>); </span><br><span class="line"> <span class="number">9</span>     err_msg(<span class="string">"step out main\n"</span>);</span><br><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">11</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">12</span> }</span><br></pre></td></tr></tbody></table></figure>
<p>Makefile 文件内容如下：</p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line"> 1 CC       = gcc </span><br><span class="line"> 2 CFLAGS   = -Wall -O -g</span><br><span class="line"> 3 CXXFLAGS = </span><br><span class="line"> 4 INCLUDE  = -I ./comm/inc -I ./dynamiclib/inc</span><br><span class="line"> 5 TARGET   = dynamiclibapp</span><br><span class="line"> 6 LIBVAR   = -lmytest             指明需要链接动态库 libmytest.so</span><br><span class="line"> 7 LIBPATH  = -L./dynamiclib/libs  指明 libmytest.so 的路径</span><br><span class="line"> 8 <span class="comment">#search paths for errorhandler.c</span></span><br><span class="line"> 9 <span class="keyword">vpath</span> %.c ./comm</span><br><span class="line">10 <span class="comment">#下行是为依赖项 apue.h 准备的，比如 [errorhandler.o:errorhandler.c apue.h] 里的 apue.h</span></span><br><span class="line">11 <span class="keyword">vpath</span> %.h ./comm/inc</span><br><span class="line">12 </span><br><span class="line">13 OBJS     = errorhandler.o dynamiclibapp.o</span><br><span class="line">14 <span class="comment">#下行的 apue.h，可以不必写出来</span></span><br><span class="line">15 errorhandler.o:errorhandler.c apue.h</span><br><span class="line">16    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(INCLUDE)</span> -c <span class="variable">$^</span></span><br><span class="line">17 dynamiclibapp.o:dynamiclibapp.c apue.h</span><br><span class="line">18    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(INCLUDE)</span> -c <span class="variable">$^</span></span><br><span class="line">19 </span><br><span class="line">20 all:<span class="variable">$(OBJS)</span> <span class="variable">$(LIB)</span></span><br><span class="line">21    cd ./dynamiclib && make all</span><br><span class="line">22    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(INCLUDE)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span> <span class="variable">$(LIBPATH)</span> <span class="variable">$(LIBVAR)</span></span><br><span class="line">23    在上行中，在执行编译时，加载了 libmytest.so 中函数</span><br><span class="line">24 clean:</span><br><span class="line">25    rm -f *.o</span><br><span class="line">26    rm -f comm/inc/*.gch</span><br><span class="line">27    rm -f <span class="variable">$(TARGET)</span></span><br><span class="line">28    cd ./dynamiclib && make clean</span><br></pre></td></tr></tbody></table></figure>
<p>对于这种方式编译出来的动态库文件，还需要在 /etc/ld.so.conf.d/ 目录中添加 libmytest.so 库文件的路径说明，即在 /etc/ld.so.conf.d/ 目录中新建配置文件 mytest.conf，且执行 ldconfig， /etc/ld.so.conf.d/mytest.conf 的文件内容为 libmytest.so 库文件的绝对路径，例如：1 /home/lijiangtao/dynamiclib/libs<br>如果不在编译应用程序时加载动态库文件里的函数，而是改为在应用程序执行时(比如：程序的main函数启动期间，或在程序执行期间)加载 libmytest.so 里函数，那么就可以不需在 /etc/ld.so.conf.d/ 目录中配置 libmytest.so路径，具体如下所述。</p>
<h4 id="在应用程序执行时加载动态库"><a href="#在应用程序执行时加载动态库" class="headerlink" title="在应用程序执行时加载动态库"></a>在应用程序执行时加载动态库</h4><p>dynamiclibapp.c 文件内容如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dynamiclibs.h"</span></span></span><br><span class="line"> <span class="number">3</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><dlfcn.h></span></span></span><br><span class="line"> <span class="number">4</span> </span><br><span class="line"> <span class="number">5</span> <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*fp_lib_add)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"> <span class="number">6</span> <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*fp_lib_mul)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"> <span class="number">7</span> <span class="keyword">typedef</span> <span class="keyword">void</span>* dlhandle;</span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span> dlhandle      dll      = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">10</span> fp_lib_add    func_add = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">11</span> fp_lib_mul    func_mul = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">13</span> <span class="function">dlhandle <span class="title">load_dynamic_func</span><span class="params">(<span class="keyword">char</span> *psopath, fp_lib_add *padd, fp_lib_mul *pmul)</span></span>;</span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">16 </span>{</span><br><span class="line"><span class="number">17</span>     <span class="keyword">char</span> *pso = <span class="string">"/home/lijiangtao/dynamiclib/libs/libmytest.so"</span>;<span class="comment">//指定 .so 路径</span></span><br><span class="line"><span class="number">18</span>     dll = load_dynamic_func(pso, &func_add, &func_mul);<span class="comment">//程序执行时，加载动态函数</span></span><br><span class="line"><span class="number">19</span>     err_msg(<span class="string">"step in main\n"</span>);</span><br><span class="line"><span class="number">20</span>     func_add(<span class="number">1</span>, <span class="number">9</span>);<span class="comment">//执行 add 函数</span></span><br><span class="line"><span class="number">21</span>     func_mul(<span class="number">1</span>, <span class="number">9</span>);<span class="comment">//执行 mul 函数</span></span><br><span class="line"><span class="number">22</span>     err_msg(<span class="string">"step out main\n"</span>);</span><br><span class="line"><span class="number">23</span> </span><br><span class="line"><span class="number">24</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">25</span> }</span><br><span class="line"><span class="number">26</span> </span><br><span class="line"><span class="number">27</span> <span class="function">dlhandle <span class="title">load_dynamic_func</span><span class="params">(<span class="keyword">char</span> *psopath, fp_lib_add *padd, fp_lib_mul *pmul)</span></span></span><br><span class="line"><span class="function">28 </span>{</span><br><span class="line"><span class="number">29</span>     <span class="keyword">if</span>(<span class="literal">NULL</span> == psopath ||<span class="string">'\0'</span> == psopath[<span class="number">0</span>])</span><br><span class="line"><span class="number">30</span>         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">31</span>     <span class="keyword">char</span> *perrormsg = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">32</span>     dlhandle dllhandle = dlopen(psopath, RTLD_LAZY);</span><br><span class="line"><span class="number">33</span>     <span class="keyword">if</span>(<span class="literal">NULL</span> == dllhandle) </span><br><span class="line"><span class="number">34</span>     {   </span><br><span class="line"><span class="number">35</span>         <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, dlerror());</span><br><span class="line"><span class="number">36</span>         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">37</span>     } </span><br><span class="line"><span class="number">38</span>     <span class="keyword">if</span>(<span class="literal">NULL</span> != padd)</span><br><span class="line"><span class="number">39</span>     {</span><br><span class="line"><span class="number">40</span>         *padd = dlsym(dllhandle, <span class="string">"dynamic_lib_func_add"</span>);<span class="comment">//加载 add 函数</span></span><br><span class="line"><span class="number">41</span>         perrormsg = dlerror();</span><br><span class="line"><span class="number">42</span>         <span class="keyword">if</span>(<span class="literal">NULL</span> != perrormsg)</span><br><span class="line"><span class="number">43</span>             <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, perrormsg);</span><br><span class="line"><span class="number">44</span>     }</span><br><span class="line"><span class="number">45</span>     <span class="keyword">if</span>(<span class="literal">NULL</span> != pmul)</span><br><span class="line"><span class="number">46</span>     {</span><br><span class="line"><span class="number">47</span>         *pmul = dlsym(dllhandle, <span class="string">"dynamic_lib_func_mul"</span>);<span class="comment">//加载 mul 函数</span></span><br><span class="line"><span class="number">48</span>         perrormsg = dlerror();</span><br><span class="line"><span class="number">49</span>         <span class="keyword">if</span>(<span class="literal">NULL</span> != perrormsg)</span><br><span class="line"><span class="number">50</span>             <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, perrormsg);</span><br><span class="line"><span class="number">51</span>     }</span><br><span class="line"><span class="number">52</span>     <span class="keyword">return</span> dllhandle;</span><br><span class="line"><span class="number">53</span> }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="c-c-混合编译"><a href="#c-c-混合编译" class="headerlink" title="c/c++ 混合编译"></a>c/c++ 混合编译</h3><p>c用gcc编译，c++用g++编译，分别生成.o文件，最后变成最终的库</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CC = arm-poky-linux-gnueabi-gcc</span><br><span class="line">C++ = arm-poky-linux-gnueabi-g++</span><br><span class="line">LINK = arm-poky-linux-gnueabi-g++</span><br><span class="line"> </span><br><span class="line">LIBS = -lz -lm -lpcre -lpthread</span><br><span class="line">#编译.so must add -fPIC option  https://www.cnblogs.com/cswuyg/p/3830703.html</span><br><span class="line">CCFLAGS = -c -g -fPIC</span><br><span class="line">C++FLAGS = -c -g -fPIC</span><br><span class="line"></span><br><span class="line">#期望得到的执行文件或动态库.so</span><br><span class="line">TARGET=libxx.so</span><br><span class="line"> </span><br><span class="line">INCLUDES = -I. -I../../</span><br><span class="line"> </span><br><span class="line">C++FILES = $(wildcard *.cpp ./../common/*.cpp)</span><br><span class="line">CFILES = $(wildcard *.c ./../common/*.c)</span><br><span class="line"> </span><br><span class="line">OBJFILE = $(CFILES:.c=.o) $(C++FILES:.cpp=.o)</span><br><span class="line"> </span><br><span class="line">all:$(TARGET)</span><br><span class="line"> </span><br><span class="line">$(TARGET): $(OBJFILE)</span><br><span class="line">	$(LINK) $^ $(LIBS) -Wall -fPIC -shared -o $@</span><br><span class="line"> </span><br><span class="line">%.o:%.c</span><br><span class="line">	$(CC) -o $@ $(CCFLAGS) $< $(INCLUDES)</span><br><span class="line"> </span><br><span class="line">%.o:%.cpp</span><br><span class="line">	$(C++) -o $@ $(C++FLAGS) $< $(INCLUDES)</span><br><span class="line"> </span><br><span class="line">install:</span><br><span class="line">	tsxs -i -o $(TARGET)</span><br><span class="line"> </span><br><span class="line">clean:</span><br><span class="line">	rm -rf $(TARGET)</span><br><span class="line">    rm -rf $(OBJFILE)</span><br></pre></td></tr></tbody></table></figure>

<p>需要注意的是为了能够让C++调用C语言代码，需要在头文件加上extern “C”，代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus <span class="comment">//而这一部分就是告诉编译器，如果定义了__cplusplus(即如果是cpp文件， </span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>{ <span class="comment">//因为cpp文件默认定义了该宏),则采用C语言方式进行编译</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：AE打印延迟</title>
    <url>/posts/7bbb0585/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a><strong>现象</strong></h2><p>在HWI的ProcessAEinfo函数中进行打印，发现AE有延迟</p>
<a id="more"></a>

<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a><strong>解决思路</strong></h2><ol>
<li>查看ProcessAEinfo函数的执行位置，发现ProcessAEinfo函数是在状态机中的<code>QCAMERA_INTERNAL_EVT_AE_UPDATE</code>状态下1执行的</li>
<li>相应的找到了只有<code>matadata_stream_cb_routine</code>函数对状态机发送这个状态事件，在执行processEVT的地方进行打印，发现这个AE打印是没有延时的；在对状态机这个状态下加打印，发现这个AE打印是有延时的</li>
<li>processAEinfo函数里的内容，会发现，状态机状态下的AE打印又没有异常了</li>
<li>当时在想，为什么输出和输入对不上呢？先对processAEinfo里的内容进行删减，查看加上那句话会造成AE打印有延时</li>
<li>发现加上persist进行赋值的地方，ae就会有延迟，对persist设置的函数前后进行打印，发现这个赋值语句需要10Ms才能执行完成。</li>
<li>需要重新设置HAL对ispctrl层传递的方法，不能使用persist的方法了</li>
</ol>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a><strong>疑问</strong></h2><p>callback一直在给statemachine发送事件消息，假设每帧发10个事件，但是statemachine由于什么问题，只处理了9个事件，并不会造成太大的影响，图像还是正常出，就是控制可能慢了0.003s</p>
<p>但是存在一个问题，那个事件被callback创建了，并没有被处理完，释放内存，当过了100帧率，就有10个事件没有进行处理，那这些事件依旧在内存中，没有被释放，长此以往，内存被占满了，程序不就各种崩溃了么。</p>
<h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a><strong>解决方案</strong>：</h2><p>是否在检查队列的时候对队列的长度进行判断，防止队列太长崩溃。</p>
<p>另外就是我们在调试代码的时候，在端口的输入端加上打印，查看每个模块处理的速度，如果低于正常的帧率，就抛出异常。当然一帧看不出什么问题，100帧检测一次，看时间是否超过了正常的时间。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><ol>
<li><p>如果上一个模块的输出和下一个模块的输入对不上，很可能是由于FIFO导致的，如果下一个模块的处理跟不上上一个</p>
</li>
<li><p>函数中尽量不要去设置persist的值，根据打印发现，平均设置需要10ms，大大影响运行性能。</p>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>persist_set</tag>
        <tag>hal</tag>
      </tags>
  </entry>
  <entry>
    <title>高通WNR滤波理解</title>
    <url>/posts/7bdc3237/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p><strong>详细原理：</strong></p>
<p><img src="https://image.qinxing.xyz/1552274631266.png" alt></p>
<p>原图先进行小波变换，对图像进行分层，高通根据不同的频率将图像分为四层。将每层的图片作为输入，先将输入和经过双边滤波之后的图相减，得到下图的噪声和细节分布图，是第一个+号的输出。edge softness来调节这个滤波器的强度。</p>
<p><img src="https://image.qinxing.xyz/1552274655450.png" alt></p>
<p>这个噪声和细节分布图和阈值λ进行比较，profile*scale就是阈值λ，1-w就是斜率。横坐标是每个像素点的差值，而Y轴是将要去除的噪声大小。第二个+号的过程是将原图和第二个图的Y（输出）进行相减，也就是用原图减去噪声得到滤波后的图。</p>
<p>当w=0，就是斜率等于1，X=Y，也就是说小于λ将会完全用双边滤波得到的图片。</p>
<p>如果说平坦区域的降噪不符合要求，应该加大edge softness，也就是第一个滤波器的强度，加大阈值是没有用的。</p>
<p><strong>调试顺序：</strong></p>
<p>由于WNR是先进行双边滤波(edge softness)，再利用scale和weight进行边缘和噪声的选择，那我们可以先将weight调到0，scale很大，去确定前面的edge，因为一旦动了edge，之后的都会改变，我们先将图片调节到可以接受的噪声的规模，在将scale调小，放出更多的边缘，最后增大weight，获取更多的细节。</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像效果调试</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>WNR</tag>
        <tag>滤波</tag>
      </tags>
  </entry>
  <entry>
    <title>aec重载chromatix功能实现</title>
    <url>/posts/48b9801d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>8056平台中如何实现对aec模块重载chromatix？</p>
</blockquote>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="第一版本"><a href="#第一版本" class="headerlink" title="第一版本"></a>第一版本</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search_dynamic_region</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">array</span>, <span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">-1</span>; i < <span class="number">2</span>; i++) {</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">-1</span>; j < <span class="number">2</span>; j++) {</span><br><span class="line">    			<span class="keyword">if</span> (x + i >= <span class="number">0</span> && x + i < row &&</span><br><span class="line">    				y + j >= <span class="number">0</span> && y + j < col &&</span><br><span class="line">    				(x || y == <span class="number">1</span>) && <span class="built_in">array</span>[(x + i)*col + y + j] == <span class="number">1</span>) {</span><br><span class="line">				<span class="built_in">array</span>[(x + i)*col + y + j] = <span class="number">2</span>;</span><br><span class="line">				search_dynamic_region(<span class="built_in">array</span>, x + i, y + j, row, col);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//BRIGHT_REGION_RANGE range:0.1-1.0 值越小，亮区越大</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BRIGHT_REGION_RANGE 0.6</span></span><br><span class="line"><span class="comment">//DYNAMIC_REGION_THRESHOLD range:>1.0 值越小，越容易判定为动态亮区</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DYNAMIC_REGION_THRESHOLD 1.2</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">keda_backlight_algo</span><span class="params">(<span class="keyword">aec_biz_t</span> *aec, <span class="keyword">const</span> <span class="keyword">stats_t</span>* stats)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//detect input</span></span><br><span class="line">    <span class="keyword">if</span> (!aec || !stats) {</span><br><span class="line">      AEC_ERR(<span class="string">"Invalid input: %p,%p"</span>,aec, stats);</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//define var</span></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="keyword">float</span> aec_ratio = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">float</span> aec_dynamic_ratio=<span class="number">1000</span>,aec_static_ratio=<span class="number">1</span>;</span><br><span class="line">    chromatix_3a_parms_type *chromatix;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">q3a_bg_stats_t</span>* q3a_bg_stats = stats->bayer_stats.p_q3a_bg_stats;</span><br><span class="line">    <span class="keyword">uint32_t</span> threhold_h = q3a_bg_stats->rMax * q3a_bg_stats->region_pixel_cnt * BRIGHT_REGION_RANGE /<span class="number">4</span>;</span><br><span class="line">    chromatix = (chromatix_3a_parms_type*)backlight_set_parameter.u.init_param.chromatix;</span><br><span class="line">    <span class="keyword">if</span> (!chromatix) {</span><br><span class="line">        AEC_ERR(<span class="string">"Invalid chromatix: %p"</span>, chromatix)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> v_step = q3a_bg_stats->bg_region_v_num/NUM_AEC_STATS;</span><br><span class="line">    <span class="keyword">int</span> h_step = q3a_bg_stats->bg_region_h_num/NUM_AEC_STATS;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint32_t</span> bg_sum[MAX_BG_STATS_NUM]={<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">char</span> grid_region[MAX_BG_STATS_NUM] ={<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">int</span> grid_v_num, grid_h_num;</span><br><span class="line">    <span class="keyword">int</span> weight_grid_count[NUM_AEC_STATS][NUM_AEC_STATS] = {{<span class="number">0</span>}};</span><br><span class="line">    <span class="keyword">uint32_t</span> bg_count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (property_get(<span class="string">"persist.liqinxing.backlight"</span>, value, <span class="string">""</span>) > <span class="number">0</span>){</span><br><span class="line">        aec_static_ratio = atoi(value)/<span class="number">1000.0</span>;</span><br><span class="line">        <span class="comment">//reduce traverse times and prevent data overflow</span></span><br><span class="line">        <span class="keyword">int</span> grid_count = q3a_bg_stats->bg_region_h_num * q3a_bg_stats->bg_region_v_num;</span><br><span class="line">        <span class="comment">//find bright region and dynamic spot</span></span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i < grid_count; i++){</span><br><span class="line">            <span class="keyword">if</span>(q3a_bg_stats->bg_r_sum[i] > threhold_h ||</span><br><span class="line">               q3a_bg_stats->bg_gr_sum[i] > threhold_h ||</span><br><span class="line">               q3a_bg_stats->bg_b_sum[i] > threhold_h){</span><br><span class="line">                    bg_count = q3a_bg_stats->bg_r_sum[i]+q3a_bg_stats->bg_gr_sum[i]+</span><br><span class="line">                    q3a_bg_stats->bg_gb_sum[i]+q3a_bg_stats->bg_b_sum[i];</span><br><span class="line">                    <span class="keyword">if</span>(bg_count*<span class="number">10</span>/bg_sum[i] > <span class="number">12</span>)</span><br><span class="line">                        grid_region[i] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        grid_region[i] = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            bg_sum[i] = q3a_bg_stats->bg_r_sum[i]+q3a_bg_stats->bg_gr_sum[i]+</span><br><span class="line">                    q3a_bg_stats->bg_gb_sum[i]+q3a_bg_stats->bg_b_sum[i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//find dynamic bright region</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i < grid_count; i++){</span><br><span class="line">            <span class="keyword">if</span>(grid_region[i] == <span class="number">2</span>){</span><br><span class="line">                search_dynamic_region(grid_region, i/q3a_bg_stats->bg_region_h_num,</span><br><span class="line">                    i%q3a_bg_stats->bg_region_h_num, q3a_bg_stats->bg_region_v_num,</span><br><span class="line">                    q3a_bg_stats->bg_region_h_num);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//convert to aec weight grid table</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i<grid_count; i++){</span><br><span class="line">            <span class="keyword">if</span>(grid_region[i] != <span class="number">0</span>){</span><br><span class="line">                grid_v_num = i/q3a_bg_stats->bg_region_h_num/v_step;<span class="comment">//calculate current position v</span></span><br><span class="line">                grid_h_num = i%q3a_bg_stats->bg_region_h_num/h_step;<span class="comment">//calculate current position h</span></span><br><span class="line">                <span class="keyword">if</span>(grid_region[i] == <span class="number">2</span>)</span><br><span class="line">                    weight_grid_count[grid_v_num][grid_h_num] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(weight_grid_count[grid_v_num][grid_h_num] != <span class="number">2</span>)</span><br><span class="line">                    weight_grid_count[grid_v_num][grid_h_num] = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//pthread_rwlock_wrlock(&chromatix->lock);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i < NUM_AEC_STATS; i++){</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>; j < NUM_AEC_STATS; j++){</span><br><span class="line">                <span class="keyword">if</span>(weight_grid_count[i][j] == <span class="number">2</span>){</span><br><span class="line">                    chromatix->AEC_algo_data.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span><br><span class="line">                        keda_exposure_weight[i][j] * aec_dynamic_ratio;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(weight_grid_count[i][j] == <span class="number">1</span>)</span><br><span class="line">                    chromatix->AEC_algo_data.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span><br><span class="line">                        keda_exposure_weight[i][j] * aec_static_ratio;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    chromatix->AEC_algo_data.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span><br><span class="line">                        keda_exposure_weight[i][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//pthread_rwlock_unlock(&chromatix->lock);</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (aec->aec_algo_ops.set_parameters) {</span><br><span class="line">            aec->aec_algo_ops.set_parameters(aec->handle, &backlight_set_parameter);</span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">          }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="问题一：一运行就崩溃"><a href="#问题一：一运行就崩溃" class="headerlink" title="问题一：一运行就崩溃"></a>问题一：一运行就崩溃</h3><p>访问了禁止访问的区域？</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">chromatix_3a_parms_type *chromatix = (chromatix_3a_parms_type*)param->u.init_param.chromatix;</span><br><span class="line">backlight_set_parameter.type = AEC_SET_INIT_CHROMATIX_SENSOR;</span><br><span class="line"><span class="built_in">memcpy</span>(&backlight_set_parameter.u.init_param, &param->u.init_param,</span><br><span class="line">  <span class="keyword">sizeof</span>(<span class="keyword">aec_set_parameter_init_t</span>));</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i < NUM_AEC_STATS; i++)</span><br><span class="line">  <span class="keyword">for</span>(j=<span class="number">0</span>;j < NUM_AEC_STATS; j++)</span><br><span class="line">      keda_exposure_weight[i][j] =</span><br><span class="line">      chromatix->AEC_algo_data.aec_metering_tables.AEC_weight_center_weighted[i][j];</span><br></pre></td></tr></tbody></table></figure>
<p>这里主要定义了二维数组<code>keda_exposure_weight</code>和<code>backlight_set_parameter</code>，其中<code>backlight_set_parameter</code>中有数组指针，很可能是指针的访问越界了。</p>
<blockquote>
<p>指针有两个属性:指向变量/对象的地址和长度，但是指针只存储地址,长度则取决于指针的类型</p>
<p>void指针赋值给其他类型的指针时都要进行转换，void指针不能参与指针运算,除非进行转换 </p>
</blockquote>
<p>这是他们初始化的地方，直接对<code>backlight_set_parameter</code>进行memcpy，值得注意的是其中有一个void*指针，由于指针只是一个8个或者4个字节的类型，因此这样赋值是没有问题的，而指针的类型只是和指针的运算有关系，在后面的运算中进行强制类型转换就可以了。</p>
<p>这里还需要注意两个问题：</p>
<ul>
<li><p>这个初始化函数是否运行，因为没有运行意味着没有对void*指针进行初始化</p>
</li>
<li><p>对void*指向的内容进行读取或者修改，也就是说对chromatix参数进行修改，是否这个参数只是一个函数的局部变量或者形参。运行完函数就会丢弃。</p>
</li>
</ul>
<p>相比较来说，第二种情况更有可能，因此进行分析，从初始化的地方搜寻chromatix指针的来源。在<code>aec_port</code>中我们可以发现：此处init_param.chromatix的数据，指向的是<code>event->u.module_event->module_event_data->chromatix3APtr</code></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">modulesChromatix_t *mod_chrom =</span><br><span class="line">    (modulesChromatix_t *)mod_evt->module_event_data;</span><br><span class="line"><span class="keyword">q3a_thread_aecawb_msg_t</span> *aec_msg = aec_port_malloc_msg(MSG_AEC_SET,</span><br><span class="line">      AEC_SET_PARAM_INIT_CHROMATIX_SENSOR);</span><br><span class="line">aec_msg->u.aec_set_parm.u.init_param.chromatix = mod_chrom->chromatix3APtr;</span><br><span class="line">rc = q3a_aecawb_thread_en_q_msg(<span class="keyword">private</span>->thread_data, aec_msg);</span><br></pre></td></tr></tbody></table></figure>

<p>在sensor模块中的<code>sensor_util_post_chromatix_event_downstream</code>函数中我们可以看到</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">module_chromatix.chromatix3APtr =</span><br><span class="line">   s_bundle->chromatix_metadata.a3_chromatix_ptr =</span><br><span class="line">     chromatix_params->chromatix_ptr[SENSOR_CHROMATIX_3A];</span><br><span class="line"> new_event.u.module_event.module_event_data =</span><br><span class="line">   (<span class="keyword">void</span> *)&module_chromatix;</span><br></pre></td></tr></tbody></table></figure>

<p>module_event中就可以获取到chromatix数据的地址，我们只需要将chromatix数据的地址保存下来，就算之后module_event的数据发生了改变，但是chromatix的数据还没进行改变就行了。</p>
<p>不过此时需要注意memcpy的地方，因为这个地方就不是传递地址了，是对值进行传递，后来的变量可能会被回收。</p>
<p>可以看到eztune获取chromatix数据时就是将<code>chromatix_params.chromatix_ptr[SENSOR_CHROMATIX_3A]</code>复制到eztune的结构体中，而设置chromatix参数时是将extune结构体中的chromatix参数复制到<code>chromatix_params.chromatix_ptr[SENSOR_CHROMATIX_3A]</code>中，由此我们也可以进行对chromatix的重载。</p>
<h3 id="重载chromatix的新想法"><a href="#重载chromatix的新想法" class="headerlink" title="重载chromatix的新想法"></a>重载chromatix的新想法</h3><p>是否可以对chromatix数据进行实时加载？通过设置persist，告诉chromatix修改了哪些地方的值，一个type对应一组数据，这个type可以用ADD_ENTRY的方式去定义数组字符串的方式去查找。而数据的话如果比较多就写入文件，这样就不需要全文读取。</p>
<p><code>memcpy(chromatix->aaa_chromatixData,
      chromatix_params.chromatix_ptr[SENSOR_CHROMATIX_3A],
      sizeof(chromatix_3a_parms_type));</code></p>
<p>回归正题，可以既然extune是可以对chromatix数据进行修改，且能够生效，我们就可以确定chromatix_params.chromatix_ptr[SENSOR_CHROMATIX_3A]这里的数据是没有问题的。</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：手动增益不能连续增大</title>
    <url>/posts/33eb76f4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p><strong>现象</strong>：从web端将增益快门改成手动，会发现随着增益的增大，图片亮度先递增，到了54时，图片瞬间变暗，再继续递增。  </p>
<p><strong>思路</strong>：从增益从上到下传递的地方推断出可能会改变的地方：<br>业务–ispctrl层–hal层–camera层的aec输出（aec.biz）–camera层的sensor模块的（设置）–写入寄存器</p>
<p><strong>过程</strong>：经过排查发现随着web界面上增益的增大，aec的输出是逐步增大的，对sensor模块进行打印，发现寄存器写入的值也是正确的。怀疑是寄存器初始化有问题，和8056平台的IMX385进行比较，没有找到异常。查看手册，发现相比于290，增益寄存器是两个字节组成的，而web界面上的53对应的是0xff，54对应的是0x100，猜测可能是寄存器只写了低八位。</p>
<p><img src="https://image.qinxing.xyz/20200317001223.png" alt></p>
<p>查看代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">reg_setting->reg_setting[reg_count].reg_addr =</span><br><span class="line">sensor_lib_ptr.exp_gain_info.global_gain_addr;</span><br><span class="line">reg_setting->reg_setting[reg_count].reg_data = gain & 0xFF;</span><br><span class="line">reg_setting->reg_setting[reg_count].delay = 0;</span><br><span class="line">reg_count = reg_count + 1;</span><br></pre></td></tr></tbody></table></figure>

<p>发现代码真的仅仅对地址0x3014h进行了赋值，没有将高八位赋值。<br>增加代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">reg_setting->reg_setting[reg_count].reg_addr =</span><br><span class="line">sensor_lib_ptr.exp_gain_info.global_gain_addr+1;</span><br><span class="line">reg_setting->reg_setting[reg_count].reg_data = (gain & 0x100) >> 8;</span><br><span class="line">reg_setting->reg_setting[reg_count].delay = 0;</span><br><span class="line">reg_count = reg_count + 1;</span><br></pre></td></tr></tbody></table></figure>

<p>解决问题。但是需要注意代码中<code>reg_setting[reg_count]</code>的<code>reg_count</code>是否进行初始化，是否会出现数组溢出的问题？此处没有细查。<br><strong>小结</strong>：<br>对增益从web端的传递到寄存器的过程加深了理解。</p>
<h2 id="帮助对日夜切换代码修改"><a href="#帮助对日夜切换代码修改" class="headerlink" title="帮助对日夜切换代码修改"></a>帮助对日夜切换代码修改</h2><ol>
<li>将结构体从HAL层的qcameraparameter传递到qcameraHWI。实现按值传递和按地址传递，最终选择按地址传递。</li>
<li>定位日夜切换代码会对ISP传递过来的参数造成影响的BUG<br><strong>小结</strong>：由于高通将每个模块的变量都分离开来，不能随意获取，同样每个模块的函数也不能随意使用，可能会将这个模块中定义的实例又刷新一遍</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>增益设置</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript学习笔记</title>
    <url>/posts/2b866d21/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>JavaScript 是一种轻量级的可插入 HTML 页面的编程语言。那么JavaScript如何编写？如何实现逻辑？</p>
<a id="more"></a>

<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><ul>
<li><p>可以写入html输出、对时间做出反应、改变HTML的内容、图像、样式等等</p>
</li>
<li><p>HTML 中的脚本必须位于 <script> 与 <script> 标签之间。</p>
</li>
<li><p><strong>脚本可被放置在 HTML 页面的<body> 和 <head> 部分中。</strong>通常的做法是把函数放入 <head&gt 部分中，或者放在页面底部。这样就可以把它们安置到同一处位置，不会干扰页面的内容。</p>
</li>
<li><p>如需在 HTML 页面中插入 JavaScript，请使用 <script> 标签。</p>
</li>
<li><p><body>中的JavaScript会在页面加载时运行</p>
</li>
<li><p>通常，我们需要在某个事件发生时执行代码，比如当用户点击按钮时。</p>
<p>如果我们把 JavaScript 代码放入函数中，就可以在事件发生时调用该函数。</p>
</li>
<li><p>如需使用外部文件，请在 <script> 标签的 “src” 属性中设置该 .js 文件，注意外部脚本不能包含 <script>标签。</p>
</li>
<li><p>document.write() 仅仅在加载时向文档输出写内容。</p>
<p>如果在文档已完成加载后再执行 document.write，整个 HTML 页面将被覆盖</p>
</li>
<li><p>注释和C语言一样</p>
</li>
<li><p>变量为var</p>
</li>
<li><p>对象的定义-名称和值对的形式：var person={firstname:”Bill”, lastname:”Gates”, id:5566};</p>
</li>
<li><p>函数定义不用定义参数类型</p>
</li>
</ul>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>JavaScript HTML DOM（Document Object Model）文档对象模型</p>
<p><strong>可访问 JavaScript HTML 文档的所有元素。</strong></p>
<p><img src="http://www.w3school.com.cn/i/ct_htmltree.gif" alt="DOM HTML 树"></p>
<p>我们可以通过id、标签名、类名找到html元素</p>
<p>可以对html元素内容进行修改</p>
<p>添加和删除节点（HTML元素）</p>
<h1 id="常用对象"><a href="#常用对象" class="headerlink" title="常用对象"></a>常用对象</h1><ul>
<li><p>对象建立类似c++，但是它可以直接创建新的实例，而不需要定义，在之后进行添加就行</p>
</li>
<li><p>只有一种数字类型，所有数字都会存储为根为10的64位浮点数</p>
</li>
<li><p>字符串长度length</p>
</li>
<li><p>Date 日期对象  getdate、setdate 可以用大小直接比较日期的先后</p>
</li>
<li><p>array 数组 sort 排序</p>
</li>
<li><p>Boolean 对象 用于将非逻辑值转换为逻辑值（true 或者 false）。</p>
</li>
<li><p><strong>正则表达式</strong>：RegExp 对象用于规定在文本中检索的内容。RegExp 对象有 3 个方法：test()、exec() 以及 compile()。</p>
<ul>
<li>test() 方法检索字符串中的指定值。返回值是 true 或 false。</li>
<li>exec() 方法检索字符串中的指定值。返回值是被找到的值。如果没有发现匹配，则返回 null。</li>
<li>compile() 方法用于改变 RegExp, 既可以改变检索模式，也可以添加或删除第二个参数。</li>
</ul>
</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>高通设备代码更新及版本更换</title>
    <url>/posts/602efc2f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="8056"><a href="#8056" class="headerlink" title="8056"></a>8056</h1><h2 id="代码更新"><a href="#代码更新" class="headerlink" title="代码更新"></a>代码更新</h2><p>短的没有日期的分支是封闭流，长的有日期的分支是每日流，注意hal层和camera层的分支和版本要一致。</p>
<h2 id="代码编译"><a href="#代码编译" class="headerlink" title="代码编译"></a>代码编译</h2><h3 id="ISP层"><a href="#ISP层" class="headerlink" title="ISP层"></a>ISP层</h3><ol>
<li><p>cd到第二个ispctrl目录下  </p>
<p><code>source makerulers/build/tools/init.sh</code>  </p>
</li>
<li><p>cd 到第三个ispctrl目录下   </p>
</li>
<li><p>sys-build config依次选择1 3 2</p>
</li>
<li><p>sys-build</p>
<p>由于每次上电初始化都会将/system/stc中的updata.bz2解压，</p>
<p>覆盖掉ispctrl的编译，所以我们可以将updata.bz2重命名，</p>
<p>让设备找不到，防止覆盖</p>
</li>
</ol>
<h3 id="hal和camera层"><a href="#hal和camera层" class="headerlink" title="hal和camera层"></a>hal和camera层</h3><ol>
<li>在根目录设置环境：<code>source build/envsetup.sh</code> 将用到的命令加在到环境变量里去</li>
<li>选择编译目标:lunch</li>
<li>选择s618-eng然后选择ipc_8056</li>
<li>mm –j24</li>
</ol>
<h3 id="生成代码位置"><a href="#生成代码位置" class="headerlink" title="生成代码位置"></a>生成代码位置</h3><ul>
<li><p>hal层: 生成<code>out\target\product\s618\obj_arm\lib\camera.sdm660.so</code> –>通过adb push推送到<code>/system/lib/hw</code></p>
</li>
<li><p>camera层：在此目录下生成的其他动态库文件通过adb push推送到<code>/system/vendor/lib</code>(对文件生成时间排序，可以知道哪些是新生成的文件)</p>
</li>
<li><p>ispctrl层：  </p>
<p>由于每次上电初始化都会将/system/stc中的updata.bz2解压，</p>
<p>覆盖掉ispctrl的编译，所以我们可以将updata.bz2重命名，</p>
<p>让设备找不到，防止覆盖</p>
</li>
</ul>
<h3 id="17230端口及网络ADB设置"><a href="#17230端口及网络ADB设置" class="headerlink" title="17230端口及网络ADB设置"></a>17230端口及网络ADB设置</h3><h2 id="网络ADB及17230端口设置"><a href="#网络ADB及17230端口设置" class="headerlink" title="网络ADB及17230端口设置"></a>网络ADB及17230端口设置</h2><p>可以将其配置成xshell中的脚本，以IP：10.82.1.123举例：</p>
<ul>
<li><p>17230端口连接：  </p>
<p>首先在web界面上确认打开了配置->系统->用户安全->安全服务->ssh登录</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">telnet 10.82.1.123 17230</span><br><span class="line">admin</span><br><span class="line">admin123</span><br><span class="line">openssh</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>23端口连接及root：  </p>
<p>需要首先打开17230端口</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">telnet 10.82.1.123</span><br><span class="line">admin</span><br><span class="line">admin123</span><br><span class="line">setprop service.adb.tcp.port 5555 && stop adbd && start adbd</span><br><span class="line">setprop service.ipc.root 1</span><br></pre></td></tr></tbody></table></figure>

<p>adb连接及root</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">adb connect 10.82.1.123</span><br><span class="line">adb root</span><br><span class="line">adb remount</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<h3 id="USB-adb-打开root"><a href="#USB-adb-打开root" class="headerlink" title="USB adb 打开root"></a>USB adb 打开root</h3><p>当推入某个动态库，设备挂掉，连不上网络的时候，可以用usb线进行adb push：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">setprop service.ipc.root 1</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>USB adb 打开root:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">setprop service.ipc.root 1</span><br></pre></td></tr></tbody></table></figure>


</li>
</ul>
<h2 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h2><h3 id="pkg"><a href="#pkg" class="headerlink" title="pkg:"></a>pkg:</h3><ul>
<li><p>txt文档中对应了每个设备的安装包;</p>
</li>
<li><p>在17230端口中输入ipcsetpkghead 8056_185；不同的设备需</p>
<p>要不同的升级包，改下这个，让其匹配才能升级(不需要这一步了)</p>
</li>
<li><p>在IE浏览器中输入IP，用户名是<code>admin</code>，密码是<code>admin123</code>，</p>
<p>进入摄像机的界面，在配置->系统->系统维护->升级</p>
</li>
</ul>
<h3 id="fastboot"><a href="#fastboot" class="headerlink" title="fastboot"></a>fastboot</h3><ul>
<li>如果正常开机模式下，通过adb进入fastboot模式：<code>adb reboot-bootloader</code></li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">fastboot flash boot C:\work\ROM\boot.img</span><br><span class="line">fastboot flash persist C:\work\ROM\persist.img</span><br><span class="line">fastboot flash system C:\work\ROM\system.img</span><br><span class="line">fastboot flash userdata C:\work\ROM\userdata.img</span><br><span class="line">fastboot flash recovery C:\work\ROM\recovery.img</span><br><span class="line"></span><br><span class="line">fastboot reboot</span><br></pre></td></tr></tbody></table></figure>

<p>fastboot reboot重启设备并进去正常启动模式（退出fastboot）</p>
<ul>
<li><p>需要用IPCSearch重新设置IP</p>
<ul>
<li><p>设备激活(密码设置为admin123)</p>
</li>
<li><p>网络参数修改</p>
<p>IP:10.82.x.xxx</p>
<p>子网掩码：255.255.0.0</p>
<p>网关：10.82.255.254</p>
</li>
</ul>
</li>
</ul>
<h2 id="版本地址"><a href="#版本地址" class="headerlink" title="版本地址"></a>版本地址</h2><h3 id="pkg-1"><a href="#pkg-1" class="headerlink" title="pkg"></a>pkg</h3><ul>
<li><p>用户名密码都是：<code>kdm</code></p>
</li>
<li><p>pkg: <code>\\10.9.0.99\ReleaseVersions\KDM\Mobile\S618\IPC2255_L6.0\ROM_Release\IPC2255_ROM_20190228_IPC-8056-V1.0.549-rel-user\ota</code></p>
</li>
</ul>
<hr>
<h1 id="执法记录仪"><a href="#执法记录仪" class="headerlink" title="执法记录仪"></a>执法记录仪</h1><h2 id="打开17230端口"><a href="#打开17230端口" class="headerlink" title="打开17230端口"></a>打开17230端口</h2><p>adb forward tcp:17230 tcp:17230</p>
<p>在xshell中连接17230端口：</p>
<p>telnet 127.0.0.1 17230</p>
<h2 id="代码编译-1"><a href="#代码编译-1" class="headerlink" title="代码编译"></a>代码编译</h2><h3 id="hal和camera层-1"><a href="#hal和camera层-1" class="headerlink" title="hal和camera层"></a>hal和camera层</h3><ul>
<li><p>进入工程的根目录下进行编译环境配置  </p>
<p><code>$source build/envsetup.sh</code></p>
<p><code>Lunch 37</code></p>
</li>
<li><p>进入对应的文件夹下<code>mm –j24</code></p>
</li>
</ul>
<h3 id="isp层"><a href="#isp层" class="headerlink" title="isp层"></a>isp层</h3><p>android-ispctrl/android-isp1/下执行：</p>
<pre><code>source makerulers/build/tools/init.sh      
sys-build config  132
sys-build 
sys-build TARGET_PRODUCT=sdm660_mobile</code></pre><p>这里的TARGET_PRODUCT，可以在make.mk里修改默认定义(只在调试时用，不要提交代码)</p>
<h3 id="推库"><a href="#推库" class="headerlink" title="推库"></a>推库</h3><p>获取权限 </p>
<pre><code>adb shell 
setprop service.user.test 1    
setenforce 0
Kdb remount</code></pre><h3 id="生成代码位置-1"><a href="#生成代码位置-1" class="headerlink" title="生成代码位置"></a>生成代码位置</h3><ul>
<li><p>hal层: 生成<code>out\target\product\u2p\system\lib\hw\camera.sdm660.so</code> –>通过adb push推送到<code>/system/lib/hw</code></p>
</li>
<li><p>camera层：在此目录下生成的其他动态库文件通过adb push推送到<code>/system/vendor/lib</code></p>
</li>
<li><p>ispctrl层：生成<code>android-ispctrl\android-isp1\packages\android-ispctrl\release\cbb\ispctrl\lib\linux_android\release\sdm660_mobile\libispctrl.so</code> –>通过adb push推送到<code>/data/app/com.kedacom.ptt-1/lib/arm</code></p>
<p>修改ispctrl中的代码，要将APK进程杀死，不能重启设备，不然又被覆盖掉了。Kdb shell pkill ptt</p>
</li>
</ul>
<h2 id="升级过程-1"><a href="#升级过程-1" class="headerlink" title="升级过程"></a>升级过程</h2><h3 id="fastboot-1"><a href="#fastboot-1" class="headerlink" title="fastboot"></a>fastboot</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">adb reboot-bootloader </span><br><span class="line">fastboot flash boot boot.img</span><br><span class="line">fastboot flash cache cache.img</span><br><span class="line">fastboot flash persist persist.img</span><br><span class="line">fastboot flash recovery recovery.img</span><br><span class="line">fastboot flash system system.img</span><br><span class="line">fastboot flash userdata userdata.img</span><br><span class="line">REM 最后一个system比较大</span><br><span class="line">fastboot flash -S 500000K system system.img</span><br><span class="line">fastboot flash aboot aboot emmc_appsboot.mbn</span><br></pre></td></tr></tbody></table></figure>

<p>变砖后进入fastboot：<br>拔电池，再放上，按住音量下连USB线，会进到fastboot</p>
<h2 id="版本地址-1"><a href="#版本地址-1" class="headerlink" title="版本地址"></a>版本地址</h2><p>APK:</p>
<p><code>\\172.16.0.99\ReleaseVersions\KDM\Solution\VS-P-a0\YDPT_ANDROID\20180810_DSJ_SDM660_APK\20180828\DSJ_SDM660_APK_R8250#0958\apk</code></p>
<hr>
<h1 id="660IPC"><a href="#660IPC" class="headerlink" title="660IPC"></a>660IPC</h1><p>门禁设备PKG：</p>
<p>\10.9.0.99\ReleaseVersions\system\android\android-rom\SDM660\KSCA120</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>版本更新</tag>
        <tag>adb</tag>
        <tag>推库</tag>
      </tags>
  </entry>
  <entry>
    <title>五子棋算法设计</title>
    <url>/posts/80d8d42a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>如何设计一个五子棋逻辑以及算法？</p>
<p>如何计算哪个位置更好？——极大值极小值算法</p>
<p>如何使程序运行更快？——alpha-beta剪枝算法</p>
<a id="more"></a>

<h1 id="极大值极小值算法"><a href="#极大值极小值算法" class="headerlink" title="极大值极小值算法"></a>极大值极小值算法</h1><p>这是一个双方博弈的游戏，双方都会下对自己有利的棋子，但对方下了一个，我可以全盘搜索，找到一个最有利的，但是对方也会找到一个对自己最有利的，这样就完全没有了防守。我们可以把棋盘进行打分，这个分数代表对我有利的程度。当对方落子之后，我有n个可以落子的地方，假设我落一个子，对方有n-1个落子的地方，它会取分数最小的一种情况，那么这就是对方会走的路子，而我的责任就是让分数最大，在这n个分数中找到一个最大值。这就是极大值极小值的算法。但是人往往可以预测好几步，所以我们也需要预测好几步，我这只是列举的两层的</p>
<h1 id="alpha-beta剪枝算法"><a href="#alpha-beta剪枝算法" class="headerlink" title="alpha-beta剪枝算法"></a>alpha-beta剪枝算法</h1><p><img src="https://image.qinxing.xyz/alphabeta%E5%89%AA%E6%9E%9D%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3.jpg" alt></p>
<p>这是四层的alpha-beta剪枝算法，达到快速删去无用分支的目的。在四层之后对棋盘做一个统计分数的行为，代表我方的得分，得分越高，对我方越有利。<br>我方要使这个数最大，因此遇到会产生小值的节点要舍弃，这里定一个alpha。<br>对方要使我的得分最小，因此遇到会产生大值得节点要舍弃，这里定一个beta，最后可以接受的节点范围是在区间（alpha，beta）<br>在这个图中，最难懂的是第三个值返回了8，为什么要舍弃这个节点？<br>误区：由于返回了8，值比beta大，肯定是对对方不利，才会删去这个节点。可是这正好是对方的回合，他完全可以寻找这个节点中有没有更小的值，它会选择一个最小的值<br>那是否是它写错了呢？其实不然<br>解释：MAX节点的目标是最大化以该节点为根的子树的值。也就是取子节点的最大值，那应该是对方，因为只要到了我方，才会要求本回合的值最大。也就是说这里的MAX是对方，MIN是我方，我方一定会下最大的值，8比6大，那么他一定会选择第二种方案，但是对方一定不会走这上一个节点（由于比上一个节点得到的值还大），因此其他节点都不需要考虑了。</p>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alpha_beta</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> player, <span class="keyword">int</span> alpha, <span class="keyword">int</span> beta)</span>      <span class="comment">//h搜索深度，player=1表示自己,player=0表示对手 </span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(h==<span class="number">6</span> || (result != <span class="number">0</span>))   <span class="comment">//若到达深度 或是出现胜负 </span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(result != <span class="number">0</span>){        <span class="comment">//若是胜负返回-inf 或+inf </span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> evaluate(player) - evaluate(player^<span class="number">1</span>);   <span class="comment">//否则返回此局面的评价值 </span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">if</span>(player){<span class="comment">//自己</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i<=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j<=n; j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(ch[i][j] == <span class="string">'.'</span>)</span><br><span class="line">            {</span><br><span class="line">                ch[i][j] = <span class="string">'o'</span>;</span><br><span class="line">                <span class="keyword">int</span> ans = alpha_beta(h+<span class="number">1</span>, player^<span class="number">1</span>, alpha, beta);</span><br><span class="line">                ch[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                <span class="keyword">if</span>(ans > alpha){    <span class="comment">//通过向上传递的子节点beta值修正alpha值 </span></span><br><span class="line">                    alpha = ans;</span><br><span class="line">                    ansx = i;       <span class="comment">//记录位置 </span></span><br><span class="line">                    ansy = j;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(alpha >= beta)   <span class="comment">//发生 alpha剪枝 </span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">return</span> alpha;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> alpha;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{<span class="comment">//对手</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i<=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j<=n; j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(ch[i][j] == <span class="string">'.'</span>)</span><br><span class="line">            {</span><br><span class="line">                ch[i][j] = <span class="string">'x'</span>;</span><br><span class="line">                <span class="keyword">int</span> ans = alpha_beta(h+<span class="number">1</span>, player^<span class="number">1</span>, alpha, beta);</span><br><span class="line">                ch[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                <span class="keyword">if</span>(ans < beta){     <span class="comment">//通过向上传递的子节点alpha值修正beta值 </span></span><br><span class="line">                    beta = ans;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(alpha >= beta)   <span class="comment">//发生 beta剪枝</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">return</span> beta;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> beta;    </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h1 id="我的五子棋实现"><a href="#我的五子棋实现" class="headerlink" title="我的五子棋实现"></a>我的五子棋实现</h1><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//基于C#</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.Data;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> xDialog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">five_in_a_row</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//棋子状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> ChessBoardState</span><br><span class="line">    {</span><br><span class="line">        empty = <span class="number">0</span>,</span><br><span class="line">        black = <span class="number">1</span>,</span><br><span class="line">        white = <span class="number">2</span>,</span><br><span class="line">        outrange =<span class="number">3</span></span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">private</span> ChessBoardState nextstate;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">bool</span> GameEnable = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">private</span> Point ChessLocation;</span><br><span class="line">        <span class="keyword">private</span> Rule rule=<span class="keyword">new</span> Rule();</span><br><span class="line">        <span class="keyword">private</span> GameJudge myjudge = <span class="keyword">new</span> GameJudge();</span><br><span class="line">        <span class="keyword">private</span> ChessBoardState mystate;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            <span class="keyword">this</span>.nextstate = ChessBoardState.empty;</span><br><span class="line">            <span class="comment">//将下拉框设置为不可编辑状态,只能选择</span></span><br><span class="line">            <span class="keyword">this</span>.comboBox1.Text = <span class="keyword">this</span>.comboBox1.Items[<span class="number">0</span>].ToString();</span><br><span class="line">            <span class="keyword">this</span>.comboBox1.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;</span><br><span class="line">            <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"请点击开始游戏\r\n祝您游戏愉快"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//棋盘界面初始化</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pictureBox1_Paint</span>(<span class="params"><span class="keyword">object</span> sender, PaintEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            Graphics g = e.Graphics;</span><br><span class="line">            Pen pen2 = <span class="keyword">new</span> Pen(Color.Brown, <span class="number">3</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">19</span>; i++)</span><br><span class="line">            {</span><br><span class="line">                g.DrawLine(pen2, <span class="number">15</span>, <span class="number">15</span> + i * <span class="number">30</span>, <span class="number">615</span>, <span class="number">15</span> + i * <span class="number">30</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">21</span>; i++)</span><br><span class="line">            {</span><br><span class="line">                g.DrawLine(pen2, <span class="number">15</span> + i * <span class="number">30</span>, <span class="number">15</span>, <span class="number">15</span> + i * <span class="number">30</span>, <span class="number">465</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//开始游戏</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="keyword">this</span>.textBox1.ResetText();</span><br><span class="line">            <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"黑子先行\n"</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.comboBox1.Text==<span class="string">"黑子"</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"您执黑子\n"</span>);</span><br><span class="line">                mystate = ChessBoardState.white;</span><br><span class="line">                <span class="keyword">this</span>.nextstate = ChessBoardState.black;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"您执白子\n"</span>);</span><br><span class="line">                mystate = ChessBoardState.black;</span><br><span class="line">                <span class="keyword">this</span>.nextstate = ChessBoardState.white;</span><br><span class="line">                rule.SetChessBoardState(<span class="number">9</span>, <span class="number">10</span>, ChessBoardState.black);</span><br><span class="line">                myjudge.ChessJudgeInitSet(<span class="number">9</span>, <span class="number">10</span>, ChessBoardState.black);</span><br><span class="line">                ChessLocation.X = <span class="number">9</span>;</span><br><span class="line">                ChessLocation.Y = <span class="number">10</span>;</span><br><span class="line">                <span class="comment">//画棋子</span></span><br><span class="line">                Graphics g = <span class="keyword">this</span>.pictureBox1.CreateGraphics();</span><br><span class="line">                    Pen pen3 = <span class="keyword">new</span> Pen(Color.Black, <span class="number">10</span>);</span><br><span class="line">                    g.DrawEllipse(pen3, <span class="number">10</span> + <span class="number">30</span> * ChessLocation.X, <span class="number">10</span> + <span class="number">30</span> * ChessLocation.Y, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">                g.Dispose();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">this</span>.comboBox1.Enabled = <span class="literal">false</span>;</span><br><span class="line">            GameEnable = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//悔棋</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button2_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="comment">//悔棋其实是把这次存储的棋盘删掉，然后将棋盘重画，少画最后一个点</span></span><br><span class="line">            <span class="keyword">this</span>.textBox1.ResetText();</span><br><span class="line">            <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"只能悔棋一次哦:-)\n"</span>);</span><br><span class="line">            rule.SetChessBoardState(ChessLocation.X, ChessLocation.Y, ChessBoardState.empty);</span><br><span class="line">            myjudge.ChessJudgeInitSet(ChessLocation.X, ChessLocation.Y, ChessBoardState.empty);</span><br><span class="line">            <span class="keyword">this</span>.pictureBox1.Refresh();</span><br><span class="line">            Graphics g = <span class="keyword">this</span>.pictureBox1.CreateGraphics();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<Rule.COL;i++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j<Rule.ROW;j++)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (rule.GetChessBoardState(i, j) == ChessBoardState.black)</span><br><span class="line">                    {</span><br><span class="line">                        Pen pen3 = <span class="keyword">new</span> Pen(Color.Black, <span class="number">10</span>);</span><br><span class="line">                        g.DrawEllipse(pen3, <span class="number">10</span> + <span class="number">30</span> * i, <span class="number">10</span> + <span class="number">30</span> * j, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">                        pen3.Dispose();</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(rule.GetChessBoardState(i, j) == ChessBoardState.white)</span><br><span class="line">                    {</span><br><span class="line">                        Pen pen4 = <span class="keyword">new</span> Pen(Color.Aqua, <span class="number">10</span>);</span><br><span class="line">                        g.DrawEllipse(pen4, <span class="number">10</span> + <span class="number">30</span> * i, <span class="number">10</span> + <span class="number">30</span> * j, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">                        pen4.Dispose();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//下一个棋子倒退回去</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.nextstate == ChessBoardState.black)</span><br><span class="line">                <span class="keyword">this</span>.nextstate = ChessBoardState.white;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">this</span>.nextstate = ChessBoardState.black;</span><br><span class="line">            g.Dispose();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//退出游戏</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button3_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="keyword">this</span>.Close();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//落子判断</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pictureBox1_MouseDown</span>(<span class="params"><span class="keyword">object</span> sender, MouseEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="comment">//只有当游戏开始之后才能落子</span></span><br><span class="line">            <span class="keyword">if</span>(GameEnable == <span class="literal">true</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//通过鼠标位置判断棋子的位置</span></span><br><span class="line">                ChessLocation.X = (e.X + <span class="number">30</span>) / <span class="number">30</span> - <span class="number">1</span>;</span><br><span class="line">                ChessLocation.Y = (e.Y + <span class="number">30</span>) / <span class="number">30</span> - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//防止此处已经落下棋子</span></span><br><span class="line">                <span class="keyword">if</span> (rule.GetChessBoardState(ChessLocation.X, ChessLocation.Y) != ChessBoardState.empty)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//画棋子</span></span><br><span class="line">                Graphics g = <span class="keyword">this</span>.pictureBox1.CreateGraphics();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.nextstate == ChessBoardState.black)</span><br><span class="line">                {</span><br><span class="line">                    Pen pen3 = <span class="keyword">new</span> Pen(Color.Black, <span class="number">10</span>);</span><br><span class="line">                    g.DrawEllipse(pen3, <span class="number">10</span> + <span class="number">30</span> * ChessLocation.X, <span class="number">10</span> + <span class="number">30</span> * ChessLocation.Y, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    Pen pen4 = <span class="keyword">new</span> Pen(Color.Aqua, <span class="number">10</span>);</span><br><span class="line">                    g.DrawEllipse(pen4, <span class="number">10</span> + <span class="number">30</span> * ChessLocation.X, <span class="number">10</span> + <span class="number">30</span> * ChessLocation.Y, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//判断是否五子连珠：若五子连珠就结束</span></span><br><span class="line">                rule.SetChessBoardState(ChessLocation.X, ChessLocation.Y, <span class="keyword">this</span>.nextstate);</span><br><span class="line">                myjudge.ChessJudgeInitSet(ChessLocation.X, ChessLocation.Y, <span class="keyword">this</span>.nextstate);</span><br><span class="line">                <span class="comment">//Console.WriteLine("此子得分:{0}分",rule.GetPointScore(ChessLocation.X, ChessLocation.Y, this.nextstate));</span></span><br><span class="line">                <span class="keyword">if</span> (rule.CheckCountLIne(ChessLocation.X, ChessLocation.Y, <span class="keyword">this</span>.nextstate) == <span class="literal">true</span>)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>.nextstate == ChessBoardState.white)</span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"\n白子胜利！\n"</span>);</span><br><span class="line">                        DialogResult result = MsgBox.Show(<span class="string">"白子胜利"</span>, <span class="string">"本局结束"</span>, </span><br><span class="line">                            MsgBox.Buttons.OK, MsgBox.Icon.Exclamation, MsgBox.AnimateStyle.SlideDown);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"\n黑子胜利！\n"</span>);</span><br><span class="line">                        DialogResult result = MsgBox.Show(<span class="string">"黑子胜利"</span>, <span class="string">"本局结束"</span>, </span><br><span class="line">                            MsgBox.Buttons.OK, MsgBox.Icon.Exclamation, MsgBox.AnimateStyle.SlideDown);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < Rule.COL; i++)</span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < Rule.ROW; j++)</span><br><span class="line">                        {</span><br><span class="line">                            rule.SetChessBoardState(i, j, ChessBoardState.empty);</span><br><span class="line">                            myjudge.ChessJudgeInitSet(i, j, ChessBoardState.empty);</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">this</span>.pictureBox1.Refresh();</span><br><span class="line">                    <span class="keyword">this</span>.textBox1.ResetText();</span><br><span class="line">                    <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"请点击开始游戏"</span>);</span><br><span class="line">                    <span class="keyword">this</span>.comboBox1.Enabled = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">this</span>.textBox1.ResetText();</span><br><span class="line">                    <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"此子得分:"</span> +</span><br><span class="line">                            myjudge.GetPointScore(ChessLocation.X, ChessLocation.Y, <span class="keyword">this</span>.nextstate).ToString()</span><br><span class="line">                            + <span class="string">"分\r\n"</span>);</span><br><span class="line">                    Point next = myjudge.NextJudge(mystate,<span class="keyword">out</span> <span class="keyword">int</span> max_score);</span><br><span class="line">                    rule.SetChessBoardState(next.X,next.Y,mystate);</span><br><span class="line">                    myjudge.ChessJudgeInitSet(next.X, next.Y, mystate);</span><br><span class="line">                    <span class="keyword">if</span> (mystate == ChessBoardState.black)</span><br><span class="line">                    {</span><br><span class="line">                        Pen pen3 = <span class="keyword">new</span> Pen(Color.Black, <span class="number">10</span>);</span><br><span class="line">                        g.DrawEllipse(pen3, <span class="number">10</span> + <span class="number">30</span> * next.X, <span class="number">10</span> + <span class="number">30</span> * next.Y, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    {</span><br><span class="line">                        Pen pen4 = <span class="keyword">new</span> Pen(Color.Aqua, <span class="number">10</span>);</span><br><span class="line">                        g.DrawEllipse(pen4, <span class="number">10</span> + <span class="number">30</span> * next.X, <span class="number">10</span> + <span class="number">30</span> * next.Y, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">                    }</span><br><span class="line">                    g.Dispose();</span><br><span class="line">                    <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"电脑预测:"</span> + max_score.ToString()+<span class="string">"分"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (rule.CheckCountLIne(next.X, next.Y, mystate) == <span class="literal">true</span>)</span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">if</span> (mystate == ChessBoardState.white)</span><br><span class="line">                        {</span><br><span class="line">                            <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"\n白子胜利！\n"</span>);</span><br><span class="line">                            DialogResult result = MsgBox.Show(<span class="string">"白子胜利"</span>, <span class="string">"本局结束"</span>,</span><br><span class="line">                                MsgBox.Buttons.OK, MsgBox.Icon.Exclamation, MsgBox.AnimateStyle.SlideDown);</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        {</span><br><span class="line">                            <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"\n黑子胜利！\n"</span>);</span><br><span class="line">                            DialogResult result = MsgBox.Show(<span class="string">"黑子胜利"</span>, <span class="string">"本局结束"</span>,</span><br><span class="line">                                MsgBox.Buttons.OK, MsgBox.Icon.Exclamation, MsgBox.AnimateStyle.SlideDown);</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < Rule.COL; i++)</span><br><span class="line">                        {</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < Rule.ROW; j++)</span><br><span class="line">                            {</span><br><span class="line">                                rule.SetChessBoardState(i, j, ChessBoardState.empty);</span><br><span class="line">                                myjudge.ChessJudgeInitSet(i, j, ChessBoardState.empty);</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">this</span>.pictureBox1.Refresh();</span><br><span class="line">                        <span class="keyword">this</span>.textBox1.ResetText();</span><br><span class="line">                        <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"请点击开始游戏"</span>);</span><br><span class="line">                        <span class="keyword">this</span>.comboBox1.Enabled = <span class="literal">true</span>;</span><br><span class="line">                    }</span><br><span class="line">                        <span class="comment">//if (this.nextstate == ChessBoardState.white)</span></span><br><span class="line">                        <span class="comment">//{</span></span><br><span class="line">                        <span class="comment">//    this.nextstate = ChessBoardState.black;</span></span><br><span class="line">                        <span class="comment">//    this.textBox1.AppendText("请黑方落子");</span></span><br><span class="line">                        <span class="comment">//}</span></span><br><span class="line">                        <span class="comment">//else</span></span><br><span class="line">                        <span class="comment">//{</span></span><br><span class="line">                        <span class="comment">//    this.nextstate = ChessBoardState.white;</span></span><br><span class="line">                        <span class="comment">//    this.textBox1.AppendText("请白方落子");</span></span><br><span class="line">                        <span class="comment">//}</span></span><br><span class="line">                    }    </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//重新开始游戏</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button4_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            GameEnable = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.pictureBox1.Refresh();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < Rule.COL; i++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < Rule.ROW; j++)</span><br><span class="line">                {</span><br><span class="line">                    rule.SetChessBoardState(i, j, ChessBoardState.empty);</span><br><span class="line">                    myjudge.ChessJudgeInitSet(i, j, ChessBoardState.empty);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">this</span>.textBox1.ResetText();</span><br><span class="line">            <span class="keyword">this</span>.textBox1.AppendText(<span class="string">"请点击开始游戏"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Rule</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">int</span> ROW = <span class="number">18</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">int</span> COL = <span class="number">21</span>;</span><br><span class="line">        <span class="keyword">private</span> ChessBoardState[,] ChessBoard;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> CurrentX;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> CurrentY;</span><br><span class="line">        <span class="keyword">private</span> ChessBoardState CurrentState;</span><br><span class="line">        <span class="comment">//通过构造函数初始化</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Rule</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="keyword">this</span>.ChessBoard = <span class="keyword">new</span> ChessBoardState[COL, ROW];</span><br><span class="line">            <span class="keyword">this</span>.CurrentX = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">this</span>.CurrentY = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">this</span>.CurrentState = ChessBoardState.empty;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//获取棋盘该位置的状态</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ChessBoardState <span class="title">GetChessBoardState</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="keyword">if</span> (x < <span class="number">0</span> || x >= COL || y < <span class="number">0</span> || y >= ROW)</span><br><span class="line">                <span class="keyword">return</span> ChessBoardState.outrange;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.ChessBoard[x, y];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//设置棋盘该位置的状态</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">SetChessBoardState</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y, ChessBoardState state</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="keyword">if</span> (x < <span class="number">0</span> || x >= COL || y < <span class="number">0</span> || y >= ROW)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">this</span>.ChessBoard[x, y] = state;</span><br><span class="line">                <span class="keyword">this</span>.CurrentX = x;</span><br><span class="line">                <span class="keyword">this</span>.CurrentY = y;</span><br><span class="line">                <span class="keyword">this</span>.CurrentState = state;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">SetChessBoardState</span>(<span class="params">Point point, ChessBoardState state</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="keyword">if</span> (point.X < <span class="number">0</span> || point.X >= COL || point.Y < <span class="number">0</span> || point.Y >= ROW)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">this</span>.ChessBoard[point.X, point.Y] = state;</span><br><span class="line">                <span class="keyword">this</span>.CurrentX = point.X;</span><br><span class="line">                <span class="keyword">this</span>.CurrentY = point.Y;</span><br><span class="line">                <span class="keyword">this</span>.CurrentState = state;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//检查是否已经五子连珠</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">CheckCountLIne</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y, ChessBoardState state</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">             * 原理：找到四个方向上的第一个子，从第一个子开始查找是否存在连续的五个字</span></span><br><span class="line"><span class="comment">             * 版本改进：while ((y - j > ROW || GetChessBoardState(x, y - j) != state) &&j < 0)</span></span><br><span class="line"><span class="comment">             *           由于越界的棋子都设置为空，因此查找第一个棋子的时候不需要判断是否越界</span></span><br><span class="line"><span class="comment">             * bug：存在隔一个子不能判断的bug;由于需要找到第一个子存在oxooooo的情况不能识别</span></span><br><span class="line"><span class="comment">             ***********************************************************</span></span><br><span class="line"><span class="comment">            int j = -4;</span></span><br><span class="line"><span class="comment">            while (GetChessBoardState(x, y - j) != state && j < 0)</span></span><br><span class="line"><span class="comment">                j += 1;</span></span><br><span class="line"><span class="comment">            while (GetChessBoardState(x, y - j - 1) == state)</span></span><br><span class="line"><span class="comment">            {</span></span><br><span class="line"><span class="comment">                count += 1;</span></span><br><span class="line"><span class="comment">                j += 1;</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">            Console.WriteLine("垂直方向上有{0}个棋子",count);</span></span><br><span class="line"><span class="comment">            if (count >= 5)</span></span><br><span class="line"><span class="comment">                result = true;</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                count = 1;</span></span><br><span class="line"><span class="comment">            j = -4;</span></span><br><span class="line"><span class="comment">            //找到第一个自己的子</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            while (GetChessBoardState(x + j, y) != state && j < 0)</span></span><br><span class="line"><span class="comment">                j += 1;</span></span><br><span class="line"><span class="comment">            while (GetChessBoardState(x + j + 1, y) == state)</span></span><br><span class="line"><span class="comment">            {</span></span><br><span class="line"><span class="comment">                count = count + 1;</span></span><br><span class="line"><span class="comment">                j += 1;</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">            Console.WriteLine("水平方向上有{0}个棋子", count);</span></span><br><span class="line"><span class="comment">            if (count >= 5)</span></span><br><span class="line"><span class="comment">                result = true;</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                count = 1;</span></span><br><span class="line"><span class="comment">            j = -4;</span></span><br><span class="line"><span class="comment">            //    break;</span></span><br><span class="line"><span class="comment">            //case Rule.LineDirection.upslope:</span></span><br><span class="line"><span class="comment">            while ( GetChessBoardState(x + j, y - j) != state && j < 0)</span></span><br><span class="line"><span class="comment">                j += 1;</span></span><br><span class="line"><span class="comment">            while (GetChessBoardState(x + j + 1, y - j - 1) == state)</span></span><br><span class="line"><span class="comment">            {</span></span><br><span class="line"><span class="comment">                count += 1;</span></span><br><span class="line"><span class="comment">                j += 1;</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">            Console.WriteLine("右下方向上有{0}个棋子", count);</span></span><br><span class="line"><span class="comment">            if (count >= 5)</span></span><br><span class="line"><span class="comment">                result = true;</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                count = 1;</span></span><br><span class="line"><span class="comment">            j = -4;</span></span><br><span class="line"><span class="comment">            //    break;</span></span><br><span class="line"><span class="comment">            //case Rule.LineDirection.downslop:</span></span><br><span class="line"><span class="comment">            while (GetChessBoardState(x + j, y + j) != state && j < 0)</span></span><br><span class="line"><span class="comment">                j += 1;</span></span><br><span class="line"><span class="comment">            while (GetChessBoardState(x + j + 1, y + j + 1) == state)</span></span><br><span class="line"><span class="comment">            {</span></span><br><span class="line"><span class="comment">                count += 1;</span></span><br><span class="line"><span class="comment">                j += 1;</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">            Console.WriteLine("左下方向上有{0}个棋子", count);</span></span><br><span class="line"><span class="comment">            if (count >= 5)</span></span><br><span class="line"><span class="comment">                result = true;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            <span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">             * 版本：第三版</span></span><br><span class="line"><span class="comment">             * 原理：在前后总共九个子中寻找连续数量的是否超过5</span></span><br><span class="line"><span class="comment">             * 未发现bug</span></span><br><span class="line"><span class="comment">             ***********************************************************/</span></span><br><span class="line">            <span class="keyword">int</span> j, count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">-4</span>; j < <span class="number">5</span>; j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (GetChessBoardState(x + j, y) == state)</span><br><span class="line">                {</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (count >= <span class="number">5</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">-4</span>; j < <span class="number">5</span>; j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (GetChessBoardState(x, y - j) == state)</span><br><span class="line">                {</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//Console.WriteLine("垂直方向上有{0}个棋子", count);</span></span><br><span class="line">                    <span class="keyword">if</span> (count >= <span class="number">5</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">-4</span>; j < <span class="number">5</span>; j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (GetChessBoardState(x + j, y + j) == state)</span><br><span class="line">                {</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//Console.WriteLine("右下方向上有{0}个棋子", count);</span></span><br><span class="line">                    <span class="keyword">if</span> (count >= <span class="number">5</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">-4</span>; j < <span class="number">5</span>; j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (GetChessBoardState(x + j, y - j) == state)</span><br><span class="line">                {</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//Console.WriteLine("左下方向上有{0}个棋子", count);</span></span><br><span class="line">                    <span class="keyword">if</span> (count >= <span class="number">5</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">     * 人机规则</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * ***********************************************************/</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/棋型估值</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">GameJudge</span></span><br><span class="line">    {</span><br><span class="line">        Rule chessjudge = <span class="keyword">new</span> Rule();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> BE_FIVE = <span class="number">10000000</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> ACTIVIE_FOUR = <span class="number">40000</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> NON_FOUR = <span class="number">5000</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> ACTIVIE_THREE = <span class="number">5000</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> NON_THREE = <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> ACTIVE_TWO = <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> NON_TWO = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> OTHER = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> SEARCH_RANGE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChessJudgeInitSet</span>(<span class="params"><span class="keyword">int</span> x,<span class="keyword">int</span> y,ChessBoardState state</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            chessjudge.SetChessBoardState(x, y, state);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//计算棋子的得分</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetPointScore</span>(<span class="params"><span class="keyword">int</span> x,<span class="keyword">int</span> y,ChessBoardState state</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="keyword">int</span> j, count=<span class="number">0</span>,count_max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">bool</span> non_flag = <span class="literal">false</span>, now_non_flag=<span class="literal">false</span>;</span><br><span class="line">            ChessBoardState non_state;<span class="comment">//获得相反的状态</span></span><br><span class="line">            <span class="keyword">if</span> (state == ChessBoardState.black)</span><br><span class="line">                non_state = ChessBoardState.white;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                non_state = ChessBoardState.black;</span><br><span class="line">            <span class="comment">//水平方向</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">-4</span>; j <= <span class="number">4</span>; j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (chessjudge.GetChessBoardState(x + j, y) == state)</span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">//判断是否有一段截断了</span></span><br><span class="line">                    <span class="keyword">if</span> (count == <span class="number">0</span> && (chessjudge.GetChessBoardState(x + j - <span class="number">1</span>, y) == non_state</span><br><span class="line">                        || chessjudge.GetChessBoardState(x + j - <span class="number">1</span>, y) == ChessBoardState.outrange))</span><br><span class="line">                        non_flag = <span class="literal">true</span>;</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">//判断是否结束截断了</span></span><br><span class="line">                    <span class="keyword">if</span> (chessjudge.GetChessBoardState(x + j, y) == non_state</span><br><span class="line">                        || chessjudge.GetChessBoardState(x + j, y) == ChessBoardState.outrange)</span><br><span class="line">                        non_flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (count > count_max)</span><br><span class="line">                    {</span><br><span class="line">                        count_max = count;</span><br><span class="line">                        now_non_flag = non_flag;</span><br><span class="line">                    }</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    non_flag =<span class="literal">false</span>;</span><br><span class="line">                }   </span><br><span class="line">            }</span><br><span class="line">            score += ScoreJudge(count_max, now_non_flag);</span><br><span class="line">            <span class="comment">//Console.WriteLine("水平得分:{0}分", score);</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            count_max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//垂直方向</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">-4</span>; j <= <span class="number">4</span>; j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (chessjudge.GetChessBoardState(x, y - j) == state)</span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">//判断是否有一段截断了</span></span><br><span class="line">                    <span class="keyword">if</span> (count == <span class="number">0</span> && (chessjudge.GetChessBoardState(x, y - j + <span class="number">1</span>) == non_state</span><br><span class="line">                        || chessjudge.GetChessBoardState(x, y - j + <span class="number">1</span>) == ChessBoardState.outrange))</span><br><span class="line">                        non_flag = <span class="literal">true</span>;</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">//判断是否结束截断了</span></span><br><span class="line">                    <span class="keyword">if</span> (chessjudge.GetChessBoardState(x, y - j) == non_state</span><br><span class="line">                        || chessjudge.GetChessBoardState(x, y - j) == ChessBoardState.outrange)</span><br><span class="line">                        non_flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (count > count_max)</span><br><span class="line">                    {</span><br><span class="line">                        count_max = count;</span><br><span class="line">                        now_non_flag = non_flag;</span><br><span class="line">                    }</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    non_flag = <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            score += ScoreJudge(count_max, now_non_flag);</span><br><span class="line">            <span class="comment">//Console.WriteLine("垂直得分:{0}分", score);</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            count_max = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//右下方向</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">-4</span>; j < <span class="number">5</span>; j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (chessjudge.GetChessBoardState(x + j, y + j) == state)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (count == <span class="number">0</span> && (chessjudge.GetChessBoardState(x + j - <span class="number">1</span>, y + j - <span class="number">1</span>) == non_state</span><br><span class="line">                        || chessjudge.GetChessBoardState(x + j - <span class="number">1</span>, y + j - <span class="number">1</span>) == ChessBoardState.outrange))</span><br><span class="line">                        non_flag = <span class="literal">true</span>;</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">//判断是否结束截断了</span></span><br><span class="line">                    <span class="keyword">if</span> (chessjudge.GetChessBoardState(x + j, y + j) == non_state</span><br><span class="line">                        || chessjudge.GetChessBoardState(x + j, y + j) == ChessBoardState.outrange)</span><br><span class="line">                        non_flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (count > count_max)</span><br><span class="line">                    {</span><br><span class="line">                        count_max = count;</span><br><span class="line">                        now_non_flag = non_flag;</span><br><span class="line">                    }</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    non_flag = <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            score += ScoreJudge(count_max, now_non_flag);</span><br><span class="line">            <span class="comment">//Console.WriteLine("右下得分:{0}分，count_max={1},non_flag={2}", score, count_max, non_flag);</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            count_max = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//左下方向</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">-4</span>; j < <span class="number">5</span>; j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (chessjudge.GetChessBoardState(x + j, y - j) == state)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (count == <span class="number">0</span> && (chessjudge.GetChessBoardState(x + j - <span class="number">1</span>, y - j + <span class="number">1</span>) == non_state</span><br><span class="line">                        || chessjudge.GetChessBoardState(x + j - <span class="number">1</span>, y - j + <span class="number">1</span>) == ChessBoardState.outrange))</span><br><span class="line">                        non_flag = <span class="literal">true</span>;</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (chessjudge.GetChessBoardState(x + j, y - j) == non_state</span><br><span class="line">                        || chessjudge.GetChessBoardState(x + j, y - j) == ChessBoardState.outrange)</span><br><span class="line">                        non_flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (count > count_max)</span><br><span class="line">                    {</span><br><span class="line">                        count_max = count;</span><br><span class="line">                        now_non_flag = non_flag;</span><br><span class="line">                    }</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    non_flag = <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            score += ScoreJudge(count_max, now_non_flag);</span><br><span class="line">            <span class="comment">//Console.WriteLine("左下得分:{0}分，count_max={1},non_flag={2}", score, count_max, non_flag);</span></span><br><span class="line">            <span class="keyword">return</span> score;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//计算每个方向上的最大分数</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">ScoreJudge</span>(<span class="params"><span class="keyword">int</span> count,<span class="keyword">bool</span> flag</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="keyword">switch</span> (count)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    <span class="keyword">return</span> BE_FIVE;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    <span class="keyword">if</span> (flag == <span class="literal">false</span>)</span><br><span class="line">                        <span class="keyword">return</span> ACTIVIE_FOUR;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> NON_FOUR;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="keyword">if</span> (flag == <span class="literal">false</span>)</span><br><span class="line">                        <span class="keyword">return</span> ACTIVIE_THREE;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> NON_THREE;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">if</span> (flag == <span class="literal">false</span>)</span><br><span class="line">                        <span class="keyword">return</span> ACTIVE_TWO;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> NON_TWO;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">return</span> OTHER;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//int[,] ScoreMapMax = new int[Rule.COL, Rule.ROW];</span></span><br><span class="line">        <span class="comment">//int[,] ScoreMapMin = new int[COL, ROW];</span></span><br><span class="line">        <span class="comment">//private Point GetBestPoint(int[,] map)</span></span><br><span class="line">        <span class="comment">//{</span></span><br><span class="line">        <span class="comment">//    int iMax = 0, jMax = 0;</span></span><br><span class="line">        <span class="comment">//    for (int i = 0; i < COL; i++)</span></span><br><span class="line">        <span class="comment">//    {</span></span><br><span class="line">        <span class="comment">//        for (int j = 0; j < ROW; j++)</span></span><br><span class="line">        <span class="comment">//        {</span></span><br><span class="line">        <span class="comment">//            if (map[i, j] > map[iMax, jMax])</span></span><br><span class="line">        <span class="comment">//            {</span></span><br><span class="line">        <span class="comment">//                iMax = i;</span></span><br><span class="line">        <span class="comment">//                jMax = j;</span></span><br><span class="line">        <span class="comment">//            }</span></span><br><span class="line">        <span class="comment">//        }</span></span><br><span class="line">        <span class="comment">//    }</span></span><br><span class="line">        <span class="comment">//    return new Point(jMax, iMax);</span></span><br><span class="line">        <span class="comment">//}</span></span><br><span class="line">        <span class="comment">//private bool[,] map = new bool[COL, ROW];</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//bool result = false;</span></span><br><span class="line">        <span class="comment">//private ChessBoardState[,] Chessjudge = new ChessBoardState[COL, ROW];</span></span><br><span class="line">        <span class="comment">//int evaluate(int player)</span></span><br><span class="line">        <span class="comment">//{</span></span><br><span class="line">        <span class="comment">//    return 1;</span></span><br><span class="line">        <span class="comment">//}</span></span><br><span class="line">        <span class="comment">//设置搜索范围，减小搜索的棋子数量</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">SearchRange</span>(<span class="params"><span class="keyword">int</span> x,<span class="keyword">int</span> y,ChessBoardState state</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            <span class="keyword">if</span>(chessjudge.GetChessBoardState(x,y)==ChessBoardState.empty)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = (x - SEARCH_RANGE); i <= (x + SEARCH_RANGE); i++)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = (y - SEARCH_RANGE); j <= (y + SEARCH_RANGE); j++)</span><br><span class="line">                        <span class="keyword">if</span> (chessjudge.GetChessBoardState(i,j) == ChessBoardState.white</span><br><span class="line">                            ||chessjudge.GetChessBoardState(i,j)==ChessBoardState.black)</span><br><span class="line">                        {</span><br><span class="line">                            <span class="keyword">if</span> (i != x || j != y)</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//剪枝算法 需要区分玩家和计算机，同时玩家可以选择先走或者后走</span></span><br><span class="line">        <span class="comment">//int alpha_beta(int depth,ChessBoardState state,int alpha,int beta)</span></span><br><span class="line">        <span class="comment">//{</span></span><br><span class="line">        <span class="comment">//    if(depth==6||result==true)</span></span><br><span class="line">        <span class="comment">//    {</span></span><br><span class="line">        <span class="comment">//        if (result == true)</span></span><br><span class="line">        <span class="comment">//            return result;</span></span><br><span class="line">        <span class="comment">//        else</span></span><br><span class="line">        <span class="comment">//        {</span></span><br><span class="line">        <span class="comment">//            return evaluate(player) - evaluate(player ^ 1);</span></span><br><span class="line">        <span class="comment">//        }</span></span><br><span class="line">        <span class="comment">//    }</span></span><br><span class="line">        <span class="comment">//    ChessBoardState anti_state;</span></span><br><span class="line">        <span class="comment">//    if (state == ChessBoardState.black)</span></span><br><span class="line">        <span class="comment">//        anti_state = ChessBoardState.white;</span></span><br><span class="line">        <span class="comment">//    else</span></span><br><span class="line">        <span class="comment">//        anti_state = ChessBoardState.black;</span></span><br><span class="line">        <span class="comment">//    int i, j;</span></span><br><span class="line">        <span class="comment">//    for(i=0;i<COL;i++)</span></span><br><span class="line">        <span class="comment">//    {</span></span><br><span class="line">        <span class="comment">//        for(j=0;j<ROW;j++)</span></span><br><span class="line">        <span class="comment">//        {</span></span><br><span class="line">        <span class="comment">//            if(SearchRange(i,j,state)==true)</span></span><br><span class="line">        <span class="comment">//            {</span></span><br><span class="line">        <span class="comment">//                Chessjudge[i, j] = state;</span></span><br><span class="line">        <span class="comment">//                int ans = alpha_beta(depth + 1, anti_state, alpha, beta);</span></span><br><span class="line">        <span class="comment">//                if (ans > alpha)</span></span><br><span class="line">        <span class="comment">//                {</span></span><br><span class="line">        <span class="comment">//                    alpha = ans;</span></span><br><span class="line">        <span class="comment">//                    ansx = i;</span></span><br><span class="line">        <span class="comment">//                    ansy = j;</span></span><br><span class="line">        <span class="comment">//                }</span></span><br><span class="line">        <span class="comment">//                if(ans <beta)</span></span><br><span class="line">        <span class="comment">//                {</span></span><br><span class="line">        <span class="comment">//                    beta = ans;</span></span><br><span class="line">        <span class="comment">//                }</span></span><br><span class="line">        <span class="comment">//                if (alpha >= beta)</span></span><br><span class="line">        <span class="comment">//                {</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//                    return alpha;</span></span><br><span class="line">        <span class="comment">//                }</span></span><br><span class="line">        <span class="comment">//            }</span></span><br><span class="line">        <span class="comment">//        }</span></span><br><span class="line">        <span class="comment">//    }</span></span><br><span class="line">        <span class="comment">//}</span></span><br><span class="line">        <span class="comment">//先写一个简单的MAXmin</span></span><br><span class="line">        <span class="comment">//其实用一个数组就够了，不需要重新定义一个棋盘</span></span><br><span class="line">        <span class="keyword">private</span> Point[] tmp = <span class="keyword">new</span> Point[<span class="number">100</span>];</span><br><span class="line">        <span class="comment">//private Point tmp[200];</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Point <span class="title">NextJudge</span>(<span class="params">ChessBoardState state,<span class="keyword">out</span> <span class="keyword">int</span> max</span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            ChessBoardState anti_state;</span><br><span class="line">            <span class="keyword">int</span> cnt=<span class="number">0</span>,score_tmp;</span><br><span class="line">            Point best=<span class="keyword">new</span> Point();</span><br><span class="line">            <span class="keyword">int</span>[] min = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">200</span>];</span><br><span class="line">            max = -BE_FIVE - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">200</span>;i++)</span><br><span class="line">            {</span><br><span class="line">                min[i] = BE_FIVE+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (state == ChessBoardState.black)</span><br><span class="line">                anti_state = ChessBoardState.white;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                anti_state = ChessBoardState.black;</span><br><span class="line">            <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<Rule.COL;i++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < Rule.ROW; j++)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (SearchRange(i, j, state) == <span class="literal">true</span>)</span><br><span class="line">                    {</span><br><span class="line">                        chessjudge.SetChessBoardState(i, j, state);</span><br><span class="line">                        score_tmp = GetPointScore(i, j, state);</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m<Rule.COL;m++)</span><br><span class="line">                        {</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n<Rule.ROW;n++)</span><br><span class="line">                            {</span><br><span class="line">                                <span class="keyword">if</span> (SearchRange(m, n, anti_state) == <span class="literal">true</span>)</span><br><span class="line">                                {</span><br><span class="line">                                    chessjudge.SetChessBoardState(m, n, anti_state);</span><br><span class="line">                                    score = score_tmp - GetPointScore(m, n, anti_state);</span><br><span class="line">                                    <span class="keyword">if</span>(score<min[cnt])</span><br><span class="line">                                    {</span><br><span class="line">                                        <span class="comment">//对方一定会取最小值,寻找最小值，并记录坐标</span></span><br><span class="line">                                        tmp[cnt].X = i;</span><br><span class="line">                                        tmp[cnt].Y = j;</span><br><span class="line">                                        min[cnt] = score;</span><br><span class="line">                                    }</span><br><span class="line">                                    chessjudge.SetChessBoardState(m, n, ChessBoardState.empty);</span><br><span class="line">                                }</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                        chessjudge.SetChessBoardState(i, j, ChessBoardState.empty);</span><br><span class="line">                        cnt++;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            cnt--;</span><br><span class="line">            <span class="keyword">while</span> (cnt >= <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (min[cnt] > max)</span><br><span class="line">                {</span><br><span class="line">                    max = min[cnt];</span><br><span class="line">                    best.X = tmp[cnt].X;</span><br><span class="line">                    best.Y = tmp[cnt].Y;</span><br><span class="line">                }</span><br><span class="line">                cnt--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> best;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>




</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title>递归函数设计</title>
    <url>/posts/80ca7941/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>问题可用递归来解决需要具备的条件：<br>1.子问题需与原问题为同样的事，且规模更小 2.程序停止条件。</p>
<p>递归函数常用方法:<br>1.分治法 2.后置递归法 3.回溯法</p>
<a id="more"></a>

<h1 id="如何思考递归"><a href="#如何思考递归" class="headerlink" title="如何思考递归"></a>如何思考递归</h1><p>那我们怎么判断这个递归计算是否是正确的呢？Paul Graham 提到一种方法，如下：</p>
<blockquote>
<p>如果下面这两点是成立的，我们就知道这个递归对于所有的 n 都是正确的。<br>当 n=0,1 时，结果正确；<br>假设递归对于 n 是正确的，同时对于 n+1 也正确。</p>
</blockquote>
<p>这种方法很像<strong>数学归纳法</strong>，也是递归正确的思考方式，上述的第 1 点称为基本情况，第 2 点称为通用情况。</p>
<p>在递归中，我们通常把第 1 点称为终止条件，因为这样更容易理解，其作用就是终止递归，防止递归无限地运行下去。</p>
<h1 id="分治法设计思想"><a href="#分治法设计思想" class="headerlink" title="分治法设计思想"></a>分治法设计思想</h1><ul>
<li><p>对于一个输入规模为n的函数或问题，用某种方法把输入分割成k(1<k≤n)个子集，从而产生<em>k</em>个相似的子问题；</p>
</li>
<li><p>分别求解这k个子问题，得出<em>k</em>个问题的子解;再用某种方法把它们<strong>组合成原来问题的解</strong>；</p>
</li>
<li><p>若子问题还相当大，则可以反复使用分治法，直至最后所分得的子问题足够小，以至可以直接求解为止。</p>
</li>
</ul>
<p>常见的解决问题有：斐波那契数列，汉诺塔问题等<br>举个例子：如绘制标尺，标出两段，找到中点并将其标出，然后同样的操作作用于标尺的左半部分和右半部分。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len=<span class="number">66</span>;   </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> divs=<span class="number">6</span>;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subdivide</span><span class="params">(<span class="keyword">char</span> ar[],<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> level)</span></span>;   </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>{   </span><br><span class="line">    <span class="keyword">char</span> ruler[len];   </span><br><span class="line">    <span class="keyword">int</span> i;   </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i<len<span class="number">-2</span>;i++)   </span><br><span class="line">        ruler[i]=<span class="string">' '</span>;   </span><br><span class="line">    ruler[len<span class="number">-1</span>]=<span class="string">'\0'</span>;   </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span>=len<span class="number">-2</span>;   </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span>=<span class="number">0</span>;   </span><br><span class="line">    ruler[<span class="built_in">min</span>]=ruler[<span class="built_in">max</span>]=<span class="string">'|'</span>;   </span><br><span class="line">    <span class="built_in">cout</span><<ruler<<<span class="built_in">endl</span>;   </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i<=divs;i++)   </span><br><span class="line">    {   </span><br><span class="line">        subdivide(ruler,<span class="built_in">min</span>,<span class="built_in">max</span>,i);   </span><br><span class="line">        <span class="built_in">cout</span><<ruler<<<span class="built_in">endl</span>;   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j<len<span class="number">-2</span>;j++)   </span><br><span class="line">            ruler[j]=<span class="string">' '</span>;   </span><br><span class="line">    }   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line"></span><br><span class="line">}   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subdivide</span><span class="params">(<span class="keyword">char</span> ar[],<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> level)</span>   </span></span><br><span class="line"><span class="function"></span>{   </span><br><span class="line">    <span class="keyword">if</span>(level==<span class="number">0</span>)   </span><br><span class="line">        <span class="keyword">return</span>;   </span><br><span class="line">    <span class="keyword">int</span> mid=(high+low)/<span class="number">2</span>;   </span><br><span class="line">    ar[mid]=<span class="string">'|'</span>;   </span><br><span class="line">    subdivide(ar,low,mid,level<span class="number">-1</span>);   </span><br><span class="line">    subdivide(ar,mid,high,level<span class="number">-1</span>);   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="后置递归设计思想"><a href="#后置递归设计思想" class="headerlink" title="后置递归设计思想"></a>后置递归设计思想</h1><p>假如某个问题的求解过程可以分成若干步进行，并且<strong>当前这一步的解可以直接求得</strong>，则<strong>先求出当前这一步的解</strong>，对于<strong>余下的问题</strong>，若问题的性质和原问题类似，则又可<strong>递归求解</strong>。</p>
<p>后置递归算法的典型举例:删除单链表中所有值为x的数据元素</p>
<p><strong>分析:</strong></p>
<p>1)单链表是一种顺序结构，必须从第一个结点起，逐个检查每个结点的数据元素;</p>
<p>2)从另一角度看，链表又是一个递归结构，若L是带头结点线性链表(a1,a2,¼, an)的头指针，则 L->next是线性链表(a2,¼, an)的头指针。</p>
<p><img src="https://img-blog.csdn.net/20180831154918148?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXhpYW5nMTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><p>回溯法是一种“穷举搜索”方法。其基本思想为:</p>
<ul>
<li><p>假设问题的解为 n 元组 (x1, x2, …, xn)；</p>
</li>
<li><p>如果n 元组的部分解为 (x1, x2, …, xi) (i<n) ,且应满足一定的约束条件；</p>
</li>
<li><p>对于已求得的部分解 (x1, x2, …, xi) ，若在添加 xi+1 之后仍然满足约束条件，则得到一个新的部分解 (x1, x2, …, xi+1) ；之后继续添加 xi+2并检查之；</p>
</li>
<li><p>若找不到一个xi+1满足约束条件，则从当前部分解中删去xi, 回溯到前一个部分解(x1,x2, × × ×,xi-1 ),重新添加那些尚未考察过的xi，并检查之；</p>
</li>
<li><p>如此反复进行，直至求得满足约束条件的问题的解，或者证明问题无解；</p>
</li>
</ul>
<p>设四皇后问题的解为 (x1, x2, x3, x4), 其中:</p>
<p> xi (i=1,2,3,4) ，约束条件为: 其中任意两个xi 和xj不能位于棋盘的同行、同列及同对角线.</p>
<p>皇后问题回溯算法关键:</p>
<p>搜索策略: 深度优先，依次取 xi=1,2,3,4;</p>
<p>约束条件: xi和xj不位于棋盘的同行、同列及同对角线上；</p>
<p>终止条件: 找到满足条件的x1,x2 x3,x4；即:i=n</p>
<p>回溯条件:  在当前初始条件下无解；无解: 回溯到了起始状态,i=0；</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trial</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">  <span class="comment">// 进入本函数时，在n×n棋盘前i-1行已放置了互不攻</span></span><br><span class="line">  <span class="comment">// 击的i-1个棋子。现从第 i 行起继续为后续棋子选择 </span></span><br><span class="line">  <span class="comment">// 满足约束条件的位置。当求得(i>n)的一个合法布局</span></span><br><span class="line">  <span class="comment">// 时，输出之。i 的初始值为1。</span></span><br><span class="line">  <span class="keyword">if</span>(i=<span class="number">0</span>)  无解；</span><br><span class="line">  <span class="keyword">if</span> (i>n) 输出棋盘的当前布局;                <span class="comment">//终止</span></span><br><span class="line">  <span class="keyword">else</span>  <span class="keyword">for</span> (j=<span class="number">1</span>;  j<=n; ++j) {                     <span class="comment">//试探策略</span></span><br><span class="line">      在第 i 行第 j 列放置一个棋子;</span><br><span class="line">      <span class="keyword">if</span> (当前布局合法) Trial(i+<span class="number">1</span>, n); <span class="comment">//约束-递归</span></span><br><span class="line">      移去第 i 行第 j 列的棋子;          <span class="comment">//回溯</span></span><br><span class="line">  }        </span><br><span class="line">} <span class="comment">// Trial</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="递归注意事项"><a href="#递归注意事项" class="headerlink" title="递归注意事项"></a>递归注意事项</h1><p>1.先写出问题求解的递归定义,包括两项内容:</p>
<ul>
<li><p>基本项:描述一个或几个递归过程的终结状态；</p>
</li>
<li><p>归纳项:描述如何从当前状态到下一状态的转换；</p>
</li>
</ul>
<p>2 写递归函数时注意: </p>
<p>严格定义函数的功能和接口;<br> 将每一个递归看成一个简单的操作;<br> <strong>切忌想得太深太远！</strong>  </p>
<p>3.分析递归算法的工具是<strong>递归树</strong>，从递归树上可以得到递归函数的各种相关信息。</p>
<ul>
<li><p>递归树的深度即为递归函数的<strong>递归深度</strong></p>
</li>
<li><p>递归树上的结点数目恰为函数中的主要操作<strong>重复进行的次数</strong>；</p>
</li>
<li><p>若递归树蜕化为<strong>单支树</strong>或者递归树中<strong>含有很多相同的结点</strong>，则表明该递归函数不适用。比如fib(n) = fib(n-1)+fib(n-2)</p>
</li>
</ul>
<p>在这种情况下会重复计算很多比n小的值得fib值，重复太多！！！<br>所以这种情况下用迭代会更适合一些！！！</p>
<p><img src="https://img-blog.csdn.net/20180831160036212?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXhpYW5nMTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>  </p>
<h1 id="我的实践"><a href="#我的实践" class="headerlink" title="我的实践"></a>我的实践</h1><p>找到与之相连的联通域</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search_dynamic_region</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-1</span>; i < <span class="number">2</span>; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">-1</span>; j < <span class="number">2</span>; j++) {</span><br><span class="line">            <span class="keyword">if</span> (x + i >= <span class="number">0</span> && x + i < row &&</span><br><span class="line">                y + j >= <span class="number">0</span> && y + j < col &&</span><br><span class="line">                p[(x + i)*row + y + j] == <span class="number">1</span>) {</span><br><span class="line">                p[(x + i)*row + y + j] = <span class="number">2</span>;</span><br><span class="line">                search_dynamic_region(p, x + i, y + j, row, col);</span><br><span class="line">            }    </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ROW = <span class="number">10</span>,COL = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> s[<span class="number">10</span>][<span class="number">10</span>] = { {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>},</span><br><span class="line">                         {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>},</span><br><span class="line">                         {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>},</span><br><span class="line">                         {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>},</span><br><span class="line">                         {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>},</span><br><span class="line">                         {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>},</span><br><span class="line">                         {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>},</span><br><span class="line">                         {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>},</span><br><span class="line">                         {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>},</span><br><span class="line">                         {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>} };</span><br><span class="line">    <span class="keyword">int</span> str[] = {  <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">                    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, </span><br><span class="line">                    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, </span><br><span class="line">                    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, </span><br><span class="line">                    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, </span><br><span class="line">                    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, </span><br><span class="line">                    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>, </span><br><span class="line">                    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>, </span><br><span class="line">                    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < ROW; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < COL; j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//一维数组的方式</span></span><br><span class="line">            <span class="comment">//if (str[i*ROW + j] == 2)</span></span><br><span class="line">            <span class="comment">//    search_dynamic_region(str, i, j,ROW,COL);</span></span><br><span class="line">            <span class="comment">//二维数组的方式</span></span><br><span class="line">            <span class="keyword">if</span>(s[i][j]==<span class="number">2</span>)</span><br><span class="line">                search_dynamic_region((<span class="keyword">int</span>*)s, i, j, ROW, COL);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 二维数组参数传递</title>
    <url>/posts/8f9bdbcd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>转载自<a href="https://www.cnblogs.com/cygalaxy/p/6963789.html" target="_blank" rel="noopener">博客</a>  </p>
</blockquote>
<blockquote>
<p>二维数组如何作为参数传递？为什么不能直接用二维指针传递？</p>
</blockquote>
<blockquote>
<p>传递动态数组推荐的方法：强制转换为一维指针，这样一维二维数组可以用同一个函数传入</p>
</blockquote>
<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p> 尝试<code>int**</code>做形参，编译错误：int(*)[10]和int**类型不符</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>** p)</span></span>{</span><br><span class="line">    ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    f(a);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="三种解决方法"><a href="#三种解决方法" class="headerlink" title="三种解决方法"></a>三种解决方法</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*传二维数组*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第1种方式：传数组,第二维必须标明</span></span><br><span class="line"><span class="comment">/*void display(int arr[][4])*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display1</span><span class="params">(<span class="keyword">int</span> arr[][<span class="number">4</span>],<span class="keyword">const</span> <span class="keyword">int</span> irows)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<irows;++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j<<span class="number">4</span>;++j)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">cout</span><<arr[i][j]<<<span class="string">" "</span>;     <span class="comment">//可以采用parr[i][j]</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">cout</span><<<span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span><<<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//第2种方式：一重指针，传数组指针,第二维必须标明</span></span><br><span class="line"><span class="comment">/*void display(int (*parr)[4])*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display2</span><span class="params">(<span class="keyword">int</span> (*parr)[<span class="number">4</span>],<span class="keyword">const</span> <span class="keyword">int</span> irows)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<irows;++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j<<span class="number">4</span>;++j)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">cout</span><<parr[i][j]<<<span class="string">" "</span>;    <span class="comment">//可以采用parr[i][j]</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">cout</span><<<span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span><<<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//注意：parr[i]等价于*(parr+i)，一维数组和二维数组都适用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第3种方式：传指针,不管是几维数组都把他看成是指针</span></span><br><span class="line"><span class="comment">/*void display3(int *arr)*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display3</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">const</span> <span class="keyword">int</span> irows,<span class="keyword">const</span> <span class="keyword">int</span> icols)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<irows;++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j<icols;++j)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">cout</span><<*(arr+i*icols+j)<<<span class="string">" "</span>;   <span class="comment">//注意:(arr+i*icols+j),不是(arr+i*irows+j)</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">cout</span><<<span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span><<<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//第2种方式：一重指针，传数组指针void display(int (*parr)[4])</span></span><br><span class="line"><span class="comment">//缺陷：需要指出第二维大小</span></span><br><span class="line"><span class="comment">typedef int parr[4];</span></span><br><span class="line"><span class="comment">void display(parr *p)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">    int *q=*p;        //q指向arr的首元素</span></span><br><span class="line"><span class="comment">    cout<<*q<<endl;   //输出0</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">typedef int (*parr1)[4];</span></span><br><span class="line"><span class="comment">void display1(parr1 p)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">    cout<<(*p)[1]<<endl;  //输出1</span></span><br><span class="line"><span class="comment">    cout<<*p[1]<<endl;    //输出4,[]运算符优先级高</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">//第3种方式：</span></span><br><span class="line"><span class="comment">void display2(int **p)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">    cout<<*p<<endl;           //输出0</span></span><br><span class="line"><span class="comment">    cout<<*((int*)p+1+1)<<endl; //输出2</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> arr[][<span class="number">4</span>]={<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>};</span><br><span class="line">    <span class="keyword">int</span> irows=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> icols=<span class="number">4</span>;</span><br><span class="line">    display1(arr,irows);</span><br><span class="line">    display2(arr,irows);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意(int*)强制转换.个人理解：相当于将a拉成了一维数组处理。</span></span><br><span class="line">    display3((<span class="keyword">int</span>*)arr,irows,icols);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 相册功能实现</title>
    <url>/posts/6ad36f8c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="利用七牛网存储图片"><a href="#利用七牛网存储图片" class="headerlink" title="利用七牛网存储图片"></a>利用七牛网存储图片</h1><h1 id="缩略图和原图实现"><a href="#缩略图和原图实现" class="headerlink" title="缩略图和原图实现"></a>缩略图和原图实现</h1><p>网上很多都是在本地利用Python等语言进行压缩，繁琐且浪费空间<br>本文使用七牛网自带的图片处理功能进行缩略图的压缩<br>首先在存储空间->图片样式，新建一个图片样式，默认就行，图片瘦身可以关闭，最后得到一个处理接口，如<code>imageView2/1/w/200/h/200/q/85</code>，在图片链接后加上<code>?</code>和处理接口就行<br>例如：原图链接<code>http://pnbj1h9rr.bkt.clouddn.com/2019-02-22_1533974526388.jpg</code>，缩略图链接为<code>http://pnbj1h9rr.bkt.clouddn.com/2019-02-22_1533974526388.jpg?imageView2/1/w/200/h/200/q/85</code><br>这都是链接，不需要在本地完成，我们配置JSON文件的时候只需要读取文件名，利用Python添加对应的文件名就行</p>
<h1 id="相册页面实现"><a href="#相册页面实现" class="headerlink" title="相册页面实现"></a>相册页面实现</h1><ol>
<li>参考<a href="https://foreti.me/archives/14046165.html#album" target="_blank" rel="noopener">博客</a>的实现方法</li>
<li>修改source\lib\album\ins.js文件114行的<code>render()</code>函数中的两个变量<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minSrc = <span class="string">'http://pnbj1h9rr.bkt.clouddn.com/'</span> + data.link[i]+<span class="string">'?imageView2/1/w/200/h/200/q/85'</span>;</span><br><span class="line"><span class="keyword">var</span> src = <span class="string">'http://pnbj1h9rr.bkt.clouddn.com/'</span> + data.link[i];</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Python脚本编辑JSON"><a href="#Python脚本编辑JSON" class="headerlink" title="Python脚本编辑JSON"></a>Python脚本编辑JSON</h1>在JSON中添加</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>工具</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>python的矩阵乘法</title>
    <url>/posts/62b4da2e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>Numpy中的矩阵乘法分为两大情况，使用numpy.array和使用numpy.matrix. </p>
<p>Numpy重载了*操作符，可以直接对array或者matrix对象进行乘法运算，但是在不同对象上，其意义是有区别的。</p>
<h2 id="对于array对象"><a href="#对于array对象" class="headerlink" title="对于array对象"></a>对于array对象</h2><p>*（或者multiply）代表的是并不是矩阵的乘法规则，而是简单的数量积，即对应位置元素相乘后的积相加。</p>
<p>验证结果如下： </p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">>>> </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">>>> </span>a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="meta">>>> </span>b = np.array([[<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">1</span>]])</span><br><span class="line"><span class="meta">>>> </span>a*b</span><br><span class="line">array([[<span class="number">4</span>,<span class="number">6</span>],</span><br><span class="line">       [<span class="number">6</span>,<span class="number">4</span>]])</span><br></pre></td></tr></tbody></table></figure>

<p>如果在array对象上要进行严格的矩阵乘法，即矢量乘法，则必须使用.dot()或者.matmul()函数，两者是等效的，我们可以通过查阅官网文档得知。<br><img src="https://image.qinxing.xyz/20200401203742.png" alt="numpy.dot"></p>
<p><img src="https://image.qinxing.xyz/20200401203922.png" alt="numpy.matmul"></p>
<p>在IDLE上运行结果如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">>>> </span>np.dot( a, b)</span><br><span class="line">array([[ <span class="number">8</span>,  <span class="number">5</span>], </span><br><span class="line">       [<span class="number">20</span>, <span class="number">13</span>]])</span><br><span class="line"><span class="meta">>>> </span>np.matmul( a, b)</span><br><span class="line">array([[ <span class="number">8</span>,  <span class="number">5</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">13</span>]])</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到两者的运行结果一致，都是矩阵的矢量积结果。</p>
<h2 id="对于matrix对象"><a href="#对于matrix对象" class="headerlink" title="对于matrix对象"></a>对于matrix对象</h2><p>对于matrix，情况就恰恰相反了。* 表示的是矢量积，如果希望以数量积方式运行，则必须使用np.multiply函数。因为*重载矩阵运算规则只限于matrix对象。 在IDLE中验证如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">>>> </span>a = np.matrix([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="meta">>>> </span>b = np.matrix([[<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">1</span>]])</span><br><span class="line"><span class="meta">>>> </span>a*b</span><br><span class="line">matrix([[ <span class="number">8</span>,  <span class="number">5</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">13</span>]])</span><br><span class="line"><span class="meta">>>> </span>np.multiply(a,b)</span><br><span class="line">matrix([[<span class="number">4</span>, <span class="number">6</span>],</span><br><span class="line">        [<span class="number">6</span>, <span class="number">4</span>]])</span><br></pre></td></tr></tbody></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>对于array对象，*和np.multiply函数代表的是数量积，如果希望使用矩阵的乘法规则，则应该调用np.dot和np.matmul函数。</li>
<li>对于matrix对象，*直接代表了原生的矩阵乘法，而如果特殊情况下需要使用数量积，则应该使用np.multiply函数。</li>
<li>对于array对象，在需要矩阵乘法的时候，也利用np.asmatrix转换成matrix对象</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>乘法</tag>
      </tags>
  </entry>
  <entry>
    <title>强光抑制算法初步实现</title>
    <url>/posts/bd8fec7b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>如何实现强光场景的识别？如何自动确定对强光区域权重的最优增益？</p>
<a id="more"></a>

<h1 id="实验数据获取"><a href="#实验数据获取" class="headerlink" title="实验数据获取"></a>实验数据获取</h1><p>控制变量，尽量保持场景不变，寻找随着曝光阶的改变，过曝的场景和普通场景的区别。<br><strong>发现问题1</strong>：当曝光阶为0时，如果场景没有什么大变化的话，再去动测光权重没有效果 –>调整拍摄顺序，在背光算法中注意控制曝光阶不为0<br><strong>发现问题2</strong>：相同的增益不一定对应同一个曝光阶，增益经过调节之后，调回去曝光阶和之前不一样<br>注意修改测光权重表，门禁设备的测光权重只有中间的一小块有效；改成默认的中心权重曝光</p>
<ol>
<li>从没有一点强光到有强光场景拍十组照片，用来识别强光场景下的特点</li>
<li>从过曝的场景到不过曝的场景拍十组数据，用来选取强光场景下的最优增益</li>
</ol>
<h1 id="强光场景识别"><a href="#强光场景识别" class="headerlink" title="强光场景识别"></a>强光场景识别</h1><ol>
<li>从直方图亮度饱和的比例来看：当亮点比较小，或者欠曝的时候很难进行区分</li>
<li>从直方图的亮暗区间的区分来看，一般亮的场景会区分比较大，但是如果</li>
<li>分块数据来看</li>
</ol>
<p>识别特征：</p>
<p>1、当前对亮区测光权重的增益；如果已经比较大，说明已经识别为背光场景</p>
<p>2、静态亮区 vs 动态亮区</p>
<p>一般来说，运动的车灯是动态亮区，而路灯等是稳定不动的，我们通过调节brightness就可以控制路灯等静态亮区，而动态亮区的权重我们可以粗略的当做车灯。或者静态亮区和动态亮区给予不同的增益。</p>
<p>当检测到某个亮区的亮度相比于前一帧的相同位置有变化，将它称作动点，一个车灯的动点只有边缘区域，而中心的区域可能没有动，因此我们可以将和动点连通的亮区作为动态亮区。如何标记动点连通的亮区，我采用的是递归的方法。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search_dynamic_region</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">array</span>, <span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">-1</span>; i < <span class="number">2</span>; i++) {</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">-1</span>; j < <span class="number">2</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (x + i >= <span class="number">0</span> && x + i < row &&</span><br><span class="line">                    y + j >= <span class="number">0</span> && y + j < col &&</span><br><span class="line">                    (x || y == <span class="number">1</span>) && <span class="built_in">array</span>[(x + i)*col + y + j] == <span class="number">1</span>) {</span><br><span class="line">                <span class="built_in">array</span>[(x + i)*col + y + j] = <span class="number">2</span>;</span><br><span class="line">                search_dynamic_region(<span class="built_in">array</span>, x + i, y + j, row, col);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="强光场景最优增益"><a href="#强光场景最优增益" class="headerlink" title="强光场景最优增益"></a>强光场景最优增益</h1><ol>
<li><p>获取9组数据，第5-6组是最优组</p>
</li>
<li><p>问题：为什么曝光行差距很大，但是Bayer域的统计数据却差不多？</p>
</li>
</ol>
<h1 id="背光补偿代码bug"><a href="#背光补偿代码bug" class="headerlink" title="背光补偿代码bug"></a>背光补偿代码bug</h1><p>   发现一个背光补偿测光权重初始化的bug，如果在途中对chromatix进行了重新加载，测光表的初始值就改变了，可能会导致图片  –>通过验证，并不会发生这种问题</p>
<p>   长时间将亮区的测光权重增大，会导致图像整体变亮 ->  </p>
<ul>
<li><p>设置一个固定的权重增益，理论上说用手遮住亮区再拿开，场景不变，曝光行应该回到正常场景，但是它在增大 </p>
</li>
<li><p>就算不懂动，曝光行好像也在缓慢的增大，会不会由于第一个原因引起的？</p>
<p> 曝光行在不断的增加，说明亮区权重在降低，或者暗区权重在增加</p>
<p> 初始化的时候就会还原</p>
</li>
<li><p>实验证明，亮区的检测并没有发生改变，依旧改的是那几个区域，测光权重表是修改正确的</p>
</li>
<li><p><strong>解决方案</strong>：将测光权重完全指定 ：说明了AEC算法内部会对测光权重进行修改</p>
</li>
</ul>
<p>如果调低亮度，容易闪烁：调低亮度之后，亮区就会变少，整体亮度会提高；而提高亮度后，亮区有变多，整体亮度会变暗<br>遮挡一个亮区后，会闪烁：亮区的权重很大，亮区有轻微的改变就会影响AE，而我的视野里有一个闪动的屏幕，因此有闪烁属于正常，最后稳定阶段在进行优化</p>
<h1 id="不同平台的实现"><a href="#不同平台的实现" class="headerlink" title="不同平台的实现"></a>不同平台的实现</h1><h2 id="660平台"><a href="#660平台" class="headerlink" title="660平台"></a>660平台</h2><p>经过验证，可以实现对运动的强光进行抑制。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> v_step = q3a_bg_stats->bg_region_v_num/NUM_AEC_STATS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h_step = q3a_bg_stats->bg_region_h_num/NUM_AEC_STATS;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> bg_sum[MAX_BG_STATS_NUM]={<span class="number">0</span>};</span><br><span class="line"><span class="keyword">char</span> grid_region[MAX_BG_STATS_NUM] ={<span class="number">0</span>};</span><br><span class="line"><span class="keyword">int</span> grid_v_num, grid_h_num;</span><br><span class="line"><span class="keyword">int</span> weight_grid_count[NUM_AEC_STATS][NUM_AEC_STATS] = {<span class="number">0</span>};</span><br><span class="line"><span class="keyword">uint32_t</span> bg_count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (property_get(<span class="string">"persist.liqinxing.backlight"</span>, value, <span class="string">""</span>) > <span class="number">0</span>){</span><br><span class="line">    aec_dynamic_ratio = atoi(value)/<span class="number">1000.0</span>;</span><br><span class="line">    <span class="comment">//reduce traverse times and prevent data overflow</span></span><br><span class="line">    <span class="keyword">int</span> grid_count = q3a_bg_stats->bg_region_h_num * q3a_bg_stats->bg_region_v_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//find bright region and dynamic spot</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < grid_count; i++){</span><br><span class="line">        <span class="keyword">if</span>(q3a_bg_stats->bg_r_sum[i] > threhold_h ||</span><br><span class="line">           q3a_bg_stats->bg_gr_sum[i] > threhold_h ||</span><br><span class="line">           q3a_bg_stats->bg_b_sum[i] > threhold_h){</span><br><span class="line">                bg_count = q3a_bg_stats->bg_r_sum[i]+q3a_bg_stats->bg_gr_sum[i]+</span><br><span class="line">                q3a_bg_stats->bg_gb_sum[i]+q3a_bg_stats->bg_b_sum[i];</span><br><span class="line">                <span class="keyword">if</span>(bg_count*<span class="number">10</span>/bg_sum[i] > <span class="number">12</span>)</span><br><span class="line">                    grid_region[i] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    grid_region[i] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        bg_sum[i] = q3a_bg_stats->bg_r_sum[i]+q3a_bg_stats->bg_gr_sum[i]+</span><br><span class="line">                q3a_bg_stats->bg_gb_sum[i]+q3a_bg_stats->bg_b_sum[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//find dynamic bright region</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i < grid_count; i++){</span><br><span class="line">        <span class="keyword">if</span>(grid_region[i] == <span class="number">2</span>){</span><br><span class="line">            search_dynamic_region(grid_region, i/q3a_bg_stats->bg_region_h_num,</span><br><span class="line">                i%q3a_bg_stats->bg_region_h_num, q3a_bg_stats->bg_region_v_num,</span><br><span class="line">                q3a_bg_stats->bg_region_h_num);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert to aec weight grid table</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i<grid_count; i++){</span><br><span class="line">        <span class="keyword">if</span>(grid_region[i] != <span class="number">0</span>){</span><br><span class="line">            grid_v_num = i/q3a_bg_stats->bg_region_h_num/v_step;<span class="comment">//calculate current position v</span></span><br><span class="line">            grid_h_num = i%q3a_bg_stats->bg_region_h_num/h_step;<span class="comment">//calculate current position h</span></span><br><span class="line">            <span class="keyword">if</span>(grid_region[i] == <span class="number">2</span>)</span><br><span class="line">                weight_grid_count[grid_v_num][grid_h_num] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(weight_grid_count[grid_v_num][grid_h_num] != <span class="number">2</span>)</span><br><span class="line">                weight_grid_count[grid_v_num][grid_h_num] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_wrlock(&chromatix->lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i < NUM_AEC_STATS; i++){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j < NUM_AEC_STATS; j++){</span><br><span class="line">            <span class="keyword">if</span>(weight_grid_count[i][j] == <span class="number">2</span>){</span><br><span class="line">                chromatix->AEC.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span><br><span class="line">                    keda_exposure_weight[i][j] * aec_dynamic_ratio;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(weight_grid_count[i][j] == <span class="number">1</span>)</span><br><span class="line">                chromatix->AEC.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span><br><span class="line">                    keda_exposure_weight[i][j] * aec_static_ratio;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                chromatix->AEC.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span><br><span class="line">                    keda_exposure_weight[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    pthread_rwlock_unlock(&chromatix->lock);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (aec->aec_algo_ops.set_parameters) {</span><br><span class="line">        aec->aec_algo_ops.set_parameters(aec->handle, &backlight_set_parameter);</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">      }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="8056平台的移植"><a href="#8056平台的移植" class="headerlink" title="8056平台的移植"></a>8056平台的移植</h2><p>由于部分参数的类型不同，以及编译规则的不同，对<code>keda_backlight_algo</code>函数进行修改。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">keda_backlight_algo</span><span class="params">(<span class="keyword">aec_biz_t</span> *aec, <span class="keyword">const</span> <span class="keyword">stats_t</span>* stats)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//detect input</span></span><br><span class="line">    <span class="keyword">if</span> (!aec || !stats) {</span><br><span class="line">      AEC_ERR(<span class="string">"Invalid input: %p,%p"</span>,aec, stats);</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//define var</span></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="keyword">float</span> aec_ratio = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">float</span> aec_dynamic_ratio=<span class="number">1000</span>,aec_static_ratio=<span class="number">1</span>;</span><br><span class="line">    chromatix_3a_parms_type *chromatix;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">q3a_bg_stats_t</span>* q3a_bg_stats = stats->bayer_stats.p_q3a_bg_stats;</span><br><span class="line">    <span class="keyword">uint32_t</span> threhold_h = q3a_bg_stats->rMax * q3a_bg_stats->region_pixel_cnt * BRIGHT_REGION_RANGE /<span class="number">4</span>;</span><br><span class="line">    chromatix = (chromatix_3a_parms_type*)backlight_set_parameter.u.init_param.chromatix;</span><br><span class="line">    <span class="keyword">if</span> (!chromatix) {</span><br><span class="line">        AEC_ERR(<span class="string">"Invalid chromatix: %p"</span>, chromatix)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> v_step = q3a_bg_stats->bg_region_v_num/NUM_AEC_STATS;</span><br><span class="line">    <span class="keyword">int</span> h_step = q3a_bg_stats->bg_region_h_num/NUM_AEC_STATS;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint32_t</span> bg_sum[MAX_BG_STATS_NUM]={<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">char</span> grid_region[MAX_BG_STATS_NUM] ={<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">int</span> grid_v_num, grid_h_num;</span><br><span class="line">    <span class="keyword">int</span> weight_grid_count[NUM_AEC_STATS][NUM_AEC_STATS] = {{<span class="number">0</span>}};</span><br><span class="line">    <span class="keyword">uint32_t</span> bg_count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (property_get(<span class="string">"persist.liqinxing.backlight"</span>, value, <span class="string">""</span>) > <span class="number">0</span>){</span><br><span class="line">        aec_static_ratio = atoi(value)/<span class="number">1000.0</span>;</span><br><span class="line">        <span class="comment">//reduce traverse times and prevent data overflow</span></span><br><span class="line">        <span class="keyword">int</span> grid_count = q3a_bg_stats->bg_region_h_num * q3a_bg_stats->bg_region_v_num;</span><br><span class="line">        <span class="comment">//find the position of bright region</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for(int i = 0; i < grid_count; i++){</span></span><br><span class="line"><span class="comment">            if(q3a_bg_stats->bg_r_sum[i] > threhold_h ||</span></span><br><span class="line"><span class="comment">               q3a_bg_stats->bg_gr_sum[i] > threhold_h ||</span></span><br><span class="line"><span class="comment">               q3a_bg_stats->bg_b_sum[i] > threhold_h){</span></span><br><span class="line"><span class="comment">               //stats bright region</span></span><br><span class="line"><span class="comment">                grid_v_num = i/q3a_bg_stats->bg_region_h_num/v_step;//calculate current position v</span></span><br><span class="line"><span class="comment">                grid_h_num = i%q3a_bg_stats->bg_region_h_num/h_step;//calculate current position h</span></span><br><span class="line"><span class="comment">                weight_grid_count[grid_v_num][grid_h_num]++;</span></span><br><span class="line"><span class="comment">                bg_count = q3a_bg_stats->bg_r_sum[i]+q3a_bg_stats->bg_gr_sum[i]+</span></span><br><span class="line"><span class="comment">                    q3a_bg_stats->bg_gb_sum[i]+q3a_bg_stats->bg_b_sum[i];</span></span><br><span class="line"><span class="comment">                if(bg_count*10/bg_sum[i] > 12)</span></span><br><span class="line"><span class="comment">                    grid_region[i] = 2;</span></span><br><span class="line"><span class="comment">                else</span></span><br><span class="line"><span class="comment">                    grid_region[i] = 1;</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for(int i=0; i < NUM_AEC_STATS; i++){</span></span><br><span class="line"><span class="comment">            for(int j=0; j < NUM_AEC_STATS; j++){</span></span><br><span class="line"><span class="comment">                if(weight_grid_count[i][j] > 3){</span></span><br><span class="line"><span class="comment">                    chromatix->AEC.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span></span><br><span class="line"><span class="comment">                        keda_exposure_weight[i][j] * aec_ratio;</span></span><br><span class="line"><span class="comment">                    //LOGE("liqinxing:aec_metering[%d,%d] modify=%f",i,j,</span></span><br><span class="line"><span class="comment">                    //    chromatix->AEC.aec_metering_tables.AEC_weight_center_weighted[i][j]);</span></span><br><span class="line"><span class="comment">                    //LOGE("liqinxing:modify count=%d",weight_grid_count[i][j]);</span></span><br><span class="line"><span class="comment">                }</span></span><br><span class="line"><span class="comment">                else</span></span><br><span class="line"><span class="comment">                    chromatix->AEC.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span></span><br><span class="line"><span class="comment">                        keda_exposure_weight[i][j];</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//find bright region and dynamic spot</span></span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i < grid_count; i++){</span><br><span class="line">            <span class="keyword">if</span>(q3a_bg_stats->bg_r_sum[i] > threhold_h ||</span><br><span class="line">               q3a_bg_stats->bg_gr_sum[i] > threhold_h ||</span><br><span class="line">               q3a_bg_stats->bg_b_sum[i] > threhold_h){</span><br><span class="line">                    bg_count = q3a_bg_stats->bg_r_sum[i]+q3a_bg_stats->bg_gr_sum[i]+</span><br><span class="line">                    q3a_bg_stats->bg_gb_sum[i]+q3a_bg_stats->bg_b_sum[i];</span><br><span class="line">                    <span class="keyword">if</span>(bg_count*<span class="number">10</span>/bg_sum[i] > <span class="number">12</span>)</span><br><span class="line">                        grid_region[i] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        grid_region[i] = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            bg_sum[i] = q3a_bg_stats->bg_r_sum[i]+q3a_bg_stats->bg_gr_sum[i]+</span><br><span class="line">                    q3a_bg_stats->bg_gb_sum[i]+q3a_bg_stats->bg_b_sum[i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//find dynamic bright region</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i < grid_count; i++){</span><br><span class="line">            <span class="keyword">if</span>(grid_region[i] == <span class="number">2</span>){</span><br><span class="line">                search_dynamic_region(grid_region, i/q3a_bg_stats->bg_region_h_num,</span><br><span class="line">                    i%q3a_bg_stats->bg_region_h_num, q3a_bg_stats->bg_region_v_num,</span><br><span class="line">                    q3a_bg_stats->bg_region_h_num);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//convert to aec weight grid table</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i<grid_count; i++){</span><br><span class="line">            <span class="keyword">if</span>(grid_region[i] != <span class="number">0</span>){</span><br><span class="line">                grid_v_num = i/q3a_bg_stats->bg_region_h_num/v_step;<span class="comment">//calculate current position v</span></span><br><span class="line">                grid_h_num = i%q3a_bg_stats->bg_region_h_num/h_step;<span class="comment">//calculate current position h</span></span><br><span class="line">                <span class="keyword">if</span>(grid_region[i] == <span class="number">2</span>)</span><br><span class="line">                    weight_grid_count[grid_v_num][grid_h_num] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(weight_grid_count[grid_v_num][grid_h_num] != <span class="number">2</span>)</span><br><span class="line">                    weight_grid_count[grid_v_num][grid_h_num] = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//pthread_rwlock_wrlock(&chromatix->lock);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i < NUM_AEC_STATS; i++){</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>; j < NUM_AEC_STATS; j++){</span><br><span class="line">                <span class="keyword">if</span>(weight_grid_count[i][j] == <span class="number">2</span>){</span><br><span class="line">                    chromatix->AEC_algo_data.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span><br><span class="line">                        keda_exposure_weight[i][j] * aec_dynamic_ratio;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(weight_grid_count[i][j] == <span class="number">1</span>)</span><br><span class="line">                    chromatix->AEC_algo_data.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span><br><span class="line">                        keda_exposure_weight[i][j] * aec_static_ratio;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    chromatix->AEC_algo_data.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span><br><span class="line">                        keda_exposure_weight[i][j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//pthread_rwlock_unlock(&chromatix->lock);</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (aec->aec_algo_ops.set_parameters) {</span><br><span class="line">            aec->aec_algo_ops.set_parameters(aec->handle, &backlight_set_parameter);</span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">          }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ol>
<li><code>aec_biz.c</code>中的<code>aec_biz_initialize_custom_tuning_param</code>函数，可以在chromatix初始化之后对chromatix重新改写。但是只有当init时才可以启动</li>
<li>优化静态变量<code>backlight_set_parameter</code>：可以在<code>aec_biz_init</code>时创建，在<code>aec_biz_destroy</code>时进行销毁。</li>
<li><code>void*</code>指针变量在结构体中定义，难道不需要进行内容大小的定义么？就可以直接对结构体<code>memcpy</code>了？因为指针大小是确定的，因此memcpy是没有问题的，指针的类型只是定义了指向数据的类型，也就是决定了指针运算的逻辑。</li>
<li>注意换了个镜头，要把膜撕掉！否则因为膜是棕色的，会导致白平衡异常，拍出来的是绿色的。</li>
<li>aec_biz是最接近aec模块的控制，aec_port是处理模块间的交流，相当于直接和aec_biz进行通信。</li>
<li>python注意点：<code>for i in a</code>：对i的值进行改变，不会影响a的值</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ private外部访问问题</title>
    <url>/posts/1793d0bf/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>private可以防止其他模块进行访问，但如果利用指针，是否可以在其他模块获取到private的数据？<br>下面对此进行实验：</p>
</blockquote>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><iostream></span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A() {</span><br><span class="line">		a2 = <span class="number">3</span>;</span><br><span class="line">		a3 = <span class="number">4</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">int</span>* <span class="title">fun3</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="built_in">cout</span> << <span class="string">"a3="</span> <<a3 << <span class="built_in">endl</span>;   <span class="comment">//正确，类内访问</span></span><br><span class="line">		<span class="keyword">return</span> &a3;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">int</span>* <span class="title">fun2</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="built_in">cout</span> << <span class="string">"a2="</span> << a2 << <span class="built_in">endl</span>;   <span class="comment">//正确，类内访问</span></span><br><span class="line">		<span class="keyword">return</span> &a2;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> a2;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a3;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	A itema;</span><br><span class="line">	<span class="keyword">int</span>* mytest;</span><br><span class="line">	<span class="comment">//不能直接获取</span></span><br><span class="line">	<span class="comment">//cout << "直接获取private值a3=" << itema.a3 << endl;</span></span><br><span class="line">	mytest = itema.fun3();</span><br><span class="line">	<span class="built_in">cout</span> << <span class="string">"通过指针获取private值a3="</span><<*mytest << <span class="built_in">endl</span>;</span><br><span class="line">	*mytest = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cout</span> << <span class="string">"对private值进行修改："</span>;</span><br><span class="line">	itema.fun3();</span><br><span class="line"></span><br><span class="line">	mytest = itema.fun2();</span><br><span class="line">	<span class="built_in">cout</span> << <span class="string">"通过指针获取protected值a3="</span> << *mytest << <span class="built_in">endl</span>;</span><br><span class="line">	*mytest = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cout</span> << <span class="string">"对private值进行修改："</span>;</span><br><span class="line">	itema.fun2();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>private数据外部不能直接获取</li>
<li>private数据如果把地址传出来，可以在外部进行读取和修改</li>
<li>protected和private都可以利用指针在外部进行读取和修改</li>
</ul>
<p>因此private不是万能的，同样可以走<code>后门</code>，进行修改，用同样的方法，我们还可以引出形参指针的地址等；当我们写程序时，也要注意private也可能被外部模块修改。</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>问题：中文乱码</title>
    <url>/posts/16d19117/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="认识编码及Python乱码"><a href="#认识编码及Python乱码" class="headerlink" title="认识编码及Python乱码"></a>认识编码及Python乱码</h1><p><a href="https://blog.csdn.net/joyfixing/article/details/79971667" target="_blank" rel="noopener">彻底搞懂 python 中文乱码问题</a>这篇博客讲的很透彻，以及在Python中如何进行转码</p>
<p>需要注意的是：   </p>
<p>字符串通过编码转换为字节码，字节码通过解码转换为字符串</p>
<p>str—>(encode)—>bytes，bytes—>(decode)—>str</p>
<h1 id="cmd中文乱码"><a href="#cmd中文乱码" class="headerlink" title="cmd中文乱码"></a>cmd中文乱码</h1><ol>
<li><p>在cmd中输入<code>chcp</code>，查看当前编码：如果是936则为GBK编码</p>
</li>
<li><p>在cmd中输入<code>chcp 65001</code>，切换为UTF-8编码</p>
</li>
<li><p>在菜单栏右击，属性->选项中勾选 丢弃旧的副本，重新打开一下之后再把勾去掉就好了</p>
</li>
</ol>
<h1 id="git中文乱码"><a href="#git中文乱码" class="headerlink" title="git中文乱码"></a>git中文乱码</h1><p>$ git config –global core.quotepath false</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>工具</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>中文乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>高通代码学习与体会</title>
    <url>/posts/2d82b27c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>对高通代码结构以及编写技巧的学习和总结，不断更新…</p>
</blockquote>
<h2 id="数组和枚举定义的另类写法"><a href="#数组和枚举定义的另类写法" class="headerlink" title="数组和枚举定义的另类写法"></a>数组和枚举定义的另类写法</h2><p>用列表的形式去表示数组和枚举类型</p>
<p><strong>优点</strong>：  </p>
<p>方便后期添加新值，便于维护。增加一个值，不必去考虑数组或者枚举的大小，也不用去考虑位置和顺序。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//枚举类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AEC_CORE_GET_ENUM_LIST(ADD_ENTRY)                                    \</span></span><br><span class="line">  ADD_ENTRY(AEC_GET_EXPOSURE_PARAMS)            <span class="comment">/* Mask to get aec info.  */</span> \</span><br><span class="line">  ADD_ENTRY(AEC_GET_META_INFO)                  <span class="comment">/* Mask to get meta info. */</span> \</span><br><span class="line">  ADD_ENTRY(AEC_GET_REAL_GAIN_FROM_ISO)                                      \</span><br><span class="line">  ADD_ENTRY(AEC_GET_STATS_REQUIRED)    <span class="comment">/* Mask to get stats type required */</span> \</span><br><span class="line">  ADD_ENTRY(AEC_GET_UNIFIED_FLASH)                                           \</span><br><span class="line">  ADD_ENTRY(AEC_GET_RGN_SKIP_PATTERN)                                        \</span><br><span class="line">  ADD_ENTRY(AEC_GET_RELOAD_EXPOSURE_PARAMS)                                  \</span><br><span class="line">  ADD_ENTRY(AEC_GET_LED_CAL_CONFIG)                                          \</span><br><span class="line">  ADD_ENTRY(AEC_GET_MAX)  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AEC_CORE_GENERATE_ENUM(ENUM) ENUM,</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">{</span><br><span class="line">  AEC_CORE_GET_ENUM_LIST(AEC_CORE_GENERATE_ENUM)</span><br><span class="line">} aec_core_get_enum_type;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//字符串数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AEC_SET_PARAM_ENUM_LIST(ADD_ENTRY)                                    \</span></span><br><span class="line">  ADD_ENTRY(AEC_SET_PARAM_INVALID)                                            \</span><br><span class="line">  ADD_ENTRY(AEC_SET_PARAM_INIT_CHROMATIX_SENSOR)                              \</span><br><span class="line">  ADD_ENTRY(AEC_SET_PARAM_EXP_COMPENSATION)                                   \</span><br><span class="line">  ADD_ENTRY(AEC_SET_PARAM_BRIGHTNESS_LVL)                                     \</span><br><span class="line">  ADD_ENTRY(AEC_SET_PARAM_MAX)        </span><br><span class="line">  </span><br><span class="line"><span class="comment">//# 是把参数字符串化，## 是将两个参数连为一个整体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AEC_PARAM_GENERATE_STRING(STRING) #STRING,    </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *aec_biz_set_param_strings[AEC_SET_PARAM_MAX+<span class="number">1</span>] = {</span><br><span class="line">  AEC_SET_PARAM_ENUM_LIST(AEC_PARAM_GENERATE_STRING)</span><br><span class="line">};</span><br><span class="line"><span class="comment">//获取数组值(eventId的值)</span></span><br><span class="line"><span class="keyword">return</span> aec_biz_set_param_strings[eventId < AEC_SET_PARAM_MAX ?</span><br><span class="line"></span><br><span class="line">    eventId : AEC_SET_PARAM_MAX];</span><br></pre></td></tr></tbody></table></figure>

<h2 id="用union去定义接口结构体"><a href="#用union去定义接口结构体" class="headerlink" title="用union去定义接口结构体"></a>用union去定义接口结构体</h2><p><strong>优点</strong>：  </p>
<ul>
<li><p>用union只需要最大的值的空间，节省空间。</p>
</li>
<li><p>加上type，可以利用switch对不同类型的请求做处理，在union中取相应的数</p>
</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  aec_set_enum_type type; <span class="comment">/**<  */</span></span><br><span class="line">  <span class="keyword">union</span></span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">aec_set_parameter_init_t</span>      init_param;</span><br><span class="line">    <span class="keyword">aec_bracket_t</span>                 aec_bracket;</span><br><span class="line">    int32                         video_hdr;  <span class="comment">/**<  */</span></span><br><span class="line">    aec_core_hdr_type             snapshot_hdr;</span><br><span class="line">    <span class="keyword">aec_precapture_trigger_t</span>      aec_trigger;</span><br><span class="line">    <span class="keyword">boolean</span>                       est_for_af;</span><br><span class="line">    aec_algo_ramp_test_type       ramp_test;</span><br><span class="line">  } u;</span><br><span class="line">} aec_core_set_param_type;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="用函数指针实现多态"><a href="#用函数指针实现多态" class="headerlink" title="用函数指针实现多态"></a>用函数指针实现多态</h2><p><strong>优点</strong>：  </p>
<ul>
<li>扩展性：把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//c文件</span></span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">aec_biz_set_param</span><span class="params">(<span class="keyword">aec_set_parameter_t</span> *param,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">aec_output_data_t</span> *output, <span class="keyword">uint8_t</span> num_of_outputs, <span class="keyword">void</span> *aec_obj)</span></span>{ …… }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aec_biz_load_function</span><span class="params">(<span class="keyword">aec_object_t</span> *aec_object)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!aec_object) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  }</span><br><span class="line">  aec_object->set_parameters = aec_biz_set_param;</span><br><span class="line">  aec_object->get_parameters = aec_biz_get_param;</span><br><span class="line">  aec_object-><span class="built_in">process</span> = aec_biz_process;</span><br><span class="line">  aec_object->init = aec_biz_init;</span><br><span class="line">  aec_object->deinit = aec_biz_destroy;</span><br><span class="line">  aec_object->iso_to_real_gain = aec_biz_map_iso_to_real_gain;</span><br><span class="line">  aec_object->get_version = aec_biz_get_version;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">boolean</span> <span class="params">(* aec_set_parameters_func)</span><span class="params">(<span class="keyword">aec_set_parameter_t</span> *param,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">aec_output_data_t</span> *output, <span class="keyword">uint8_t</span> num_of_outputs, <span class="keyword">void</span> *aec_obj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">boolean</span> <span class="params">(* aec_get_parameters_func)</span><span class="params">(<span class="keyword">aec_get_parameter_t</span> *param,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">void</span> *aec_obj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">boolean</span> <span class="params">(* aec_process_func)</span><span class="params">(<span class="keyword">stats_t</span> *stats, <span class="keyword">void</span> *aec_obj,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">aec_output_data_t</span> *output, <span class="keyword">uint8_t</span> num_of_ouputs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(* aec_callback_func)</span><span class="params">(<span class="keyword">aec_output_data_t</span> *output, <span class="keyword">void</span> *port)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *(* aec_init_func)(<span class="keyword">void</span> *aec_lib);</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(* aec_deinit_func)</span><span class="params">(<span class="keyword">void</span> *aec)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">float</span> <span class="params">(* aec_iso_to_real_gain)</span><span class="params">(<span class="keyword">void</span> *aec_obj, <span class="keyword">uint32_t</span> iso,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">uint8_t</span> camera_id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">boolean</span> <span class="params">(* aec_get_version)</span><span class="params">(<span class="keyword">void</span> *aec_obj, Q3a_version_t *version,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">uint8_t</span> camera_id)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">aec_object</span> {</span></span><br><span class="line"> <span class="keyword">pthread_mutex_t</span> obj_lock;</span><br><span class="line"> <span class="keyword">void</span> *aec;</span><br><span class="line"> aec_set_parameters_func set_parameters;</span><br><span class="line"> aec_get_parameters_func get_parameters;</span><br><span class="line"> aec_process_func <span class="built_in">process</span>;</span><br><span class="line"> aec_init_func init;</span><br><span class="line"> aec_deinit_func deinit;</span><br><span class="line"> <span class="keyword">aec_output_data_t</span> output;</span><br><span class="line"> aec_iso_to_real_gain iso_to_real_gain;</span><br><span class="line"> <span class="keyword">q3a_custom_data_t</span> aec_custom_param;</span><br><span class="line"> aec_get_version get_version;</span><br><span class="line"> } <span class="keyword">aec_object_t</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>由于变量可能到处被定义和引用，当它被引用的次数很多时，就很难找到这个变量的含义。可以变量值前面需要加上@，这样搜索变量的含义很快。<br>在高通代码中搜索某个变量的意义的时候，也可以使用这个方法进行查找。<br>下面是注释范例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*===========================================================================</span></span><br><span class="line"><span class="comment"> * FUNCTION   : set_parameters</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DESCRIPTION: set camera parameters</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PARAMETERS :</span></span><br><span class="line"><span class="comment"> *   @device  : ptr to camera device struct</span></span><br><span class="line"><span class="comment"> *   @parms   : string of packed parameters</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURN     : int32_t type of status</span></span><br><span class="line"><span class="comment"> *              NO_ERROR  -- success</span></span><br><span class="line"><span class="comment"> *              none-zero failure code</span></span><br><span class="line"><span class="comment"> *==========================================================================*/</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="能力集的使用"><a href="#能力集的使用" class="headerlink" title="能力集的使用"></a>能力集的使用</h2><p>高通很多部分用到能力集，当时一直觉得这个一个多余的操作。后来有了各种各样的设备之后才知道了能力集的好处。</p>
<p>比如说不同的sensor，你会对每个sensor都写一套代码么？每次都在代码中加sensor型号的判断？不说代码复杂，但是肯定很乱。</p>
<p>如果每个sensor都有自己的能力集之后，代码中只需要根据能力集的配置进行判断，就屏蔽了对sensor型号的判断，即使是新增一个sensor型号，也只需要多配置一组能力集，十分方便。继续推广开来，视频流也有自己的能力集（如分辨率，格式等），每个设备也有自己的能力集（如不同的镜头，sensor型号，各种功能的配置），这样就更加容易实现各种各样设备的管理。</p>
<p>能力集中可能会用到多组配置，比如多种分辨率有不同的配置。这个时候可以在结构体里面定义数组，也可以定义指针。数组会提前分配内存，可能会分配大了，占用空间，指针的话分配的内存可控。</p>
<p>高通的能力集也经历了几个阶段：8056的老代码是把能力集写到代码里面，编译成动态库，进行调用的。后来变成了利用xml进行配置，在设备中读取进行配置。再接下来，是在本地将xml编译成bin文件，在设备中进行读取，减少xml解码的时间，提高效率。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">power_setting_t</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> seq_val;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">delay</span>;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">power_setting_array</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">power_setting_t</span> power_setting_a[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">power_setting_t</span> *power_setting_b;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">power_setting_t</span> test_b[] = {</span><br><span class="line">    {</span><br><span class="line">        .seq_val = <span class="number">1</span>,</span><br><span class="line">        .<span class="built_in">delay</span> = <span class="number">1</span>,</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">        .seq_val = <span class="number">2</span>,</span><br><span class="line">        .<span class="built_in">delay</span> = <span class="number">2</span>,</span><br><span class="line">    }};</span><br><span class="line"><span class="keyword">static</span> power_setting_array test = {</span><br><span class="line">    <span class="comment">//结构体有两种非顺序的赋值方法，冒号和等号都可以</span></span><br><span class="line">    .power_setting_a = {</span><br><span class="line">        {</span><br><span class="line">            seq_val : <span class="number">1</span>,</span><br><span class="line">            <span class="built_in">delay</span> : <span class="number">1</span>,</span><br><span class="line">        },</span><br><span class="line">        {</span><br><span class="line">            .seq_val = <span class="number">2</span>,</span><br><span class="line">            .<span class="built_in">delay</span> = <span class="number">2</span>,</span><br><span class="line">        }},</span><br><span class="line">    .power_setting_b = test_b,</span><br><span class="line">    .num = <span class="keyword">sizeof</span>(test_b) / <span class="keyword">sizeof</span>(test_b[<span class="number">0</span>]),</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="回调函数的注册和使用"><a href="#回调函数的注册和使用" class="headerlink" title="回调函数的注册和使用"></a>回调函数的注册和使用</h2></body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>高通</tag>
      </tags>
  </entry>
  <entry>
    <title>线程进程总结</title>
    <url>/posts/9fc0e279/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>线程和进程是什么？为什么需要使用多线程？有什么可能存在的问题？如何使用线程？</p>
<a id="more"></a>

<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>线程，有时被称为轻量进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304" target="_blank" rel="noopener">指针</a>(PC），<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8/187682" target="_blank" rel="noopener">寄存器</a>集合和<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88/1682032" target="_blank" rel="noopener">堆栈</a>组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程<strong>共享进程所拥有的全部资源</strong>。一个线程可以<strong>创建和撤消另一个线程</strong>，同一进程中的多个线程之间可以并发执行。</p>
<p>线程有<a href="https://baike.baidu.com/item/%E5%B0%B1%E7%BB%AA/10932509" target="_blank" rel="noopener">就绪</a>、<a href="https://baike.baidu.com/item/%E9%98%BB%E5%A1%9E/9032404" target="_blank" rel="noopener">阻塞</a>和<a href="https://baike.baidu.com/item/%E8%BF%90%E8%A1%8C/5480697" target="_blank" rel="noopener">运行</a>三种基本状态。就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；运行状态是指线程占有处理机正在运行；阻塞状态是指线程在等待一个事件（如某个信号量），逻辑上不可执行。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。</p>
<p>线程是程序中一个单一的顺序控制流程。进程内有一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指令<a href="https://baike.baidu.com/item/%E8%BF%90%E8%A1%8C" target="_blank" rel="noopener">运行</a>时的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为<a href="https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404" target="_blank" rel="noopener">多线程</a>。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><strong>1）轻型实体</strong></p>
<p>线程中的实体基本上不拥有<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90" target="_blank" rel="noopener">系统资源</a>，只是有一点必不可少的、能保证独立<a href="https://baike.baidu.com/item/%E8%BF%90%E8%A1%8C" target="_blank" rel="noopener">运行</a>的资源。</p>
<p>线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。TCB包括以下信息：</p>
<p>（1）线程状态。</p>
<p>（2）当线程不运行时，被保存的现场资源。</p>
<p>（3）一组执行堆栈。</p>
<p>（4）存放每个线程的局部变量主存区。</p>
<p>（5）访问同一个进程中的主存和其它资源。</p>
<p>用于指示被执行指令序列的<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8" target="_blank" rel="noopener">程序计数器</a>、保留<a href="https://baike.baidu.com/item/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">局部变量</a>、少数状态参数和<a href="https://baike.baidu.com/item/%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">返回地址</a>等的一组<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8" target="_blank" rel="noopener">寄存器</a>和<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88" target="_blank" rel="noopener">堆栈</a>。</p>
<p><strong>2）独立调度和分派的基本单位。</strong></p>
<p>在多线程OS中，线程是能独立<a href="https://baike.baidu.com/item/%E8%BF%90%E8%A1%8C" target="_blank" rel="noopener">运行</a>的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>中的）。</p>
<p><strong>3）可并发执行。</strong></p>
<p>在一个<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA" target="_blank" rel="noopener">处理机</a>与外围设备并行工作的能力。</p>
<p><strong>4）共享</strong><a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>资源。</p>
<p><a href="https://baike.baidu.com/pic/%E7%BA%BF%E7%A8%8B/103101/0/a583631edbe8bbb41ad57610?fr=lemma&ct=single" target="_blank" rel="noopener" title="线程"><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=ae1c7b5b9d16fdfadc6cc1ec848e8cea/c8177f3e6709c93d793c8e879f3df8dcd00054f7.jpg" alt="线程"></a>线程</p>
<p>在同一<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的<a href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4" target="_blank" rel="noopener">地址空间</a>（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">文件</a>、定时器、<a href="https://baike.baidu.com/item/%E4%BF%A1%E5%8F%B7%E9%87%8F" target="_blank" rel="noopener">信号量</a>机构等。由于同一个<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>内的线程<a href="https://baike.baidu.com/item/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98" target="_blank" rel="noopener">共享内存</a>和<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">文件</a>，所以线程之间互相通信不必调用<a href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8" target="_blank" rel="noopener">内核</a>。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。</p>
<p>广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192" target="_blank" rel="noopener">操作系统</a>动态执行的<a href="https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83" target="_blank" rel="noopener">基本单元</a>，在传统的<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">操作系统</a>中，进程既是基本的<a href="https://baike.baidu.com/item/%E5%88%86%E9%85%8D%E5%8D%95%E5%85%83" target="_blank" rel="noopener">分配单元</a>，也是基本的执行单元。</p>
<p>进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括<a href="https://baike.baidu.com/item/%E6%96%87%E6%9C%AC" target="_blank" rel="noopener">文本</a>区域（text region）、数据区域（data region）和<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88" target="_blank" rel="noopener">堆栈</a>（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86" target="_blank" rel="noopener">处理</a>器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>。</p>
<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p><strong>动态性</strong>：进程的实质是程序在<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">多道程序系统</a>中的一次执行过程，进程是动态产生，动态消亡的。</p>
<p><strong>并发性</strong>：任何进程都可以同其他进程一起并发执行</p>
<p><strong>独立性</strong>：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的<strong>独立</strong>单位；</p>
<p><strong>异步性</strong>：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进</p>
<p><strong>结构特征</strong>：进程由程序、数据和<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97" target="_blank" rel="noopener">进程控制块</a>三部分组成。</p>
<p>多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果；但是执行过程中，程序不能发生改变。</p>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1></body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 线程和进程</title>
    <url>/posts/ea480f1d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>转载自<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319272686365ec7ceaeca33428c914edf8f70cca383000" target="_blank" rel="noopener">廖雪峰教程</a></p>
</blockquote>
<h1 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h1><h2 id="Unix-Linux"><a href="#Unix-Linux" class="headerlink" title="Unix/Linux"></a>Unix/Linux</h2><p>Unix/Linux操作系统提供了一个<code>fork()</code>系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是<code>fork()</code>调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p>
<p>子进程永远返回<code>0</code>，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用<code>getppid()</code>就可以拿到父进程的ID。</p>
<p>Python的<code>os</code>模块封装了常见的系统调用，其中就包括<code>fork</code>，可以在Python程序中轻松创建子进程：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># multiprocessing.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Process (%s) start...'</span> % os.getpid()</span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="keyword">if</span> pid==<span class="number">0</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'I am child process (%s) and my parent is %s.'</span> % (os.getpid(), os.getppid())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'I (%s) just created a child process (%s).'</span> % (os.getpid(), pid)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>由于Windows没有<code>fork</code>调用，上面的代码在Windows上无法运行。<code>multiprocessing</code>模块就是跨平台版本的多进程模块。<code>multiprocessing</code>模块提供了一个<code>Process</code>类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程要执行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Run child process %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line">    p = Process(target=run_proc, args=(<span class="string">'test'</span>,))</span><br><span class="line">    print(<span class="string">'Child process will start.'</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">'Child process end.'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>执行结果如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">Parent process <span class="number">928.</span></span><br><span class="line">Process will start.</span><br><span class="line">Run child process test (<span class="number">929</span>)...</span><br><span class="line">Process end.</span><br></pre></td></tr></tbody></table></figure>

<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个<code>Process</code>实例，用<code>start()</code>方法启动，这样创建进程比<code>fork()</code>还要简单。</p>
<p><code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>
<h2 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Run task %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line">    p = Pool(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p.apply_async(long_time_task, args=(i,))</span><br><span class="line">    print(<span class="string">'Waiting for all subprocesses done...'</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">'All subprocesses done.'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>对<code>Pool</code>对象调用<code>join()</code>方法会等待所有子进程执行完毕，调用<code>join()</code>之前必须先调用<code>close()</code>，调用<code>close()</code>之后就不能继续添加新的<code>Process</code>了。</p>
<p>请注意输出的结果，task <code>0</code>，<code>1</code>，<code>2</code>，<code>3</code>是立刻执行的，而task <code>4</code>要等待前面某个task完成后才执行，这是因为<code>Pool</code>的默认大小在我的电脑上是4，因此，最多同时执行4个进程。这是<code>Pool</code>有意设计的限制，并不是操作系统的限制。如果改成：<code>p = Pool(5)</code>就可以同时跑五个进程 。</p>
<p>由于<code>Pool</code>的默认大小是CPU的核数，如果你不幸拥有8核CPU，你要提交至少9个子进程才能看到上面的等待效果。</p>
<h2 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h2><p>很多时候，子进程并不是自身，而是一个外部进程。我们创建了子进程后，还需要控制子进程的输入和输出。</p>
<p><code>subprocess</code>模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。</p>
<p>下面的例子演示了如何在Python代码中运行命令<code>nslookup www.python.org</code>，这和命令行直接运行的效果是一样的：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">print(<span class="string">'$ nslookup www.python.org'</span>)</span><br><span class="line">r = subprocess.call([<span class="string">'nslookup'</span>, <span class="string">'www.python.org'</span>])</span><br><span class="line">print(<span class="string">'Exit code:'</span>, r)</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ nslookup www.python.org</span><br><span class="line">Server:        <span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span></span><br><span class="line">Address:    <span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span><span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.python.org    canonical name = python.map.fastly.net.</span><br><span class="line">Name:    python.map.fastly.net</span><br><span class="line">Address: <span class="number">199.27</span><span class="number">.79</span><span class="number">.223</span></span><br><span class="line"></span><br><span class="line">Exit code: <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果子进程还需要输入，则可以通过<code>communicate()</code>方法输入：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">print(<span class="string">'$ nslookup'</span>)</span><br><span class="line">p = subprocess.Popen([<span class="string">'nslookup'</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">output, err = p.communicate(<span class="string">b'set q=mx\npython.org\nexit\n'</span>)</span><br><span class="line">print(output.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">print(<span class="string">'Exit code:'</span>, p.returncode)</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码相当于在命令行执行命令<code>nslookup</code>，然后手动输入：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">set q=mx</span><br><span class="line">python.org</span><br><span class="line">exit</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ nslookup</span><br><span class="line">Server:        <span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span></span><br><span class="line">Address:    <span class="number">192.168</span><span class="number">.19</span><span class="number">.4</span><span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">python.org    mail exchanger = <span class="number">50</span> mail.python.org.</span><br><span class="line"></span><br><span class="line">Authoritative answers can be found <span class="keyword">from</span>:</span><br><span class="line">mail.python.org    internet address = <span class="number">82.94</span><span class="number">.164</span><span class="number">.166</span></span><br><span class="line">mail.python.org    has AAAA address <span class="number">2001</span>:<span class="number">888</span>:<span class="number">2000</span>:d::a6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exit code: <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p><code>Process</code>之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的<code>multiprocessing</code>模块包装了底层的机制，提供了<code>Queue</code>、<code>Pipes</code>等多种方式来交换数据。</p>
<p>我们以<code>Queue</code>为例，在父进程中创建两个子进程，一个往<code>Queue</code>里写数据，一个从<code>Queue</code>里读数据：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写数据进程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">'Process to write: %s'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]:</span><br><span class="line">        print(<span class="string">'Put %s to queue...'</span> % value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读数据进程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">'Process to read: %s'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        value = q.get(<span class="literal">True</span>)</span><br><span class="line">        print(<span class="string">'Get %s from queue.'</span> % value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 父进程创建Queue，并传给各个子进程：</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line">    <span class="comment"># 启动子进程pw，写入:</span></span><br><span class="line">    pw.start()</span><br><span class="line">    <span class="comment"># 启动子进程pr，读取:</span></span><br><span class="line">    pr.start()</span><br><span class="line">    <span class="comment"># 等待pw结束:</span></span><br><span class="line">    pw.join()</span><br><span class="line">    <span class="comment"># pr进程里是死循环，无法等待其结束，只能强行终止:</span></span><br><span class="line">    pr.terminate()</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">Process to write: <span class="number">50563</span></span><br><span class="line">Put A to queue...</span><br><span class="line">Process to read: <span class="number">50564</span></span><br><span class="line">Get A <span class="keyword">from</span> queue.</span><br><span class="line">Put B to queue...</span><br><span class="line">Get B <span class="keyword">from</span> queue.</span><br><span class="line">Put C to queue...</span><br><span class="line">Get C <span class="keyword">from</span> queue.</span><br></pre></td></tr></tbody></table></figure>

<p>在Unix/Linux下，<code>multiprocessing</code>模块封装了<code>fork()</code>调用，使我们不需要关注<code>fork()</code>的细节。由于Windows没有<code>fork</code>调用，因此，<code>multiprocessing</code>需要“模拟”出<code>fork</code>的效果，父进程所有Python对象都必须通过pickle序列化再传到子进程去，所有，如果<code>multiprocessing</code>在Windows下调用失败了，要先考虑是不是pickle失败了。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>多任务可以由多进程完成，也可以由一个进程内的多线程完成。</p>
<p>我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。</p>
<p>由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。</p>
<p>Python的标准库提供了两个模块：<code>_thread</code>和<code>threading</code>，<code>_thread</code>是低级模块，<code>threading</code>是高级模块，对<code>_thread</code>进行了封装。绝大多数情况下，我们只需要使用<code>threading</code>这个高级模块。</p>
<p>启动一个线程就是把一个函数传入并创建<code>Thread</code>实例，然后调用<code>start()</code>开始执行：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新线程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n < <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        print(<span class="string">'thread %s >>> %s'</span> % (threading.current_thread().name, n))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(target=loop, name=<span class="string">'LoopThread'</span>)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</span><br></pre></td></tr></tbody></table></figure>

<p>执行结果如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">thread MainThread <span class="keyword">is</span> running...</span><br><span class="line">thread LoopThread <span class="keyword">is</span> running...</span><br><span class="line">thread LoopThread >>> <span class="number">1</span></span><br><span class="line">thread LoopThread >>> <span class="number">2</span></span><br><span class="line">thread LoopThread >>> <span class="number">3</span></span><br><span class="line">thread LoopThread >>> <span class="number">4</span></span><br><span class="line">thread LoopThread >>> <span class="number">5</span></span><br><span class="line">thread LoopThread ended.</span><br><span class="line">thread MainThread ended.</span><br></pre></td></tr></tbody></table></figure>

<p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的<code>threading</code>模块有个<code>current_thread()</code>函数，它永远返回当前线程的实例。主线程实例的名字叫<code>MainThread</code>，子线程的名字在创建时指定，我们用<code>LoopThread</code>命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为<code>Thread-1</code>，<code>Thread-2</code>……</p>
<h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><p>创建一个锁是通过<code>threading.Lock()</code>来实现：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">balance = 0</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">def run_thread(n):</span><br><span class="line">    for i in range(100000):</span><br><span class="line">        # 先要获取锁:</span><br><span class="line">        lock.acquire()</span><br><span class="line">        try:</span><br><span class="line">            # 放心地改吧:</span><br><span class="line">            change_it(n)</span><br><span class="line">        finally:</span><br><span class="line">            # 改完了一定要释放锁:</span><br><span class="line">            lock.release()</span><br></pre></td></tr></tbody></table></figure>

<p>当多个线程同时执行<code>lock.acquire()</code>时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p>
<p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用<code>try...finally</code>来确保锁一定会被释放。</p>
<p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</p>
<h2 id="多核CPU"><a href="#多核CPU" class="headerlink" title="多核CPU"></a>多核CPU</h2><p>如果你不幸拥有一个多核CPU，你肯定在想，多核应该可以同时执行多个线程。</p>
<p>如果写一个死循环的话，会出现什么情况呢？</p>
<p>打开Mac OS X的Activity Monitor，或者Windows的Task Manager，都可以监控某个进程的CPU使用率。</p>
<p>我们可以监控到一个死循环线程会100%占用一个CPU。</p>
<p>如果有两个死循环线程，在多核CPU中，可以监控到会占用200%的CPU，也就是占用两个CPU核心。</p>
<p>要想把N核CPU的核心全部跑满，就必须启动N个死循环线程。</p>
<p>试试用Python写个死循环：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import threading, multiprocessing</span><br><span class="line"></span><br><span class="line">def loop():</span><br><span class="line">    x = 0</span><br><span class="line">    while True:</span><br><span class="line">        x = x ^ 1</span><br><span class="line"></span><br><span class="line">for i in range(multiprocessing.cpu_count()):</span><br><span class="line">    t = threading.Thread(target=loop)</span><br><span class="line">    t.start()</span><br></pre></td></tr></tbody></table></figure>

<p>启动与CPU核心数量相同的N个线程，在4核CPU上可以监控到CPU占用率仅有102%，也就是仅使用了一核。</p>
<p>但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？</p>
<p>因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>
<p>GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。</p>
<p>所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。</p>
<p>不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建全局ThreadLocal对象:</span></span><br><span class="line">local_school = threading.local()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_student</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 获取当前线程关联的student:</span></span><br><span class="line">    std = local_school.student</span><br><span class="line">    print(<span class="string">'Hello, %s (in %s)'</span> % (std, threading.current_thread().name))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_thread</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="comment"># 绑定ThreadLocal的student:</span></span><br><span class="line">    local_school.student = name</span><br><span class="line">    process_student()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target= process_thread, args=(<span class="string">'Alice'</span>,), name=<span class="string">'Thread-A'</span>)</span><br><span class="line">t2 = threading.Thread(target= process_thread, args=(<span class="string">'Bob'</span>,), name=<span class="string">'Thread-B'</span>)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br></pre></td></tr></tbody></table></figure>

<p>执行结果：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">Hello, Alice (<span class="keyword">in</span> Thread-A)</span><br><span class="line">Hello, Bob (<span class="keyword">in</span> Thread-B)</span><br></pre></td></tr></tbody></table></figure>

<p>全局变量<code>local_school</code>就是一个<code>ThreadLocal</code>对象，每个<code>Thread</code>对它都可以读写<code>student</code>属性，但互不影响。你可以把<code>local_school</code>看成全局变量，但每个属性如<code>local_school.student</code>都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，<code>ThreadLocal</code>内部会处理。</p>
<p>可以理解为全局变量<code>local_school</code>是一个<code>dict</code>，不但可以用<code>local_school.student</code>，还可以绑定其他变量，如<code>local_school.teacher</code>等等。</p>
<p><code>ThreadLocal</code>最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p>
<h1 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h1><p>首先，要实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。</p>
<p>如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。</p>
<p>如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。</p>
<p>多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。</p>
<p>多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用<code>fork</code>调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。</p>
<p>多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。</p>
<p>在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。</p>
<h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><p>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？</p>
<p>我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。</p>
<p>如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型，或者批处理任务模型。</p>
<p>假设你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以幼儿园小朋友的眼光来看，你就正在同时写5科作业。</p>
<p>但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。</p>
<p>所以，多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果效率急剧下降，所有任务都做不好。</p>
<h2 id="计算密集型-vs-IO密集型"><a href="#计算密集型-vs-IO密集型" class="headerlink" title="计算密集型 vs. IO密集型"></a>计算密集型 vs. IO密集型</h2><p>是否采用多任务的第二个考虑是任务的类型。我们可以把任务分为计算密集型和IO密集型。</p>
<p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p>
<p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p>
<p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p>
<p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p>
<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。</p>
<p>现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。</p>
<p>对应到Python语言，单线程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。我们会在后面讨论如何编写协程。</p>
<h1 id="分布式进程"><a href="#分布式进程" class="headerlink" title="分布式进程"></a>分布式进程</h1><p>在Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。</p>
<p>Python的<code>multiprocessing</code>模块不但支持多进程，其中<code>managers</code>子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于<code>managers</code>模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。</p>
<p>举个例子：如果我们已经有一个通过<code>Queue</code>通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？</p>
<p>原有的<code>Queue</code>可以继续使用，但是，通过<code>managers</code>模块把<code>Queue</code>通过网络暴露出去，就可以让其他机器的进程访问<code>Queue</code>了。</p>
<p>我们先看服务进程，服务进程负责启动<code>Queue</code>，把<code>Queue</code>注册到网络上，然后往<code>Queue</code>里面写入任务：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># task_master.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random, time, queue</span><br><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送任务的队列:</span></span><br><span class="line">task_queue = queue.Queue()</span><br><span class="line"><span class="comment"># 接收结果的队列:</span></span><br><span class="line">result_queue = queue.Queue()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从BaseManager继承的QueueManager:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueManager</span><span class="params">(BaseManager)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把两个Queue都注册到网络上, callable参数关联了Queue对象:</span></span><br><span class="line">QueueManager.register(<span class="string">'get_task_queue'</span>, callable=<span class="keyword">lambda</span>: task_queue)</span><br><span class="line">QueueManager.register(<span class="string">'get_result_queue'</span>, callable=<span class="keyword">lambda</span>: result_queue)</span><br><span class="line"><span class="comment"># 绑定端口5000, 设置验证码'abc':</span></span><br><span class="line">manager = QueueManager(address=(<span class="string">''</span>, <span class="number">5000</span>), authkey=<span class="string">b'abc'</span>)</span><br><span class="line"><span class="comment"># 启动Queue:</span></span><br><span class="line">manager.start()</span><br><span class="line"><span class="comment"># 获得通过网络访问的Queue对象:</span></span><br><span class="line">task = manager.get_task_queue()</span><br><span class="line">result = manager.get_result_queue()</span><br><span class="line"><span class="comment"># 放几个任务进去:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    n = random.randint(<span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line">    print(<span class="string">'Put task %d...'</span> % n)</span><br><span class="line">    task.put(n)</span><br><span class="line"><span class="comment"># 从result队列读取结果:</span></span><br><span class="line">print(<span class="string">'Try get results...'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    r = result.get(timeout=<span class="number">10</span>)</span><br><span class="line">    print(<span class="string">'Result: %s'</span> % r)</span><br><span class="line"><span class="comment"># 关闭:</span></span><br><span class="line">manager.shutdown()</span><br><span class="line">print(<span class="string">'master exit.'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>请注意，当我们在一台机器上写多进程程序时，创建的<code>Queue</code>可以直接拿来用，但是，在分布式多进程环境下，添加任务到<code>Queue</code>不可以直接对原始的<code>task_queue</code>进行操作，那样就绕过了<code>QueueManager</code>的封装，必须通过<code>manager.get_task_queue()</code>获得的<code>Queue</code>接口添加。</p>
<p>然后，在另一台机器上启动任务进程（本机上启动也可以）：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># task_worker.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time, sys, queue</span><br><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建类似的QueueManager:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueManager</span><span class="params">(BaseManager)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:</span></span><br><span class="line">QueueManager.register(<span class="string">'get_task_queue'</span>)</span><br><span class="line">QueueManager.register(<span class="string">'get_result_queue'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到服务器，也就是运行task_master.py的机器:</span></span><br><span class="line">server_addr = <span class="string">'127.0.0.1'</span></span><br><span class="line">print(<span class="string">'Connect to server %s...'</span> % server_addr)</span><br><span class="line"><span class="comment"># 端口和验证码注意保持与task_master.py设置的完全一致:</span></span><br><span class="line">m = QueueManager(address=(server_addr, <span class="number">5000</span>), authkey=<span class="string">b'abc'</span>)</span><br><span class="line"><span class="comment"># 从网络连接:</span></span><br><span class="line">m.connect()</span><br><span class="line"><span class="comment"># 获取Queue的对象:</span></span><br><span class="line">task = m.get_task_queue()</span><br><span class="line">result = m.get_result_queue()</span><br><span class="line"><span class="comment"># 从task队列取任务,并把结果写入result队列:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = task.get(timeout=<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'run task %d * %d...'</span> % (n, n))</span><br><span class="line">        r = <span class="string">'%d * %d = %d'</span> % (n, n, n*n)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        result.put(r)</span><br><span class="line">    <span class="keyword">except</span> Queue.Empty:</span><br><span class="line">        print(<span class="string">'task queue is empty.'</span>)</span><br><span class="line"><span class="comment"># 处理结束:</span></span><br><span class="line">print(<span class="string">'worker exit.'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>任务进程要通过网络连接到服务进程，所以要指定服务进程的IP。</p>
<p>现在，可以试试分布式进程的工作效果了。先启动<code>task_master.py</code>服务进程：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ python3 task_master.py </span><br><span class="line">Put task <span class="number">3411.</span>..</span><br><span class="line">Put task <span class="number">1605.</span>..</span><br><span class="line">Put task <span class="number">1398.</span>..</span><br><span class="line">Put task <span class="number">4729.</span>..</span><br><span class="line">Put task <span class="number">5300.</span>..</span><br><span class="line">Put task <span class="number">7471.</span>..</span><br><span class="line">Put task <span class="number">68.</span>..</span><br><span class="line">Put task <span class="number">4219.</span>..</span><br><span class="line">Put task <span class="number">339.</span>..</span><br><span class="line">Put task <span class="number">7866.</span>..</span><br><span class="line">Try get results...</span><br></pre></td></tr></tbody></table></figure>

<p><code>task_master.py</code>进程发送完任务后，开始等待<code>result</code>队列的结果。现在启动<code>task_worker.py</code>进程：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ python3 task_worker.py</span><br><span class="line">Connect to server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>...</span><br><span class="line">run task <span class="number">3411</span> * <span class="number">3411.</span>..</span><br><span class="line">run task <span class="number">1605</span> * <span class="number">1605.</span>..</span><br><span class="line">run task <span class="number">1398</span> * <span class="number">1398.</span>..</span><br><span class="line">run task <span class="number">4729</span> * <span class="number">4729.</span>..</span><br><span class="line">run task <span class="number">5300</span> * <span class="number">5300.</span>..</span><br><span class="line">run task <span class="number">7471</span> * <span class="number">7471.</span>..</span><br><span class="line">run task <span class="number">68</span> * <span class="number">68.</span>..</span><br><span class="line">run task <span class="number">4219</span> * <span class="number">4219.</span>..</span><br><span class="line">run task <span class="number">339</span> * <span class="number">339.</span>..</span><br><span class="line">run task <span class="number">7866</span> * <span class="number">7866.</span>..</span><br><span class="line">worker exit.</span><br></pre></td></tr></tbody></table></figure>

<p><code>task_worker.py</code>进程结束，在<code>task_master.py</code>进程中会继续打印出结果：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">Result: <span class="number">3411</span> * <span class="number">3411</span> = <span class="number">11634921</span></span><br><span class="line">Result: <span class="number">1605</span> * <span class="number">1605</span> = <span class="number">2576025</span></span><br><span class="line">Result: <span class="number">1398</span> * <span class="number">1398</span> = <span class="number">1954404</span></span><br><span class="line">Result: <span class="number">4729</span> * <span class="number">4729</span> = <span class="number">22363441</span></span><br><span class="line">Result: <span class="number">5300</span> * <span class="number">5300</span> = <span class="number">28090000</span></span><br><span class="line">Result: <span class="number">7471</span> * <span class="number">7471</span> = <span class="number">55815841</span></span><br><span class="line">Result: <span class="number">68</span> * <span class="number">68</span> = <span class="number">4624</span></span><br><span class="line">Result: <span class="number">4219</span> * <span class="number">4219</span> = <span class="number">17799961</span></span><br><span class="line">Result: <span class="number">339</span> * <span class="number">339</span> = <span class="number">114921</span></span><br><span class="line">Result: <span class="number">7866</span> * <span class="number">7866</span> = <span class="number">61873956</span></span><br></pre></td></tr></tbody></table></figure>

<p>这个简单的Master/Worker模型有什么用？其实这就是一个简单但真正的分布式计算，把代码稍加改造，启动多个worker，就可以把任务分布到几台甚至几十台机器上，比如把计算<code>n*n</code>的代码换成发送邮件，就实现了邮件队列的异步发送。</p>
<p>Queue对象存储在哪？注意到<code>task_worker.py</code>中根本没有创建Queue的代码，所以，Queue对象存储在<code>task_master.py</code>进程中：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">                                             │</span><br><span class="line">┌─────────────────────────────────────────┐     ┌──────────────────────────────────────┐</span><br><span class="line">│task_master.py                           │  │  │task_worker.py                        │</span><br><span class="line">│                                         │     │                                      │</span><br><span class="line">│  task = manager.get_task_queue()        │  │  │  task = manager.get_task_queue()     │</span><br><span class="line">│  result = manager.get_result_queue()    │     │  result = manager.get_result_queue() │</span><br><span class="line">│              │                          │  │  │              │                       │</span><br><span class="line">│              │                          │     │              │                       │</span><br><span class="line">│              ▼                          │  │  │              │                       │</span><br><span class="line">│  ┌─────────────────────────────────┐    │     │              │                       │</span><br><span class="line">│  │QueueManager                     │    │  │  │              │                       │</span><br><span class="line">│  │ ┌────────────┐ ┌──────────────┐ │    │     │              │                       │</span><br><span class="line">│  │ │ task_queue │ │ result_queue │ │<───┼──┼──┼──────────────┘                       │</span><br><span class="line">│  │ └────────────┘ └──────────────┘ │    │     │                                      │</span><br><span class="line">│  └─────────────────────────────────┘    │  │  │                                      │</span><br><span class="line">└─────────────────────────────────────────┘     └──────────────────────────────────────┘</span><br><span class="line">                                             │</span><br><span class="line"></span><br><span class="line">                                          Network</span><br></pre></td></tr></tbody></table></figure>

<p>而<code>Queue</code>之所以能通过网络访问，就是通过<code>QueueManager</code>实现的。由于<code>QueueManager</code>管理的不止一个<code>Queue</code>，所以，要给每个<code>Queue</code>的网络调用接口起个名字，比如<code>get_task_queue</code>。</p>
<p><code>authkey</code>有什么用？这是为了保证两台机器正常通信，不被其他机器恶意干扰。如果<code>task_worker.py</code>的<code>authkey</code>和<code>task_master.py</code>的<code>authkey</code>不一致，肯定连接不上。</p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>线程</tag>
        <tag>进程</tag>
        <tag>分布式进程</tag>
      </tags>
  </entry>
  <entry>
    <title>void*指针疑问和总结</title>
    <url>/posts/d9680356/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>对void用法和注意事项进行总结，以及提出几个问题：</p>
<ul>
<li><p>void*进行赋值后，可以直接使用memcpy么</p>
</li>
<li><p>void*并不知道空间大小，放在结构体中如何确定结构体的空间</p>
</li>
</ul>
<a id="more"></a>

<h1 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h1><p>void即“无类型”，void *则为“无类型指针”，能够指向不论什么数据类型。  </p>
<h1 id="void指针总结"><a href="#void指针总结" class="headerlink" title="void指针总结"></a>void指针总结</h1><blockquote>
<p>指针有两个属性:指向变量/对象的地址和长度 </p>
<p>但是指针只存储地址,长度则取决于指针的类型</p>
</blockquote>
<p>首先我们要了解指针是什么，指针只存储地址的值，长度取决于指针的类型，也就是说指针的运算才和类型有关，因此可以进行memcpy只是需要定义一下指针的类型。也就解决了<strong>第二个问题</strong>，void*存储的是变量/对象地址，地址是一个4位或者8位的变量，根据系统位数而定，因此结构体的空间也就是固定的。</p>
<blockquote>
<p>任何指针都可以赋值给void指针 </p>
</blockquote>
<p>void指针能够指向随意类型的数据，亦就可以用随意数据类型的指针对void指针赋值。其中可以不进行转换，只需要获取变量、对象的地址而不获取大小。<strong>第一个问题</strong>也就解决了，void*指针是可以直接<code>memcpy</code>的，但是如果要进行指针运算，就需要转换，具体原因看下面。</p>
<blockquote>
<p>void指针赋值给其他类型的指针时都要进行转换</p>
<p>void指针不能参与指针运算,除非进行转换 </p>
</blockquote>
<p>但是值得注意的是，void指针赋值给其他类型的指针都要进行转换，因为指针不仅要知道指向变量/对象的地址，还需要知道指向对象的长度。也因此参与指针运算，同样需要类型转换。</p>
<p>在ANSIC标准中，不同意对void指针进行算术运算如pvoid++或pvoid+=1等，而在GNU中则同意，由于在缺省情况下，GNU觉得void <em>与char *一样。sizeof(</em>pvoid )== sizeof( char)。不同的标准对指针运算的标准不一样，但是严格起见，我们都应该对指针类型进行赋值才能开始运算。</p>
<blockquote>
<p>在函数的返回值中, void 是没有任何返回值, 而 void * 是返回任意类型的值的指针.</p>
</blockquote>
<p>注意函数的返回值是void*的时候是返回任意类型的值。</p>
<h1 id="void-指针的作用"><a href="#void-指针的作用" class="headerlink" title="void*指针的作用"></a>void*指针的作用</h1><p>由于void指针能够指向随意类型的数据，亦就可以用随意数据类型的指针对void指针赋值，因此还能够用void指针来作为函数形參，这样函数就能够接受随意数据类型的指针作为參数。比如： </p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memcpy</span><span class="params">( <span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> len )</span></span>; </span><br><span class="line">void * memset( void * buffer, int c, size_t num)；</span><br></pre></td></tr></tbody></table></figure>

<p>相比于void发挥的作用在于：</p>
<ul>
<li>对函数返回的限定；</li>
<li>对函数參数的限定。</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>背光算法代码实现</title>
    <url>/posts/1b12e938/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>如何实现强光下自由降低曝光阶？修改stats数据是否有效？如何动态修改曝光权重？</p>
<a id="more"></a>

<h1 id="修改stats数据"><a href="#修改stats数据" class="headerlink" title="修改stats数据"></a>修改stats数据</h1><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>为了注重强光，需要降低亮度，如果增加亮区的亮度，原来可能已经饱和了，现在如果继续增加，就没有效果了。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>如果调整stats数据中RGB的最大值，防止超出最大值，是否有用。</p>
<p>实验发现调整rbg_max大小是没有用的，ISP输出数据深度，超过这个深度之后无效，因此增大亮区的统计亮度基本没有效果；如果改成增大暗区的统计亮度来降低曝光，就失去了背光补偿的意义</p>
<h1 id="修改曝光权重"><a href="#修改曝光权重" class="headerlink" title="修改曝光权重"></a>修改曝光权重</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>曝光权重是从chromatix直接导入的，流经stats模块，进入了aec_port，我们可以在stats模块中截取进行修改；也可以再aec模块传入的地方进行修改。</p>
<h2 id="STATS模块尝试"><a href="#STATS模块尝试" class="headerlink" title="STATS模块尝试"></a>STATS模块尝试</h2><p>如果在stats模块传递到的位置进行修改，因为先要由统计数据去调整曝光权重，而程序是先执行调整曝光权重再去判断统计数据的话，理论上曝光调整会延迟一帧进行。因此最好在stats模块中能获取到stats和曝光权重的时候一并修改。但是可能存在一个问题，在stats模块修改了chromatix中的数据，aec模块可能不会重新加载。</p>
<p>在<code>stats_port_event</code>函数中的<code>IPC_KEDA_AE_CONTROL</code>下方对private中的chromatix参数进行修改</p>
<p>首先确认这是否是每帧都会运行的地方，加打印，看打印时间相隔多少，如果是33ms就是每帧都会打印；却发现没有打印，因此需要重新找到将stats数据和测光权重传递给aec的事件</p>
<p>从名称中定位到可能的事件，并查看处理方法：<code>MCT_EVENT_CONTROL_SET_PARM</code> （不是每帧都执行）<code>MCT_EVENT_MODULE_ISP_STATS_INFO</code>(用来debug的，排除) <code>MCT_EVENT_CONTROL_PARM_STREAM_BUF</code> (stats模块控制，排除)<code>MCT_EVENT_CONTROL_SOF</code>(控制帧开头，用来插入JPEG信息，排除) <code>MCT_EVENT_MODULE_STATS_DATA</code>（平均20ms执行一次是不是有点过快了）</p>
<h2 id="AEC模块尝试"><a href="#AEC模块尝试" class="headerlink" title="AEC模块尝试"></a>AEC模块尝试</h2><p>由于stats模块在aec模块的上游，因此我们在aec模块中进行修改，可以更简单快捷的控制AEC模块的输入。</p>
<h3 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h3><ol>
<li><p>我们要找到chromatix导入的位置：<code>aec_biz_map_init_chromatix_sensor</code>函数</p>
</li>
<li><p>可以看到chromatix数据是从<code>chromatix_3a_parms_wrapper</code>导入到<code>aec_set_parameter_init_t</code>结构体中，<code>chromatix_3a_parms_wrapper</code>在stats模块中也可以进行修改，但是为了防止修改了chromatix参数，如果仅在初始化时进行修改，那么不会生效</p>
</li>
<li><p>接下来找到<code>aec_biz_map_init_chromatix_sensor</code>函数调用位置：<code>aec_biz_set_param</code>，仅有在<code>param->type == AEC_SET_PARAM_INIT_CHROMATIX_SENSOR</code>时，才会进行调用。因此我们之前可能不生效的猜测是正确的，只有在初始化的时候才会加载。</p>
</li>
<li><p>两个解决方案：一是我们在最后必须经过的地方，对chromatix中的值进行修改；二是增加一个自定义的<code>param->type</code>类型。 相比较来说，肯定是第二种方法比较好，在一帧里不会重复的对chromatix中的值进行修改。</p>
</li>
<li><p>还有一个问题值得注意：<code>aec_biz_set_param</code>函数也不是每帧都会执行的，只有当设置参数的时候才会执行。经过打印实验，相比于set_params，函数<code>aec_biz_process</code>是会每帧执行的。我们的背光补偿算法以及对测光权重的处理需要放在一个一直执行的地方。</p>
</li>
<li><p>很遗憾的是<code>aec_biz_map_init_chromatix_sensor</code>是对数据<code>set_param</code>进行操作的，而<code>set_param</code>只能由函数<code>set_parameters</code>进行设置，不能在函数<code>aec_biz_process</code>中进行处理。</p>
</li>
<li><p>下面有三种解决方案：</p>
<ul>
<li><p>一种是在process中调用<code>set_parameters</code>函数(但是不知道形参)</p>
</li>
<li><p>一种是在set_parameters中增加自定义的处理</p>
</li>
<li><p>最后一种是定义一个全局变量<code>backlight_set_parameter</code>指向aec_set_parameter_t的地址，当运行<code>aec_biz_set_param</code>时更新全局变量，然后在process中处理。</p>
</li>
<li><p>但是这个时候第二种方法就不如第三种方法来的简单，第二种方法会导致开启背光补偿后每帧都需要执行<code>aec_biz_set_param</code>函数，第三种方法更加简单，但是相当于给set_param和process之间开了一个后门，可能会有安全隐患？</p>
</li>
</ul>
</li>
<li><p>为了可以修改送入AEC算法的stats数据，以及需要在aec算法之前操作，我们将背光补偿算法放在函数<code>aec_biz_process</code>中，位于函数<code>aec_biz_stats_map</code>和<code>aec_algo_ops.process</code>之前。</p>
</li>
<li><p>但是发现函数process不能使用<code>aec_set_parameter_t</code>这个数据，一个方法是定义一个全局变量<code>backlight_set_parameter</code>指向aec_set_parameter_t的地址，当运行<code>aec_biz_set_param</code>时更新全局变量，然后在process中处理。这样相当于开了一个后门</p>
</li>
<li><p>由于aec_core_set_param_type是<code>union</code>类型，因此需要在一个合适的时候讲</p>
</li>
<li><p>定义一个static的变量，将设置的值保存起来</p>
</li>
</ol>
<p>发现问题：</p>
<ol>
<li><p>死机，摄像头加载不了  </p>
<p>解决方法：将指针改成了结构体变量，防止由于set_param变量的变化而变化</p>
</li>
<li><p>打印修改的测光权重，发现不对应  </p>
<p>解决方法：调整stats分块数据和测光权重表的对应关系</p>
</li>
<li><p>想要更新AEC的参数，只能通过set_param函数进行修改，传入的值是一个union类型加一个type，也就是说每次传入的参数是跟type有关系的。而aec模块的输入是封闭的，需要你有对应的set_param类型，通过命名很明显的发现没有</p>
<p>解决方法只能是init_chromatix的方法对测光权重进行修改</p>
</li>
<li><p>难道说这里的aec_algo_ops一直指的是aec_biz，而不是aec的算法，也就是说它会经常调用自身，那我之前的推导岂不是全部乱掉了</p>
<p>解决方法：重新对结构体进行了分析 ，param->type 的枚举值里有PARAM，而set_param里面没有，按照set_param的函数的执行顺序，是将类型<code>aec_set_parameter_t</code>转换成了<code>aec_core_set_param_type</code>的类型，发现之前的推论没有问题。</p>
</li>
<li><ul>
<li><p>写入chromatix文件无效，尝试读取权重表，自己计算current luma，将两者的current luma进行对比，确实将曝光权重进行了修改，但是参数不生效。</p>
</li>
<li><p>无论写入什么值或者不写入值，图像曝光都不够，cur_luma一直很低：是否是chromatix参数传递有问题？将chromatix打印出来没有问题啊。是否可能是因为调用memcpy函数之前没有对目标指针进行初始化？</p>
</li>
<li><p>时间一长设备会挂掉，是否因为哪个地方内存泄露？或者越界访问了？</p>
</li>
<li><p>解决方法：将设置参数类型改为<code>AEC_SET_COPY_CHROMATIX_SENSOR</code>,，参数生效，但是好像过一段时间会再次不生效</p>
<p>AE容易闪烁</p>
</li>
</ul>
</li>
</ol>
<p>解决方法：因为增大了亮区的权重，会对亮的地方很敏感，我测试的场景下有个会动的显示屏，所以出现闪烁的情况也是正常现象。</p>
<ol start="11">
<li>如果用ADRC的方法实现，由于set_param只有enable这个选项，也需要进行chromatix参数的改写。也可以利用这个方法对chromatix参数进行改写。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>在aec_biz.c中进行修改</p>
<ol>
<li>首先定义局部静态变量，储存chromatix数据以及初始化时的测光权重数据。</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> aec_core_set_param_type backlight_set_parameter;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">float</span> keda_exposure_weight[NUM_AEC_STATS][NUM_AEC_STATS]={<span class="number">0</span>};</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>在初始化时读取chromatix数据，并存储测光权重表</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//放在代码pthread_rwlock_rdlock(&chromatix->lock)之后</span></span><br><span class="line"><span class="comment">//在对读写锁进行读操作之后</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> IPC_BACKLIGHT_CONTROL</span></span><br><span class="line"> backlight_set_parameter.type = AEC_SET_COPY_CHROMATIX_SENSOR;</span><br><span class="line">  STATS_MEMCPY(&backlight_set_parameter.u.init_param, <span class="keyword">sizeof</span>(<span class="keyword">aec_set_parameter_init_t</span>),</span><br><span class="line">    &param->u.init_param, <span class="keyword">sizeof</span>(<span class="keyword">aec_set_parameter_init_t</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i < NUM_AEC_STATS; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j < NUM_AEC_STATS; j++)</span><br><span class="line">        keda_exposure_weight[i][j] =</span><br><span class="line">        chromatix->AEC.aec_metering_tables.AEC_weight_center_weighted[i][j];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>在aec_biz_process函数之前定义处理自定义处理函数</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">keda_backlight_algo</span><span class="params">(<span class="keyword">aec_biz_t</span> *aec, <span class="keyword">const</span> <span class="keyword">stats_t</span>* stats)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (!aec || !stats) {</span><br><span class="line">      AEC_ERR(<span class="string">"Invalid input: %p,%p"</span>,aec, stats);</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="keyword">float</span> aec_ratio = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    chromatix_3a_parms_wrapper *chromatix;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">q3a_bg_stats_t</span>* q3a_bg_stats = stats->bayer_stats.p_q3a_bg_stats;</span><br><span class="line">    <span class="keyword">uint32_t</span> threhold_h = q3a_bg_stats->rMax * q3a_bg_stats->region_pixel_cnt * <span class="number">0.6</span> /<span class="number">4</span>;</span><br><span class="line">    chromatix = (chromatix_3a_parms_wrapper*)</span><br><span class="line">        backlight_set_parameter.u.init_param.chromatix;</span><br><span class="line">    <span class="keyword">if</span> (!chromatix) {</span><br><span class="line">        AEC_ERR(<span class="string">"Invalid chromatix: %p"</span>, chromatix)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> v_step = q3a_bg_stats->bg_region_v_num/NUM_AEC_STATS;</span><br><span class="line">    <span class="keyword">int</span> h_step = q3a_bg_stats->bg_region_h_num/NUM_AEC_STATS;</span><br><span class="line">    <span class="keyword">int</span> grid_v_num, grid_h_num;</span><br><span class="line">    <span class="keyword">int</span> weight_grid_count[NUM_AEC_STATS][NUM_AEC_STATS] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">if</span> (property_get(<span class="string">"persist.liqinxing.backlight"</span>, value, <span class="string">""</span>) > <span class="number">0</span>){</span><br><span class="line">        aec_ratio = atoi(value)/<span class="number">1000.0</span>;</span><br><span class="line">        <span class="comment">//reduce traverse times and prevent data overflow</span></span><br><span class="line">        <span class="keyword">int</span> grid_count = q3a_bg_stats->bg_region_h_num * q3a_bg_stats->bg_region_v_num;</span><br><span class="line">        <span class="comment">//find the position of bright region</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < grid_count; i++){</span><br><span class="line">            <span class="keyword">if</span>(q3a_bg_stats->bg_r_sum[i] > threhold_h ||</span><br><span class="line">               q3a_bg_stats->bg_gr_sum[i] > threhold_h ||</span><br><span class="line">               q3a_bg_stats->bg_b_sum[i] > threhold_h){</span><br><span class="line">                grid_v_num = i/q3a_bg_stats->bg_region_h_num/v_step;<span class="comment">//calculate current position v</span></span><br><span class="line">                grid_h_num = i%q3a_bg_stats->bg_region_h_num/h_step;<span class="comment">//calculate current position h</span></span><br><span class="line">                weight_grid_count[grid_v_num][grid_h_num]++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//adjust metering ratio in the bright region</span></span><br><span class="line">        pthread_rwlock_wrlock(&chromatix->lock);</span><br><span class="line">        backlight_set_parameter.type = AEC_SET_COPY_CHROMATIX_SENSOR;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i < NUM_AEC_STATS; i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j < NUM_AEC_STATS; j++){</span><br><span class="line">                <span class="keyword">if</span>(weight_grid_count[i][j] > <span class="number">3</span>){</span><br><span class="line">                    chromatix->AEC.aec_metering_tables.AEC_weight_center_weighted[i][j] =</span><br><span class="line">                        keda_exposure_weight[i][j] * aec_ratio;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        pthread_rwlock_unlock(&chromatix->lock);</span><br><span class="line">        <span class="keyword">if</span> (aec->aec_algo_ops.set_parameters) {</span><br><span class="line"></span><br><span class="line">            aec->aec_algo_ops.set_parameters(aec->handle, &backlight_set_parameter);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">return</span> TRUE;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li>在aec_biz_process函数中的<code>ret = aec_biz_stats_map(aec, stats);</code>上方调用我们的函数：<code>keda_backlight_algo(aec,stats);</code></li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>代码实现</tag>
      </tags>
  </entry>
  <entry>
    <title>车辆人员监控调试注意点</title>
    <url>/posts/1c2adf17/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><blockquote>
<p>讨论车辆人员卡口的注意点，对以后可能遇到的问题进行指导</p>
</blockquote>
<a id="more"></a>



<h1 id="产品类型"><a href="#产品类型" class="headerlink" title="产品类型"></a>产品类型</h1><ul>
<li><p>4N   ==人脸</p>
</li>
<li><p>7N   ==车辆+人（小比例，能检测到人就行；同<code>结构化</code>）</p>
</li>
<li><p>8N   ==车辆</p>
</li>
<li><p>PID是产品号；HID是硬件型号，HID可能一样</p>
</li>
</ul>
<h1 id="车辆卡口"><a href="#车辆卡口" class="headerlink" title="车辆卡口"></a>车辆卡口</h1><h2 id="架设要求"><a href="#架设要求" class="headerlink" title="架设要求"></a>架设要求</h2><ol>
<li><p>根据摄像头的像素去决定拍几车道  </p>
<p>车牌要150个像素点以上，一般200万的就拍双车道</p>
</li>
<li><p>视角大小  </p>
</li>
</ol>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol>
<li><p>颜色容易偏色</p>
</li>
<li><p>补光容易过曝  </p>
<p> 尽量用外置不用内置，打到地面上通过漫发射照亮车牌</p>
</li>
<li><p>对比度第一点</p>
</li>
<li><p>镜头不好，可能会产生光斑</p>
</li>
</ol>
<h2 id="电警卡口"><a href="#电警卡口" class="headerlink" title="电警卡口"></a>电警卡口</h2><p>由于爆闪灯，需要比较精确控制AEC和AWB的时序，爆闪灯来会有一个中断</p>
<p>快门一般设置为1/400</p>
<p>白平衡容易出错 </p>
<p><strong>解决方法</strong>：预先设置好，并将白平衡的优先级调高</p>
<p>FPGA直接控制sensor</p>
<h1 id="人员卡口"><a href="#人员卡口" class="headerlink" title="人员卡口"></a>人员卡口</h1><ul>
<li><p>让人脸大的时候再抓拍 ==视场角</p>
</li>
<li><p>逆光场景 ==由于PK时只看人脸效果，也只会存人脸效果，无论视频效果怎么样，能看清人脸就行</p>
</li>
<li><p>景深  ==AF  </p>
</li>
</ul>
<ol>
<li><p>纵深场景时，AF容易聚到后面，而在前面的话人脸效果更好，可以限制焦点的距离</p>
</li>
<li><p>环境比较光滑时，如瓷砖地板，容易聚在纹理清楚的地方，聚不到人脸上</p>
</li>
<li><p>日夜切换容易跑焦</p>
</li>
</ol>
<ul>
<li>一定要看所有的时间段，最好隔15分钟拍一张照片，查看一下每个时候的照片效果</li>
</ul>
<p>逆光 –>红斑</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像效果调试</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>海思camera</tag>
      </tags>
  </entry>
  <entry>
    <title>chromatix 重载代码实现</title>
    <url>/posts/730cc3a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>在高通自带的reload函数中，每次reload的时候都要先查找hash值以及lru，也就是内存中是否存在，如果存在就不会重新重新读取动态库数据。因此本文的方法是在读取hash值的位置加一个函数，不进行hash值和lru count的读取，删除之前的hash和lru，重新进行读取。</p>
<a id="more"></a>

<h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><ol>
<li>在<code>port_sensor.c</code>文件中的<code>port_sensor_handle_upstream_module_event</code>函数判断传入参数非空之后增加对自定义perisist的处理:当persist从0变为1，重载chromatix头文件</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> chromatix_reload = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (property_get(<span class="string">"persist.chromatix.reload"</span>, value, <span class="string">""</span>) > <span class="number">0</span>){</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"0"</span>, value) == <span class="number">0</span>)</span><br><span class="line">          chromatix_reload = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span>{</span><br><span class="line">          <span class="keyword">if</span>(chromatix_reload){</span><br><span class="line">              chromatix_reload = <span class="number">0</span>; </span><br><span class="line">              <span class="keyword">if</span>(keda_reload_chromatix_ptr(<span class="keyword">module</span>,event,</span><br><span class="line"> bundle_info->s_bundle) == TRUE)</span><br><span class="line">               SERR(<span class="string">"chromatix reload sucess"</span>);</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               SERR(<span class="string">"chromatix reload failed"</span>);                                                                                              </span><br><span class="line">           }</span><br><span class="line">      }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>在<code>port_sensor_handle_upstream_module_event</code>函数上方加入<code>keda_reload_chromatix_ptr</code>的定义，在8056平台中要删除<code>CAMERA_CHROMATIX_MODULE_ALL</code>参数    </li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">keda_reload_chromatix_ptr</span><span class="params">(<span class="keyword">mct_module_t</span> *<span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">mct_event_t</span> *event, <span class="keyword">module_sensor_bundle_info_t</span>* s_bundle)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">      <span class="keyword">sensor_chromatix_params_t</span> chromatix_params;</span><br><span class="line">      <span class="keyword">int32_t</span>                   rc = SENSOR_FAILURE;</span><br><span class="line">      <span class="built_in">memset</span>(&chromatix_params, <span class="number">0</span>, <span class="keyword">sizeof</span>(chromatix_params));</span><br><span class="line">      RETURN_ON_NULL(s_bundle);</span><br><span class="line">      RETURN_ON_NULL(event);</span><br><span class="line">      RETURN_ON_NULL(<span class="keyword">module</span>);</span><br><span class="line"></span><br><span class="line">      SHIGH(<span class="string">"load chromatix for sensor %s"</span>,</span><br><span class="line">       s_bundle->sensor_lib_params->sensor_lib_ptr->sensor_slave_info.sensor_name);</span><br><span class="line"></span><br><span class="line">      SENSOR_SUB_MODULE_PROCESS_EVENT(s_bundle, SUB_MODULE_SENSOR,</span><br><span class="line">            SENSOR_GET_CUR_CHROMATIX_NAME, &chromatix_params, rc);</span><br><span class="line">      RETURN_FALSE_IF(rc < <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      SENSOR_SUB_MODULE_PROCESS_EVENT(s_bundle, SUB_MODULE_CHROMATIX,</span><br><span class="line">            CHROMATIX_KEDA_RELOAD, &chromatix_params, rc);</span><br><span class="line">      RETURN_FALSE_IF(rc < <span class="number">0</span>);</span><br><span class="line">      RETURN_ON_FALSE(sensor_util_validate_chromatix_params(&chromatix_params));</span><br><span class="line"></span><br><span class="line">      RETURN_ON_FALSE(sensor_util_post_chromatix_event_downstream(</span><br><span class="line">          <span class="keyword">module</span>, s_bundle, event->identity, &chromatix_params,</span><br><span class="line">          CAMERA_CHROMATIX_MODULE_ALL));</span><br><span class="line">      <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>在<code>sensor_common.h</code>中增加<code>CHROMATIX_KEDA_RELOAD</code>的枚举定义</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">CHROMATIX_ENUM_MIN, <span class="comment">/* start of chromatix enums */</span></span><br><span class="line"><span class="comment">/* Get enums */</span></span><br><span class="line">CHROMATIX_GET_PTR, <span class="comment">/* sensor_chromatix_params_t * */</span></span><br><span class="line">CHROMATIX_GET_CACHED_PTR,</span><br><span class="line"><span class="comment">/* Set enums */</span></span><br><span class="line">CHROMATIX_SET_CM,</span><br><span class="line">CHROMATIX_RESET_NAME,</span><br><span class="line">CHROMATIX_KEDA_RELOAD,</span><br><span class="line">CHROMATIX_ENUM_MAX, <span class="comment">/* End of Chromatix enums*/</span></span><br><span class="line"><span class="comment">/* End of Actuator enums*/</span></span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li>在<code>chromatix_sub_module.c</code>中的<code>chromatix_process</code>函数添加对<code>CHROMATIX_KEDA_RELOAD</code>的处理</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (event) {</span><br><span class="line"><span class="keyword">case</span> CHROMATIX_SET_CM:</span><br><span class="line">  ctrl->cm = (chromatix_manager_type *)data;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CHROMATIX_GET_PTR:</span><br><span class="line">  chromatix_get_ptr(ctrl, data);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CHROMATIX_GET_CACHED_PTR:</span><br><span class="line">  chromatix_get_cached_ptr(ctrl, data);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CHROMATIX_RESET_NAME:</span><br><span class="line">  chromatix_reset_name(ctrl);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CHROMATIX_KEDA_RELOAD:</span><br><span class="line">  chromatix_reload_get_ptr(ctrl, data);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  SERR(<span class="string">"invalid event %d"</span>, event);</span><br><span class="line">  rc = SENSOR_FAILURE;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="5">
<li>模仿<code>chromatix_get_ptr</code>函数，在<code>chromatix_process</code>函数上方加入<code>chromatix_reload_get_ptr</code>的定义</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int32_t</span> <span class="title">chromatix_reload_get_ptr</span><span class="params">(<span class="keyword">chromatix_data_t</span> *ctrl, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">int32_t</span> i;</span><br><span class="line">    <span class="keyword">sensor_chromatix_params_t</span> *params;</span><br><span class="line">    SLOW(<span class="string">"Enter"</span>);</span><br><span class="line"></span><br><span class="line">    RETURN_ERROR_ON_NULL(ctrl);</span><br><span class="line">    RETURN_ERROR_ON_NULL(data);</span><br><span class="line"></span><br><span class="line">    params = (<span class="keyword">sensor_chromatix_params_t</span> *)data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i < SENSOR_CHROMATIX_MAX; i++) {</span><br><span class="line">      SLOW(<span class="string">"type[%d]:[%s]"</span>, i, params->chromatix_lib_name[i]);</span><br><span class="line">      <span class="keyword">if</span> (params->chromatix_lib_name[i] == ctrl->chromatix_name[i])</span><br><span class="line">        params->chromatix_reloaded[i] = FALSE;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        params->chromatix_reloaded[i] = TRUE;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (i == SENSOR_CHROMATIX_EXTERNAL) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!params->chromatix_lib_name[i]) {</span><br><span class="line">        params->chromatix_ptr[i] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      ctrl->chromatix_ptr[i] =</span><br><span class="line">        reload_getChromatix(ctrl->cm, params->chromatix_lib_name[i],</span><br><span class="line">        pick_calibration_type[i]);</span><br><span class="line">      <span class="keyword">if</span> (!ctrl->chromatix_ptr[i]) {</span><br><span class="line">        SERR(<span class="string">"Can't get chromatix pointer : %s"</span>, </span><br><span class="line">        params->chromatix_lib_name[i]);</span><br><span class="line">        <span class="keyword">return</span> SENSOR_FAILURE;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      params->chromatix_ptr[i] = ctrl->chromatix_ptr[i];</span><br><span class="line"></span><br><span class="line">      SLOW(<span class="string">"chromatix version: 0x%x"</span>,</span><br><span class="line">        ((chromatix_parms_type*)ctrl->chromatix_ptr[i])</span><br><span class="line">        ->chromatix_version_info.chromatix_version);</span><br><span class="line">      ctrl->chromatix_name[i] = params->chromatix_lib_name[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    SLOW(<span class="string">"Exit"</span>);</span><br><span class="line">    <span class="keyword">return</span> SENSOR_SUCCESS;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<ol start="6">
<li>在<code>chromatix_manager.c</code>中模仿<code>cm_getChromatix</code>函数重新定义一个<code>reload_getChromatix</code>,并进行修改，删除对哈希值和页面置换算法时间的判断</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//660平台</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">reload_getChromatix</span><span class="params">(chromatix_manager_type* cm, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">uint32_t</span> calibration_type)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">void</span>    *data_sym = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">void</span>    *data_hdl = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">char</span>    *key      = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> cIndex;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!cm || !name) {</span><br><span class="line">    SERR(<span class="string">"NULL pointer detected"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  SLOW(<span class="string">"%s"</span>, name);</span><br><span class="line">  PTHREAD_MUTEX_LOCK(&cm->mutex);</span><br><span class="line">  SERR(<span class="string">"delete least used file from cache, and add"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* get the least used chromatix file info */</span></span><br><span class="line">  lru_getLeastRecent(&cm->lru, &key, &cIndex);</span><br><span class="line">  <span class="comment">/* delete has node and unload the library */</span></span><br><span class="line">  hash_delete(&cm->hash, key, &data_hdl, &data_sym);</span><br><span class="line">  unload_chromatix(data_hdl, data_sym);</span><br><span class="line"></span><br><span class="line">  data_sym = addLib_getSymbol(cm, name, calibration_type);</span><br><span class="line">  <span class="keyword">if</span> (data_sym == <span class="literal">NULL</span>)</span><br><span class="line">    SERR(<span class="string">"failed : addLib2"</span>);</span><br><span class="line"></span><br><span class="line">  lru_traverse(&cm->lru);</span><br><span class="line">  PTHREAD_MUTEX_UNLOCK(&cm->mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> data_sym;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//8056平台</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">reload_getChromatix</span><span class="params">(chromatix_manager_type* cm, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">uint32_t</span> calibration_type)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> <span class="keyword">void</span> *data_sym = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">void</span> *data_hdl = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">char</span> *key = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">uint32_t</span> cIndex;</span><br><span class="line"> <span class="keyword">if</span> (!cm || !name) {</span><br><span class="line"> SERR(<span class="string">"NULL pointer detected"</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"> }</span><br><span class="line"> SLOW(<span class="string">"%s"</span>, name);</span><br><span class="line"> PTHREAD_MUTEX_LOCK(&cm->mutex);</span><br><span class="line"> SERR(<span class="string">"delete least used file from cache, and add"</span>);</span><br><span class="line"> <span class="comment">/* get the least used chromatix file info */</span></span><br><span class="line"></span><br><span class="line"> lru_getLeastRecent(&cm->lru, &key, &cIndex);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* delete has node and unload the library */</span></span><br><span class="line"></span><br><span class="line"> hash_delete(&cm->hash, key, &data_hdl);</span><br><span class="line"></span><br><span class="line"> chromatix_unload_library(data_hdl);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> data_sym = addLib_getSymbol(cm, name, calibration_type);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (data_sym == <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">     SERR(<span class="string">"failed : addLib2"</span>);</span><br><span class="line"> lru_traverse(&cm->lru);</span><br><span class="line"> PTHREAD_MUTEX_UNLOCK(&cm->mutex);</span><br><span class="line"> <span class="keyword">return</span> data_sym;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//在chromatix_manager.h中添加reload_getChromatix的定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">reload_getChromatix</span><span class="params">(chromatix_manager_type* cm, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> calibration_type)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<h1 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h1><ol>
<li><p>在线或者本地编译好chromatix头文件后，将编译生成的动态库push进设备相应的地址</p>
</li>
<li><p>手动输入或者运行脚本</p>
</li>
</ol>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">adb shell setprop persist.chromatix.reload 0</span><br><span class="line">adb shell setprop persist.chromatix.reload 1</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>可以查看关键词<code>chromatix reload</code>，如果显示成功，则重载成功</li>
</ol>
<p>BUG：</p>
<ol>
<li>发现部分动态库加载不正确</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>功能实现</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：室内灯光闪烁</title>
    <url>/posts/2bb8db15/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>较亮的室内灯光会闪烁</p>
<a id="more"></a>
<p><strong>问题描述</strong>：在较亮的室内，对着灯会闪烁，查看曝光时间会小于10ms</p>
<p><strong>原因</strong>：抗闪烁会让曝光时间锁定在10ms整数倍，但是如果增益为1，曝光时间是10ms的时候依旧大于目标亮度，会当做室外场景，继续降低曝光时间。</p>
<p><strong>解决方法</strong>：  </p>
<ol>
<li>增加目标亮度，就可以增大曝光行。直接调节亮度，可以增大所有的目标亮度，但是会影响夜晚时候的效果。因此在头文件中增加亮区的目标亮度，使其他场景下影响最小。  </li>
<li>减小光圈，可以增大曝光行，使之大于10ms。</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>BUG</tag>
        <tag>闪烁</tag>
      </tags>
  </entry>
  <entry>
    <title>原有背光补偿算法实现</title>
    <url>/posts/138be4c3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><ol>
<li><p>获取分块亮度统计数据  </p>
<p>– 用的memcp，是否可以直接用指针获取，用const保护；</p>
</li>
<li><p>计算分块亮度  </p>
<p>–用RGGB的平均亮度代替一个块的亮度</p>
</li>
<li><p>进行排序  </p>
<p>–是否会出现totalblockNum比总数大的问题</p>
</li>
<li><p>求平均亮度</p>
</li>
<li><p>设置亮度阈值  </p>
<p>–根据level获取相应百分比的块的亮度和序号</p>
</li>
<li><p>如果检测到当前亮度大于亮度阈值，CurFrameAvgLuma加上该分块的亮度</p>
</li>
<li><p>求亮区的平均亮度</p>
</li>
<li><p>将分块亮度统计数据乘以（亮区亮度和平均亮度的比值）</p>
</li>
</ol>
<h1 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h1><p>原有的背光补偿等级仅仅调节的是亮区的范围，而亮区的程度并不能调节。<br>而且如果没有强光，也会对普通场景的亮度降低。为了不影响普通场景的亮度，可以采用对强光进行识别的算法。</p>
<p>首先用执法仪对强光和普通场景的直方图进行分析，场景1-3是普通场景，场景4-6是强光场景。发现强光场景的共同点是256的值很大，而255或者254却很小。同时要对RGB都进行分析，有的时候可能有一种光很亮，会误判成强光场景。<br><strong>注意</strong>：可能不能直接用比例的方式去减小曝光时间，可能会出现不收敛的情况，导致上下波动。<br><img src="/posts/138be4c3/1.jpg" alt="强光和普通场景直方图"></p>
<p>由于AE统计信息是将图像分块统计，也相当于一个缩小的直方图数据。<br>如果分块数据的话，强光场景下应该是强光区域有不少，同时暗光很多，由于成对数关系，因此区分应该很明显。<br>亮度在最大值亮度的50%-90%区间内，比例很少。<br>同时可以判断亮区的边界，如果边界大于一定的范围，则进行调整。</p>
<p>获取分块数据</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> aec_get_status = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> histo_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (property_get(<span class="string">"persist.liqinxing.aec_stats.get"</span>, value, <span class="string">""</span>) > <span class="number">0</span>){</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"0"</span>, value) == <span class="number">0</span>){</span><br><span class="line">        aec_get_status = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">if</span>(aec_get_status){</span><br><span class="line">            aec_get_status = <span class="number">0</span>;</span><br><span class="line">        FILE *fp;</span><br><span class="line">        fp = fopen(<span class="string">"/data/aec_stats.txt"</span>,<span class="string">"a"</span>);</span><br><span class="line">        <span class="keyword">if</span>(fp == <span class="literal">NULL</span>){</span><br><span class="line">            LOGE(<span class="string">"cannot open file aec_stats.txt,please create it"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"No.%d sence h_num:%d v_num:%d"</span>,</span><br><span class="line">        histo_count++, aec_stats->bayer_stats.p_q3a_bg_stats->bg_region_h_num,</span><br><span class="line">        aec_stats->bayer_stats.p_q3a_bg_stats->bg_region_v_num);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp,<span class="string">"channel-r:\n"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">3888</span>; i++)</span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">"%d  "</span>, aec_stats->bayer_stats.p_q3a_bg_stats->bg_r_sum[i]);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp,<span class="string">"\n"</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp,<span class="string">"channel-gr:\n"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">3888</span>; i++)</span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">"%d  "</span>, aec_stats->bayer_stats.p_q3a_bg_stats->bg_gr_sum[i]);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp,<span class="string">"\n"</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp,<span class="string">"channel-gb:\n"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">3888</span>; i++)</span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">"%d  "</span>, aec_stats->bayer_stats.p_q3a_bg_stats->bg_gb_sum[i]);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp,<span class="string">"\n"</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp,<span class="string">"channel-b:\n"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">3888</span>; i++)</span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">"%d  "</span>, aec_stats->bayer_stats.p_q3a_bg_stats->bg_b_sum[i]);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp,<span class="string">"\n"</span>);</span><br><span class="line">        <span class="comment">//free point p</span></span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">if</span>(fp!=<span class="literal">NULL</span>)</span><br><span class="line">            fp=<span class="literal">NULL</span>;</span><br><span class="line">       }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是出现问题，没有将数据打印出来<br>发现没有进入这个mask中，函数没有执行<br>因此放在aec_biz_stats_map中，这里是将stats数据map进aec算法模块的地方。<br>先用matlab进行处理；本文用的python处理<br><img src="/posts/138be4c3/2.jpg" alt></p>
<h2 id="强光场景识别"><a href="#强光场景识别" class="headerlink" title="强光场景识别"></a>强光场景识别</h2><ol>
<li>计算相比于最强光强的比例  </li>
</ol>
<p>分为三个区间，暗区，中间区间，亮区，阈值为30%和80%</p>
<p><img src="/posts/138be4c3/3.jpg" alt></p>
<p>可以看到强光场景下暗区比例很大，中间区间较小，亮区类似</p>
<p>中位数</p>
<ol start="2">
<li><p>打印stats其他参数，了解参数的意义</p>
<ol>
<li><p>rmax,grmax,gbmax,bmax是一样的16383，是一个像素上最大亮度（14位）</p>
</li>
<li><p>region_pixel_cnt=bg_region_height*bg_region_width 660=22*30 </p>
<p>1920/64=30 1080/48=22 因此总共的最大亮度为1e7 单体最大亮度为2703195，这符合实验得出的结论</p>
</li>
<li><p><img src="https://i.loli.net/2019/01/24/5c493fc5e0c0b.jpg" alt></p>
</li>
<li><p>直方图数据长度不一致，原来是4096，后来变成了256</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (CAM_HISTOGRAM_STATS_SIZE == bhist_stats->num_bins) {</span><br><span class="line">  <span class="built_in">memcpy</span>(hist_data->hist_buf, stats_ptr,</span><br><span class="line">  <span class="keyword">sizeof</span>(hist->bayer_stats.r_stats.hist_buf));</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (bhist_stats->num_bins > CAM_HISTOGRAM_STATS_SIZE &&</span><br><span class="line">          bhist_stats->num_bins % CAM_HISTOGRAM_STATS_SIZE == <span class="number">0</span>) {</span><br><span class="line">  <span class="comment">/* Stats from HW have more bins and is a multiple of output bin size */</span></span><br><span class="line">  <span class="comment">/* scale bins by collapsing */</span></span><br><span class="line">  <span class="keyword">uint32_t</span> factor = bhist_stats->num_bins / CAM_HISTOGRAM_STATS_SIZE;</span><br><span class="line">  <span class="keyword">uint32_t</span> i, j;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i < CAM_HISTOGRAM_STATS_SIZE; i++) {</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j < factor; j++) {</span><br><span class="line">     hist_data->hist_buf[i] +=</span><br><span class="line">       stats_ptr[i * factor + j];</span><br><span class="line">     }</span><br><span class="line">  }</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  ISP_ERR(<span class="string">"CHANNEL_Y Size mismatch error bhist_stats->num_bins %d"</span>,</span><br><span class="line">  bhist_stats->num_bins);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
</li>
</ol>
<p>num_bins是实际直方图数据的长度，由于这个长度是256的倍数，aec模块中的统计数据其实是将num_bins的直方图数据进行了压缩</p>
<p>这里用goto语句防止打开文件错误，没有执行下面原有的程序</p>
<p>通过控制增益的方式来控制图像的过曝和正常情况，对两种情况进行对比。</p>
<p>从过曝到正常，中位数降低很明显</p>
<p>可以看梯度–直方图或者分块亮度数据的梯度</p>
<p><strong>注意</strong>：写入txt数据的时候不要连续写入两个<code>\n</code>，如果这样readlines的时候第一个字符会为空</p>
<p>可以以梯度来衡量</p>
<p>我只要找到强光的特点就行了，  </p>
<p>首先有值很大的，直方图中255的值很大，而254的值很小  </p>
<p>直方图后面160-254之间几乎是平的  </p>
<p>检测到如果大于一定的值如80%的最大值，则进行权重的增大或者，或者直接对AE进行调整  </p>
<p>原来的方法不行，因为亮的区域亮度已经满了，再增大也改变不了多少AE的效果，可以修改测光表的权重  </p>
<p>框架式构图 –人手搭框架、框架拍景物</p>
<p>搜查AEC chromatix数据的调用位置</p>
<p>prase</p>
<p>自动调节可以算最高点80%和40%面积的比值作为他们的梯度</p>
<p>如果是sink端口，则不需要查看事件，取而代之的，只需转发事件并让下游模块处理它们并采取相应的行动</p>
<p>MCT_EVENT_DOWNSTREAM是接受上游的数据，向下游传递</p>
<p>chromatix数据是在stats模块进行最先一步的加载，分发给下游进行处理</p>
<p><strong>PROBLEM</strong>：究竟什么算是下游模块？</p>
<p>动态修改权重：两种方案，去修改chromatix文件，让它重新加载一次；在chromatix数据向下发的时候修改它的值；由于第一种方法存在一个数据大量赋值的过程，可能会降低速度，甚至导致一大堆赋值问题，因此采用第二种方案。</p>
<p><strong>想法</strong>：修改reload应该就可以让chromatix文件重载，这样不就不需要重启设备调参数了么</p>
<p><code>sensor_util_post_chromatix_event_downstream</code></p>
<p>cached</p>
<p><code>macro</code>:宏指令</p>
<p><strong>PROBLEM</strong>：只搜索到了<code>event_module->module_event_data</code>给其他模块赋值，没有搜索到谁赋值给它的？void*难道就是这么神奇？难道是在framework层进行赋值的？</p>
<p>func_tbl有三个方法：open/process/close 可以对chromatix进行操作</p>
<p>process中可以选择</p>
<p><code>SENSOR_SUB_MODULE_PROCESS_EVENT</code>对sensor的每个子模块进行处理，chromatix也是在其中 如果要搜索子模块的处理函数可以搜索process的类型，如<code>CHROMATIX_GET_PTR</code></p>
<p>第二个参数是对那个模块生效</p>
<p><strong>PROBLEM</strong>：为什么加载chromatix的时候还要加载一堆模块</p>
<p>lru页面置换算法（Least Recently Used）</p>
<p>关于操作系统的内存管理，如何节省利用容量不大的内存为最多的进程提供资源，一直是研究的重要方向。而内存的虚拟存储管理，是现在最通用，最成功的方式—— 在内存有限的情况下，扩展一部分外存作为<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/101812" target="_blank" rel="noopener">虚拟内存</a>，真正的内存只存储当前运行时所用得到信息。这无疑极大地扩充了内存的功能，极大地提高了计算机的并发度。虚拟页式存储管理，则是将进程所需空间划分为多个页面，内存中只存放当前所需页面，其余页面放入外存的管理方式。  </p>
<p>然而，有利就有弊，虚拟页式存储管理增加了进程所需的内存空间，却也带来了运行时间变长这一缺点：进程运行过程中，不可避免地要把在外存中存放的一些信息和内存中已有的进行交换，由于外存的低速，这一步骤所花费的时间不可忽略。因而，采取尽量好的算法以减少读取外存的次数，也是相当有意义的事情。</p>
<p><strong>我的理解</strong>：这个算法就是去决定哪些数据该放在内存里，哪些数据该放在外存里。</p>
<p><strong>PROBLEM</strong>：为什么替换了动态库文件，chromatix数据依旧没有生效</p>
<p><strong>ANSWER</strong>:  so文件是位于外存之中，而程序运行会先检测所需的数据内存中是否存在，如果存在就加载内存中的数据，如果不存在再去加载位于外存的数据。虚拟内存可以虚拟的扩大程序的内存空间，但是会出现一个问题，</p>
<p><strong>BIZ</strong>:business model ，实际上就是控制层（业务逻辑层）。<br><strong>解释</strong>：控制层的主要作用就是协调model层和view层直接的调用和转换。能够有效的避免请求直接进行数据库内容调用，而忽略了逻辑处理的部分。<br>实际上biz就起到了一个server服务的角色，很好的沟通了上层和下层直接的转换，避免在model层进行业务处理（代码太混乱，不利于维护）</p>
<p>由于每次reload的时候都要先查找hash值以及lru，不会重新重新读取动态库数据，因此在读取hash值的位置加一个函数，不进行hash值的读取</p>
<p><strong>PROBLEM</strong>：为何直接用eztune中的代码可以生效</p>
<p>方法一：由于在reload chromatix文件的时候，会首先查找是否存在hash值以及lru；当程序运行时会将so文件中的数据加载到内存中，因此我们要删去原来的hash值和lru，重新load chromatix。</p>
<p>方法二：移植extune的代码</p>
<p><strong>PROBLEM</strong>：没有对指针进行malloc，可以进行赋值么</p>
<p>由于测光权重表和bg_stats(grid)不是一一对应的关系，</p>
<p>还可以判断是否是运动光源</p>
<p>如果想要降低AE，有下面几种方法：</p>
<ol>
<li>提升cur_luma：</li>
</ol>
<ul>
<li><p>增加测光权重：但是不知道在哪一帧生效</p>
</li>
<li><p>增大输入的stats   —— aec使用bg_stats和直方图数据进行统计</p>
</li>
</ul>
<ol start="2">
<li><p>减少target_luma</p>
</li>
<li><p>直接对写入寄存器的值进行操作</p>
</li>
</ol>
<ul>
<li>对index进行操作</li>
</ul>
<p>对光晕的检测；如果正常曝光，应该不会存在过大的光晕</p>
<p>设置两个阈值，饱和亮度和较亮的亮度。用饱和亮度的块数除较亮的亮度的块数得到ratio，可以得出光晕的比例。ratio越大，光晕越小。</p>
<p>但是实际上发现，普通场景较亮亮度色块很多，而很亮的很少；强光场景中，ratio反而大——解释：由于强光场景亮度区分的很大，较亮的色块就比较少，因此ratio值就比较大</p>
<p>难道说ratio值越小越正常？理论上如果光晕少的话，应该是较亮的区域很少，饱和的区域很多，理论上数字很大呀</p>
<p>直方图更加精确一点，为何不用直方图呢 –转用直方图</p>
<p>发现直方图更逼近想象中的曲线，光晕越小，ratio越大，但是不太好判断</p>
<p>整理照片</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>算法实现</tag>
      </tags>
  </entry>
  <entry>
    <title>python stats数据绘图</title>
    <url>/posts/b8795a15/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="（一）绘图"><a href="#（一）绘图" class="headerlink" title="（一）绘图"></a>（一）绘图</h2><h3 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#导入模块  </span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="comment">#创建新图</span></span><br><span class="line">fig = plt.figure()  <span class="comment"># an empty figure with no axes</span></span><br><span class="line">fig.suptitle(<span class="string">'No axes on this figure'</span>)  <span class="comment"># Add a title so we know which it is</span></span><br><span class="line"></span><br><span class="line">fig, ax_lst = plt.subplots(<span class="number">2</span>, <span class="number">2</span>)  <span class="comment"># a figure with a 2x2 grid of Axes</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="输入及图表属性"><a href="#输入及图表属性" class="headerlink" title="输入及图表属性"></a>输入及图表属性</h3><p><img src="/posts/b8795a15/1.jpg" alt><br>所有绘图功能都期望np.array或np.ma.masked_array作为输入,类似“数组”的类.例如pandas数据对象，np.matrix可能会或可能不会按预期工作。最好用np.array在绘图之前将这些转换为对象。<br>例如，转换一个 pandas.DataFrame</p>
<p>a = pandas.DataFrame(np.random.rand(4,5), columns = list(‘abcde’))<br>a_asndarray = a.values<br>和隐蔽的 np.matrix</p>
<p>b = np.matrix([[1,2],[3,4]])<br>b_asarray = np.asarray(b)</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><strong>例子1</strong>：同一张图画多根曲线    </p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x, x, label=<span class="string">'linear'</span>)</span><br><span class="line">plt.plot(x, x**<span class="number">2</span>, label=<span class="string">'quadratic'</span>)</span><br><span class="line">plt.plot(x, x**<span class="number">3</span>, label=<span class="string">'cubic'</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">'x label'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y label'</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">"Simple Plot"</span>)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/posts/b8795a15/2.jpg" alt><br><strong>例子2</strong>：重复画图  </p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_plotter</span><span class="params">(ax, data1, data2, param_dict)</span>:</span></span><br><span class="line">    out = ax.plot(data1, data2, **param_dict)</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">data1, data2, data3, data4 = np.random.randn(<span class="number">4</span>, <span class="number">100</span>)</span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">my_plotter(ax, data1, data2, {<span class="string">'marker'</span>: <span class="string">'x'</span>})</span><br><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">my_plotter(ax1, data1, data2, {<span class="string">'marker'</span>: <span class="string">'x'</span>})</span><br><span class="line">my_plotter(ax2, data3, data4, {<span class="string">'marker'</span>: <span class="string">'o'</span>})</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/posts/b8795a15/3.jpg" alt></p>
<h2 id="（二）numpy"><a href="#（二）numpy" class="headerlink" title="（二）numpy"></a>（二）numpy</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><p>ndarray.ndim  </p>
<p>数组的轴数（尺寸）。  </p>
</li>
<li><p>ndarray.shape  </p>
<p>数组的大小。这是一个整数元组，表示每个维度中数组的大小。对于具有n行和m列的矩阵，shape将是(n,m)。shape因此，元组的长度 是轴的数量ndim。  </p>
</li>
<li><p>ndarray.size  </p>
<p>数组的元素总数。这等于元素的乘积shape。  </p>
</li>
<li><p>ndarray.dtype  </p>
<p>描述数组中元素类型的对象。可以使用标准Python类型创建或指定dtype。此外，NumPy还提供自己的类型。numpy.int32，numpy.int16和numpy.float64就是一些例子。  </p>
</li>
<li><p>ndarray.itemsize  </p>
<p>数组中每个元素的大小（以字节为单位）。例如，类型的元素数组float64有itemsize8（= 64/8），而其中一个类型complex32有itemsize4（= 32/8）。它相当于ndarray.dtype.itemsize。  </p>
</li>
<li><p>ndarray.data  </p>
<p>包含数组实际元素的缓冲区。通常，我们不需要使用此属性，因为我们将使用索引工具访问数组中的元素。 </p>
</li>
</ul>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><ul>
<li><p>从常规Python列表或元组创建数组:np.array()  </p>
</li>
<li><p>创建全零数组：np.zeros( (3,4) )  </p>
</li>
<li><p>创建数字序列：np.arange( 10, 30, 5 ) （接受float参数）  </p>
<p>第三个参数是步进长度</p>
</li>
<li><p>当arange与浮点参数一起使用时，由于有限的浮点精度，通常不可能预测所获得的元素的数量。出于这个原因，通常最好使用linspace作为参数接收我们想要的元素数量的函数 </p>
<p>np.linspace( 0, 2, 9 )  第三个参数是总数</p>
</li>
</ul>
<h3 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h3><ul>
<li><p>a[0:2]：  –a[0] a[1]  </p>
<p><strong>注意</strong>：留左不留右</p>
</li>
<li><p>resharp(,)： 转换数组的大小</p>
</li>
</ul>
<h2 id="（三）读写文件"><a href="#（三）读写文件" class="headerlink" title="（三）读写文件"></a>（三）读写文件</h2><p>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></tbody></table></figure>

<p>或者用</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read())</span><br></pre></td></tr></tbody></table></figure>

<h2 id="（四）读函数"><a href="#（四）读函数" class="headerlink" title="（四）读函数"></a>（四）读函数</h2><p>python文件对象提供了三个“读”方法： read()、readline() 和 readlines()。每种方法可以接受一个变量以限制每次读取的数据量。</p>
<p>read() 每次读取整个文件，它通常用于将文件内容放到一个字符串变量中。如果文件大于可用内存，为了保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。<br>readlines() 之间的差异是后者一次读取整个文件，象 .read() 一样。.readlines() 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for … in … 结构进行处理。<br>readline() 每次只读取一行，通常比readlines() 慢得多。仅当没有足够内存可以一次读取整个文件时，才应该使用 readline()。<br><strong>注意</strong>：这三种方法是把每行末尾的’\n’也读进来了，它并不会默认的把’\n’去掉，需要我们手动去掉。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">In[<span class="number">4</span>]: <span class="keyword">with</span> open(<span class="string">'test1.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    list1 = f1.readlines()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(list1)):</span><br><span class="line">    list1[i] = list1[i].rstrip(<span class="string">'\n'</span>)</span><br><span class="line">In[<span class="number">5</span>]: list1</span><br><span class="line">Out[<span class="number">5</span>]: [<span class="string">'111'</span>, <span class="string">'222'</span>, <span class="string">'333'</span>, <span class="string">'444'</span>, <span class="string">'555'</span>, <span class="string">'666'</span>]</span><br></pre></td></tr></tbody></table></figure>

<h1 id="绘图脚本编写"><a href="#绘图脚本编写" class="headerlink" title="绘图脚本编写"></a>绘图脚本编写</h1><h2 id="待解决问题"><a href="#待解决问题" class="headerlink" title="待解决问题"></a>待解决问题</h2><ol>
<li><p>Spyder中其他路径的文件读取不到  </p>
<p>添加文件路径</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">"Z:\liqinxing\test_photo\sdm660_ipc"</span>)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>字符串如何批量转数字 ——map函数   </p>
</li>
<li><p>一行字符串如何转数组 ——split函数  </p>
</li>
<li><p>一维数组如何转二维数组  ——resharp   </p>
</li>
<li><p>三维数组如何画图  ——引入mpl_toolkits.mplot3d</p>
</li>
</ol>
<h2 id="脚本如下"><a href="#脚本如下" class="headerlink" title="脚本如下"></a>脚本如下</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">line=<span class="number">1</span></span><br><span class="line">sence=<span class="number">1</span></span><br><span class="line">stats_data=np.zeros((<span class="number">48</span>,<span class="number">64</span>))</span><br><span class="line"><span class="comment">#添加文件路径并打开</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'Z:\\liqinxing\\test_photo\\sdm660_ipc\\aec_stats.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    list1 = f1.readlines()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(list1)):</span><br><span class="line">    <span class="comment">#去掉每行的\n</span></span><br><span class="line">    list1[i] = list1[i].rstrip(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="comment">#判断每一行的第一个字符</span></span><br><span class="line">    <span class="keyword">if</span> list1[i][<span class="number">1</span>].isdigit() == <span class="literal">True</span>:</span><br><span class="line">        <span class="comment">#split将字符串切分成数组 </span></span><br><span class="line">        <span class="comment">#map函数将函数依次作用到list上的每个元素</span></span><br><span class="line">        data=list(map(int,list1[i].split())) </span><br><span class="line">        print(<span class="string">'line='</span>+str(line))</span><br><span class="line">        line += <span class="number">1</span></span><br><span class="line">        <span class="comment">#将数组转换成np数组</span></span><br><span class="line">        data_tmp=np.array(data)</span><br><span class="line">        <span class="comment">#将一维数组切块，留左不留右，并转换成二维数组</span></span><br><span class="line">        stats_subdata = data_tmp[<span class="number">0</span>:<span class="number">64</span>*<span class="number">48</span>].reshape(<span class="number">48</span>,<span class="number">64</span>)</span><br><span class="line">        <span class="comment">#对RGGB四个通道的值进行相加</span></span><br><span class="line">        stats_data += stats_subdata</span><br><span class="line">        <span class="keyword">if</span> line%<span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="comment">#建立一个figure</span></span><br><span class="line">            figure = plt.figure()</span><br><span class="line">            <span class="comment">#3D绘图</span></span><br><span class="line">            ax = Axes3D(figure)</span><br><span class="line">            <span class="comment">#定义XY轴</span></span><br><span class="line">            X = np.arange(<span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">            Y = np.arange(<span class="number">0</span>, <span class="number">48</span>)</span><br><span class="line">            X, Y = np.meshgrid(X, Y)</span><br><span class="line">            <span class="comment">#设置标题</span></span><br><span class="line">            ax.set_title(<span class="string">'sence'</span>+str(sence))</span><br><span class="line">            <span class="comment">#绘图</span></span><br><span class="line">            ax.plot_surface(X,Y,stats_data,</span><br><span class="line">                rstride=<span class="number">1</span>, cstride=<span class="number">1</span>, cmap=<span class="string">'rainbow'</span>)</span><br><span class="line">            stats_data=np.zeros((<span class="number">48</span>,<span class="number">64</span>))</span><br><span class="line">            sence += <span class="number">1</span></span><br><span class="line"><span class="comment">#plt.show是将所有的图画出来，而且是阻塞性的</span></span><br><span class="line"><span class="comment">#如果想画多个图，一定要在最后结束的时候用</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/posts/423abe9e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="远程仓库相关命令"><a href="#远程仓库相关命令" class="headerlink" title="远程仓库相关命令"></a>远程仓库相关命令</h1><ul>
<li>检出仓库：$ git clone git://github.com/jquery/jquery.git  </li>
<li>查看远程仓库：$ git remote -v  </li>
<li>添加远程仓库：$ git remote add [name] [url]  </li>
<li>删除远程仓库：$ git remote rm [name]  </li>
<li>修改远程仓库：$ git remote set-url –push[name][newUrl]  </li>
<li>拉取远程仓库：$ git pull [remoteName] [localBranchName]  </li>
<li>推送远程仓库：$ git push [remoteName] [localBranchName]  </li>
</ul>
<h1 id="分支操作相关命令"><a href="#分支操作相关命令" class="headerlink" title="分支操作相关命令"></a>分支操作相关命令</h1><ul>
<li>查看本地分支：$ git branch  </li>
<li>查看远程分支：$ git branch -r  </li>
<li>创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支  </li>
<li>切换分支：$ git checkout [name]  </li>
<li>创建新分支并立即切换到新分支：$ git checkout -b [name]  </li>
<li>删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项  </li>
<li>合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并  </li>
<li>创建远程分支(本地分支push到远程)：$ git push origin [name]  </li>
<li>删除远程分支：$ git push origin :heads/[name]  </li>
</ul>
<p>我从master分支创建了一个issue5560分支，做了一些修改后，使用git push origin master提交，但是显示的结果却是’Everything up-to-date’，发生问题的原因是git push origin master 在没有track远程分支的本地分支中默认提交的master分支，因为master分支默认指向了origin master 分支，这里要使用git push origin issue5560：master 就可以把issue5560推送到远程的master分支了。</p>
<ul>
<li><p>如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，那么可以这么做。<br>$ git push origin test:master         // 提交本地test分支作为远程的master分支 //好像只写这一句，远程的github就会自动创建一个test分支<br>$ git push origin test:test              // 提交本地test分支作为远程的test分支</p>
</li>
<li><p>如果想删除远程的分支呢？类似于上面，如果:左边的分支为空，那么将删除:右边的远程的分支。<br>$ git push origin :test              // 刚提交到远程的test将被删除，但是本地还会保存的，不用担心</p>
</li>
</ul>
<h1 id="版本-tag-操作相关命令"><a href="#版本-tag-操作相关命令" class="headerlink" title="版本(tag)操作相关命令"></a>版本(tag)操作相关命令</h1><ul>
<li>查看版本：$ git tag</li>
<li>创建版本：$ git tag [name]</li>
<li>删除版本：$ git tag -d [name]</li>
<li>查看远程版本：$ git tag -r</li>
<li>创建远程版本(本地版本push到远程)：$ git push origin [name]</li>
<li>删除远程版本：$ git push origin :refs/tags/[name]</li>
</ul>
<h1 id="子模块-submodule-相关操作命令"><a href="#子模块-submodule-相关操作命令" class="headerlink" title="子模块(submodule)相关操作命令"></a>子模块(submodule)相关操作命令</h1><ul>
<li>添加子模块：$ git submodule add [url] [path]  </li>
</ul>
<p>如：$ git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs  </p>
<ul>
<li>初始化子模块：$ git submodule init —-只在首次检出仓库时运行一次就行</li>
<li>更新子模块：$ git submodule update —-每次更新或切换分支后都需要运行一下</li>
<li>删除子模块：<ul>
<li>$ git rm –cached [path]</li>
<li>编辑“.gitmodules”文件，将子模块的相关配置节点删除掉</li>
<li>编辑“.git/config”文件，将子模块的相关配置节点删除掉</li>
<li>手动删除子模块残留的目录</li>
</ul>
</li>
</ul>
<h1 id="忽略一些文件、文件夹不提交"><a href="#忽略一些文件、文件夹不提交" class="headerlink" title="忽略一些文件、文件夹不提交"></a>忽略一些文件、文件夹不提交</h1><p>在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如<br>target<br>bin<br>*.db  </p>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>工具</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 多终端同步</title>
    <url>/posts/5f460a06/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>#准备条件#<br>安装了Node.js,Git,Hexo环境<br>完成Github与本地Hexo的对接<br>这部分可以参考<a href="https://xuanwo.org/2015/03/26/hexo-intor/" target="_blank" rel="noopener">最详细的Hexo博客搭建图文教程</a></p>
<h1 id="push本地文件"><a href="#push本地文件" class="headerlink" title="push本地文件"></a>push本地文件</h1><p>在其中一个终端操作，push本地文件夹Hexo中的必要文件到yourname.github.io的hexo分支上（这里分支名称我使用的develop）</p>
<p>在利用Github+Hexo搭建自己的博客时，新建了一个Hexo的文件夹，并进行相关的配置，这部分主要是将这些配置的文件托管到Github项目的分支上，其中只托管部分用于多终端的同步的文件，如完成的效果图所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git init  //初始化本地仓库</span><br><span class="line">git add source //将必要的文件依次添加，有些文件夹如npm install产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件，如下图所示</span><br><span class="line">git commit -m "Blog Source Hexo"</span><br><span class="line">git branch hexo  //新建hexo分支</span><br><span class="line">git checkout hexo  //切换到hexo分支上</span><br><span class="line">git remote add origin git@github.com:yourname/yourname.github.io.git  //将本地与Github项目对接</span><br><span class="line">git push origin hexo  //push到Github项目的hexo分支上</span><br></pre></td></tr></tbody></table></figure>

<p>这样你的github项目中就会多出一个Hexo分支，这个就是用于多终端同步关键的部分。</p>
<h1 id="clone和push更新文件"><a href="#clone和push更新文件" class="headerlink" title="clone和push更新文件"></a>clone和push更新文件</h1><p>此时在另一终端更新博客，只需要将Github的hexo分支clone下来，进行初次的相关配置</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git clone -b hexo git@github.com:yourname/yourname.github.io.git  //将Github中hexo分支clone到本地</span><br><span class="line">cd  yourname.github.io  //切换到刚刚clone的文件夹内</span><br><span class="line">npm install    //注意，这里一定要切换到刚刚clone的文件夹内执行，安装必要的所需组件，不用再init</span><br><span class="line">hexo new post "new blog name"   //新建一个.md文件，并编辑完成自己的博客内容</span><br><span class="line">git add source  //经测试每次只要更新sorcerer中的文件到Github中即可，因为只是新建了一篇新博客</span><br><span class="line">git commit -m "XX"</span><br><span class="line">git push origin hexo  //更新分支</span><br><span class="line">hexo d -g   //push更新完分支之后将自己写的博客对接到自己搭的博客网站上，同时同步了Github中的master</span><br></pre></td></tr></tbody></table></figure>
<h1 id="不同终端间配置"><a href="#不同终端间配置" class="headerlink" title="不同终端间配置"></a>不同终端间配置</h1><p>在不同的终端已经做完配置，就可以分享自己更新的博客<br>进入自己相应的文件夹</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git pull origin hexo  //先pull完成本地与远端的融合</span><br><span class="line">hexo new post " new blog name"</span><br><span class="line">git add source</span><br><span class="line">git commit -m "XX"</span><br><span class="line">git push origin hexo</span><br><span class="line">hexo d -g</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>工具</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG：手动增益过大时闪烁</title>
    <url>/posts/ebc3ac5b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>当手动增益调节到90多时，图像会有闪烁<br>当调到100时，增益突然变低，图像突然变好</p>
<h2 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h2><ol>
<li>增益太高，导致曝光行一行跨度太大，达不到目标亮度</li>
<li>虽然增益很高，我们是在AE模块的输出截取修改，其实AE会把这个场景当做很亮的场景，曝光行在很小的地方波动，那个时候的曝光行不够平滑</li>
<li>是否可能增益到100时候超过了IMX327的最大数字增益</li>
</ol>
<h2 id="排查经过"><a href="#排查经过" class="headerlink" title="排查经过"></a>排查经过</h2><ul>
<li>1/17/2019 13:28:49</li>
</ul>
<p>烧写最新版本启动不了  –烧写1.4版本<br>搭好环境，更新代码</p>
<ul>
<li>2019/1/17 13:43:27  </li>
</ul>
<p>曝光行一直在变化，增益也在变化。  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( output->stats_update.aec_update.sensor_gain > aec->aec_exp_limit.gain_max){</span><br><span class="line">  <span class="keyword">if</span>((output->stats_update.aec_update.linecount < (<span class="keyword">uint32_t</span>)output->stats_update.aec_update.preview_linesPerFrame/<span class="number">10</span>)</span><br><span class="line">&& (aec->aec_exp_limit.shutter_max_line != aec->aec_exp_limit.shutter_min_line))</span><br><span class="line">    output->stats_update.aec_update.sensor_gain *= aec->aec_exp_limit.gain_max;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    output->stats_update.aec_update.sensor_gain= aec->aec_exp_limit.gain_max;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( output->stats_update.aec_update.sensor_gain < aec->aec_exp_limit.gain_min){</span><br><span class="line">  <span class="keyword">if</span>((output->stats_update.aec_update.linecount < (<span class="keyword">uint32_t</span>)output->stats_update.aec_update.preview_linesPerFrame/<span class="number">10</span>) \</span><br><span class="line">&& (aec->aec_exp_limit.shutter_max_line != aec->aec_exp_limit.shutter_min_line))</span><br><span class="line">    output->stats_update.aec_update.sensor_gain *= aec->aec_exp_limit.gain_min;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    output->stats_update.aec_update.sensor_gain = aec->aec_exp_limit.gain_min;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    aec->aec_exp_limit.cur_lux_index = core_output->lux_idx;</span><br></pre></td></tr></tbody></table></figure>


<p><strong>问题</strong>：调节手动增益为什么不是直接设置固定值？  </p>
<p><strong>解释</strong>：可能是由于增益比较大，如果想要达到目标亮度，曝光行可能会来回跳动，因此需要将手动增益乘以一个较小的数，也就是原始的输出增益。这里就相当于在原来的AEC基础上加上了一个固定的倍数。</p>
<ul>
<li>2019/1/17 14:38:34  </li>
</ul>
<p>可能是在之前乘以的倍数比较大？超过了最大值？ –可以到达600多倍</p>
<p><img src="/posts/ebc3ac5b/bug1-1583661012571.jpg" alt></p>
<ul>
<li>2019/1/17 15:38:45 </li>
</ul>
<p>lib中设置了最大增益上限为252，是否是因为超过了最大上限？ –在sensor.c中的<code>sensor_set_aec_update</code>函数用persist强制设置  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> prop[PROPERTY_VALUE_MAX];</span><br><span class="line"><span class="keyword">uint32_t</span> Debug_flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> real_gain = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">uint32_t</span> linecount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">property_get(<span class="string">"persist.camera.debug.flag"</span>, prop, <span class="string">"0"</span>);</span><br><span class="line">Debug_flag = atoi(prop);</span><br><span class="line">   </span><br><span class="line">property_get(<span class="string">"persist.camera.debug.real_gain"</span>, prop, <span class="string">"0"</span>);</span><br><span class="line">real_gain = atof(prop);</span><br><span class="line">    </span><br><span class="line">property_get(<span class="string">"persist.camera.debug.linecount"</span>, prop, <span class="string">"0"</span>);</span><br><span class="line">linecount = atoi(prop);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (Debug_flag == <span class="number">1</span>) {</span><br><span class="line">  exposure.real_gain = real_gain;</span><br><span class="line">  exposure.linecount = linecount;</span><br><span class="line">  SERR(<span class="string">"liqinxing: manual_set real_gain: %f,</span></span><br><span class="line"><span class="string">    linecnt = %d"</span>, real_gain,linecount);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sensor_set_exposure(sctrl, exposure);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>2019/1/18 10:40:06 </li>
</ul>
<p>排查99和100效果不同的原因：<br>注意一个问题：100ms更新一次数据 –理论上不是两帧更新一次么，也就是66ms;由于不是每次都打印，可能会出现这个问题</p>
<p>设置的手动增益是正常的，一直在增大；难道说是超出阈值了<br>保持图片的当前亮度稳定，那么曝光行和增益的乘积是固定的，也就是当增益增大，固定增益增大，曝光阶会会减小，但是到了100就不对了；为什么之前不会出现这个问题呢？</p>
<ul>
<li>2019/1/18 13:37:03  </li>
</ul>
<p>尝试修改lib.h文件中的IMX327_MAX_GAIN为1000<br>发现增益等级设置的手动增益范围也变成了1-1000，当为80时，手动增益为252倍，之后和100相同的情况，而在70-80之间依旧闪烁</p>
<ul>
<li>2019/1/18 14:10:49 </li>
</ul>
<p>为什么增益到了252就会出问题呢？这个增益恰好是lib中设置的最大增益</p>
<ul>
<li>2019/1/18 15:00:40 </li>
</ul>
<p>尝试将IMX327_MAX_GAIN改小，发现不再闪烁了，但是并不能解释根本原因</p>
<h2 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h2><p>写入寄存器是字节型写入的，需要将float型转换成十六进制，它是通过一个查找表<code>reg_value_lookup_table</code>去设置对应的倍数的。但是有个问题，超过查找表的最大值就没有进行赋值。而查找表的最大值只有251倍，我们设置的最大倍数有252倍，所以会出现问题。我们只需要将查找表加长，让每个倍数有对应的写入寄存器的值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>与camera相关参数的设置，注意是以字节形式写入，有时需要进入底层去查看原因。</li>
<li>aec_port中的real_gain并不是最终写入寄存器的值，需要经过sensor模块（可能会经过截取等简单操作），还有最后转换成字节型。</li>
</ul>
<h2 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h2><ul>
<li>imx327数字增益范围是0.3-42dB；换算一下最大数字增益是125.89；最大增益为71.4dB</li>
<li>imx327_lib.h文件中最大增益是252，也就是24dB</li>
<li>增益和倍数的换算是20lg(倍数)=dB</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>bug</tag>
        <tag>闪烁</tag>
      </tags>
  </entry>
  <entry>
    <title>ADRC</title>
    <url>/posts/1227eaa4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>用来提高整体亮度并抑制过曝，混合使用GTM和LTM。用直方图AEC设置更低的目标亮度，用更高的数字增益来增大暗处的亮度，会带来噪声的增加，尤其是户外的场景。</p>
<a id="more"></a> 

<h2 id="（一）ADRC初始化设置"><a href="#（一）ADRC初始化设置" class="headerlink" title="（一）ADRC初始化设置"></a>（一）ADRC初始化设置</h2><ul>
<li>使能直方图和ADRC: <code>Histogram Metering</code></li>
<li>为每个区间设置最大ADRC增益 <code>Max ADRC Gain</code></li>
<li>设置每个区间GTM/LTM的比例 <code>LTM/GTM Percentage</code> </li>
<li>在直方图保留部分使能DRC增益标志位 <code>ltm/gtm_enable</code>，如果没有GTM的平台，使能gamma和ltm</li>
<li>使能LTM<code>Local Tone Mapping</code></li>
<li>在<strong>isp头文件</strong>里不要使能<strong>GTM</strong></li>
</ul>
<h2 id="（二）判断是否设置成功"><a href="#（二）判断是否设置成功" class="headerlink" title="（二）判断是否设置成功"></a>（二）判断是否设置成功</h2><p>3A信息：<code>AEC Debug Info ->Histogram Adjustment</code> 中<code>ADRC target gain</code></p>
<h2 id="（三）基础调试"><a href="#（三）基础调试" class="headerlink" title="（三）基础调试"></a>（三）基础调试</h2><h3 id="微调直方图AEC获得恰当的整体亮度和DRC增益"><a href="#微调直方图AEC获得恰当的整体亮度和DRC增益" class="headerlink" title="微调直方图AEC获得恰当的整体亮度和DRC增益"></a>微调直方图AEC获得恰当的整体亮度和DRC增益</h3><p>ADRC工作范围：ideal_luma_target < legacy_luma_target * Min_Target_Adj_Ratio<br>在ADRC的情况下，亮度由final_luma_target * drc_gain决定</p>
<p><img src="/posts/1227eaa4/adrc_brightness.jpg" alt="adrc_brightness"></p>
<table>
<thead>
<tr>
<th align="center">ITEM</th>
<th align="left">AEC模块</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">luma_target (legacy_luma_target)</td>
<td align="left">luma targets</td>
<td>整体亮度越强，值越大</td>
</tr>
<tr>
<td align="center">ideal_luma_target</td>
<td align="left">Histogram Metering</td>
<td>ADRC越强，值越小。可以调节sat_low_ref,sat_high_ref,dark_low_ref,dark_high_ref,hist sat range,hist darc range。<code>sat</code>参数是调节ADRC的关键</td>
</tr>
<tr>
<td align="center">Min Target Adj Ratio</td>
<td align="left">Histogram Metering</td>
<td>整体亮度越亮，ADRC越强，值越大</td>
</tr>
<tr>
<td align="center">max_drc_gain</td>
<td align="left">Histogram Metering</td>
<td>限制ADRC的最大增益，ADRC越强，值越大；一开始调试不要超过2，谨慎增大这个值</td>
</tr>
<tr>
<td align="center">### 调试ADRC比例</td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="center">如果用了LTM，会提升对比度。不应该期望有明显的改进，也不应该过度使用LTM，因为他可能导致几种问题。</td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="center">一般来说，LTM比GTM/gamma对对比度和强光抑制更好，但是它可能产生一些副作用。对于对比度改善，高光抑制你也可以细调遗留的目标亮度和gamma</td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td align="center"><strong>建议</strong>：第一次调LTM不要超过0.5，留下的给gamma/gtm</td>
<td align="left"></td>
<td></td>
</tr>
</tbody></table>
<h2 id="（四）高级ADRC调试"><a href="#（四）高级ADRC调试" class="headerlink" title="（四）高级ADRC调试"></a>（四）高级ADRC调试</h2><h3 id="LTM调试"><a href="#LTM调试" class="headerlink" title="LTM调试"></a>LTM调试</h3><pre><code>我们可以调试`Global Tone Contrast`(修改对比度)和`Fixed content low`(修改暗区亮度)</code></pre><h3 id="抗闪烁优先还是ADRC"><a href="#抗闪烁优先还是ADRC" class="headerlink" title="抗闪烁优先还是ADRC"></a>抗闪烁优先还是ADRC</h3><pre><code>由于启用了ADRC，曝光时间可能小于10Ms，因此`可能出现闪烁问题`</code></pre><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/* 3A头文件 Histogram Metering 最后*/</span><br><span class="line">1.000000f,/* adrc_antibanding_priority_enable */</span><br><span class="line">170.000000f,/* atb_cutoff_idx_50hz */</span><br><span class="line">160.000000f,/* atb_cutoff_idx_60hz */</span><br><span class="line">200.000000f,/* atb_trigger.start */</span><br><span class="line">230.000000f,/* atb_trigger.end */</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果lux_idx <atb_trigger.end(非常非常明亮的情况下)，我们认为这是一个明确的亮度户外情况下，没有闪烁。所以，什么都不会发生。</li>
<li>当lux_idx >atb_trigger.end(可能在door中)，如果检测到条带，ADRC算法使曝光指数小于cutoff_idx，则该特性将把曝光指数限制在cutoff_idx，并降低drc idx(更小的drc gain)来调节亮度。</li>
<li>如果lux_idx在start和endzhi之间。调整比例将从0.0到1.0插值，使调整平滑。</li>
</ul>
<p><strong>闪烁问题和建议</strong>：</p>
<ul>
<li>也可能有曝光表的设计和模块的灵敏度有关</li>
<li>一开始关闭这个功能，除非你发现ADRC会引起闪烁问题</li>
<li>减少触发点可以对抗闪烁更有帮助</li>
<li>设置cutoff index比理论值略大一点</li>
</ul>
<h3 id="ADRC-WNR调整"><a href="#ADRC-WNR调整" class="headerlink" title="ADRC WNR调整"></a>ADRC WNR调整</h3><p>我们有机会调整CPP头中WNR的权重，DRC 增益是触发。<code>ADRC WNR Adjustment feature</code>，这个值可以大于或者小于1，最后WNR的设置会乘上ADRC WNR adjustment value。<br><strong>注意</strong>：<br>我们总是为WNR设置增益触发，而WNR的触发中也包含ADRC增益。gain(wnr-trigger) = gain * drc_gain</p>
<h3 id="ADRC-ACE调整"><a href="#ADRC-ACE调整" class="headerlink" title="ADRC ACE调整"></a>ADRC ACE调整</h3><p>我们可以在isp头中设置颜色调整，<code>DRC Sat Adj Factor</code>将会在color conversion模块中乘上a_m,a_p,c_m,c_p，可以对饱和度进行增强或者减少<br><strong>建议</strong>：不是必须的，一开始不需要打开</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像效果调试</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>直方图AEC</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo markdown常用语法</title>
    <url>/posts/2215beeb/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h1 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h1><ul>
<li><p>添加目录：<code>[TOC]</code></p>
</li>
<li><p>分段 <code>两个回车</code></p>
</li>
<li><p>换行 <code>两个空格</code> + <code>回车</code></p>
</li>
<li><p>标题 <code>#</code> ~ <code>######</code>，<code>#</code>号的个数表示几级标题，即表示一级标题到六级标题</p>
</li>
<li><p>强调 <code>**文字**</code>，<code>__文字__</code> ， <code>_文字_</code> ， <code>*文字*</code> ， <code>~~文字~~</code></p>
</li>
<li><p>引用 <code>></code> 注意后面紧跟个空格；两个空格结束引用。</p>
</li>
<li><p>代码块 <code>四个空格</code> 开头或， 使用```</p>
</li>
<li><p>链接 <code>[文字] (链接地址)</code></p>
</li>
<li><p>图片 <code>![图片说明] (图片地址)</code> ，地址可以是本地路劲，也可以是网络地址</p>
</li>
<li><p>列表 <code>*</code> ， <code>+</code>， <code>-</code>， <code>1.</code> ，选其中之一，注意后面紧跟个空格，如果是二级列表就在前面加一个空格</p>
</li>
<li><p>表格 - 和 | 分割行和列 ， 用<code>:</code>控制对其方式</p>
<p><strong>注</strong>：一般对合并单元格，以及其他特殊格式表格，markdown 是无能为力的<br>所以常规的做法是使用HTML标签，但是这样的编写效率极低。<br>但是有了这款工具的话，所有问题都迎刃而解。</p>
<p>在线生成HTML代码 <a href="http://www.tablesgenerator.com/" target="_blank" rel="noopener">Tables Generator</a> (国外的站)</p>
</li>
</ul>
<h1 id="首页概述"><a href="#首页概述" class="headerlink" title="首页概述"></a>首页概述</h1><ul>
<li>首页显示正文内容 <code><!-- more --></code></li>
<li>如果想空着：在layout设置部分用<code>description: <br></code></li>
<li>如果想要和正文不一样，用<code>description:</code>加上文字</li>
<li>如果想要概述中换行，用<br></li>
<li>如果md文件编写概述中换行，不能直接换行，需要加上<code>-</code>，但是注意不同的行直接会自动多一个<code>,</code></li>
</ul>
<h1 id="常用html格式"><a href="#常用html格式" class="headerlink" title="常用html格式"></a>常用html格式</h1><p>用div去指定特殊格式 </p>
<ul>
<li>古诗  <figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-family:cursive; font-style:normal; line-height:100%; font-size:250%; font-weight:bold; color:#FC8500; text-align:center;"</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br></pre></td></tr></tbody></table></figure></li>
<li>诗歌  <figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-family:cursive; font-style:normal; line-height:150%; font-size:200%; font-weight:bold; color:#FC8500; text-align:left; padding-left:10%"</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>工具</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>背光补偿和强光抑制算法实现</title>
    <url>/posts/d74e7b23/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p><strong>背光补偿</strong>是忽略强光，将暗处提亮，提高整体亮度<br><strong>强光抑制</strong>是重视强光，将亮处抑制，降低整体亮度</p>
<p>这两者的本质都是对曝光进行操作，再对图像进行gamma映射等轻微的调整。<br>本文用三种方案对问题进行讨论和实现</p>
<a id="more"></a> 
<hr>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li>强光抑制太注重亮区，当车辆快速驶来，车灯的影响可能会很大，暗区看不清，甚至导致<code>AE不稳定</code></li>
<li>强光抑制可能会导致噪声比较大，是否可以通过增大降噪触发点去自动增大<code>降噪等级</code></li>
<li>注意<code>ABF</code>可能会对亮区进行降噪，是否可以对ABF增加一个亮区参数</li>
<li>通过调节<code>锐化和降噪的LNR</code>对亮区进行锐化，对暗区进行进一步的降噪</li>
</ul>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="方案一：对测光权重进行调整"><a href="#方案一：对测光权重进行调整" class="headerlink" title="方案一：对测光权重进行调整"></a>方案一：对测光权重进行调整</h3><h4 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h4><ul>
<li><strong>自动模式</strong>：修改亮区的权重</li>
<li><strong>手动模式</strong>：修改相应区域的权重</li>
</ul>
<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><h3 id="方案二：对高通GTM-LTM进行调整"><a href="#方案二：对高通GTM-LTM进行调整" class="headerlink" title="方案二：对高通GTM/LTM进行调整"></a>方案二：对高通GTM/LTM进行调整</h3><h4 id="实现方案-1"><a href="#实现方案-1" class="headerlink" title="实现方案"></a>实现方案</h4><p>查看高通直方图AEC以及GTM/LTM的调节</p>
<ul>
<li><strong>自动模式</strong>：修改GTM/LTM的等级</li>
</ul>
<h3 id="方案三：对Bayer域和YUV域的直方图数据进行处理"><a href="#方案三：对Bayer域和YUV域的直方图数据进行处理" class="headerlink" title="方案三：对Bayer域和YUV域的直方图数据进行处理"></a>方案三：对Bayer域和YUV域的直方图数据进行处理</h3><h4 id="实现方案-2"><a href="#实现方案-2" class="headerlink" title="实现方案"></a>实现方案</h4><ul>
<li>通过Bayer域直方图统计数据得到亮区的区间，或者修改目标亮度</li>
<li>在yuv域直方图对gamma进行细微调整，可以通过调整LTM，也可以直接对亮区的gamma曲线进行抑制</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>算法实现</tag>
      </tags>
  </entry>
  <entry>
    <title>ADB指令小结</title>
    <url>/posts/81d156db/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>ADB，即 Android Debug Bridge。利用ADB指令可以对安卓设备进行命令行操作。<br>下面总结一些常用的ADB指令方便设备的开发与调试。</p>
<a id="more"></a> 

<h2 id="（一）推库不用重启的方法："><a href="#（一）推库不用重启的方法：" class="headerlink" title="（一）推库不用重启的方法："></a>（一）推库不用重启的方法：</h2><p>可以节省大量时间，需要重启启动程序，和第二条搭配使用<br>另外还可以方便的查看开camera初始化时的一些打印<br>注意：需要有APK，部分IPC上不能使用</p>
<h3 id="660-8998平台"><a href="#660-8998平台" class="headerlink" title="660/8998平台:"></a>660/8998平台:</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">adb shell stop cameraserver</span><br><span class="line">adb shell start cameraserver</span><br><span class="line">adb shell sync</span><br></pre></td></tr></tbody></table></figure>

<h3 id="老平台："><a href="#老平台：" class="headerlink" title="老平台："></a>老平台：</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">adb shell stop media</span><br><span class="line">adb shell start media</span><br><span class="line">adb shell stop qcamerasvr</span><br><span class="line">adb shell start qcamerasvr</span><br><span class="line">adb shell sync</span><br></pre></td></tr></tbody></table></figure>

<h2 id="（二）adb启动和关闭程序的方法"><a href="#（二）adb启动和关闭程序的方法" class="headerlink" title="（二）adb启动和关闭程序的方法"></a>（二）adb启动和关闭程序的方法</h2><h3 id="先找到当前窗口的程序名，拿骁龙相机举例"><a href="#先找到当前窗口的程序名，拿骁龙相机举例" class="headerlink" title="先找到当前窗口的程序名，拿骁龙相机举例"></a>先找到当前窗口的程序名，拿骁龙相机举例</h3><p>输入：adb shell dumpsys window windows | findstr Current<br>输出：mCurrentFocus=Window{59a08b7 u0 org.codeaurora.snapcam/com.android.camera.CameraLauncher}<br>后面一长串的字母就是程序名</p>
<h3 id="先找到当前窗口的程序名，拿骁龙相机举例启动程序，adb-shell-am-start-–n-程序名"><a href="#先找到当前窗口的程序名，拿骁龙相机举例启动程序，adb-shell-am-start-–n-程序名" class="headerlink" title="先找到当前窗口的程序名，拿骁龙相机举例启动程序，adb shell am start –n + 程序名"></a>先找到当前窗口的程序名，拿骁龙相机举例启动程序，adb shell am start –n + 程序名</h3><p>adb shell am start -n org.codeaurora.snapcam/com.android.camera.CameraLauncher</p>
<h3 id="先找到当前窗口的程序名，拿骁龙相机举例关闭程序"><a href="#先找到当前窗口的程序名，拿骁龙相机举例关闭程序" class="headerlink" title="先找到当前窗口的程序名，拿骁龙相机举例关闭程序"></a>先找到当前窗口的程序名，拿骁龙相机举例关闭程序</h3><p>adb shell pkill snapcam(缩写就够了)</p>
<h2 id="（三）拍照：用模拟抓拍键的方式抓拍"><a href="#（三）拍照：用模拟抓拍键的方式抓拍" class="headerlink" title="（三）拍照：用模拟抓拍键的方式抓拍"></a>（三）拍照：用模拟抓拍键的方式抓拍</h2><p>adb shell input keyevent 27<br>如果写成脚本，速度较快，有的时候图片不能立即pull出来，建议加个延时，具体延时长度自己试验<br>延时：ping /n 2 127.1>nul<br>此处的2代表延时2秒</p>
<h2 id="（四）抓raw图的方法：不一定要骁龙相机，方便拍raw图以及平时的分析（660平台）"><a href="#（四）抓raw图的方法：不一定要骁龙相机，方便拍raw图以及平时的分析（660平台）" class="headerlink" title="（四）抓raw图的方法：不一定要骁龙相机，方便拍raw图以及平时的分析（660平台）"></a>（四）抓raw图的方法：不一定要骁龙相机，方便拍raw图以及平时的分析（660平台）</h2><h3 id="先找到当前窗口的程序名，拿骁龙相机举例先修改文件夹权限"><a href="#先找到当前窗口的程序名，拿骁龙相机举例先修改文件夹权限" class="headerlink" title="先找到当前窗口的程序名，拿骁龙相机举例先修改文件夹权限"></a>先找到当前窗口的程序名，拿骁龙相机举例先修改文件夹权限</h3><p>adb shell chmod 777 /data/misc/camera</p>
<h3 id="先找到当前窗口的程序名，拿骁龙相机举例抓取一帧RAW"><a href="#先找到当前窗口的程序名，拿骁龙相机举例抓取一帧RAW" class="headerlink" title="先找到当前窗口的程序名，拿骁龙相机举例抓取一帧RAW"></a>先找到当前窗口的程序名，拿骁龙相机举例抓取一帧RAW</h3><p>可以在QCamera2HWICallbacks.cpp的dumpFrameToFile函数查看具体实现过程。可能会出现抓拍到不止1张raw图的情况。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">adb shell setprop persist.camera.raw_yuv 1</span><br><span class="line">adb shell setprop persist.camera.preview_raw 1</span><br><span class="line">adb shell setprop persist.camera.dumpimg 0</span><br><span class="line">adb shell setprop persist.camera.dumpimg 131088</span><br></pre></td></tr></tbody></table></figure>
<h3 id="先找到当前窗口的程序名，拿骁龙相机举例导入chromatix时，用骁龙相机抓出来的raw图是MIPI格式"><a href="#先找到当前窗口的程序名，拿骁龙相机举例导入chromatix时，用骁龙相机抓出来的raw图是MIPI格式" class="headerlink" title="先找到当前窗口的程序名，拿骁龙相机举例导入chromatix时，用骁龙相机抓出来的raw图是MIPI格式"></a>先找到当前窗口的程序名，拿骁龙相机举例导入chromatix时，用骁龙相机抓出来的raw图是MIPI格式</h3><p>而这里格式要改成packed，图片的名称中有图片的大小<br>注意：第一次抓取raw图，设置好要重启camera<br>由于persist.camera.raw_yuv只有在给channel添加通道的时候才会读取，因此设置之后需要重启camera，可以重启设备或者重启应用程序。</p>
<h2 id="（五）抓YUV图的方法（660平台）："><a href="#（五）抓YUV图的方法（660平台）：" class="headerlink" title="（五）抓YUV图的方法（660平台）："></a>（五）抓YUV图的方法（660平台）：</h2><h3 id="VFE输出"><a href="#VFE输出" class="headerlink" title="VFE输出"></a>VFE输出</h3><p>和上面一个类似，先改权限</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">adb shell setprop persist.camera.isp.dump_cnt 10</span><br><span class="line">adb shell setprop persist.camera.isp.dump 0</span><br><span class="line">adb shell setprop persist.camera.isp.dump 2</span><br></pre></td></tr></tbody></table></figure>
<p>实现函数：iface_util.c中的 iface_util_dump_frame</p>
<p>如果想要再次dump 10帧，需要把isp.dump值设置成0，再设置一次2</p>
<h3 id="CPP输出（方法和抓raw图差不多）"><a href="#CPP输出（方法和抓raw图差不多）" class="headerlink" title="CPP输出（方法和抓raw图差不多）"></a>CPP输出（方法和抓raw图差不多）</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">adb shell setprop persist.camera.dumpimg 0</span><br><span class="line">adb shell setprop persist.camera.dumpimg 131073</span><br></pre></td></tr></tbody></table></figure>

<h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p>persist.camera.isp.dump 0到12位的意义：<br>CAM_STREAM_TYPE_PREVIEW – 0x2<br>CAM_STREAM_TYPE_SNAPSHOT – 0x8<br>CAM_STREAM_TYPE_VIDEO – 0x10<br>persist.camera.dumpimg<br>16到23位表示dump多少帧，但如果是0，就是10帧<br>8-15位表示跳过多少帧，默认不跳过.<br>0到7位：<br>QCAMERA_DUMP_FRM_PREVIEW –0x1<br>QCAMERA_DUMP_FRM_VIDEO –0x2<br>QCAMERA_DUMP_FRM_SNAPSHOT –0x4<br>QCAMERA_DUMP_FRM_THUMBNAIL –0x8<br>QCAMERA_DUMP_FRM_RAW –0x10<br>QCAMERA_DUMP_FRM_JPEG –0x20</p>
<h2 id="（六）查看HAL层和客户端设置的参数值"><a href="#（六）查看HAL层和客户端设置的参数值" class="headerlink" title="（六）查看HAL层和客户端设置的参数值"></a>（六）查看HAL层和客户端设置的参数值</h2><p>adb shell dumpsys media.camera</p>
<h2 id="（七）log打印"><a href="#（七）log打印" class="headerlink" title="（七）log打印"></a>（七）log打印</h2><p>logcat|grep xxx –搜索包含xxx的log<br>logcat|grep xxx > /data/log.log –将包含xxx的log存到/data/log.log中<br>setprop persist.camera.stats.aec.debug 5 –stats中的AEC模块等级小于等于5的都打印出来</p>
<h3 id="关键词："><a href="#关键词：" class="headerlink" title="关键词："></a>关键词：</h3><p>查看曝光信：target_luma<br>查看灰点信息：simple-grey-world<br>查看决策点：final_awb_decision<br>查看HAL层帧率：PROFILE_PREVIEW_FRAMES_PER_SECOND<br>查看camera层模块帧率：fps</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">{</span><br><span class="line">  Q3A_AWB_AGW_D65 = <span class="number">0</span>,                                <span class="comment">/* D65*/</span></span><br><span class="line">  Q3A_AWB_AGW_D75,                                    <span class="comment">/* D75*/</span></span><br><span class="line">  Q3A_AWB_AGW_A,                                      <span class="comment">/* A*/</span></span><br><span class="line">  Q3A_AWB_AGW_WARM_FLO,                               <span class="comment">/* TL84*/</span></span><br><span class="line">  Q3A_AWB_AGW_COLD_FLO,                               <span class="comment">/* CW*/</span></span><br><span class="line">  Q3A_AWB_AGW_HORIZON,                                <span class="comment">/* H*/</span></span><br><span class="line">  Q3A_AWB_AGW_D50,                                    <span class="comment">/* D50*/</span></span><br><span class="line">  Q3A_AWB_AGW_CUSTOM_FLO,                             <span class="comment">/* CustFlo*/</span></span><br><span class="line">  Q3A_AWB_AGW_NOON,                                   <span class="comment">/* Noon*/</span></span><br><span class="line">  Q3A_AWB_AGW_CUSTOM_DAYLIGHT,</span><br><span class="line">  Q3A_AWB_AGW_CUSTOM_A,</span><br><span class="line">  Q3A_AWB_AGW_U30,</span><br><span class="line">  Q3A_AWB_AGW_CUSTOM_DAYLIGHT1,</span><br><span class="line">  Q3A_AWB_AGW_CUSTOM_DAYLIGHT2,</span><br><span class="line">  Q3A_AWB_AGW_CUSTOM_FLO1,</span><br><span class="line">  Q3A_AWB_AGW_CUSTOM_FLO2,</span><br><span class="line">  Q3A_AWB_AGW_MAX_LIGHT,</span><br><span class="line">  Q3A_AWB_AGW_INVALID_LIGHT = Q3A_AWB_AGW_MAX_LIGHT,</span><br><span class="line">  Q3A_AWB_DAY_LINE_1 = Q3A_AWB_AGW_MAX_LIGHT,</span><br><span class="line">  Q3A_AWB_DAY_LINE_2,</span><br><span class="line">  Q3A_AWB_FLINE,</span><br><span class="line">  Q3A_AWB_A_LINE_1,</span><br><span class="line">  Q3A_AWB_A_LINE_2,</span><br><span class="line">  <span class="comment">/* Daylight, only used for algorithm, not data*/</span></span><br><span class="line">  Q3A_AWB_AGW_HYBRID,    </span><br><span class="line">  <span class="comment">/* Don't count the hybrid*/</span></span><br><span class="line">  Q3A_AWB_AGW_MAX_ALL_LIGHT = Q3A_AWB_AGW_HYBRID,   </span><br><span class="line">  Q3A_AWB_AGW_INVALID_ALL_LIGHT = Q3A_AWB_AGW_MAX_ALL_LIGHT</span><br><span class="line">} chromatix_awb_all_light_adapter;</span><br></pre></td></tr></tbody></table></figure>


<h3 id="推库技巧："><a href="#推库技巧：" class="headerlink" title="推库技巧："></a>推库技巧：</h3><p>如果一次生成的so文件比较多，可以放在一个文件夹内，把文件夹的内容推入设备。<br>adb push C:\ROM. System/vendor/lib      注意.不能少</p>
<h2 id="（八）参考脚本："><a href="#（八）参考脚本：" class="headerlink" title="（八）参考脚本："></a>（八）参考脚本：</h2><h3 id="push-bat（推动态库）"><a href="#push-bat（推动态库）" class="headerlink" title="push.bat（推动态库）"></a>push.bat（推动态库）</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">REM 在推库之前关闭应用程序，不然可能会卡死在应用程序的界面</span><br><span class="line">REM IPC上建议不要关掉程序，重启会很慢，直接推库会卡一会儿，然后就可以正常使用</span><br><span class="line">adb shell pkill ptt</span><br><span class="line">REM HAL层动态库</span><br><span class="line">adb push adb push Z:\liqinxing\sdm660\sdm660_ipw300\out\target\product\u2p\obj_arm\lib\camera.sdm660.so system/lib/hw</span><br><span class="line">REM camera层动态库</span><br><span class="line">adb push Z:\liqinxing\sdm660\sdm660_ipw300\out\target\product\u2p\obj_arm\lib\libchromatix_imx290_default_preview_3a.so system/vendor/lib</span><br><span class="line">adb push Z:\liqinxing\sdm660\sdm660_ipw300\out\target\product\u2p\obj_arm\lib\libchromatix_imx290_cpp_preview.so system/vendor/lib</span><br><span class="line">adb push Z:\liqinxing\sdm660\sdm660_ipw300\out\target\product\u2p\obj_arm\lib\libchromatix_imx290_preview.so system/vendor/lib</span><br><span class="line">adb push Z:\liqinxing\sdm660\sdm660_ipw300\out\target\product\u2p\obj_arm\lib\libchromatix_imx290_common.so system/vendor/lib</span><br><span class="line">REM 重启cameraserver（8998/sdm660平台）</span><br><span class="line">adb shell stop cameraserver</span><br><span class="line">adb shell start cameraserver</span><br><span class="line">adb shell sync</span><br><span class="line">REM 启动应用程序</span><br><span class="line">adb shell am start -n com.kedacom.ptt/com.kedacom.kdmipw300.activity.IPW300MainActivity</span><br><span class="line">ping /n 3 127.1>nul</span><br><span class="line">REM 确认是否打开</span><br><span class="line">adb shell dumpsys window windows | findstr Current</span><br></pre></td></tr></tbody></table></figure>

<h3 id="capture-bat（拍照）"><a href="#capture-bat（拍照）" class="headerlink" title="capture.bat（拍照）"></a>capture.bat（拍照）</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">REM 先清空原来的图片</span><br><span class="line">adb shell rm -r /sdcard/DCIM/Camera/*</span><br><span class="line">adb shell rm -r /storage/extdisk/ipw300/image/chn0_0/*</span><br><span class="line">REM 拍照</span><br><span class="line">adb shell input keyevent 27</span><br><span class="line">ping /n 3 127.1>nul</span><br><span class="line">REM 导出照片</span><br><span class="line">adb pull /storage/extdisk/ipw300/image/chn0_0 Z:\liqinxing\test_photo\sixth_tunning</span><br><span class="line">adb pull /sdcard/DCIM/Camera Z:\liqinxing\test_photo\sixth_tunning</span><br></pre></td></tr></tbody></table></figure>

<h3 id="sdm660-root-bat"><a href="#sdm660-root-bat" class="headerlink" title="sdm660_root.bat"></a>sdm660_root.bat</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell setprop service.user.test 1</span><br><span class="line">ping -n 5 127.1 > nul</span><br><span class="line">adb shell setenforce 0</span><br><span class="line">ping -n 1 127.1 > nul</span><br><span class="line">adb remount</span><br></pre></td></tr></tbody></table></figure>

<h3 id="captureraw-bat"><a href="#captureraw-bat" class="headerlink" title="captureraw.bat"></a>captureraw.bat</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">adb shell chmod 777 /data/misc/camera</span><br><span class="line">adb shell rm  /data/misc/camera/*</span><br><span class="line">adb shell setprop persist.camera.raw_yuv 1</span><br><span class="line">adb shell setprop persist.camera.preview_raw 1</span><br><span class="line">adb shell setprop persist.camera.dumpimg 0</span><br><span class="line">adb shell setprop persist.camera.dumpimg 131088</span><br><span class="line">adb pull /data/misc/camera Z:\liqinxing\test_photo\raw</span><br></pre></td></tr></tbody></table></figure>

<h3 id="captureyuv-bat"><a href="#captureyuv-bat" class="headerlink" title="captureyuv.bat"></a>captureyuv.bat</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">adb shell chmod 777 /data/misc/camera</span><br><span class="line">adb shell rm  /data/misc/camera/*</span><br><span class="line">adb shell setprop persist.camera.isp.dump_cnt 1</span><br><span class="line">adb shell setprop persist.camera.isp.dump 0</span><br><span class="line">adb shell setprop persist.camera.isp.dump 2 </span><br><span class="line">adb pull /data/misc/camera Z:\liqinxing\test_photo\raw</span><br></pre></td></tr></tbody></table></figure>

</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
      </tags>
  </entry>
  <entry>
    <title>sdm660 ISP效果调试总结</title>
    <url>/posts/a825c630/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><p>经过一轮的调试，发现660相比于上一代，在降噪和锐化方面有所提升，具体体现在在同一张图的亮区和暗区，中心和边缘可以用不同的降噪锐化参数。这样可以在保留亮区细节的同时，可以降低暗区的噪声，也减小rolloff带来的噪声。</p>
<a id="more"></a>

<h2 id="1-黑电平"><a href="#1-黑电平" class="headerlink" title="1. 黑电平"></a>1. 黑电平</h2><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>如图1、由于采用的是14位，相比于之前的12位，平均值会出现比以前大4倍的情况。右边的平均值和左边的不等，是因为开启了BLSS，这个功能是指一部分不进行ABF，可以减少噪声的偏移，让黑色区域更纯粹，建议开启。</p>
<p><img src="/posts/a825c630/1.1.jpg" alt="1.1"></p>
<h3 id="BLSS介绍"><a href="#BLSS介绍" class="headerlink" title="BLSS介绍"></a>BLSS介绍</h3><p>图二中介绍：ABF会带来噪声的偏移，在图三中左边是开启了BLSS，右边是关闭了BLSS，从直方图可以看出开启了BLSS可以减少噪声偏移。当出现在极弱光条件下，暗色调为微红/紫色，而中色调和亮色调为灰色情况，考虑是否关闭了BLSS。</p>
<p><img src="/posts/a825c630/1.2.jpg" alt="1.2"></p>
<p><img src="/posts/a825c630/1.3.jpg" alt="1.3"></p>
<h3 id="代码位置介绍"><a href="#代码位置介绍" class="headerlink" title="代码位置介绍"></a>代码位置介绍</h3><p><img src="/posts/a825c630/1.4.jpg" alt="1.4"></p>
<p>在注释中说明线性化的第一个数就是黑电平</p>
<p><img src="/posts/a825c630/1.5.jpg" alt="1.5"></p>
<p>BLSS offset位置</p>
<h2 id="2-ABF"><a href="#2-ABF" class="headerlink" title="2. ABF"></a>2. ABF</h2><h3 id="操作简介"><a href="#操作简介" class="headerlink" title="操作简介"></a>操作简介</h3><p>在每个降噪和锐化模块之前都有一个radial table，是指在不同的半径范围内用不同的降噪锐化参数。由于进行rolloff校正，边缘的增益较大，会带来很多的噪声。如果镜头本身shading较小，RNR参数可以较小或者忽略。在base table中可以调节不同半径运用的降噪参数的比例。</p>
<p>如图2.4，在filter strength中可以根据每个像素点的亮度去调节不同的降噪强度，值越小，降噪越大。我一般使用工具测出哪些亮度的噪声较大，再去选择强度范围，这里强度是10位的，而我们是8位的，根据最后图像中的RGB值乘以4，可以大致得出暗区范围。由于暗区gamma抬升的较严重，这对于降低暗区的噪声很有效。在很亮的情况下，甚至可以将strength调到1，提升细节。Edge softness是调节噪声的检测区域，值越大，进行降噪的噪声范围越大。</p>
<p><img src="/posts/a825c630/2.1.jpg" alt="2.1"></p>
<p><img src="/posts/a825c630/2.2.jpg" alt="2.2"></p>
<p><img src="/posts/a825c630/2.3.jpg" alt="2.3"></p>
<p><img src="/posts/a825c630/2.4.jpg" alt="2.4"></p>
<h3 id="代码位置"><a href="#代码位置" class="headerlink" title="代码位置"></a>代码位置</h3><p>1、 前两行代表strength的强度，两列分别代表RG和GRGB通道的强度。</p>
<p>2、 Lo代表暗区范围的边界对应上图的127，Hi代表亮区的边界</p>
<p>3、 Edge softness不必说，base table就是图2.3的代码形式</p>
<p><img src="/posts/a825c630/2.5.jpg" alt="2.5"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ABF是在gamma之前进行的降噪，暗区经过gamma抬升之后引入了更多的噪声，在此之前进行一波简单的降噪，尤其是对暗区颗粒感的噪声有较好的效果。亮区如果ABF较强会抹掉细节，因此需要确定好暗区的亮区的范围。如果启用LTM，ABF也可以有效降低暗区的噪声。</p>
<h2 id="3-LTM"><a href="#3-LTM" class="headerlink" title="3. LTM"></a>3. LTM</h2><h3 id="操作简介-1"><a href="#操作简介-1" class="headerlink" title="操作简介"></a>操作简介</h3><p><img src="/posts/a825c630/3.1.jpg" alt="3.1"></p>
<p>这是LTM界面，比较简单，三个滑块可以修改，strength代表LTM的强度，右边两个滑块是暗区的增强程度和亮区的抑制程度，亮区的抑制可以调到4.0，而暗区的提升区域和LTM要随着增益的降低而降低，否则会带来很多的噪声，可以通过调节ABF来减小他们。也可以减小暗区的饱和度来减小噪声。</p>
<p>右上角的图片可以右键点击，添加拐点，进行曲线的调整，要降低已提升区域的饱和度，饱和度曲线必须呈现右侧下凹并且左侧上凸的状态。</p>
<h2 id="4-WNR"><a href="#4-WNR" class="headerlink" title="4. WNR"></a>4. WNR</h2><h3 id="操作简介-2"><a href="#操作简介-2" class="headerlink" title="操作简介"></a>操作简介</h3><p>RNR的操作类似，一开始进行base table的半径大小的选择，在调试时候的RNR可以进行不同区域scale和softness的缩放。</p>
<p>原始的LNR如图4.1，横坐标是intensity，指的是像素点的强度，值越大代表越亮的区域。纵坐标代表的是对降噪阈值和权重的缩放比例。比如说亮度区域，我们想要看到他的细节，就要减小scale的缩放比例。暗区想要降噪比较强，可以增大scale的比例，这个地方需要根据具体的情况判断缩放比例。因此不一定按照原来的曲线，根据自己的目标进行调整。</p>
<p>第五层和第六层参数过大，会减少图片的饱和度和以及出现渗色的情况，低照度的情况下使用，数值不能太大。</p>
<h3 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h3><p>1、 拍raw图时记下当前的增益值，以便生成该增益下的噪声模板</p>
<p>2、 调整的WNR的时候可以先将ASF关闭，避免由于锐化造成的噪声。</p>
<p>3、 先观察中间中等亮度的区域，避免因为LNR和RNR的影响。</p>
<p>4、 由于scale是滤波的程度，而softness是对噪声和边缘的选择，我们可以先将scale调至很大，权重也调成0，通过想要放出的细节去确定softness，然后通过调整scale，调整滤波的程度，调整到能够去除噪声的最小值。最后调整权重，调整权重会放出部分噪声和细节。</p>
<p>5、 最后进行LNR和RNR进行细微的调整，比如增强暗亮区的细节。</p>
<p><img src="/posts/a825c630/4.1.jpg" alt="4.1"></p>
<p><img src="/posts/a825c630/4.2.jpg" alt="4.2"></p>
<h3 id="代码位置-1"><a href="#代码位置-1" class="headerlink" title="代码位置"></a>代码位置</h3><p>代码中的WNR有两处，下面的那组参数是low power模式下的参数。先确认用的是哪一组参数。其他的参数和上一代类似，只是增加了第五层和第六层。RNR和LNR可以用chromatix工具生成。</p>
<h2 id="5-ASF"><a href="#5-ASF" class="headerlink" title="5. ASF"></a>5. ASF</h2><h3 id="操作简介-3"><a href="#操作简介-3" class="headerlink" title="操作简介"></a>操作简介</h3><p>一开始同样是RNR的调整。</p>
<p>接下来是边缘检测模板等配置。</p>
<p><img src="/posts/a825c630/5.1.jpg" alt="5.1"></p>
<p>这里不需要我们改值，但是后面可以选择我们用薄的还是厚的，在增益较小的情况下，顾及细节用thin kernels，增益较大，比较模糊的情况可以选择用mid或者thick kernels，顾及噪声。</p>
<p>接下来是几条锐化曲线：</p>
<p><img src="/posts/a825c630/5.2.jpg" alt="5.2"></p>
<p>第一条曲线是activity normalization factor曲线。横坐标是局部亮度，纵坐标是代表了活动归一化因子的缩放，这幅图代表越暗的区域，降低偏暗像素缩放因子，可以降低暗区的噪声，但也会带来对比度较低的问题。当然降低缩放因子，并不能直接导致锐化程度的降低，而是通过第三条曲线降低gain weight来降低锐化，甚至有滤波的效果。</p>
<p><img src="/posts/a825c630/5.3.jpg" alt="5.3"></p>
<p>这条gain lut曲线是最主要的一条曲线，第一个滑块是代表平坦区域的锐化程度，第二个代表对暗处的锐化的提升效果，最后一个是对亮处锐化的提升。可以增强阴影部分和高亮部分的细节，如果暗处噪声较多，可以降低暗区的提升效果，甚至变成负值，代表对暗处锐化的抑制。</p>
<p><img src="/posts/a825c630/5.4.jpg" alt="5.4"></p>
<p>这条gain weight曲线横坐标是归一化活动，我理解的是边缘的程度，值越大，就越是边缘，值越小，代表越平坦。Gain weight如果是0，就完全用9x9的低通滤波器，如果是1，就完全是经过锐化的数值，如果在两者之间，这是用的两者的比例之和。</p>
<p>上面的滑块会让曲线向右移动，可以让噪声不被锐化出来，增益较大的情况下进行右移。左边的滑块就是调整平坦区域的锐化和滤波的比例。</p>
<p>联系第一条曲线，如果暗区的缩放因子设置的比较小，归一化活动缩小了，相当于在原来的基础上横坐标的值减小了，那么它的锐化程度会更小，滤波会更多，可以降低噪声，也会抹掉细节，因此需要适当注意。</p>
<p><img src="/posts/a825c630/5.5.jpg" alt="5.5"></p>
<p>这条曲线是gain negative lut，只需要用滑块调整和gain lut的比例。锐化出来是有两个边的，一个是黑边，一个是白边，上一条gain lut指的是白边，这个是黑边，为了减少白边，我一般将gain lut调的较小，gain negative lut调的较大。同时还有钳位可以调整。代码中的Clamp UL 是白边的阈值，可以小一点。Clamp LL 是黑边的阈值。当然，这样会降低细节，如果细节不够，我们可以增加gain lut去增加细节的锐化，同时用clamp UL去减小白边。</p>
<p><img src="/posts/a825c630/5.6.jpg" alt="5.6"></p>
<p>最后是RNR的调整，由于之前的ABF和WNR，边缘的滤波可能更加严重，这里可以对边缘增强一些，但也可能带来更多的噪声，因此适当增强或者不增强。</p>
<p>在other的选项中勾选median filter blend，在锐化之前用中值滤波器，可以减小尖峰噪声，同时对细节影响不大，建议勾选。</p>
</body></html>]]></content>
      <categories>
        <category>工作</category>
        <category>图像效果调试</category>
      </categories>
      <tags>
        <tag>高通camera</tag>
        <tag>效果调试</tag>
      </tags>
  </entry>
  <entry>
    <title>linux服务器的基本操作和配置</title>
    <url>/posts/2322381c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><html><head></head><body><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol>
<li>查看内存：free -m (-m是以M为单位，-g是以G为单位，-h自动加适合的单位)</li>
<li>立刻关机：<code>shutdown -h now</code></li>
</ol>
<h2 id="linux更换国内源"><a href="#linux更换国内源" class="headerlink" title="linux更换国内源"></a>linux更换国内源</h2><ol>
<li><p>备份原来的源<br>sudo cp /etc/apt/sources.list /etc/apt/sources_init.list<br>将以前的源备份一下，以防以后可以用的。</p>
</li>
<li><p>更换源<br>sudo gedit /etc/apt/sources.list<br>使用gedit打开文档，将下边的阿里源复制进去，然后点击保存关闭。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 阿里源</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>更新<br>更新源<br><code>sudo apt-get update</code><br>复损坏的软件包，尝试卸载出错的包，重新安装正确版本的。<br><code>sudo apt-get -f install</code><br>更新软件<br><code>sudo apt-get upgrade</code></p>
</li>
</ol>
<h2 id="用户的创建与删除"><a href="#用户的创建与删除" class="headerlink" title="用户的创建与删除"></a>用户的创建与删除</h2><p>1、新建一个用户 <code>sudo adduser liqinxing</code>,接着设置密码</p>
<p>如果需要让此用户有root权限，执行命令：<code>sudo vim /etc/sudoers</code><br>修改文件如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># User privilege specification</span><br><span class="line">root ALL=(ALL) ALL</span><br><span class="line">liqinxing ALL=(ALL) ALL</span><br></pre></td></tr></tbody></table></figure>

<p>保存退出，db用户就拥有了root权限。</p>
<p>2、删除用户：sudo userdel -r liqinxing</p>
<p><strong>问题：</strong>linux用户source .bashrc或.profile找不到文件</p>
<p> 之前在debian遇到这种情况，新增加的用户，每次登入的路径都显示sh-42$必须su - 用户名才能恢复正常，<br> 并且用户目录下的.bashrc和其他的配置文件都没有办法source，导致一系列问题。</p>
<p> 如果是这种情况，极有可能是linux的默认启动shell不正确，su切换成超级用户，vi  /etc/passwd查看用户相应的启动shell，<br> 对比其他正常的用户的启动shell，如果不一样则修改成相同即可。。例如其他正常用户的shell为/bin/bash  ，异常用户对应的shell是/bin/sh，<br> 则将其改为/bin/bash再:wq!   保存修改，重启解决！</p>
<p> 如果source仍显示找不到文件, ls -al查看.profile文件的拥有者和拥有者级别是否是当前用户，如果不是则使用chown命令修改，再source试试。</p>
<h2 id="samba"><a href="#samba" class="headerlink" title="samba"></a>samba</h2><p>可以使用pdbedit命令来建立Samba账户。pdbedit命令的参数很多，我们列出几个主要的。</p>
<ol>
<li>pdbedit –a username：新建Samba账户。</li>
<li>pdbedit –x username：删除Samba账户。</li>
<li>pdbedit –L：列出Samba用户列表，读取passdb.tdb数据库文件。</li>
<li>pdbedit –Lv：列出Samba用户列表的详细信息。</li>
<li>pdbedit –c “[D]” –u username：暂停该Samba用户的账号。</li>
<li>pdbedit –c “[]” –u username：恢复该Samba用户的账号。</li>
</ol>
<h2 id="挂载新硬盘"><a href="#挂载新硬盘" class="headerlink" title="挂载新硬盘"></a>挂载新硬盘</h2><p>关于逻辑扇区512bytes，物理扇区 4096 bytes<br>首先用fdisk -l /dev/sd*查看信息，可以看到<br>Sector size (logical/physical): 512 bytes / 4096 bytes<br>或<br>Sector size (logical/physical): 512 bytes / 512 bytes</p>
<p>physical sector size为4096 bytes的，物理分区起点需要能被4096 bytes整除</p>
<ol>
<li>sudo fdisk -l 查看硬盘，显示/dev/sd* 表示识别到, *为adcde等字母序号<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">（已经分区好的盘会显示：</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">设备 启动      起点          终点     块数   Id  系统</span></span><br><span class="line">/dev/sdb1               1  2344225967  1172112983+  ee  GPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">未分区的盘会显示</span></span><br><span class="line">Disk /dev/sdd doesn't contain a valid partition table</span><br><span class="line"><span class="meta">#</span><span class="bash"> sdc把sdc整个格式化，而不是把sdc1格式化，可能是这个原因，导致也未显示分区</span></span><br></pre></td></tr></tbody></table></figure>


</li>
</ol>
<ol start="2">
<li><p>使用parted分区。</p>
<p> sudo parted /dev/sd* ， 对sd*分区</p>
<ol>
<li><p>查看该盘的分区信息(如果没有分区，则无显示):print（或p）</p>
</li>
<li><p>建立gpt分区表 <code>mklabel gpt</code><br>（对于Sector size (logical/physical): 512 bytes / 4096 bytes，<br>创建msdos分区表:<br><code>mklabel msdos</code><br>起点和gpt起点不一样.（why?））</p>
</li>
<li><p>确认该盘的分区信息<br>print /<em>此时会显示该磁盘的容量等信息</em>/</p>
</li>
<li><p>分配硬盘地址空间，比如2000GB<br><code>mkpart primary 0KB 2000GB</code><br>（对于Sector size (logical/physical): 512 bytes / 4096 bytes，<br>起点不应从0开始<br>mkpart primary 2048s 2000GB<br>2048s代表2048个扇区。2048x512=1048K bytes，可以被4096整除。<br>2048s或许可以更小<br>另一个方法 “mkpart primary 0% 100%”）</p>
</li>
<li><p>确认提示问题y</p>
</li>
<li><p>忽视提示问题i</p>
</li>
<li><p>确认该盘的分区信息print</p>
</li>
<li><p>退出分区操作quit</p>
</li>
</ol>
</li>
<li><p>此时fdisk -l ，能看到刚才操作的sd*的分区信息。</p>
</li>
<li><p>为新分区建立ext4文件系统，sd*1是sd*的具体盘号，后面的数字默认为1<br> sudo mkfs -t ext4 /dev/sdxx1;</p>
</li>
<li><p>新建文件夹/new_home，用于挂载空盘</p>
</li>
</ol>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo mkdir /new_home;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂载磁盘并设置可读写</span></span><br><span class="line">sudo mount -t ext4 -o rw /dev/sde1 /new_home;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行（查看？）挂载</span></span><br><span class="line">mount;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置所有人都可以对磁盘进行读写操作（可选）</span></span><br><span class="line">sudo chmod a+rw /new_home</span><br></pre></td></tr></tbody></table></figure>

<ol start="6">
<li><p>注意：以上操作都是临时挂载，系统重启后挂载信息会丢失！<br>因此在所有空盘都挂载后，更改/etc/fstab文件，使系统重启也可以正确挂载磁盘。<br><code>/dev/sde1   /new_home   ext4    defaults    0   0</code></p>
<table>
<thead>
<tr>
<th>file system</th>
<th>mount point</th>
<th>type</th>
<th>options</th>
<th>dump</th>
<th>pass</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
</tbody></table>
<p>1 指代文件系统的设备名。最初，该字段只包含待挂载分区的设备名（如/dev/sda1）。现在，除设备名外，还可以包含LABEL或UUID<br>2 文件系统挂载点。文件系统包含挂载点下整个目录树结构里的所有数据，除非其中某个目录又挂载了另一个文件系统<br>3 文件系统类型。下面是多数常见文件系统类型（ext3,tmpfs,devpts,sysfs,proc,swap,vfat）<br>4 mount命令选项。mount选项包括noauto（启动时不挂载该文件系统）和ro（只读方式挂载文件系统）等。在该字段里添加用户或属主选项，即可允许该用户挂载文件系统。多个选项之间必须用逗号隔开。其他选项的相关信息可参看mount命令手册页（-o选项处）<br>5转储文件系统。该字段只在用dump备份时才有意义。数字1表示该文件系统需要转储，0表示不需要转储<br>6文件系统检查。该字段里的数字表示文件系统是否需要用fsck检查。0表示不必检查该文件系统，数字1示意该文件系统需要先行检查（用于根文件系统）。数字2则表示完成根文件系统检查后，再检查该文件系统</p>
<p>修改/etc/fstab并保存后，可以用mount -a来测试是否正常。</p>
</li>
<li><p>在/etc/samba/smb.conf中，添加共享信息。</p>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
